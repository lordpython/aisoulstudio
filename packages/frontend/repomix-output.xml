This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
App.tsx
components.json
components/AgentProgress.tsx
components/AmbientBackground.tsx
components/auth/AuthModal.tsx
components/auth/index.ts
components/auth/UserMenu.tsx
components/chat/ChatInput.tsx
components/chat/index.ts
components/chat/MessageBubble.tsx
components/chat/QuickActions.tsx
components/CheckpointApproval.test.tsx
components/CheckpointApproval.tsx
components/ErrorBoundary.tsx
components/FormatSelector.test.ts
components/FormatSelector.tsx
components/gradient-generator/GradientControls.tsx
components/gradient-generator/GradientExport.tsx
components/gradient-generator/GradientGenerator.tsx
components/gradient-generator/GradientPresets.tsx
components/gradient-generator/GradientPreview.tsx
components/gradient-generator/hooks.ts
components/gradient-generator/index.ts
components/gradient-generator/types.ts
components/gradient-generator/utils.ts
components/HomeView.tsx
components/IntroAnimation.css
components/IntroAnimation.tsx
components/layout/AppLayout.tsx
components/layout/AppShell.tsx
components/layout/DirectionalIcon.tsx
components/layout/Header.tsx
components/layout/index.ts
components/layout/LanguageSwitcher.tsx
components/layout/ScreenLayout.tsx
components/layout/Sidebar.tsx
components/MusicChatModalV2.tsx
components/MusicGeneratorModal.tsx
components/PipelineProgress.test.ts
components/PipelineProgress.tsx
components/projects/ProjectCard.tsx
components/QualityDashboard.tsx
components/QuickExport.tsx
components/QuickUpload.tsx
components/ReferenceDocumentUpload.tsx
components/SceneEditor.tsx
components/SEO/index.ts
components/SEO/StructuredData.tsx
components/SettingsModal.tsx
components/story/BreakdownProgress.tsx
components/story/CharacterView.tsx
components/story/ExportOptionsPanel.tsx
components/story/IdeaView.tsx
components/story/index.ts
components/story/LockWarningDialog.tsx
components/story/SceneCard.tsx
components/story/ScriptView.tsx
components/story/ShotEditorModal.tsx
components/story/StepProgressBar.tsx
components/story/StoryboardProgress.tsx
components/story/StoryboardView.tsx
components/story/StoryWorkspace.tsx
components/story/StoryWorkspaceErrorBoundary.tsx
components/story/StyleSelector.tsx
components/story/TemplatesGallery.tsx
components/story/VersionHistoryPanel.tsx
components/TimelineEditor/AudioClip.tsx
components/TimelineEditor/AudioTimelineEditor.tsx
components/TimelineEditor/editor/ImageClipComponent.tsx
components/TimelineEditor/editor/ImportMediaModal.tsx
components/TimelineEditor/editor/index.ts
components/TimelineEditor/editor/SubtitleClip.tsx
components/TimelineEditor/editor/TimelineControls.tsx
components/TimelineEditor/editor/TimelinePanel.tsx
components/TimelineEditor/editor/TrackSidebar.tsx
components/TimelineEditor/editor/VideoClipComponent.tsx
components/TimelineEditor/editor/VideoPreview.tsx
components/TimelineEditor/editor/WaveformClip.tsx
components/TimelineEditor/FooterNav.tsx
components/TimelineEditor/graphite-timeline-utils.ts
components/TimelineEditor/graphite-timeline.css
components/TimelineEditor/GraphiteClip.tsx
components/TimelineEditor/GraphiteTimeline.tsx
components/TimelineEditor/index.ts
components/TimelineEditor/Playhead.tsx
components/TimelineEditor/timelineAdapter.ts
components/TimelineEditor/TimeRuler.tsx
components/TimelineEditor/TrackLabel.tsx
components/TimelineEditor/TrackLane.tsx
components/TimelineEditor/TransportBar.tsx
components/TimelineEditor/useTimelineScroll.ts
components/TimelinePlayer.tsx
components/ui/badge.tsx
components/ui/button.tsx
components/ui/card.tsx
components/ui/dialog.tsx
components/ui/dropdown-menu.tsx
components/ui/ErrorState.tsx
components/ui/input.tsx
components/ui/label.tsx
components/ui/LoadingState.tsx
components/ui/MarkdownContent.tsx
components/ui/progress.tsx
components/ui/scroll-area.tsx
components/ui/select.tsx
components/ui/skeleton.tsx
components/ui/skip-link.tsx
components/ui/SlidePanel.tsx
components/ui/slider.tsx
components/ui/switch.tsx
components/ui/tabs.tsx
components/ui/textarea.tsx
components/ui/toast.tsx
components/ui/toaster.tsx
components/ui/tooltip.tsx
components/ui/use-toast.tsx
components/VideoEditor/CanvasPreview.tsx
components/VideoEditor/clips/AudioTrackClip.tsx
components/VideoEditor/clips/ImageTrackClip.tsx
components/VideoEditor/clips/TextClip.tsx
components/VideoEditor/clips/VideoTrackClip.tsx
components/VideoEditor/EnhancedTransportBar.tsx
components/VideoEditor/hooks/useVideoEditorStore.ts
components/VideoEditor/index.ts
components/VideoEditor/MultiTrackTimeline.tsx
components/VideoEditor/ToolPanels.tsx
components/VideoEditor/TrackLabelPanel.tsx
components/VideoEditor/TrackRow.tsx
components/VideoEditor/types/video-editor-types.ts
components/VideoEditor/video-editor.css
components/VideoEditor/VideoEditor.tsx
components/VideoEditor/VideoEditorToolbar.tsx
components/VideoExportModal.tsx
components/VideoPreviewCard.tsx
components/visualizer/AudioUploadForm.tsx
components/visualizer/index.ts
components/visualizer/SceneThumbnails.tsx
components/visualizer/VisualPreview.tsx
hooks/useAuth.ts
hooks/useFocusTrap.ts
hooks/useFormatPipeline.ts
hooks/useLyricLens.ts
hooks/useMediaPlayback.ts
hooks/useModalState.ts
hooks/useProjectSession.ts
hooks/useStoryGeneration.ts
hooks/useStoryProject.ts
hooks/useSunoMusic.ts
hooks/useTimelineAdapter.ts
hooks/useTimelineKeyboard.ts
hooks/useTimelineSelection.ts
hooks/useVideoNarration.ts
hooks/useVideoProductionCore.ts
hooks/useVideoProductionRefactored.ts
hooks/useVideoPromptTools.ts
hooks/useVideoQuality.ts
hooks/useVideoSFX.ts
hooks/useVideoVisuals.ts
i18n/index.ts
i18n/locales/ar.json
i18n/locales/en.json
i18n/useLanguage.ts
index.css
index.html
index.tsx
package.json
postcss.config.js
public/favicon.ico
public/production_prod_1769364025193_ch60ee8c1/_session_started.txt
public/production_prod_1769364025193_ch60ee8c1/audio/narration_scene-1.wav
public/production_prod_1769364025193_ch60ee8c1/audio/narration_scene-2.wav
public/production_prod_1769364025193_ch60ee8c1/audio/narration_scene-3.wav
public/production_prod_1769364025193_ch60ee8c1/audio/narration_scene-4.wav
public/production_prod_1769364025193_ch60ee8c1/audio/narration_scene-5.wav
public/production_prod_1769364025193_ch60ee8c1/video_clips/scene_0_veo.mp4
public/production_prod_1769364025193_ch60ee8c1/video_clips/scene_1_veo.mp4
public/production_prod_1769364025193_ch60ee8c1/video_clips/scene_2_veo.mp4
public/production_prod_1769364025193_ch60ee8c1/video_clips/scene_3_veo.mp4
public/production_prod_1769364025193_ch60ee8c1/video_clips/scene_4_veo.mp4
public/robots.txt
public/sitemap.html
public/sitemap.xml
router/guards/index.ts
router/guards/UnsavedChangesGuard.tsx
router/index.tsx
router/RouteLayout.tsx
router/routes.ts
screens/GradientGeneratorScreen.tsx
screens/HomeScreen.tsx
screens/index.ts
screens/NotFoundScreen.tsx
screens/ProjectsScreen.tsx
screens/SettingsScreen.tsx
screens/SignInScreen.tsx
screens/StudioScreen.tsx
screens/VisualizerScreen.tsx
tsconfig.json
vite-env.d.ts
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="App.tsx">
/**
 * Main App Component
 * Requirements: 3.1 - Support Arabic and English languages
 * Requirements: 2.1, 2.2 - Use React Router for all navigation
 * Requirements: 1.3 - Remove ProductionView and SleekProductionView
 */

import { useState, Suspense, lazy } from "react";
import { AnimatePresence } from "framer-motion";
import { TooltipProvider } from "@/components/ui/tooltip";
import { Toaster } from "@/components/ui/toaster";
import { ErrorBoundary } from "./components/ErrorBoundary";
import { AppShell } from "./components/layout/AppShell";
import { AppRouter } from "./router";

// Import i18n configuration - this initializes i18next
import "./i18n";

// Lazy load intro animation
const IntroAnimation = lazy(() => import("./components/IntroAnimation").then(m => ({ default: m.IntroAnimation })));

export default function App() {
  // UI-specific state for intro animation
  const [showIntro, setShowIntro] = useState(true);

  return (
    <TooltipProvider>
      <ErrorBoundary>
        <AppShell>
          {/* Intro Animation */}
          <AnimatePresence>
            {showIntro && (
              <Suspense fallback={<div className="fixed inset-0 bg-slate-900 z-50" />}>
                <IntroAnimation onComplete={() => setShowIntro(false)} />
              </Suspense>
            )}
          </AnimatePresence>

          {/* Main App with React Router */}
          <AppRouter />
          
          {/* Toast Notifications */}
          <Toaster />
        </AppShell>
      </ErrorBoundary>
    </TooltipProvider>
  );
}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "index.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}
</file>

<file path="components/AgentProgress.tsx">
/**
 * AgentProgress Component
 * 
 * Real-time visualization of the multi-agent production pipeline.
 * Shows progress through: ContentPlanner ‚Üí Narrator ‚Üí Editor ‚Üí Export
 * Includes accessible aria-live regions for screen reader support
 */

import React from "react";
import { motion } from "framer-motion";
import {
    FileText,
    Mic,
    Film,
    CheckCircle2,
    Loader2,
    Sparkles
} from "lucide-react";
import { cn } from "@/lib/utils";
import { ProductionProgress, ProductionStage } from "@/services/agentOrchestrator";

interface AgentProgressProps {
    progress: ProductionProgress | null;
    className?: string;
}

interface StageInfo {
    id: ProductionStage;
    label: string;
    icon: React.ReactNode;
}

const STAGES: StageInfo[] = [
    { id: "content_planning", label: "Planning", icon: <FileText className="w-5 h-5" /> },
    { id: "narrating", label: "Narration", icon: <Mic className="w-5 h-5" /> },
    { id: "generating_visuals", label: "Visuals", icon: <Film className="w-5 h-5" /> },
    { id: "validating", label: "Review", icon: <CheckCircle2 className="w-5 h-5" /> },
];

function getStageStatus(
    stageId: ProductionStage,
    currentStage: ProductionStage | undefined
): "pending" | "active" | "complete" {
    if (!currentStage) return "pending";

    const stageOrder = STAGES.map(s => s.id);
    const currentIndex = stageOrder.indexOf(currentStage);
    const stageIndex = stageOrder.indexOf(stageId);

    if (currentStage === "complete") return "complete";
    if (currentStage === "adjusting") {
        // During adjustment, show validating as active
        return stageId === "validating" ? "active" : stageIndex < 3 ? "complete" : "pending";
    }

    if (stageIndex < currentIndex) return "complete";
    if (stageIndex === currentIndex) return "active";
    return "pending";
}

function getAccessibleStageLabel(stage: ProductionStage | undefined): string {
    if (!stage) return "Not started";
    switch (stage) {
        case "content_planning": return "Content Planning";
        case "narrating": return "Narration";
        case "generating_visuals": return "Generating Visuals";
        case "validating": return "Review and Validation";
        case "adjusting": return "Making Adjustments";
        case "complete": return "Complete";
        default: return stage;
    }
}

export function AgentProgress({ progress, className }: AgentProgressProps) {
    if (!progress) return null;

    // Generate accessible status description
    const getAccessibleStatus = () => {
        const stageLabel = getAccessibleStageLabel(progress.stage);
        const progressText = `${Math.round(progress.progress)}% complete`;
        const sceneText = progress.currentScene && progress.totalScenes
            ? `, scene ${progress.currentScene} of ${progress.totalScenes}`
            : "";
        return `${stageLabel} stage: ${progressText}${sceneText}. ${progress.message}`;
    };

    return (
        <div
            className={cn("rounded-xl bg-slate-900/50 border border-slate-700/50 p-6", className)}
            role="status"
            aria-live="polite"
            aria-label={getAccessibleStatus()}
        >
            {/* Stage indicators */}
            <nav
                className="flex items-center justify-between mb-6"
                aria-label="Production pipeline stages"
            >
                {STAGES.map((stage, index) => {
                    const status = getStageStatus(stage.id, progress.stage);

                    return (
                        <React.Fragment key={stage.id}>
                            {/* Stage node */}
                            <div className="flex flex-col items-center gap-2">
                                <motion.div
                                    className={cn(
                                        "w-12 h-12 rounded-full flex items-center justify-center transition-colors",
                                        status === "complete" && "bg-green-500/20 text-green-400 border-2 border-green-500/50",
                                        status === "active" && "bg-cyan-500/20 text-cyan-400 border-2 border-cyan-500/50",
                                        status === "pending" && "bg-slate-800 text-slate-500 border-2 border-slate-600/50"
                                    )}
                                    animate={status === "active" ? { scale: [1, 1.05, 1] } : {}}
                                    transition={{ duration: 1.5, repeat: Infinity }}
                                    aria-label={`${stage.label}: ${status === "complete" ? "completed" : status === "active" ? "in progress" : "pending"}`}
                                    aria-current={status === "active" ? "step" : undefined}
                                >
                                    {status === "active" ? (
                                        <Loader2 className="w-5 h-5 animate-spin" aria-hidden="true" />
                                    ) : status === "complete" ? (
                                        <CheckCircle2 className="w-5 h-5" aria-hidden="true" />
                                    ) : (
                                        <span aria-hidden="true">{stage.icon}</span>
                                    )}
                                </motion.div>
                                <span className={cn(
                                    "text-xs font-medium",
                                    status === "active" && "text-cyan-400",
                                    status === "complete" && "text-green-400",
                                    status === "pending" && "text-slate-500"
                                )}>
                                    {stage.label}
                                </span>
                            </div>

                            {/* Connector line */}
                            {index < STAGES.length - 1 && (
                                <div
                                    className="flex-1 mx-2 h-0.5 bg-slate-700 relative"
                                    aria-hidden="true"
                                >
                                    <motion.div
                                        className="absolute inset-y-0 left-0 bg-linear-to-r from-cyan-500 to-green-500"
                                        initial={{ width: "0%" }}
                                        animate={{
                                            width: (index + 1 < STAGES.length && getStageStatus(STAGES[index + 1]!.id, progress.stage) !== "pending")
                                                ? "100%"
                                                : getStageStatus(stage.id, progress.stage) === "active"
                                                    ? `${progress.progress}%`
                                                    : "0%"
                                        }}
                                        transition={{ duration: 0.5 }}
                                    />
                                </div>
                            )}
                        </React.Fragment>
                    );
                })}
            </nav>

            {/* Progress bar */}
            <div className="mb-4">
                <div
                    className="h-2 bg-slate-800 rounded-full overflow-hidden"
                    role="progressbar"
                    aria-valuenow={Math.round(progress.progress)}
                    aria-valuemin={0}
                    aria-valuemax={100}
                    aria-label={`Overall progress: ${Math.round(progress.progress)}%`}
                >
                    <motion.div
                        className="h-full bg-linear-to-r from-cyan-500 via-purple-500 to-pink-500"
                        initial={{ width: "0%" }}
                        animate={{ width: `${progress.progress}%` }}
                        transition={{ duration: 0.3 }}
                    />
                </div>
            </div>

            {/* Status message */}
            <div className="flex items-center gap-2 text-sm">
                <Sparkles className="w-4 h-4 text-purple-400" aria-hidden="true" />
                <span className="text-slate-300">{progress.message}</span>
                {progress.currentScene && progress.totalScenes && (
                    <span className="text-slate-500 ml-auto">
                        Scene {progress.currentScene}/{progress.totalScenes}
                    </span>
                )}
            </div>

            {/* Screen reader announcement for completion */}
            <div className="sr-only" aria-live="assertive" aria-atomic="true">
                {progress.stage === "complete" && "Production pipeline complete!"}
            </div>
        </div>
    );
}

/**
 * Compact version for inline display
 */
export function AgentProgressCompact({ progress, className }: AgentProgressProps) {
    if (!progress) return null;

    // Generate accessible status for compact view
    const getCompactAccessibleStatus = () => {
        const stageLabel = getAccessibleStageLabel(progress.stage);
        return `${stageLabel}: ${progress.message}`;
    };

    return (
        <div
            className={cn("flex items-center gap-3", className)}
            role="status"
            aria-live="polite"
            aria-label={getCompactAccessibleStatus()}
        >
            <div className="flex items-center gap-1" role="list" aria-label="Stage indicators">
                {STAGES.map((stage) => {
                    const status = getStageStatus(stage.id, progress.stage);
                    return (
                        <div
                            key={stage.id}
                            role="listitem"
                            aria-label={`${stage.label}: ${status === "complete" ? "completed" : status === "active" ? "in progress" : "pending"}`}
                            className={cn(
                                "w-2 h-2 rounded-full",
                                status === "complete" && "bg-green-500",
                                status === "active" && "bg-cyan-500 animate-pulse",
                                status === "pending" && "bg-slate-600"
                            )}
                        />
                    );
                })}
            </div>
            <span className="text-sm text-slate-400">{progress.message}</span>
        </div>
    );
}

export default AgentProgress;
</file>

<file path="components/AmbientBackground.tsx">
import React from "react";
import { cn } from "@/lib/utils";

/**
 * AmbientBackground Component
 *
 * Provides the signature "Deep Space" background for the Invisible Interface.
 * Features animated glowing orbs using the OKLCH design token palette.
 * Fixed position to sit behind all content.
 */
export function AmbientBackground({ className }: { className?: string }) {
    return (
        <div className={cn("fixed inset-0 z-[-1] overflow-hidden pointer-events-none", className)}>
            {/* Deep dark base is handled by body bg-background, but we ensure it here too */}
            <div className="absolute inset-0 bg-background/80" />

            {/* Primary Nebula ‚Äî uses --primary (cyan/teal) */}
            <div
                className="absolute top-[-20%] left-[-10%] w-[70%] h-[70%] rounded-full blur-[120px] mix-blend-screen animate-pulse-slow"
                style={{
                    backgroundColor: 'oklch(0.70 0.15 190 / 0.12)',
                    animationDuration: '15s',
                }}
            />

            {/* Secondary Nebula ‚Äî uses --secondary (deep indigo) */}
            <div
                className="absolute bottom-[-20%] right-[-10%] w-[60%] h-[60%] rounded-full blur-[100px] mix-blend-screen animate-pulse-slow"
                style={{
                    backgroundColor: 'oklch(0.30 0.08 240 / 0.10)',
                    animationDuration: '20s',
                    animationDelay: '2s',
                }}
            />

            {/* Accent Glow ‚Äî uses --accent (supernova orange) */}
            <div
                className="absolute top-[40%] left-[60%] w-[30%] h-[30%] rounded-full blur-[80px] mix-blend-screen animate-pulse-slow"
                style={{
                    backgroundColor: 'oklch(0.65 0.25 30 / 0.06)',
                    animationDuration: '12s',
                    animationDelay: '5s',
                }}
            />
        </div>
    );
}
</file>

<file path="components/auth/AuthModal.tsx">
/**
 * AuthModal Component
 *
 * Modal dialog for user authentication (Google and email sign-in).
 * Matches the cinematic design system.
 */
import { useState } from 'react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@/components/ui/dialog';
import { useAuth } from '@/hooks/useAuth';
import { Loader2, Mail, AlertCircle } from 'lucide-react';

interface AuthModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function AuthModal({ open, onOpenChange }: AuthModalProps) {
  const { signInWithGoogle, signInWithEmail, createAccount, error, clearError, isLoading } = useAuth();
  const [mode, setMode] = useState<'signin' | 'signup'>('signin');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleGoogleSignIn = async () => {
    await signInWithGoogle();
    if (!error) {
      onOpenChange(false);
    }
  };

  const handleEmailSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (mode === 'signin') {
      await signInWithEmail(email, password);
    } else {
      await createAccount(email, password);
    }
    if (!error) {
      onOpenChange(false);
    }
  };

  const switchMode = () => {
    setMode(mode === 'signin' ? 'signup' : 'signin');
    clearError();
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="bg-[var(--cinema-celluloid)] border-[var(--cinema-silver)]/20 max-w-md">
        <DialogHeader>
          <DialogTitle className="font-display text-2xl text-[var(--cinema-silver)]">
            {mode === 'signin' ? 'Welcome Back' : 'Create Account'}
          </DialogTitle>
          <DialogDescription className="text-[var(--cinema-silver)]/60">
            {mode === 'signin'
              ? 'Sign in to sync your stories across devices'
              : 'Create an account to save your work to the cloud'}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 pt-4">
          {/* Google Sign In */}
          <button
            onClick={handleGoogleSignIn}
            disabled={isLoading}
            className="w-full flex items-center justify-center gap-3 px-4 py-3 bg-white hover:bg-gray-50 text-gray-800 rounded-lg font-medium transition-colors disabled:opacity-50"
          >
            {isLoading ? (
              <Loader2 className="w-5 h-5 animate-spin" />
            ) : (
              <svg className="w-5 h-5" viewBox="0 0 24 24">
                <path
                  fill="currentColor"
                  d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                />
                <path
                  fill="#34A853"
                  d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                />
                <path
                  fill="#FBBC05"
                  d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                />
                <path
                  fill="#EA4335"
                  d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                />
              </svg>
            )}
            Continue with Google
          </button>

          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-[var(--cinema-silver)]/20" />
            </div>
            <div className="relative flex justify-center text-xs">
              <span className="bg-[var(--cinema-celluloid)] px-2 text-[var(--cinema-silver)]/50">
                or continue with email
              </span>
            </div>
          </div>

          {/* Email Form */}
          <form onSubmit={handleEmailSubmit} className="space-y-3">
            <div>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="Email address"
                required
                className="w-full px-4 py-3 bg-[var(--cinema-void)] border border-[var(--cinema-silver)]/20 rounded-lg text-[var(--cinema-silver)] placeholder:text-[var(--cinema-silver)]/40 focus:outline-none focus:border-[var(--cinema-spotlight)]"
              />
            </div>
            <div>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Password"
                required
                minLength={6}
                className="w-full px-4 py-3 bg-[var(--cinema-void)] border border-[var(--cinema-silver)]/20 rounded-lg text-[var(--cinema-silver)] placeholder:text-[var(--cinema-silver)]/40 focus:outline-none focus:border-[var(--cinema-spotlight)]"
              />
            </div>

            {error && (
              <div className="flex items-center gap-2 text-[var(--cinema-velvet)] text-sm">
                <AlertCircle className="w-4 h-4 shrink-0" />
                <span>{error}</span>
              </div>
            )}

            <button
              type="submit"
              disabled={isLoading}
              className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-[var(--cinema-spotlight)] hover:bg-[var(--cinema-spotlight)]/90 text-[var(--cinema-void)] rounded-lg font-medium transition-colors disabled:opacity-50"
            >
              {isLoading ? (
                <Loader2 className="w-5 h-5 animate-spin" />
              ) : (
                <Mail className="w-5 h-5" />
              )}
              {mode === 'signin' ? 'Sign In' : 'Create Account'}
            </button>
          </form>

          <div className="text-center text-sm text-[var(--cinema-silver)]/60">
            {mode === 'signin' ? (
              <>
                Don't have an account?{' '}
                <button
                  onClick={switchMode}
                  className="text-[var(--cinema-spotlight)] hover:underline"
                >
                  Sign up
                </button>
              </>
            ) : (
              <>
                Already have an account?{' '}
                <button
                  onClick={switchMode}
                  className="text-[var(--cinema-spotlight)] hover:underline"
                >
                  Sign in
                </button>
              </>
            )}
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}

export default AuthModal;
</file>

<file path="components/auth/index.ts">
/**
 * Auth Components
 */
export { AuthModal } from './AuthModal';
export { UserMenu } from './UserMenu';
</file>

<file path="components/auth/UserMenu.tsx">
/**
 * UserMenu Component
 *
 * Dropdown menu for authenticated users showing profile and sign out.
 * Shows sign-in button when not authenticated.
 */
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { useAuth } from '@/hooks/useAuth';
import { AuthModal } from './AuthModal';
import { User, LogOut, Cloud, CloudOff } from 'lucide-react';

interface UserMenuProps {
  className?: string;
}

export function UserMenu({ className }: UserMenuProps) {
  const navigate = useNavigate();
  const { user, isAuthenticated, isAuthAvailable, signOut, isLoading } = useAuth();
  const [authModalOpen, setAuthModalOpen] = useState(false);

  // Navigate to dedicated sign-in page
  const handleSignInClick = () => {
    navigate('/signin');
  };

  // If Firebase is not configured, don't show anything
  if (!isAuthAvailable) {
    return null;
  }

  // Not authenticated - show sign in button (navigates to dedicated page)
  if (!isAuthenticated) {
    return (
      <>
        <button
          onClick={handleSignInClick}
          disabled={isLoading}
          className={`flex items-center gap-2 px-3 py-1.5 text-sm text-[var(--cinema-silver)]/70 hover:text-[var(--cinema-silver)] border border-[var(--cinema-silver)]/20 hover:border-[var(--cinema-silver)]/40 rounded-lg transition-colors ${className}`}
        >
          <CloudOff className="w-4 h-4" />
          <span className="hidden sm:inline">Sign In</span>
        </button>
        {/* AuthModal kept for fallback use in other contexts */}
        <AuthModal open={authModalOpen} onOpenChange={setAuthModalOpen} />
      </>
    );
  }

  // Authenticated - show user menu
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <button
          className={`flex items-center gap-2 px-2 py-1.5 text-sm text-[var(--cinema-silver)]/80 hover:text-[var(--cinema-silver)] rounded-lg transition-colors ${className}`}
        >
          {user?.photoURL ? (
            <img
              src={user.photoURL}
              alt={user.displayName || 'User'}
              className="w-6 h-6 rounded-full"
            />
          ) : (
            <div className="w-6 h-6 rounded-full bg-[var(--cinema-spotlight)]/20 flex items-center justify-center">
              <User className="w-4 h-4 text-[var(--cinema-spotlight)]" />
            </div>
          )}
          <Cloud className="w-3.5 h-3.5 text-emerald-400" />
        </button>
      </DropdownMenuTrigger>
      <DropdownMenuContent
        align="end"
        className="w-56 bg-[var(--cinema-celluloid)] border-[var(--cinema-silver)]/20"
      >
        <DropdownMenuLabel className="font-normal">
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium text-[var(--cinema-silver)]">
              {user?.displayName || 'User'}
            </p>
            <p className="text-xs text-[var(--cinema-silver)]/60">
              {user?.email}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator className="bg-[var(--cinema-silver)]/10" />
        <DropdownMenuItem className="text-[var(--cinema-silver)]/80">
          <Cloud className="w-4 h-4 mr-2 text-emerald-400" />
          <span>Sync enabled</span>
        </DropdownMenuItem>
        <DropdownMenuSeparator className="bg-[var(--cinema-silver)]/10" />
        <DropdownMenuItem
          onClick={signOut}
          className="text-[var(--cinema-velvet)] focus:text-[var(--cinema-velvet)]"
        >
          <LogOut className="w-4 h-4 mr-2" />
          <span>Sign out</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

export default UserMenu;
</file>

<file path="components/chat/ChatInput.tsx">
/**
 * ChatInput - Chat message input component
 *
 * Provides a styled textarea with send button for chat interfaces.
 * Supports RTL layout and keyboard shortcuts.
 */

import React, { useRef, useCallback, KeyboardEvent } from 'react';
import { Send, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

export interface ChatInputProps {
  value: string;
  onChange: (value: string) => void;
  onSubmit: () => void;
  placeholder?: string;
  disabled?: boolean;
  isLoading?: boolean;
  isRTL?: boolean;
  hintText?: string;
  className?: string;
  inputId?: string;
}

/**
 * Chat input with auto-resizing textarea and send button
 */
export function ChatInput({
  value,
  onChange,
  onSubmit,
  placeholder = 'Type a message...',
  disabled = false,
  isLoading = false,
  isRTL = false,
  hintText,
  className,
  inputId = 'chat-input',
}: ChatInputProps) {
  const inputRef = useRef<HTMLTextAreaElement>(null);

  const handleKeyDown = useCallback(
    (e: KeyboardEvent<HTMLTextAreaElement>) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (!disabled && !isLoading && value.trim()) {
          onSubmit();
        }
      }
    },
    [disabled, isLoading, value, onSubmit]
  );

  const handleSubmit = useCallback(
    (e: React.FormEvent) => {
      e.preventDefault();
      if (!disabled && !isLoading && value.trim()) {
        onSubmit();
      }
    },
    [disabled, isLoading, value, onSubmit]
  );

  const isSubmitDisabled = !value.trim() || disabled || isLoading;

  return (
    <div className={cn('border-t border-white/5 bg-black/20 backdrop-blur-xl', className)}>
      <div className="max-w-3xl mx-auto px-4 py-4">
        <form
          onSubmit={handleSubmit}
          className="bg-white/5 rounded-2xl border border-white/10 focus-within:border-violet-500/50 focus-within:ring-1 focus-within:ring-violet-500/20 transition-all"
        >
          <label htmlFor={inputId} className="sr-only">
            {placeholder}
          </label>
          <textarea
            id={inputId}
            ref={inputRef}
            value={value}
            onChange={(e) => onChange(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder={placeholder}
            className={cn(
              'w-full bg-transparent border-0 focus:ring-0 resize-none text-sm text-white placeholder:text-white/30 min-h-[52px] max-h-[200px] px-4 py-3',
              isRTL && 'text-right'
            )}
            rows={1}
            disabled={disabled || isLoading}
            dir={isRTL ? 'rtl' : 'ltr'}
            aria-describedby={hintText ? `${inputId}-hint` : undefined}
          />
          <div
            className={cn(
              'flex justify-between items-center px-3 pb-3',
              isRTL && 'flex-row-reverse'
            )}
          >
            {hintText && (
              <span
                id={`${inputId}-hint`}
                className="text-[10px] text-white/20 uppercase tracking-wider"
              >
                {hintText}
              </span>
            )}
            {!hintText && <span />}
            <Button
              type="submit"
              disabled={isSubmitDisabled}
              size="sm"
              className={cn(
                'rounded-xl transition-all',
                value.trim()
                  ? 'bg-violet-600 hover:bg-violet-500 text-white'
                  : 'bg-white/10 text-white/30'
              )}
              aria-label="Send message"
            >
              {isLoading ? (
                <Loader2 className="w-4 h-4 animate-spin" aria-hidden="true" />
              ) : (
                <Send className="w-4 h-4" aria-hidden="true" />
              )}
            </Button>
          </div>
        </form>
      </div>
    </div>
  );
}

export default ChatInput;
</file>

<file path="components/chat/index.ts">
/**
 * Chat Components Index
 *
 * Exports all chat-related components for easy importing.
 */

export { MessageBubble } from './MessageBubble';
export type { MessageBubbleProps, ChatMessage, ChatMessageStatus } from './MessageBubble';

export { ChatInput } from './ChatInput';
export type { ChatInputProps } from './ChatInput';

export { QuickActions } from './QuickActions';
export type { QuickActionsProps, QuickActionItem } from './QuickActions';
</file>

<file path="components/chat/MessageBubble.tsx">
/**
 * MessageBubble - Chat message display component
 *
 * Renders individual chat messages with support for:
 * - User and assistant message styling
 * - Quick action buttons
 * - Progress indicators
 * - RTL layout support
 */

import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { Sparkles, Loader2, CheckCircle2 } from 'lucide-react';
import { cn } from '@/lib/utils';
import type { Message, QuickAction } from '@/stores/appStore';

export interface ChatMessageStatus {
  status?: 'thinking' | 'generating' | 'complete' | 'error';
  progress?: number;
  videoReady?: boolean;
}

export interface ChatMessage extends Message, ChatMessageStatus {
  quickActions?: Array<{
    id: string;
    label: string;
    labelAr?: string;
    action: QuickAction['action'];
    variant?: 'primary' | 'secondary';
  }>;
}

export interface FeedbackData {
  helpful: boolean;
  rating: number;
  comment?: string;
}

export interface MessageBubbleProps {
  message: ChatMessage;
  isRTL?: boolean;
  onQuickAction?: (action: QuickAction['action']) => void;
  onFeedback?: (messageId: string, feedback: FeedbackData) => void;
  className?: string;
}

/**
 * Renders a single chat message bubble
 */
export function MessageBubble({
  message,
  isRTL = false,
  onQuickAction,
  onFeedback,
  className,
}: MessageBubbleProps) {
  const [showFeedbackForm, setShowFeedbackForm] = useState(false);
  const [feedbackComment, setFeedbackComment] = useState('');

  const isUser = message.role === 'user';
  const hasQuickActions = !isUser && message.quickActions && message.quickActions.length > 0;

  const handleFeedback = (helpful: boolean) => {
    if (helpful) {
      onFeedback?.(message.id, { helpful: true, rating: 5 });
    } else {
      setShowFeedbackForm(true);
    }
  };

  const submitFeedback = () => {
    onFeedback?.(message.id, {
      helpful: false,
      rating: 2,
      comment: feedbackComment,
    });
    setShowFeedbackForm(false);
    setFeedbackComment('');
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      className={cn(
        'flex gap-4',
        isUser ? 'justify-end' : 'justify-start',
        isRTL && 'flex-row-reverse',
        className
      )}
    >
      {/* Assistant Avatar */}
      {!isUser && (
        <div
          className="w-8 h-8 rounded-full bg-gradient-to-br from-violet-600 to-fuchsia-600 flex items-center justify-center shrink-0 mt-1"
          aria-hidden="true"
        >
          <Sparkles className="w-4 h-4 text-white" />
        </div>
      )}

      {/* Message Content */}
      <div className={cn('max-w-[80%]', isUser && (isRTL ? 'text-start' : 'text-end'))}>
        <div
          className={cn(
            'inline-block px-4 py-3 text-[15px] leading-relaxed',
            isUser
              ? 'bg-violet-600 text-white rounded-2xl rounded-te-md'
              : 'bg-white/5 text-white/90 rounded-2xl rounded-ts-md border border-white/10'
          )}
        >
          <div className="whitespace-pre-wrap">{message.content}</div>
        </div>

        {/* Quick Action Buttons */}
        {hasQuickActions && (
          <motion.div
            initial={{ opacity: 0, y: 5 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2 }}
            className={cn('mt-3 flex flex-wrap gap-2', isRTL && 'flex-row-reverse')}
          >
            {message.quickActions!.map((qa) => (
              <button
                key={qa.id}
                onClick={() => onQuickAction?.(qa.action)}
                className={cn(
                  'px-4 py-2 rounded-xl text-sm font-medium transition-all',
                  'hover:scale-105 active:scale-95',
                  qa.variant === 'primary'
                    ? 'bg-gradient-to-r from-violet-600 to-fuchsia-600 text-white hover:from-violet-500 hover:to-fuchsia-500'
                    : 'bg-white/10 text-white/90 border border-white/20 hover:bg-white/20'
                )}
              >
                {isRTL && qa.labelAr ? qa.labelAr : qa.label}
              </button>
            ))}
          </motion.div>
        )}

        {/* Progress Indicator */}
        {message.status === 'generating' && message.progress !== undefined && (
          <div className={cn('mt-3 flex items-center gap-3', isRTL && 'flex-row-reverse')}>
            <div className="flex-1 h-1.5 bg-white/10 rounded-full overflow-hidden max-w-[200px]">
              <motion.div
                className="h-full bg-gradient-to-r from-violet-500 to-fuchsia-500"
                initial={{ width: 0 }}
                animate={{ width: `${message.progress}%` }}
                transition={{ duration: 0.5 }}
              />
            </div>
            <span className="text-xs text-white/40 tabular-nums">
              {Math.round(message.progress)}%
            </span>
          </div>
        )}

        {/* Thinking Indicator */}
        {message.status === 'thinking' && (
          <div
            className={cn(
              'mt-2 flex items-center gap-2 text-white/40 text-sm',
              isRTL && 'flex-row-reverse'
            )}
          >
            <Loader2 className="w-3.5 h-3.5 animate-spin" aria-hidden="true" />
            <span>...</span>
          </div>
        )}

        {/* Video Ready Badge */}
        {message.videoReady && (
          <motion.div
            initial={{ opacity: 0, y: 5 }}
            animate={{ opacity: 1, y: 0 }}
            className="mt-3 inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-emerald-500/10 border border-emerald-500/20 text-emerald-400 text-xs font-medium"
          >
            <CheckCircle2 className="w-3.5 h-3.5" aria-hidden="true" />
            Ready
          </motion.div>
        )}

        {/* Feedback Buttons (only for assistant messages) */}
        {!isUser && onFeedback && (
          <div className={cn('mt-2 flex gap-2', isRTL && 'flex-row-reverse')}>
            <button
              onClick={() => handleFeedback(true)}
              className="text-xs text-white/40 hover:text-green-400 transition-colors flex items-center gap-1"
              aria-label="Mark as helpful"
            >
              <span>üëç</span>
              <span>Helpful</span>
            </button>
            <button
              onClick={() => handleFeedback(false)}
              className="text-xs text-white/40 hover:text-red-400 transition-colors flex items-center gap-1"
              aria-label="Mark as not helpful"
            >
              <span>üëé</span>
              <span>Not helpful</span>
            </button>
          </div>
        )}

        {/* Feedback Form */}
        {showFeedbackForm && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            className="mt-3 p-3 bg-white/5 rounded-lg border border-white/10"
          >
            <label htmlFor={`feedback-${message.id}`} className="text-xs text-white/60 block mb-2">
              What could be improved?
            </label>
            <textarea
              id={`feedback-${message.id}`}
              value={feedbackComment}
              onChange={(e) => setFeedbackComment(e.target.value)}
              placeholder="Your feedback helps us improve..."
              className="w-full bg-white/10 rounded p-2 text-sm text-white placeholder:text-white/30 border border-white/10 focus:border-violet-500 focus:ring-1 focus:ring-violet-500 min-h-[60px]"
              dir={isRTL ? 'rtl' : 'ltr'}
            />
            <div className={cn('mt-2 flex gap-2', isRTL && 'flex-row-reverse')}>
              <button
                onClick={submitFeedback}
                disabled={!feedbackComment.trim()}
                className="px-3 py-1.5 bg-violet-600 hover:bg-violet-500 disabled:bg-white/10 disabled:text-white/30 rounded text-sm transition-colors"
              >
                Submit
              </button>
              <button
                onClick={() => setShowFeedbackForm(false)}
                className="px-3 py-1.5 bg-white/10 hover:bg-white/20 rounded text-sm transition-colors"
              >
                Cancel
              </button>
            </div>
          </motion.div>
        )}
      </div>

      {/* User Avatar */}
      {isUser && (
        <div
          className="w-8 h-8 rounded-full bg-white/10 flex items-center justify-center shrink-0 mt-1 text-white/60 text-sm font-medium"
          aria-hidden="true"
        >
          U
        </div>
      )}
    </motion.div>
  );
}

export default MessageBubble;
</file>

<file path="components/chat/QuickActions.tsx">
/**
 * QuickActions - Quick action button strip
 *
 * Displays a row of quick action buttons for common actions
 * like creating videos, generating music, etc.
 */

import React from 'react';
import { LucideIcon } from 'lucide-react';
import { cn } from '@/lib/utils';

export interface QuickActionItem {
  icon: LucideIcon;
  label: string;
  prompt?: string;
  onClick?: () => void;
}

export interface QuickActionsProps {
  /** List of quick actions to display */
  actions: QuickActionItem[];
  /** Callback when an action is selected */
  onSelect?: (action: QuickActionItem) => void;
  /** RTL layout */
  isRTL?: boolean;
  /** Additional class names */
  className?: string;
}

/**
 * Quick action button strip
 *
 * @example
 * ```tsx
 * <QuickActions
 *   actions={[
 *     { icon: Video, label: 'Create Video', prompt: 'Create a...' },
 *     { icon: Music, label: 'Generate Music', prompt: 'Generate...' },
 *   ]}
 *   onSelect={(action) => setInput(action.prompt)}
 * />
 * ```
 */
export function QuickActions({
  actions,
  onSelect,
  isRTL = false,
  className,
}: QuickActionsProps) {
  const handleClick = (action: QuickActionItem) => {
    if (action.onClick) {
      action.onClick();
    } else if (onSelect) {
      onSelect(action);
    }
  };

  return (
    <div className={cn('max-w-3xl mx-auto w-full px-4 pb-4', className)}>
      <div
        className={cn(
          'flex flex-wrap justify-center gap-2',
          isRTL && 'flex-row-reverse'
        )}
      >
        {actions.map((action) => (
          <button
            key={action.label}
            onClick={() => handleClick(action)}
            className="flex items-center gap-2 px-4 py-2.5 rounded-full bg-white/5 hover:bg-white/10 border border-white/10 text-sm text-white/70 hover:text-white transition-all"
          >
            <action.icon className="w-4 h-4 text-violet-400" aria-hidden="true" />
            {action.label}
          </button>
        ))}
      </div>
    </div>
  );
}

export default QuickActions;
</file>

<file path="components/CheckpointApproval.test.tsx">
/**
 * CheckpointApproval Component Tests
 *
 * Tests: approval flow, change request flow, timeout handling
 * Requirements: 17.1, 17.2, 17.3, 17.5
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { CheckpointApproval } from './CheckpointApproval';

// Suppress framer-motion in test env
vi.mock('framer-motion', () => ({
  motion: {
    div: ({ children, className, ...props }: any) => (
      <div className={className} {...props}>{children}</div>
    ),
  },
  AnimatePresence: ({ children }: any) => <>{children}</>,
}));

describe('CheckpointApproval', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  const defaultProps = {
    checkpointId: 'cp_test_001',
    phase: 'script-review',
    title: 'Review Script',
    onApprove: vi.fn(),
    onRequestChanges: vi.fn(),
  };

  describe('Approval flow', () => {
    it('should render with title and phase', () => {
      render(<CheckpointApproval {...defaultProps} />);
      expect(screen.getByText('Review Script')).toBeTruthy();
      expect(screen.getByText('script-review')).toBeTruthy();
    });

    it('should call onApprove with checkpointId when Approve is clicked', () => {
      const onApprove = vi.fn();
      render(<CheckpointApproval {...defaultProps} onApprove={onApprove} />);

      fireEvent.click(screen.getByText('Approve'));
      expect(onApprove).toHaveBeenCalledWith('cp_test_001');
    });

    it('should render preview data when provided', () => {
      render(
        <CheckpointApproval
          {...defaultProps}
          previewData={<span>Preview content here</span>}
        />,
      );
      expect(screen.getByText('Preview content here')).toBeTruthy();
    });

    it('should render description when provided', () => {
      render(
        <CheckpointApproval
          {...defaultProps}
          description="Check the generated script"
        />,
      );
      expect(screen.getByText('Check the generated script')).toBeTruthy();
    });
  });

  describe('Change request flow', () => {
    it('should show textarea when Request Changes is clicked', () => {
      render(<CheckpointApproval {...defaultProps} />);

      fireEvent.click(screen.getByText('Request Changes'));
      expect(screen.getByPlaceholderText('Describe what should be changed...')).toBeTruthy();
    });

    it('should call onRequestChanges with change text', () => {
      const onRequestChanges = vi.fn();
      render(
        <CheckpointApproval {...defaultProps} onRequestChanges={onRequestChanges} />,
      );

      fireEvent.click(screen.getByText('Request Changes'));
      const textarea = screen.getByPlaceholderText('Describe what should be changed...');
      fireEvent.change(textarea, { target: { value: 'Make it shorter' } });
      fireEvent.click(screen.getByText('Submit Changes'));

      expect(onRequestChanges).toHaveBeenCalledWith('cp_test_001', 'Make it shorter');
    });

    it('should not submit empty change requests', () => {
      const onRequestChanges = vi.fn();
      render(
        <CheckpointApproval {...defaultProps} onRequestChanges={onRequestChanges} />,
      );

      fireEvent.click(screen.getByText('Request Changes'));
      fireEvent.click(screen.getByText('Submit Changes'));

      expect(onRequestChanges).not.toHaveBeenCalled();
    });

    it('should hide textarea when Cancel is clicked', () => {
      render(<CheckpointApproval {...defaultProps} />);

      fireEvent.click(screen.getByText('Request Changes'));
      expect(screen.getByPlaceholderText('Describe what should be changed...')).toBeTruthy();

      // Button text changes to "Cancel"
      fireEvent.click(screen.getByText('Cancel'));
      expect(screen.queryByPlaceholderText('Describe what should be changed...')).toBeNull();
    });
  });

  describe('Timeout handling', () => {
    it('should show countdown timer', () => {
      render(<CheckpointApproval {...defaultProps} timeoutMs={60_000} />);
      // Should show ~1:00
      expect(screen.getByText('1:00')).toBeTruthy();
    });

    it('should show warning banner at 5 minutes remaining', () => {
      render(<CheckpointApproval {...defaultProps} timeoutMs={10 * 60 * 1000} />);

      // Advance to 5 min remaining (5 min elapsed of 10 min total)
      act(() => {
        vi.advanceTimersByTime(5 * 60 * 1000);
      });

      expect(screen.getByText(/auto-save/i)).toBeTruthy();
    });

    it('should call onTimeout when timer expires', () => {
      const onTimeout = vi.fn();
      render(
        <CheckpointApproval {...defaultProps} timeoutMs={5000} onTimeout={onTimeout} />,
      );

      act(() => {
        vi.advanceTimersByTime(5100);
      });

      expect(onTimeout).toHaveBeenCalledWith('cp_test_001');
    });

    it('should show auto-saved notification after timeout', () => {
      render(<CheckpointApproval {...defaultProps} timeoutMs={5000} />);

      act(() => {
        vi.advanceTimersByTime(5100);
      });

      expect(screen.getByText(/auto-saved/i)).toBeTruthy();
    });

    it('should disable buttons after timeout', () => {
      render(<CheckpointApproval {...defaultProps} timeoutMs={5000} />);

      act(() => {
        vi.advanceTimersByTime(5100);
      });

      const approveBtn = screen.getByLabelText('Approve checkpoint');
      expect(approveBtn).toHaveProperty('disabled', true);
    });
  });
});
</file>

<file path="components/CheckpointApproval.tsx">
/**
 * Checkpoint Approval Component
 *
 * Displays a checkpoint gate for human-in-the-loop approval during
 * multi-format pipeline execution. Shows preview content, approve/reject
 * controls, and a countdown timer with timeout warnings.
 *
 * Requirements: 17.1, 17.2, 17.3, 17.5
 */

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Check,
  X,
  Clock,
  Edit3,
  AlertTriangle,
  Save,
} from 'lucide-react';
import { cn } from '@/lib/utils';

export interface CheckpointApprovalProps {
  checkpointId: string;
  phase: string;
  title: string;
  description?: string;
  previewData?: React.ReactNode;
  timeoutMs?: number;
  onApprove: (checkpointId: string) => void;
  onRequestChanges: (checkpointId: string, changeRequest: string) => void;
  onTimeout?: (checkpointId: string) => void;
  className?: string;
}

const DEFAULT_TIMEOUT_MS = 30 * 60 * 1000;
const WARNING_THRESHOLD_MS = 5 * 60 * 1000;

function formatCountdown(ms: number): string {
  if (ms <= 0) return '0:00';
  const totalSeconds = Math.ceil(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

export function CheckpointApproval({
  checkpointId,
  phase,
  title,
  description,
  previewData,
  timeoutMs = DEFAULT_TIMEOUT_MS,
  onApprove,
  onRequestChanges,
  onTimeout,
  className,
}: CheckpointApprovalProps) {
  const [showChangeInput, setShowChangeInput] = useState(false);
  const [changeRequest, setChangeRequest] = useState('');
  const [remaining, setRemaining] = useState(timeoutMs);
  const [timedOut, setTimedOut] = useState(false);
  const startTimeRef = useRef(Date.now());
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    startTimeRef.current = Date.now();
    setRemaining(timeoutMs);
    setTimedOut(false);

    const interval = setInterval(() => {
      const elapsed = Date.now() - startTimeRef.current;
      const left = Math.max(0, timeoutMs - elapsed);
      setRemaining(left);

      if (left <= 0) {
        clearInterval(interval);
        setTimedOut(true);
        onTimeout?.(checkpointId);
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [checkpointId, timeoutMs, onTimeout]);

  useEffect(() => {
    if (showChangeInput) {
      textareaRef.current?.focus();
    }
  }, [showChangeInput]);

  const handleApprove = useCallback(() => {
    onApprove(checkpointId);
  }, [checkpointId, onApprove]);

  const handleSubmitChanges = useCallback(() => {
    const trimmed = changeRequest.trim();
    if (!trimmed) return;
    onRequestChanges(checkpointId, trimmed);
  }, [checkpointId, changeRequest, onRequestChanges]);

  const handleToggleChangeInput = useCallback(() => {
    setShowChangeInput((prev) => !prev);
    setChangeRequest('');
  }, []);

  const isWarning = remaining <= WARNING_THRESHOLD_MS && remaining > 0;

  return (
    <motion.div
      initial={{ opacity: 0, y: 8 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -8 }}
      transition={{ duration: 0.25, ease: 'easeOut' }}
      className={cn('w-full max-w-2xl mx-auto', className)}
      role="dialog"
      aria-label={`Checkpoint approval: ${title}`}
    >
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <div>
          <div className="flex items-center gap-2 mb-1">
            <span className="font-mono text-[10px] font-medium tracking-[0.15em] uppercase text-zinc-500">
              {phase}
            </span>
          </div>
          <h2 className="text-lg font-medium text-zinc-100">{title}</h2>
          {description && (
            <p className="text-[13px] text-zinc-400 mt-1">{description}</p>
          )}
        </div>

        <div
          className={cn(
            'flex items-center gap-1.5 px-2.5 py-1 rounded-sm border font-mono text-xs',
            timedOut
              ? 'border-zinc-700 bg-zinc-900/60 text-zinc-500'
              : isWarning
                ? 'border-amber-500/50 bg-amber-500/10 text-amber-400'
                : 'border-zinc-700 text-zinc-400',
          )}
          aria-label={`Time remaining: ${formatCountdown(remaining)}`}
          aria-live="polite"
        >
          <Clock className="w-3 h-3" />
          <span>{timedOut ? 'Timed out' : formatCountdown(remaining)}</span>
        </div>
      </div>

      {/* Warning banner */}
      <AnimatePresence>
        {isWarning && !timedOut && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            className="mb-4 overflow-hidden"
          >
            <div className="flex items-center gap-2 px-3 py-2 rounded-sm border border-amber-500/40 bg-amber-500/10">
              <AlertTriangle className="w-3.5 h-3.5 text-amber-400 shrink-0" />
              <span className="text-xs font-mono text-amber-300">
                Checkpoint will auto-save in {formatCountdown(remaining)}
              </span>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Auto-saved notification */}
      <AnimatePresence>
        {timedOut && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            className="mb-4 overflow-hidden"
          >
            <div className="flex items-center gap-2 px-3 py-2 rounded-sm border border-zinc-600 bg-zinc-800/80">
              <Save className="w-3.5 h-3.5 text-zinc-400 shrink-0" />
              <span className="text-xs font-mono text-zinc-300">
                State auto-saved. Approval timed out.
              </span>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Preview content */}
      {previewData && (
        <div className="mb-4 px-3 py-3 rounded-sm border border-zinc-700 bg-zinc-900/80">
          <span className="font-mono text-[10px] font-medium tracking-[0.15em] uppercase text-zinc-500 block mb-2">
            Preview
          </span>
          <div className="text-[13px] text-zinc-300">{previewData}</div>
        </div>
      )}

      {/* Action buttons */}
      <div className="flex items-center gap-2">
        <button
          type="button"
          onClick={handleApprove}
          disabled={timedOut}
          className={cn(
            'flex items-center gap-2 px-3 py-1.5 rounded-sm border text-xs font-mono transition-colors duration-200',
            'disabled:opacity-50 disabled:cursor-not-allowed',
            'border-emerald-500/50 bg-emerald-500/10 text-emerald-400',
            'hover:bg-emerald-500/20 hover:border-emerald-500/70',
            'focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-emerald-500',
          )}
          aria-label={`Approve checkpoint`}
        >
          <Check className="w-3 h-3" />
          <span>Approve</span>
        </button>

        <button
          type="button"
          onClick={handleToggleChangeInput}
          disabled={timedOut}
          className={cn(
            'flex items-center gap-2 px-3 py-1.5 rounded-sm border text-xs font-mono transition-colors duration-200',
            'disabled:opacity-50 disabled:cursor-not-allowed',
            showChangeInput
              ? 'border-amber-500/50 bg-amber-500/10 text-amber-400'
              : 'border-zinc-700 text-zinc-400 hover:border-zinc-500 hover:text-zinc-200',
            'focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-zinc-500',
          )}
          aria-label="Request changes"
          aria-expanded={showChangeInput}
        >
          <Edit3 className="w-3 h-3" />
          <span>{showChangeInput ? 'Cancel' : 'Request Changes'}</span>
        </button>
      </div>

      {/* Change request textarea */}
      <AnimatePresence>
        {showChangeInput && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.2 }}
            className="overflow-hidden"
          >
            <div className="mt-3 space-y-2">
              <label
                htmlFor={`change-request-${checkpointId}`}
                className="font-mono text-[10px] font-medium tracking-[0.15em] uppercase text-zinc-500"
              >
                Describe requested changes
              </label>
              <textarea
                ref={textareaRef}
                id={`change-request-${checkpointId}`}
                value={changeRequest}
                onChange={(e) => setChangeRequest(e.target.value)}
                placeholder="Describe what should be changed..."
                rows={3}
                className={cn(
                  'w-full px-3 py-2 rounded-sm border border-zinc-700 bg-zinc-900/80',
                  'text-[13px] text-zinc-200 placeholder:text-zinc-600',
                  'font-mono resize-none',
                  'focus:outline-none focus:border-zinc-500',
                )}
              />
              <button
                type="button"
                onClick={handleSubmitChanges}
                disabled={!changeRequest.trim()}
                className={cn(
                  'flex items-center gap-2 px-3 py-1.5 rounded-sm border text-xs font-mono transition-colors duration-200',
                  'disabled:opacity-50 disabled:cursor-not-allowed',
                  'border-amber-500/50 bg-amber-500/10 text-amber-400',
                  'hover:bg-amber-500/20 hover:border-amber-500/70',
                  'focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-amber-500',
                )}
              >
                <X className="w-3 h-3" />
                <span>Submit Changes</span>
              </button>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
}

export default CheckpointApproval;
</file>

<file path="components/ErrorBoundary.tsx">
import React from "react";
import { Button } from "./ui/button";

interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ReactNode;
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

/**
 * Error Boundary component that catches JavaScript errors in child components,
 * logs them, and displays a fallback UI instead of crashing the entire app.
 * 
 * Requirements: 7.1, 7.2, 7.3, 7.4
 */
class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    // Update state so the next render shows the fallback UI
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    // Log error for debugging purposes (Requirement 7.3)
    console.error("[ErrorBoundary] Caught error:", error);
    console.error("[ErrorBoundary] Component stack:", errorInfo.componentStack);

    // Call optional error callback
    this.props.onError?.(error, errorInfo);
  }

  handleRetry = (): void => {
    this.setState({ hasError: false, error: null });
  };

  render(): React.ReactNode {
    if (this.state.hasError) {
      // Render custom fallback if provided, otherwise use default
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <DefaultErrorFallback
          error={this.state.error}
          onRetry={this.handleRetry}
        />
      );
    }

    return this.props.children;
  }
}

interface DefaultErrorFallbackProps {
  error: Error | null;
  onRetry: () => void;
}

/**
 * Generate a unique error ID for support reference
 */
function generateErrorId(): string {
  return `ERR-${Date.now().toString(36).toUpperCase()}-${Math.random().toString(36).substring(2, 6).toUpperCase()}`;
}

/**
 * Default fallback UI shown when an error is caught.
 * Provides retry functionality (Requirement 7.4)
 */
function DefaultErrorFallback({ error, onRetry }: DefaultErrorFallbackProps): React.ReactElement {
  const errorId = React.useMemo(() => generateErrorId(), []);

  return (
    <div
      role="alert"
      aria-live="assertive"
      aria-atomic="true"
      className="flex flex-col items-center justify-center min-h-[200px] p-8 bg-slate-800/50 rounded-lg border border-slate-700"
    >
      <div className="text-red-400 mb-4">
        <svg
          className="w-12 h-12"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          aria-hidden="true"
          focusable="false"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
          />
        </svg>
      </div>

      <h2 className="text-xl font-semibold text-white mb-2">
        Something went wrong
      </h2>

      <p className="text-slate-400 text-center mb-4 max-w-md">
        An unexpected error occurred. You can try again or refresh the page.
      </p>

      {error && (
        <details className="mb-4 text-sm text-slate-500 max-w-md">
          <summary className="cursor-pointer hover:text-slate-400">
            Error details
          </summary>
          <pre className="mt-2 p-2 bg-slate-900 rounded text-xs overflow-auto max-h-32">
            {error.message}
          </pre>
        </details>
      )}

      {/* Error ID for support reference */}
      <p className="text-xs text-slate-600 mb-4" aria-label={`Error reference ID: ${errorId}`}>
        Reference: <code className="font-mono">{errorId}</code>
      </p>

      <div className="flex gap-3">
        <Button
          onClick={onRetry}
          variant="default"
          className="bg-purple-600 hover:bg-purple-700"
        >
          Try Again
        </Button>
        <Button
          onClick={() => window.location.reload()}
          variant="outline"
          className="border-slate-600 text-slate-300 hover:bg-slate-700"
        >
          Refresh Page
        </Button>
      </div>
    </div>
  );
}

export { ErrorBoundary, DefaultErrorFallback };
</file>

<file path="components/FormatSelector.test.ts">
/**
 * FormatSelector Property-Based Tests
 *
 * Feature: multi-format-pipeline
 *
 * Property 43: Genre Filtering by Format
 *   Validates: Requirements 1.3, 23.1
 *
 * Property 44: Format-Specific Placeholder
 *   Validates: Requirements 1.4
 *
 * Property 45: Pipeline Execution Prevention
 *   Validates: Requirements 1.5
 */

import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import { formatRegistry } from '@/services/formatRegistry';
import { getGenresForFormat, getPlaceholderForFormat } from './FormatSelector';
import type { VideoFormat } from '@/types';

// ============================================================================
// Arbitraries
// ============================================================================

const ALL_FORMAT_IDS: VideoFormat[] = [
  'youtube-narrator',
  'advertisement',
  'movie-animation',
  'educational',
  'shorts',
  'documentary',
  'music-video',
  'news-politics',
];

const arbFormatId = fc.constantFrom(...ALL_FORMAT_IDS);

// ============================================================================
// Property 43: Genre Filtering by Format
// ============================================================================

describe('Feature: multi-format-pipeline, Property 43: Genre Filtering by Format', () => {
  it('displayed genres SHALL be exactly the format\'s applicableGenres list', () => {
    fc.assert(
      fc.property(arbFormatId, (formatId) => {
        const formatMetadata = formatRegistry.getFormat(formatId);
        expect(formatMetadata).not.toBeNull();

        const displayedGenres = getGenresForFormat(formatId);

        // Exactly matches the format's applicableGenres
        expect(displayedGenres).toEqual(formatMetadata!.applicableGenres);

        // No additional or missing genres
        expect(displayedGenres.length).toBe(formatMetadata!.applicableGenres.length);

        // Every displayed genre is in the format's list
        for (const genre of displayedGenres) {
          expect(formatMetadata!.applicableGenres).toContain(genre);
        }

        // Every format genre is displayed
        for (const genre of formatMetadata!.applicableGenres) {
          expect(displayedGenres).toContain(genre);
        }
      }),
      { numRuns: 100 },
    );
  });

  it('invalid format returns empty genre list', () => {
    fc.assert(
      fc.property(
        fc.string().filter((s) => !ALL_FORMAT_IDS.includes(s as VideoFormat)),
        (invalidId) => {
          const genres = getGenresForFormat(invalidId);
          expect(genres).toEqual([]);
        },
      ),
      { numRuns: 50 },
    );
  });

  it('all 8 formats have at least one applicable genre', () => {
    for (const formatId of ALL_FORMAT_IDS) {
      const genres = getGenresForFormat(formatId);
      expect(genres.length).toBeGreaterThan(0);
    }
  });
});

// ============================================================================
// Property 44: Format-Specific Placeholder
// ============================================================================

describe('Feature: multi-format-pipeline, Property 44: Format-Specific Placeholder', () => {
  it('each format SHALL have a unique, non-empty placeholder text', () => {
    fc.assert(
      fc.property(arbFormatId, (formatId) => {
        const placeholder = getPlaceholderForFormat(formatId);

        // Must be a non-empty string
        expect(typeof placeholder).toBe('string');
        expect(placeholder.length).toBeGreaterThan(0);
      }),
      { numRuns: 100 },
    );
  });

  it('different formats have different placeholder text', () => {
    const placeholders = new Set<string>();
    for (const formatId of ALL_FORMAT_IDS) {
      const placeholder = getPlaceholderForFormat(formatId);
      placeholders.add(placeholder);
    }
    // All 8 formats have unique placeholders
    expect(placeholders.size).toBe(ALL_FORMAT_IDS.length);
  });
});

// ============================================================================
// Property 45: Pipeline Execution Prevention
// ============================================================================

describe('Feature: multi-format-pipeline, Property 45: Pipeline Execution Prevention', () => {
  it('SHALL prevent execution when no format is selected (null)', () => {
    // Simulates the execution guard logic from FormatSelector
    const selectedFormat: VideoFormat | null = null;
    const canExecute = selectedFormat !== null;
    expect(canExecute).toBe(false);
  });

  it('SHALL allow execution when a valid format is selected', () => {
    fc.assert(
      fc.property(arbFormatId, (formatId) => {
        const selectedFormat: VideoFormat | null = formatId;
        const idea = 'A test idea';
        const canExecute = selectedFormat !== null && idea.trim().length > 0;
        expect(canExecute).toBe(true);
      }),
      { numRuns: 100 },
    );
  });

  it('SHALL prevent execution when format is selected but idea is empty', () => {
    fc.assert(
      fc.property(
        arbFormatId,
        fc.constantFrom('', '   ', '\n', '\t'),
        (formatId, emptyIdea) => {
          const canExecute = formatId !== null && emptyIdea.trim().length > 0;
          expect(canExecute).toBe(false);
        },
      ),
      { numRuns: 100 },
    );
  });
});
</file>

<file path="components/FormatSelector.tsx">
/**
 * Format Selector Component
 *
 * Displays 8 video format options in a grid layout.
 * Handles format selection, genre filtering, and format-specific placeholder text.
 * Prevents pipeline execution until a format is selected.
 *
 * Requirements: 1.1, 1.3, 1.4, 1.5
 * Properties: 43 (Genre Filtering), 44 (Format-Specific Placeholder), 45 (Execution Prevention)
 */

import React, { useState, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Mic,
  Megaphone,
  Film,
  GraduationCap,
  Smartphone,
  Camera,
  Music,
  Newspaper,
  ChevronRight,
  ArrowRight,
  AlertCircle,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import type { VideoFormat, FormatMetadata } from '@/types';
import { formatRegistry } from '@/services/formatRegistry';

// Map format IDs to lucide icons
const FORMAT_ICONS: Record<VideoFormat, React.ElementType> = {
  'youtube-narrator': Mic,
  advertisement: Megaphone,
  'movie-animation': Film,
  educational: GraduationCap,
  shorts: Smartphone,
  documentary: Camera,
  'music-video': Music,
  'news-politics': Newspaper,
};

// Format-specific placeholder text for the idea input
const FORMAT_PLACEHOLDERS: Record<VideoFormat, string> = {
  'youtube-narrator':
    'Describe a topic you want to narrate about... e.g., "The hidden history of the Silk Road"',
  advertisement:
    'Describe your product or service... e.g., "A new fitness app that uses AI to create personalized workouts"',
  'movie-animation':
    'Describe your story concept... e.g., "A young robot dreams of becoming a painter"',
  educational:
    'Describe what you want to teach... e.g., "How photosynthesis works at the molecular level"',
  shorts:
    'Describe a short, punchy idea... e.g., "3 mind-blowing facts about the ocean"',
  documentary:
    'Describe your documentary subject... e.g., "The rise and fall of a forgotten civilization"',
  'music-video':
    'Describe the song mood and theme... e.g., "An upbeat pop song about chasing your dreams"',
  'news-politics':
    'Describe the news topic... e.g., "The impact of AI regulation on global tech industries"',
};

export interface FormatSelectorProps {
  selectedFormat: VideoFormat | null;
  onFormatSelect: (format: VideoFormat) => void;
  selectedGenre: string | null;
  onGenreSelect: (genre: string) => void;
  idea: string;
  onIdeaChange: (idea: string) => void;
  onExecute: () => void;
  isProcessing?: boolean;
}

export function FormatSelector({
  selectedFormat,
  onFormatSelect,
  selectedGenre,
  onGenreSelect,
  idea,
  onIdeaChange,
  onExecute,
  isProcessing = false,
}: FormatSelectorProps) {
  const [showExecutionError, setShowExecutionError] = useState(false);

  const allFormats = useMemo(() => formatRegistry.getAllFormats(), []);

  const selectedFormatMetadata = useMemo(
    () => (selectedFormat ? formatRegistry.getFormat(selectedFormat) : null),
    [selectedFormat],
  );

  // Property 43: Genre list is exactly the format's applicableGenres
  const applicableGenres = useMemo(
    () => selectedFormatMetadata?.applicableGenres ?? [],
    [selectedFormatMetadata],
  );

  // Property 44: Placeholder updates based on format
  const placeholder = selectedFormat
    ? FORMAT_PLACEHOLDERS[selectedFormat]
    : 'Select a format above to get started...';

  // Property 45: Prevent execution without format
  const handleExecuteClick = () => {
    if (!selectedFormat) {
      setShowExecutionError(true);
      setTimeout(() => setShowExecutionError(false), 3000);
      return;
    }
    onExecute();
  };

  const canExecute = !!selectedFormat && idea.trim().length > 0 && !isProcessing;

  return (
    <div className="flex flex-col items-center min-h-[70vh] px-6 py-12 bg-black">
      <div className="w-full max-w-3xl">
        {/* Header */}
        <div className="mb-10">
          <h1 className="font-sans text-3xl font-medium tracking-tight text-zinc-100">
            What will you create?
          </h1>
          <p className="text-zinc-500 text-sm mt-2 leading-relaxed">
            Choose a format to shape your entire production pipeline
          </p>
        </div>

        {/* Format Grid */}
        <div className="grid grid-cols-2 sm:grid-cols-4 gap-3 mb-10">
          {allFormats.map((format) => {
            const Icon = FORMAT_ICONS[format.id];
            const isSelected = selectedFormat === format.id;

            return (
              <button
                key={format.id}
                type="button"
                onClick={() => onFormatSelect(format.id)}
                disabled={isProcessing}
                className={cn(
                  'group relative flex flex-col items-center gap-2.5 px-4 py-5 rounded-sm border transition-all duration-200',
                  'disabled:opacity-40 disabled:cursor-not-allowed',
                  isSelected
                    ? 'bg-blue-500/10 border-blue-500/50'
                    : 'border-zinc-800 hover:border-zinc-600 bg-zinc-900/50',
                )}
              >
                <Icon
                  className={cn(
                    'w-6 h-6 transition-colors duration-200',
                    isSelected ? 'text-blue-400' : 'text-zinc-500 group-hover:text-zinc-300',
                  )}
                />
                <span
                  className={cn(
                    'text-[13px] font-medium text-center leading-tight transition-colors duration-200',
                    isSelected ? 'text-blue-400' : 'text-zinc-400 group-hover:text-zinc-200',
                  )}
                >
                  {format.name}
                </span>
                <span className="text-[10px] text-zinc-600 text-center leading-snug line-clamp-2">
                  {format.description}
                </span>
              </button>
            );
          })}
        </div>

        {/* Genre Selection - only shown when format is selected */}
        <AnimatePresence>
          {selectedFormat && applicableGenres.length > 0 && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              transition={{ duration: 0.2, ease: 'easeOut' }}
              className="mb-8"
            >
              <div className="flex items-center justify-between mb-3">
                <span className="font-mono text-[11px] font-medium tracking-[0.15em] uppercase text-zinc-500">
                  Genre
                </span>
                <span className="text-[10px] font-mono text-zinc-600">
                  {applicableGenres.length} available
                </span>
              </div>
              <div className="flex flex-wrap gap-2">
                {applicableGenres.map((genre) => {
                  const isSelected = selectedGenre === genre;
                  return (
                    <button
                      key={genre}
                      type="button"
                      onClick={() => onGenreSelect(genre)}
                      disabled={isProcessing}
                      className={cn(
                        'px-3 py-1.5 rounded-sm border text-[13px] font-medium transition-colors duration-200',
                        'disabled:opacity-40 disabled:cursor-not-allowed',
                        isSelected
                          ? 'bg-blue-500/10 border-blue-500/50 text-blue-400'
                          : 'border-zinc-800 text-zinc-500 hover:border-zinc-600 hover:text-zinc-300',
                      )}
                    >
                      {genre}
                    </button>
                  );
                })}
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Idea Input */}
        <div className="mb-8">
          <div className="bg-zinc-900 border border-zinc-800 rounded-sm focus-within:border-blue-500/50 transition-colors duration-200">
            <textarea
              value={idea}
              onChange={(e) => onIdeaChange(e.target.value)}
              placeholder={placeholder}
              disabled={isProcessing}
              className="
                w-full min-h-[120px] px-5 py-4
                bg-transparent
                text-[15px] text-zinc-100 leading-relaxed
                placeholder:text-zinc-600
                focus:outline-none
                resize-none
              "
            />
            <div className="flex items-center justify-end px-5 pb-3.5 pt-0">
              <span className="font-mono text-[10px] text-zinc-600 tabular-nums">
                {idea.length}
              </span>
            </div>
          </div>
        </div>

        {/* Execute Button */}
        <div className="relative">
          <button
            type="button"
            onClick={handleExecuteClick}
            disabled={isProcessing}
            className={cn(
              'w-full flex items-center justify-center gap-3 px-8 py-3 rounded-sm font-mono text-sm font-medium transition-colors duration-200',
              canExecute
                ? 'bg-white text-black hover:bg-zinc-200'
                : 'bg-zinc-800 text-zinc-600 cursor-not-allowed',
            )}
          >
            {isProcessing ? (
              <>
                <div className="w-4 h-4 rounded-sm border-2 border-current border-t-transparent animate-spin" />
                <span>Processing...</span>
              </>
            ) : (
              <>
                <span>Start Production</span>
                <ArrowRight className="w-4 h-4" />
              </>
            )}
          </button>

          {/* Execution prevention error */}
          <AnimatePresence>
            {showExecutionError && (
              <motion.div
                initial={{ opacity: 0, y: -4 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -4 }}
                className="absolute top-full left-0 right-0 mt-2 flex items-center gap-2 text-xs text-red-400 font-mono"
              >
                <AlertCircle className="w-3.5 h-3.5 shrink-0" />
                <span>Please select a format before starting production</span>
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      </div>
    </div>
  );
}

/**
 * Utility: get applicable genres for a format ID.
 * Used by property tests.
 */
export function getGenresForFormat(formatId: string): string[] {
  const format = formatRegistry.getFormat(formatId);
  return format?.applicableGenres ?? [];
}

/**
 * Utility: get placeholder text for a format ID.
 * Used by property tests.
 */
export function getPlaceholderForFormat(formatId: VideoFormat): string {
  return FORMAT_PLACEHOLDERS[formatId] ?? '';
}

export default FormatSelector;
</file>

<file path="components/gradient-generator/GradientControls.tsx">
/**
 * CSS Gradient Generator - Gradient Controls Component
 */

import React, { useState } from 'react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Slider } from '@/components/ui/slider';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Plus, Trash2, RotateCcw } from 'lucide-react';
import type { GradientControlsProps } from './types';
import { generateGradientCSS } from './utils';

export function GradientControls({
  config,
  onConfigChange,
  maxColorStops = 10,
  minColorStops = 2,
  className,
}: GradientControlsProps) {
  const [editingColorId, setEditingColorId] = useState<string | null>(null);

  const handleGradientTypeChange = (type: string) => {
    if (type !== 'linear' && type !== 'radial' && type !== 'conic') return;

    let newConfig;

    if (type === 'linear') {
      newConfig = {
        type: 'linear' as const,
        angle: 90,
        colorStops: config.colorStops,
      };
    } else if (type === 'radial') {
      newConfig = {
        type: 'radial' as const,
        shape: 'circle' as const,
        position: { x: 50, y: 50 },
        colorStops: config.colorStops,
      };
    } else {
      newConfig = {
        type: 'conic' as const,
        angle: 0,
        position: { x: 50, y: 50 },
        colorStops: config.colorStops,
      };
    }

    onConfigChange(newConfig);
  };

  const handleColorChange = (id: string, color: string) => {
    const newColorStops = config.colorStops.map((stop) =>
      stop.id === id ? { ...stop, color } : stop
    );
    onConfigChange({ ...config, colorStops: newColorStops });
  };

  const handlePositionChange = (id: string, position: number) => {
    const newColorStops = config.colorStops.map((stop) =>
      stop.id === id ? { ...stop, position } : stop
    ).sort((a, b) => a.position - b.position);
    onConfigChange({ ...config, colorStops: newColorStops });
  };

  const handleAddColorStop = () => {
    if (config.colorStops.length >= maxColorStops) return;

    const newStop = {
      id: `${Date.now()}-${Math.random()}`,
      color: '#ffffff',
      position: 50,
    };

    const newColorStops = [...config.colorStops, newStop].sort((a, b) => a.position - b.position);
    onConfigChange({ ...config, colorStops: newColorStops });
  };

  const handleRemoveColorStop = (id: string) => {
    if (config.colorStops.length <= minColorStops) return;

    const newColorStops = config.colorStops.filter((stop) => stop.id !== id);
    onConfigChange({ ...config, colorStops: newColorStops });
  };

  const handleAngleChange = (angle: number) => {
    if (config.type !== 'linear' && config.type !== 'conic') return;
    onConfigChange({ ...config, angle });
  };

  const handlePositionXYChange = (x: number, y: number) => {
    if (config.type !== 'radial' && config.type !== 'conic') return;
    onConfigChange({ ...config, position: { x, y } });
  };

  const handleShapeChange = (shape: 'circle' | 'ellipse') => {
    if (config.type !== 'radial') return;
    onConfigChange({ ...config, shape });
  };

  const canAddColorStop = config.colorStops.length < maxColorStops;
  const canRemoveColorStop = config.colorStops.length > minColorStops;

  return (
    <div className={cn('gradient-controls space-y-6', className)}>
      {/* Gradient Type Selector */}
      <div className="space-y-3">
        <Label htmlFor="gradient-type">Gradient Type</Label>
        <Tabs value={config.type} onValueChange={handleGradientTypeChange}>
          <TabsList className="w-full">
            <TabsTrigger value="linear" className="flex-1">Linear</TabsTrigger>
            <TabsTrigger value="radial" className="flex-1">Radial</TabsTrigger>
            <TabsTrigger value="conic" className="flex-1">Conic</TabsTrigger>
          </TabsList>
        </Tabs>
      </div>

      {/* Direction/Angle Controls */}
      {(config.type === 'linear' || config.type === 'conic') && (
        <div className="space-y-3">
          <Label htmlFor="angle-slider">
            Angle: {config.angle}¬∞
          </Label>
          <Slider
            id="angle-slider"
            value={[config.angle]}
            onValueChange={([value]) => value !== undefined && handleAngleChange(value)}
            min={0}
            max={360}
            step={1}
            className="w-full"
            aria-label="Gradient angle in degrees"
            aria-valuemin={0}
            aria-valuemax={360}
            aria-valuenow={config.angle}
          />
        </div>
      )}

      {/* Radial Shape Control */}
      {config.type === 'radial' && (
        <div className="space-y-3">
          <Label htmlFor="shape-select">Shape</Label>
          <Select value={config.shape} onValueChange={handleShapeChange}>
            <SelectTrigger id="shape-select">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="circle">Circle</SelectItem>
              <SelectItem value="ellipse">Ellipse</SelectItem>
            </SelectContent>
          </Select>
        </div>
      )}

      {/* Position Controls for Radial/Conic */}
      {(config.type === 'radial' || config.type === 'conic') && (
        <div className="space-y-3">
          <Label>Position</Label>
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="position-x" className="text-sm text-muted-foreground">
                X: {config.position.x}%
              </Label>
              <Slider
                id="position-x"
                value={[config.position.x]}
                onValueChange={([value]) => value !== undefined && handlePositionXYChange(value, config.position.y)}
                min={0}
                max={100}
                step={1}
                className="w-full"
                aria-label="Gradient position X"
                aria-valuemin={0}
                aria-valuemax={100}
                aria-valuenow={config.position.x}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="position-y" className="text-sm text-muted-foreground">
                Y: {config.position.y}%
              </Label>
              <Slider
                id="position-y"
                value={[config.position.y]}
                onValueChange={([value]) => value !== undefined && handlePositionXYChange(config.position.x, value)}
                min={0}
                max={100}
                step={1}
                className="w-full"
                aria-label="Gradient position Y"
                aria-valuemin={0}
                aria-valuemax={100}
                aria-valuenow={config.position.y}
              />
            </div>
          </div>
        </div>
      )}

      {/* Color Stops */}
      <div className="space-y-3">
        <div className="flex items-center justify-between">
          <Label>Color Stops</Label>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={handleAddColorStop}
            disabled={!canAddColorStop}
            aria-label="Add color stop"
          >
            <Plus className="w-4 h-4 mr-1" />
            Add
          </Button>
        </div>

        <div className="space-y-3">
          {config.colorStops.map((stop, index) => (
            <div
              key={stop.id}
              className="flex items-center gap-3 p-3 rounded-lg border border-border bg-card"
            >
              {/* Color Picker */}
              <div className="relative">
                <input
                  type="color"
                  value={stop.color}
                  onChange={(e) => handleColorChange(stop.id, e.target.value)}
                  className="w-10 h-10 rounded cursor-pointer border-0 p-0"
                  aria-label={`Color stop ${index + 1} color`}
                />
              </div>

              {/* Position Slider */}
              <div className="flex-1 space-y-1">
                <Label htmlFor={`position-${stop.id}`} className="text-sm text-muted-foreground">
                  Position: {stop.position}%
                </Label>
                <Slider
                  id={`position-${stop.id}`}
                  value={[stop.position]}
                  onValueChange={([value]) => value !== undefined && handlePositionChange(stop.id, value)}
                  min={0}
                  max={100}
                  step={1}
                  className="w-full"
                  aria-label={`Color stop ${index + 1} position`}
                  aria-valuemin={0}
                  aria-valuemax={100}
                  aria-valuenow={stop.position}
                />
              </div>

              {/* Remove Button */}
              <Button
                type="button"
                variant="ghost"
                size="icon"
                onClick={() => handleRemoveColorStop(stop.id)}
                disabled={!canRemoveColorStop}
                aria-label={`Remove color stop ${index + 1}`}
              >
                <Trash2 className="w-4 h-4 text-destructive" />
              </Button>
            </div>
          ))}
        </div>
      </div>

      {/* Reset Button */}
      <Button
        type="button"
        variant="outline"
        className="w-full"
        onClick={() => {
          const defaultConfig = {
            type: 'linear' as const,
            angle: 90,
            colorStops: [
              { id: '1', color: '#6366f1', position: 0 },
              { id: '2', color: '#a855f7', position: 100 },
            ],
          };
          onConfigChange(defaultConfig);
        }}
      >
        <RotateCcw className="w-4 h-4 mr-2" />
        Reset to Default
      </Button>
    </div>
  );
}

export default GradientControls;
</file>

<file path="components/gradient-generator/GradientExport.tsx">
/**
 * CSS Gradient Generator - Gradient Export Component
 */

import React, { useState } from 'react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Copy, Download, Code } from 'lucide-react';
import { generateGradientCSS, downloadCSS, copyToClipboard } from './utils';
import type { GradientExportProps } from './types';

export function GradientExport({
  config,
  exportOptions,
  onExportOptionsChange,
  onCopy,
  onDownload,
  className,
}: GradientExportProps) {
  const [copied, setCopied] = useState(false);
  const [open, setOpen] = useState(false);

  const css = generateGradientCSS(config, exportOptions);

  const handleCopy = async () => {
    const success = await copyToClipboard(css);
    if (success) {
      setCopied(true);
      onCopy?.(css);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  const handleDownload = () => {
    downloadCSS(css, 'gradient.css');
    onDownload?.(css, 'gradient.css');
  };

  const handleFormatChange = (format: 'standard' | 'shorthand' | 'legacy') => {
    onExportOptionsChange({ ...exportOptions, format });
  };

  const handleIncludePrefixesChange = (includePrefixes: boolean) => {
    onExportOptionsChange({ ...exportOptions, includePrefixes });
  };

  const handleIncludeCommentsChange = (includeComments: boolean) => {
    onExportOptionsChange({ ...exportOptions, includeComments });
  };

  return (
    <div className={cn('gradient-export space-y-4', className)}>
      {/* Quick Actions */}
      <div className="flex gap-2">
        <Button
          type="button"
          variant="outline"
          className="flex-1"
          onClick={handleCopy}
          aria-label="Copy CSS to clipboard"
        >
          <Copy className="w-4 h-4 mr-2" />
          {copied ? 'Copied!' : 'Copy CSS'}
        </Button>
        <Button
          type="button"
          variant="default"
          className="flex-1"
          onClick={handleDownload}
          aria-label="Download CSS file"
        >
          <Download className="w-4 h-4 mr-2" />
          Download
        </Button>
      </div>

      {/* View Code Dialog */}
      <Dialog open={open} onOpenChange={setOpen}>
        <DialogTrigger asChild>
          <Button type="button" variant="outline" className="w-full">
            <Code className="w-4 h-4 mr-2" />
            View CSS Code
          </Button>
        </DialogTrigger>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>CSS Gradient Code</DialogTitle>
          </DialogHeader>

          <div className="space-y-4">
            {/* Export Options */}
            <div className="space-y-3">
              <Label>Export Options</Label>

              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="format-select" className="text-sm text-muted-foreground">
                    Format
                  </Label>
                  <Select value={exportOptions.format} onValueChange={handleFormatChange}>
                    <SelectTrigger id="format-select">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="standard">Standard</SelectItem>
                      <SelectItem value="shorthand">Shorthand</SelectItem>
                      <SelectItem value="legacy">Legacy</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>

              <div className="flex items-center gap-4">
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={exportOptions.includePrefixes}
                    onChange={(e) => handleIncludePrefixesChange(e.target.checked)}
                    className="w-4 h-4 rounded border-input"
                    aria-label="Include vendor prefixes"
                  />
                  <span className="text-sm">Include vendor prefixes</span>
                </label>

                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={exportOptions.includeComments}
                    onChange={(e) => handleIncludeCommentsChange(e.target.checked)}
                    className="w-4 h-4 rounded border-input"
                    aria-label="Include comments"
                  />
                  <span className="text-sm">Include comments</span>
                </label>
              </div>
            </div>

            {/* CSS Code Display */}
            <div className="space-y-2">
              <Label htmlFor="css-code">CSS Code</Label>
              <Textarea
                id="css-code"
                value={css}
                readOnly
                className="font-mono text-sm min-h-[200px]"
                aria-label="Generated CSS code"
              />
            </div>

            {/* Dialog Actions */}
            <div className="flex gap-2">
              <Button
                type="button"
                variant="outline"
                className="flex-1"
                onClick={handleCopy}
              >
                <Copy className="w-4 h-4 mr-2" />
                {copied ? 'Copied!' : 'Copy'}
              </Button>
              <Button
                type="button"
                variant="default"
                className="flex-1"
                onClick={handleDownload}
              >
                <Download className="w-4 h-4 mr-2" />
                Download
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}

export default GradientExport;
</file>

<file path="components/gradient-generator/GradientGenerator.tsx">
/**
 * CSS Gradient Generator - Main Component
 */

import React from 'react';
import { cn } from '@/lib/utils';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { ScrollArea } from '@/components/ui/scroll-area';
import { useGradientState, useGradientCSS, useGradientPresets } from './hooks';
import { GradientPreview } from './GradientPreview';
import { GradientControls } from './GradientControls';
import { GradientPresets } from './GradientPresets';
import { GradientExport } from './GradientExport';
import { DEFAULT_PRESETS } from './utils';
import type { GradientGeneratorProps } from './types';

export function GradientGenerator({
  initialConfig,
  onGradientChange,
  presets,
  showPresets = true,
  showExportPanel = true,
  className,
  maxColorStops = 10,
  minColorStops = 2,
  enableAnimation = false,
  animationDuration = 3,
}: GradientGeneratorProps) {
  const gradientState = useGradientState({
    initialConfig,
    maxColorStops,
    minColorStops,
    onChange: onGradientChange,
  });

  const { config } = gradientState;
  const { css } = useGradientCSS(config);

  // Use default presets if none provided
  const presetsToUse = presets || DEFAULT_PRESETS;

  // Export options state
  const [exportOptions, setExportOptions] = React.useState({
    format: 'standard' as 'standard' | 'shorthand' | 'legacy',
    includePrefixes: false,
    includeComments: false,
  });

  const handlePresetSelect = (preset: typeof presetsToUse[0]) => {
    gradientState.setConfig(preset.config);
  };

  return (
    <div className={cn('gradient-generator w-full', className)}>
      <div className="grid gap-6 lg:grid-cols-2">
        {/* Left Column: Preview */}
        <div className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Gradient Preview</CardTitle>
            </CardHeader>
            <CardContent>
              <GradientPreview
                config={config}
                enableAnimation={enableAnimation}
                animationDuration={animationDuration}
              />
            </CardContent>
          </Card>

          {/* Export Panel */}
          {showExportPanel && (
            <Card>
              <CardHeader>
                <CardTitle>Export CSS</CardTitle>
              </CardHeader>
              <CardContent>
                <GradientExport
                  config={config}
                  exportOptions={exportOptions}
                  onExportOptionsChange={setExportOptions}
                />
              </CardContent>
            </Card>
          )}
        </div>

        {/* Right Column: Controls */}
        <div className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Gradient Controls</CardTitle>
            </CardHeader>
            <CardContent>
              <ScrollArea className="h-[500px] pr-4">
                <GradientControls
                  config={config}
                  onConfigChange={gradientState.setConfig}
                  maxColorStops={maxColorStops}
                  minColorStops={minColorStops}
                />
              </ScrollArea>
            </CardContent>
          </Card>

          {/* Presets Panel */}
          {showPresets && (
            <Card>
              <CardHeader>
                <CardTitle>Preset Gradients</CardTitle>
              </CardHeader>
              <CardContent>
                <GradientPresets
                  presets={presetsToUse}
                  onPresetSelect={handlePresetSelect}
                  showCategories={true}
                  columns={3}
                />
              </CardContent>
            </Card>
          )}
        </div>
      </div>
    </div>
  );
}

export default GradientGenerator;
</file>

<file path="components/gradient-generator/GradientPresets.tsx">
/**
 * CSS Gradient Generator - Gradient Presets Component
 */

import React, { useState } from 'react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { generateGradientCSS } from './utils';
import type { GradientPresetsProps } from './types';

export function GradientPresets({
  presets,
  selectedPresetId,
  onPresetSelect,
  showCategories = true,
  columns = 3,
  className,
}: GradientPresetsProps) {
  const [activeCategory, setActiveCategory] = useState<string | null>(null);

  // Get unique categories
  const categories = Array.from(
    new Set(presets.map((p) => p.category).filter(Boolean) as string[])
  );

  // Filter presets by category
  const filteredPresets = activeCategory
    ? presets.filter((p) => p.category === activeCategory)
    : presets;

  const handleCategoryClick = (category: string | null) => {
    setActiveCategory(category);
  };

  const handlePresetClick = (preset: typeof presets[0]) => {
    onPresetSelect(preset);
  };

  return (
    <div className={cn('gradient-presets space-y-4', className)}>
      {/* Category Filters */}
      {showCategories && categories.length > 0 && (
        <div className="flex flex-wrap gap-2">
          <Button
            type="button"
            variant={activeCategory === null ? 'default' : 'outline'}
            size="sm"
            onClick={() => handleCategoryClick(null)}
          >
            All
          </Button>
          {categories.map((category) => (
            <Button
              key={category}
              type="button"
              variant={activeCategory === category ? 'default' : 'outline'}
              size="sm"
              onClick={() => handleCategoryClick(category)}
            >
              {category}
            </Button>
          ))}
        </div>
      )}

      {/* Presets Grid */}
      <ScrollArea className="h-64">
        <div
          className="grid gap-3"
          style={{
            gridTemplateColumns: `repeat(${columns}, minmax(0, 1fr))`,
          }}
        >
          {filteredPresets.map((preset) => {
            const isSelected = selectedPresetId === preset.id;
            const gradientStyle = {
              background: generateGradientCSS(preset.config).replace('background: ', '').replace(';', ''),
            };

            return (
              <button
                key={preset.id}
                type="button"
                className={cn(
                  'group relative rounded-lg border-2 transition-all hover:scale-105 focus:outline-none focus:ring-2 focus:ring-ring',
                  isSelected
                    ? 'border-primary ring-2 ring-primary ring-offset-2'
                    : 'border-border hover:border-primary/50'
                )}
                onClick={() => handlePresetClick(preset)}
                aria-label={`Select ${preset.name} preset: ${preset.description || ''}`}
                aria-pressed={isSelected}
              >
                {/* Gradient Preview */}
                <div
                  className="aspect-square w-full rounded-md"
                  style={gradientStyle}
                  aria-hidden="true"
                />

                {/* Preset Info Overlay */}
                <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/50 opacity-0 transition-opacity group-hover:opacity-100">
                  <span className="text-sm font-medium text-white">{preset.name}</span>
                  {preset.category && (
                    <Badge variant="secondary" className="mt-1 text-xs">
                      {preset.category}
                    </Badge>
                  )}
                </div>

                {/* Selected Indicator */}
                {isSelected && (
                  <div className="absolute top-2 right-2 flex h-6 w-6 items-center justify-center rounded-full bg-primary text-primary-foreground">
                    <svg
                      className="h-4 w-4"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M5 13l4 4L19 7"
                      />
                    </svg>
                  </div>
                )}
              </button>
            );
          })}
        </div>

        {filteredPresets.length === 0 && (
          <div className="flex h-32 items-center justify-center text-muted-foreground">
            No presets found
          </div>
        )}
      </ScrollArea>
    </div>
  );
}

export default GradientPresets;
</file>

<file path="components/gradient-generator/GradientPreview.tsx">
/**
 * CSS Gradient Generator - Gradient Preview Component
 */

import React from 'react';
import { cn } from '@/lib/utils';
import { useGradientCSS } from './hooks';
import type { GradientPreviewProps } from './types';

export function GradientPreview({
  config,
  width = '100%',
  height = '200px',
  showTransparencyGrid = true,
  className,
  enableAnimation = false,
  animationDuration = 3,
}: GradientPreviewProps) {
  const { css } = useGradientCSS(config);

  const previewStyle: React.CSSProperties = {
    width,
    height,
    background: css.replace('background: ', '').replace(';', ''),
    ...(enableAnimation && {
      animation: `gradientShift ${animationDuration}s ease infinite`,
    }),
  };

  return (
    <div className={cn('gradient-preview', className)}>
      <div
        className="relative rounded-lg overflow-hidden border border-border"
        style={{ width, height }}
      >
        {showTransparencyGrid && (
          <div
            className="absolute inset-0 opacity-50"
            style={{
              backgroundImage: `
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%)
              `,
              backgroundSize: '20px 20px',
              backgroundPosition: '0 0, 0 10px, 10px -10px, -10px 0px',
            }}
            aria-hidden="true"
          />
        )}
        <div
          className="relative w-full h-full"
          style={previewStyle}
          role="img"
          aria-label={`Gradient preview: ${config.type} gradient`}
        />
      </div>

      {enableAnimation && (
        <style>{`
          @keyframes gradientShift {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
          }
        `}</style>
      )}
    </div>
  );
}

export default GradientPreview;
</file>

<file path="components/gradient-generator/hooks.ts">
/**
 * CSS Gradient Generator - Custom Hooks
 */

import { useState, useCallback, useMemo } from 'react';
import type { GradientConfig, ColorStop, GradientType, GradientPreset, ExportOptions } from './types';
import { generateGradientCSS, DEFAULT_PRESETS } from './utils';

/**
 * Hook for managing gradient state
 */
interface UseGradientStateOptions {
  initialConfig?: GradientConfig;
  maxColorStops?: number;
  minColorStops?: number;
  onChange?: (config: GradientConfig) => void;
}

interface UseGradientStateReturn {
  config: GradientConfig;
  gradientType: GradientType;
  colorStops: ColorStop[];

  // Actions
  setGradientType: (type: GradientType) => void;
  setColorStops: (stops: ColorStop[]) => void;
  addColorStop: (color?: string, position?: number) => void;
  removeColorStop: (id: string) => void;
  updateColorStop: (id: string, updates: Partial<ColorStop>) => void;
  setLinearAngle: (angle: number) => void;
  setRadialPosition: (x: number, y: number) => void;
  setRadialShape: (shape: 'circle' | 'ellipse') => void;
  setConicAngle: (angle: number) => void;
  setConicPosition: (x: number, y: number) => void;
  setConfig: (config: GradientConfig) => void;
  resetConfig: () => void;

  // Computed
  canAddColorStop: boolean;
  canRemoveColorStop: boolean;
}

export function useGradientState(options: UseGradientStateOptions = {}): UseGradientStateReturn {
  const {
    initialConfig,
    maxColorStops = 10,
    minColorStops = 2,
    onChange,
  } = options;

  // Default initial configuration
  const defaultConfig: GradientConfig = {
    type: 'linear',
    angle: 90,
    colorStops: [
      { id: '1', color: '#6366f1', position: 0 },
      { id: '2', color: '#a855f7', position: 100 },
    ],
  };

  const [config, setConfig] = useState<GradientConfig>(initialConfig || defaultConfig);

  // Computed values
  const gradientType = config.type;
  const colorStops = config.colorStops;
  const canAddColorStop = colorStops.length < maxColorStops;
  const canRemoveColorStop = colorStops.length > minColorStops;

  // Actions
  const setGradientType = useCallback((type: GradientType) => {
    setConfig((prev) => {
      let newConfig: GradientConfig;

      if (type === 'linear') {
        newConfig = {
          type: 'linear',
          angle: 90,
          colorStops: prev.colorStops,
        };
      } else if (type === 'radial') {
        newConfig = {
          type: 'radial',
          shape: 'circle',
          position: { x: 50, y: 50 },
          colorStops: prev.colorStops,
        };
      } else {
        newConfig = {
          type: 'conic',
          angle: 0,
          position: { x: 50, y: 50 },
          colorStops: prev.colorStops,
        };
      }

      onChange?.(newConfig);
      return newConfig;
    });
  }, [onChange]);

  const setColorStops = useCallback((stops: ColorStop[]) => {
    setConfig((prev) => {
      const newConfig = { ...prev, colorStops: stops };
      onChange?.(newConfig);
      return newConfig;
    });
  }, [onChange]);

  const addColorStop = useCallback((color?: string, position?: number) => {
    setConfig((prev) => {
      if (prev.colorStops.length >= maxColorStops) return prev;

      const newStop: ColorStop = {
        id: `${Date.now()}-${Math.random()}`,
        color: color || '#ffffff',
        position: position ?? 50,
      };

      const newConfig = {
        ...prev,
        colorStops: [...prev.colorStops, newStop].sort((a, b) => a.position - b.position),
      };
      onChange?.(newConfig);
      return newConfig;
    });
  }, [maxColorStops, onChange]);

  const removeColorStop = useCallback((id: string) => {
    setConfig((prev) => {
      if (prev.colorStops.length <= minColorStops) return prev;

      const newConfig = {
        ...prev,
        colorStops: prev.colorStops.filter((stop) => stop.id !== id),
      };
      onChange?.(newConfig);
      return newConfig;
    });
  }, [minColorStops, onChange]);

  const updateColorStop = useCallback((id: string, updates: Partial<ColorStop>) => {
    setConfig((prev) => {
      const newConfig = {
        ...prev,
        colorStops: prev.colorStops.map((stop) =>
          stop.id === id ? { ...stop, ...updates } : stop
        ).sort((a, b) => a.position - b.position),
      };
      onChange?.(newConfig);
      return newConfig;
    });
  }, [onChange]);

  const setLinearAngle = useCallback((angle: number) => {
    setConfig((prev) => {
      if (prev.type !== 'linear') return prev;
      const newConfig = { ...prev, angle };
      onChange?.(newConfig);
      return newConfig;
    });
  }, [onChange]);

  const setRadialPosition = useCallback((x: number, y: number) => {
    setConfig((prev) => {
      if (prev.type !== 'radial') return prev;
      const newConfig = { ...prev, position: { x, y } };
      onChange?.(newConfig);
      return newConfig;
    });
  }, [onChange]);

  const setRadialShape = useCallback((shape: 'circle' | 'ellipse') => {
    setConfig((prev) => {
      if (prev.type !== 'radial') return prev;
      const newConfig = { ...prev, shape };
      onChange?.(newConfig);
      return newConfig;
    });
  }, [onChange]);

  const setConicAngle = useCallback((angle: number) => {
    setConfig((prev) => {
      if (prev.type !== 'conic') return prev;
      const newConfig = { ...prev, angle };
      onChange?.(newConfig);
      return newConfig;
    });
  }, [onChange]);

  const setConicPosition = useCallback((x: number, y: number) => {
    setConfig((prev) => {
      if (prev.type !== 'conic') return prev;
      const newConfig = { ...prev, position: { x, y } };
      onChange?.(newConfig);
      return newConfig;
    });
  }, [onChange]);

  const resetConfig = useCallback(() => {
    setConfig(defaultConfig);
    onChange?.(defaultConfig);
  }, [onChange]);

  return {
    config,
    gradientType,
    colorStops,
    setGradientType,
    setColorStops,
    addColorStop,
    removeColorStop,
    updateColorStop,
    setLinearAngle,
    setRadialPosition,
    setRadialShape,
    setConicAngle,
    setConicPosition,
    setConfig,
    resetConfig,
    canAddColorStop,
    canRemoveColorStop,
  };
}

/**
 * Hook for generating CSS from gradient config
 */
interface UseGradientCSSReturn {
  css: string;
  cssWithPrefixes: string;
  getCSS: (options?: ExportOptions) => string;
}

export function useGradientCSS(config: GradientConfig): UseGradientCSSReturn {
  const css = useMemo(() => {
    return generateGradientCSS(config, { format: 'standard', includePrefixes: false, includeComments: false });
  }, [config]);

  const cssWithPrefixes = useMemo(() => {
    return generateGradientCSS(config, { format: 'standard', includePrefixes: true, includeComments: false });
  }, [config]);

  const getCSS = (options?: ExportOptions) => {
    return generateGradientCSS(config, options);
  };

  return { css, cssWithPrefixes, getCSS };
}

/**
 * Hook for managing gradient presets
 */
interface UseGradientPresetsReturn {
  presets: GradientPreset[];
  selectedPreset: GradientPreset | null;
  selectPreset: (preset: GradientPreset) => void;
  addPreset: (preset: GradientPreset) => void;
  removePreset: (id: string) => void;
  filterByCategory: (category: string | null) => void;
  categories: string[];
  activeCategory: string | null;
}

export function useGradientPresets(customPresets?: GradientPreset[]): UseGradientPresetsReturn {
  const [presets, setPresets] = useState<GradientPreset[]>([...DEFAULT_PRESETS, ...(customPresets || [])]);
  const [selectedPreset, setSelectedPreset] = useState<GradientPreset | null>(null);
  const [activeCategory, setActiveCategory] = useState<string | null>(null);

  const selectPreset = useCallback((preset: GradientPreset) => {
    setSelectedPreset(preset);
  }, []);

  const addPreset = useCallback((preset: GradientPreset) => {
    setPresets((prev) => [...prev, preset]);
  }, []);

  const removePreset = useCallback((id: string) => {
    setPresets((prev) => prev.filter((p) => p.id !== id));
    if (selectedPreset?.id === id) {
      setSelectedPreset(null);
    }
  }, [selectedPreset]);

  const filterByCategory = useCallback((category: string | null) => {
    setActiveCategory(category);
  }, []);

  const categories = useMemo(() => {
    const cats = new Set(presets.map((p) => p.category).filter(Boolean) as string[]);
    return Array.from(cats);
  }, [presets]);

  const filteredPresets = activeCategory
    ? presets.filter((p) => p.category === activeCategory)
    : presets;

  return {
    presets: filteredPresets,
    selectedPreset,
    selectPreset,
    addPreset,
    removePreset,
    filterByCategory,
    categories,
    activeCategory,
  };
}
</file>

<file path="components/gradient-generator/index.ts">
/**
 * CSS Gradient Generator - Public API Exports
 */

// Main component
export { GradientGenerator } from './GradientGenerator';

// Sub-components
export { GradientPreview } from './GradientPreview';
export { GradientControls } from './GradientControls';
export { GradientPresets } from './GradientPresets';
export { GradientExport } from './GradientExport';

// Custom hooks
export { useGradientState, useGradientCSS, useGradientPresets } from './hooks';

// Utility functions
export {
  generateGradientCSS,
  downloadCSS,
  copyToClipboard,
  hexToRgb,
  rgbToHex,
  isValidColor,
  getContrastColor,
  randomColor,
  interpolateColor,
  validateGradientConfig,
  gradientConfigToHash,
  generateCSSWithClass,
  generateInlineStyle,
  DEFAULT_PRESETS,
} from './utils';

// Types
export type {
  GradientType,
  ColorStop,
  LinearGradientConfig,
  RadialGradientConfig,
  ConicGradientConfig,
  GradientConfig,
  GradientPreset,
  CSSExportFormat,
  ExportOptions,
  GradientGeneratorProps,
  GradientPreviewProps,
  GradientControlsProps,
  GradientPresetsProps,
  GradientExportProps,
  ColorStopEditorProps,
  DirectionControlsProps,
} from './types';
</file>

<file path="components/gradient-generator/types.ts">
/**
 * CSS Gradient Generator - TypeScript Type Definitions
 */

/**
 * Supported gradient types
 */
export type GradientType = 'linear' | 'radial' | 'conic';

/**
 * Color stop definition
 */
export interface ColorStop {
  id: string;
  color: string;        // Hex, RGB, or HSL color value
  position: number;     // 0-100 percentage
}

/**
 * Linear gradient configuration
 */
export interface LinearGradientConfig {
  type: 'linear';
  angle: number;        // 0-360 degrees
  colorStops: ColorStop[];
}

/**
 * Radial gradient configuration
 */
export interface RadialGradientConfig {
  type: 'radial';
  shape: 'circle' | 'ellipse';
  position: {
    x: number;         // 0-100 percentage
    y: number;         // 0-100 percentage
  };
  colorStops: ColorStop[];
}

/**
 * Conic gradient configuration
 */
export interface ConicGradientConfig {
  type: 'conic';
  angle: number;        // 0-360 degrees
  position: {
    x: number;         // 0-100 percentage
    y: number;         // 0-100 percentage
  };
  colorStops: ColorStop[];
}

/**
 * Union type for all gradient configurations
 */
export type GradientConfig =
  | LinearGradientConfig
  | RadialGradientConfig
  | ConicGradientConfig;

/**
 * Gradient preset definition
 */
export interface GradientPreset {
  id: string;
  name: string;
  description?: string;
  config: GradientConfig;
  thumbnail?: string;   // Optional preview image
  category?: string;   // For grouping presets
}

/**
 * CSS export format options
 */
export type CSSExportFormat = 'standard' | 'shorthand' | 'legacy';

/**
 * Export options
 */
export interface ExportOptions {
  format: CSSExportFormat;
  includePrefixes: boolean;  // Include vendor prefixes
  includeComments: boolean;  // Include descriptive comments
}

/**
 * Main GradientGenerator component props
 */
export interface GradientGeneratorProps {
  /** Initial gradient configuration */
  initialConfig?: GradientConfig;
  /** Callback when gradient changes */
  onGradientChange?: (config: GradientConfig) => void;
  /** Available presets to display */
  presets?: GradientPreset[];
  /** Whether to show the presets panel */
  showPresets?: boolean;
  /** Whether to show the CSS export panel */
  showExportPanel?: boolean;
  /** Custom className for styling */
  className?: string;
  /** Maximum number of color stops allowed */
  maxColorStops?: number;
  /** Minimum number of color stops required */
  minColorStops?: number;
  /** Whether to enable animation on the preview */
  enableAnimation?: boolean;
  /** Animation duration in seconds (when enabled) */
  animationDuration?: number;
}

/**
 * GradientPreview component props
 */
export interface GradientPreviewProps {
  config: GradientConfig;
  /** Preview dimensions */
  width?: number | string;
  height?: number | string;
  /** Whether to show a checkerboard pattern for transparency */
  showTransparencyGrid?: boolean;
  /** Custom className */
  className?: string;
  /** Whether to enable animation */
  enableAnimation?: boolean;
  /** Animation duration in seconds */
  animationDuration?: number;
}

/**
 * GradientControls component props
 */
export interface GradientControlsProps {
  config: GradientConfig;
  onConfigChange: (config: GradientConfig) => void;
  /** Maximum number of color stops allowed */
  maxColorStops?: number;
  /** Minimum number of color stops required */
  minColorStops?: number;
  /** Custom className */
  className?: string;
}

/**
 * GradientPresets component props
 */
export interface GradientPresetsProps {
  presets: GradientPreset[];
  selectedPresetId?: string;
  onPresetSelect: (preset: GradientPreset) => void;
  /** Whether to show category filters */
  showCategories?: boolean;
  /** Grid layout columns */
  columns?: number;
  /** Custom className */
  className?: string;
}

/**
 * GradientExport component props
 */
export interface GradientExportProps {
  config: GradientConfig;
  exportOptions: ExportOptions;
  onExportOptionsChange: (options: ExportOptions) => void;
  /** Callback when copy to clipboard is triggered */
  onCopy?: (css: string) => void;
  /** Callback when download is triggered */
  onDownload?: (css: string, filename: string) => void;
  /** Custom className */
  className?: string;
}

/**
 * ColorStopEditor component props
 */
export interface ColorStopEditorProps {
  colorStops: ColorStop[];
  onColorStopsChange: (stops: ColorStop[]) => void;
  maxStops?: number;
  minStops?: number;
  /** Whether to show position sliders */
  showPositionSliders?: boolean;
  /** Custom className */
  className?: string;
}

/**
 * DirectionControls component props
 */
export interface DirectionControlsProps {
  config: GradientConfig;
  onConfigChange: (config: GradientConfig) => void;
  /** Available preset directions for linear gradients */
  presetDirections?: Array<{ label: string; angle: number }>;
  /** Custom className */
  className?: string;
}
</file>

<file path="components/gradient-generator/utils.ts">
/**
 * CSS Gradient Generator - Utility Functions
 */

import type { GradientConfig, ExportOptions, GradientPreset } from './types';

/**
 * Generate CSS gradient string from configuration
 */
export function generateGradientCSS(
  config: GradientConfig,
  options: ExportOptions = { format: 'standard', includePrefixes: false, includeComments: false }
): string {
  const { format, includePrefixes, includeComments } = options;

  const colorStops = config.colorStops
    .map((stop) => `${stop.color} ${stop.position}%`)
    .join(', ');

  let gradient = '';

  switch (config.type) {
    case 'linear':
      gradient = `linear-gradient(${config.angle}deg, ${colorStops})`;
      break;
    case 'radial':
      gradient = `radial-gradient(${config.shape} at ${config.position.x}% ${config.position.y}%, ${colorStops})`;
      break;
    case 'conic':
      gradient = `conic-gradient(from ${config.angle}deg at ${config.position.x}% ${config.position.y}%, ${colorStops})`;
      break;
  }

  let css = `background: ${gradient};`;

  if (includePrefixes && config.type === 'linear') {
    css = `-webkit-linear-gradient(${config.angle}deg, ${colorStops});\n` +
          `-moz-linear-gradient(${config.angle}deg, ${colorStops});\n` +
          `-o-linear-gradient(${config.angle}deg, ${colorStops});\n` +
          `background: ${gradient};`;
  }

  if (includeComments) {
    css = `/* ${config.type.charAt(0).toUpperCase() + config.type.slice(1)} Gradient */\n` + css;
  }

  return css;
}

/**
 * Download CSS as a file
 */
export function downloadCSS(css: string, filename: string = 'gradient.css'): void {
  const blob = new Blob([css], { type: 'text/css' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Copy text to clipboard
 */
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
}

/**
 * Convert hex color to RGB
 */
export function hexToRgb(hex: string): { r: number; g: number; b: number } | null {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? {
        r: parseInt(result[1] || '00', 16),
        g: parseInt(result[2] || '00', 16),
        b: parseInt(result[3] || '00', 16),
      }
    : null;
}

/**
 * Convert RGB to hex
 */
export function rgbToHex(r: number, g: number, b: number): string {
  return '#' + [r, g, b].map((x) => {
    const hex = x.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  }).join('');
}

/**
 * Check if a color string is valid
 */
export function isValidColor(color: string): boolean {
  const s = new Option().style;
  s.color = color;
  return s.color !== '';
}

/**
 * Get contrasting text color (black or white) for a given background
 */
export function getContrastColor(hex: string): 'black' | 'white' {
  const rgb = hexToRgb(hex);
  if (!rgb) return 'black';

  const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
  return luminance > 0.5 ? 'black' : 'white';
}

/**
 * Generate a random color
 */
export function randomColor(): string {
  return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
}

/**
 * Interpolate between two colors
 */
export function interpolateColor(color1: string, color2: string, factor: number): string {
  const rgb1 = hexToRgb(color1);
  const rgb2 = hexToRgb(color2);

  if (!rgb1 || !rgb2) return color1;

  const r = Math.round(rgb1.r + factor * (rgb2.r - rgb1.r));
  const g = Math.round(rgb1.g + factor * (rgb2.g - rgb1.g));
  const b = Math.round(rgb1.b + factor * (rgb2.b - rgb1.b));

  return rgbToHex(r, g, b);
}

/**
 * Validate gradient configuration
 */
export function validateGradientConfig(config: GradientConfig): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  if (config.colorStops.length < 2) {
    errors.push('At least 2 color stops are required');
  }

  if (config.colorStops.length > 10) {
    errors.push('Maximum 10 color stops allowed');
  }

  for (const stop of config.colorStops) {
    if (stop.position < 0 || stop.position > 100) {
      errors.push(`Color stop position must be between 0 and 100`);
    }
    if (!isValidColor(stop.color)) {
      errors.push(`Invalid color: ${stop.color}`);
    }
  }

  if (config.type === 'linear') {
    if (config.angle < 0 || config.angle > 360) {
      errors.push('Linear angle must be between 0 and 360');
    }
  }

  if (config.type === 'radial' || config.type === 'conic') {
    if (config.position.x < 0 || config.position.x > 100) {
      errors.push('Position X must be between 0 and 100');
    }
    if (config.position.y < 0 || config.position.y > 100) {
      errors.push('Position Y must be between 0 and 100');
    }
  }

  return { valid: errors.length === 0, errors };
}

/**
 * Convert gradient config to a unique hash for comparison
 */
export function gradientConfigToHash(config: GradientConfig): string {
  return JSON.stringify(config);
}

/**
 * Generate CSS with class wrapper
 */
export function generateCSSWithClass(
  config: GradientConfig,
  className: string = 'gradient-bg',
  options: ExportOptions = { format: 'standard', includePrefixes: false, includeComments: true }
): string {
  const gradientCSS = generateGradientCSS(config, options);

  return `.${className} {
  ${gradientCSS}
}`;
}

/**
 * Generate CSS with inline style
 */
export function generateInlineStyle(config: GradientConfig): string {
  const gradientCSS = generateGradientCSS(config, {
    format: 'standard',
    includePrefixes: false,
    includeComments: false
  });
  return gradientCSS.replace('background: ', '').replace(';', '');
}

/**
 * Default gradient presets
 */
export const DEFAULT_PRESETS: GradientPreset[] = [
  // Warm presets
  {
    id: 'sunset',
    name: 'Sunset',
    description: 'Warm orange to purple gradient',
    category: 'Warm',
    config: {
      type: 'linear',
      angle: 135,
      colorStops: [
        { id: '1', color: '#ff7e5f', position: 0 },
        { id: '2', color: '#feb47b', position: 100 },
      ],
    },
  },
  {
    id: 'fire',
    name: 'Fire',
    description: 'Intense red and orange gradient',
    category: 'Warm',
    config: {
      type: 'linear',
      angle: 45,
      colorStops: [
        { id: '1', color: '#f12711', position: 0 },
        { id: '2', color: '#f5af19', position: 100 },
      ],
    },
  },
  {
    id: 'peach',
    name: 'Peach',
    description: 'Soft peach gradient',
    category: 'Warm',
    config: {
      type: 'linear',
      angle: 180,
      colorStops: [
        { id: '1', color: '#ffecd2', position: 0 },
        { id: '2', color: '#fcb69f', position: 100 },
      ],
    },
  },
  // Cool presets
  {
    id: 'ocean',
    name: 'Ocean',
    description: 'Deep blue to cyan gradient',
    category: 'Cool',
    config: {
      type: 'linear',
      angle: 180,
      colorStops: [
        { id: '1', color: '#2193b0', position: 0 },
        { id: '2', color: '#6dd5ed', position: 100 },
      ],
    },
  },
  {
    id: 'sky',
    name: 'Sky',
    description: 'Light blue sky gradient',
    category: 'Cool',
    config: {
      type: 'linear',
      angle: 90,
      colorStops: [
        { id: '1', color: '#56ccf2', position: 0 },
        { id: '2', color: '#2f80ed', position: 100 },
      ],
    },
  },
  {
    id: 'ice',
    name: 'Ice',
    description: 'Cool ice blue gradient',
    category: 'Cool',
    config: {
      type: 'linear',
      angle: 135,
      colorStops: [
        { id: '1', color: '#a8edea', position: 0 },
        { id: '2', color: '#fed6e3', position: 100 },
      ],
    },
  },
  // Nature presets
  {
    id: 'forest',
    name: 'Forest',
    description: 'Green nature gradient',
    category: 'Nature',
    config: {
      type: 'linear',
      angle: 45,
      colorStops: [
        { id: '1', color: '#134e5e', position: 0 },
        { id: '2', color: '#71b280', position: 100 },
      ],
    },
  },
  {
    id: 'meadow',
    name: 'Meadow',
    description: 'Fresh meadow gradient',
    category: 'Nature',
    config: {
      type: 'linear',
      angle: 90,
      colorStops: [
        { id: '1', color: '#d4fc79', position: 0 },
        { id: '2', color: '#96e6a1', position: 100 },
      ],
    },
  },
  // Vibrant presets
  {
    id: 'neon',
    name: 'Neon',
    description: 'Vibrant purple to pink gradient',
    category: 'Vibrant',
    config: {
      type: 'linear',
      angle: 90,
      colorStops: [
        { id: '1', color: '#667eea', position: 0 },
        { id: '2', color: '#764ba2', position: 100 },
      ],
    },
  },
  {
    id: 'aurora',
    name: 'Aurora',
    description: 'Northern lights inspired gradient',
    category: 'Vibrant',
    config: {
      type: 'linear',
      angle: 120,
      colorStops: [
        { id: '1', color: '#00c6ff', position: 0 },
        { id: '2', color: '#0072ff', position: 100 },
      ],
    },
  },
  // Dark presets
  {
    id: 'midnight',
    name: 'Midnight',
    description: 'Dark blue to black gradient',
    category: 'Dark',
    config: {
      type: 'linear',
      angle: 180,
      colorStops: [
        { id: '1', color: '#0f2027', position: 0 },
        { id: '2', color: '#203a43', position: 50 },
        { id: '3', color: '#2c5364', position: 100 },
      ],
    },
  },
  {
    id: 'galaxy',
    name: 'Galaxy',
    description: 'Space-inspired purple gradient',
    category: 'Dark',
    config: {
      type: 'radial',
      shape: 'circle',
      position: { x: 50, y: 50 },
      colorStops: [
        { id: '1', color: '#667eea', position: 0 },
        { id: '2', color: '#764ba2', position: 100 },
      ],
    },
  },
];
</file>

<file path="components/HomeView.tsx">
/**
 * HomeView - Landing Page Component
 *
 * Provides a clear, guided experience for users to choose what they want to create
 * before entering the AI workspace. This helps the AI agent understand user intent.
 */

import { useState, useMemo } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  Video,
  Music,
  AudioWaveform,
  Sparkles,
  Settings2,
  ChevronRight,
  Clock,
  Palette,
  Users,
  Globe,
  ArrowLeft,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Slider } from "@/components/ui/slider";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { cn } from "@/lib/utils";
import { ART_STYLES, VIDEO_PURPOSES, type VideoPurpose } from "@/constants";

// Creation mode types
export type CreationMode = "video" | "music" | "visualizer" | null;

// Preset configurations for AI agent
export interface CreationPreset {
  mode: CreationMode;
  // Video presets
  videoPurpose?: VideoPurpose;
  visualStyle?: string;
  duration?: number;
  topic?: string;
  // Music presets
  musicStyle?: string;
  instrumental?: boolean;
  musicPrompt?: string;
  lyrics?: string;
  musicModel?: "V4" | "V4_5" | "V4_5PLUS" | "V4_5ALL" | "V5";
  // Common
  targetAudience?: string;
  language?: string;
}

interface HomeViewProps {
  onStartCreation: (preset: CreationPreset) => void;
  onSwitchToVisualizer: () => void;
}

// Mode card data
const CREATION_MODES = [
  {
    id: "video" as const,
    title: "Create Video",
    description: "Generate AI videos from any topic with narration, visuals, and music",
    icon: Video,
    color: "from-violet-500 to-purple-600",
    features: ["AI Narration", "Visual Generation", "Background Music", "Auto SFX"],
  },
  {
    id: "music" as const,
    title: "Generate Music",
    description: "Create full songs, instrumentals, or background tracks with Suno AI",
    icon: Music,
    color: "from-pink-500 to-rose-600",
    features: ["Full Songs", "Instrumentals", "Custom Lyrics", "Multiple Styles"],
  },
  {
    id: "visualizer" as const,
    title: "Audio Visualizer",
    description: "Upload audio + SRT to create lyric videos with synced visuals",
    icon: AudioWaveform,
    color: "from-cyan-500 to-blue-600",
    features: ["Lyric Sync", "Visual Effects", "Waveform Display", "Custom Timing"],
  },
];

// Quick start presets
const VIDEO_PRESETS = [
  { id: "documentary", label: "Documentary", purpose: "documentary" as VideoPurpose, style: "Cinematic", duration: 60 },
  { id: "social", label: "Social Short", purpose: "social_short" as VideoPurpose, style: "Modern", duration: 30 },
  { id: "educational", label: "Educational", purpose: "educational" as VideoPurpose, style: "Clean", duration: 90 },
  { id: "storytelling", label: "Storytelling", purpose: "storytelling" as VideoPurpose, style: "Cinematic", duration: 120 },
  { id: "travel", label: "Travel", purpose: "travel" as VideoPurpose, style: "Vibrant", duration: 60 },
  { id: "motivational", label: "Motivational", purpose: "motivational" as VideoPurpose, style: "Inspiring", duration: 45 },
];

const MUSIC_PRESETS = [
  { id: "pop", label: "Pop Song", style: "Pop, Catchy, Upbeat", instrumental: false },
  { id: "cinematic", label: "Cinematic Score", style: "Cinematic, Orchestral, Epic", instrumental: true },
  { id: "lofi", label: "Lo-Fi Beats", style: "Lo-Fi, Chill, Relaxing", instrumental: true },
  { id: "rock", label: "Rock Anthem", style: "Rock, Powerful, Electric Guitar", instrumental: false },
  { id: "electronic", label: "Electronic", style: "Electronic, Synthwave, Energetic", instrumental: true },
  { id: "ambient", label: "Ambient", style: "Ambient, Atmospheric, Peaceful", instrumental: true },
];

export function HomeView({ onStartCreation, onSwitchToVisualizer }: HomeViewProps) {
  const [selectedMode, setSelectedMode] = useState<CreationMode>(null);
  const [showConfig, setShowConfig] = useState(false);

  // Video config state
  const [videoPurpose, setVideoPurpose] = useState<VideoPurpose>("documentary");
  const [visualStyle, setVisualStyle] = useState("Cinematic");
  const [duration, setDuration] = useState(60);
  const [topic, setTopic] = useState("");

  // Music config state
  const [musicStyle, setMusicStyle] = useState("Pop, Catchy, Upbeat");
  const [instrumental, setInstrumental] = useState(false);
  const [musicPrompt, setMusicPrompt] = useState("");
  const [lyrics, setLyrics] = useState("");
  const [musicModel, setMusicModel] = useState<"V4" | "V4_5" | "V4_5PLUS" | "V4_5ALL" | "V5">("V5");

  // Character limits based on model - reactive to model changes
  const charLimits = useMemo(() => {
    if (musicModel === "V4") {
      return { prompt: 3000, style: 200, title: 80 };
    } else if (musicModel === "V4_5ALL") {
      return { prompt: 5000, style: 1000, title: 80 };
    } else {
      // V4_5, V4_5PLUS, V5
      return { prompt: 5000, style: 1000, title: 100 };
    }
  }, [musicModel]);

  const handleModeSelect = (mode: CreationMode) => {
    if (mode === "visualizer") {
      onSwitchToVisualizer();
      return;
    }
    setSelectedMode(mode);
    setShowConfig(true);
  };

  const handlePresetSelect = (preset: any) => {
    if (selectedMode === "video") {
      setVideoPurpose(preset.purpose);
      setVisualStyle(preset.style);
      setDuration(preset.duration);
    } else if (selectedMode === "music") {
      setMusicStyle(preset.style);
      setInstrumental(preset.instrumental);
    }
  };

  const handleStartCreation = () => {
    const preset: CreationPreset = {
      mode: selectedMode,
    };

    if (selectedMode === "video") {
      preset.videoPurpose = videoPurpose;
      preset.visualStyle = visualStyle;
      preset.duration = duration;
      preset.topic = topic;
    } else if (selectedMode === "music") {
      preset.musicStyle = musicStyle;
      preset.instrumental = instrumental;
      preset.musicPrompt = musicPrompt;
      preset.musicModel = musicModel;
      if (!instrumental && lyrics) {
        preset.lyrics = lyrics;
      }
    }

    onStartCreation(preset);
  };

  const handleBack = () => {
    setShowConfig(false);
    setSelectedMode(null);
  };

  return (
    <div className="min-h-screen bg-[#0a0a0f] text-white overflow-hidden">
      {/* Background gradient */}
      <div className="fixed inset-0 pointer-events-none">
        <div className="absolute top-0 left-1/4 w-96 h-96 bg-violet-500/10 rounded-full blur-[128px]" />
        <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-pink-500/10 rounded-full blur-[128px]" />
      </div>

      {/* Content */}
      <div className="relative z-10 min-h-screen flex flex-col">
        {/* Header */}
        <header className="p-6 flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-violet-500 to-purple-600 flex items-center justify-center">
              <Sparkles className="w-5 h-5 text-white" />
            </div>
            <span className="text-xl font-semibold">LyricLens</span>
          </div>

          {showConfig && (
            <Button
              variant="ghost"
              size="sm"
              onClick={handleBack}
              className="text-white/60 hover:text-white"
            >
              <ArrowLeft className="w-4 h-4 mr-2" />
              Back
            </Button>
          )}
        </header>

        {/* Main Content */}
        <main className="flex-1 flex items-center justify-center p-6">
          <AnimatePresence mode="wait">
            {!showConfig ? (
              /* Mode Selection */
              <motion.div
                key="mode-select"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                className="max-w-5xl w-full"
              >
                {/* Title */}
                <div className="text-center mb-12">
                  <h1 className="text-4xl md:text-5xl font-bold mb-4">
                    What would you like to create?
                  </h1>
                  <p className="text-lg text-white/60 max-w-2xl mx-auto">
                    Choose a creation mode to get started. Our AI will guide you through the process.
                  </p>
                </div>

                {/* Mode Cards */}
                <div className="grid md:grid-cols-3 gap-6">
                  {CREATION_MODES.map((mode) => {
                    const Icon = mode.icon;
                    return (
                      <motion.button
                        key={mode.id}
                        onClick={() => handleModeSelect(mode.id)}
                        whileHover={{ scale: 1.02, y: -4 }}
                        whileTap={{ scale: 0.98 }}
                        className={cn(
                          "group relative p-6 rounded-2xl text-left transition-all duration-300",
                          "bg-white/5 hover:bg-white/10 border border-white/10 hover:border-white/20",
                          "backdrop-blur-sm"
                        )}
                      >
                        {/* Icon */}
                        <div className={cn(
                          "w-14 h-14 rounded-xl bg-gradient-to-br flex items-center justify-center mb-4",
                          mode.color
                        )}>
                          <Icon className="w-7 h-7 text-white" />
                        </div>

                        {/* Title & Description */}
                        <h3 className="text-xl font-semibold mb-2">{mode.title}</h3>
                        <p className="text-sm text-white/60 mb-4">{mode.description}</p>

                        {/* Features */}
                        <div className="flex flex-wrap gap-2">
                          {mode.features.map((feature) => (
                            <span
                              key={feature}
                              className="px-2 py-1 text-xs rounded-full bg-white/10 text-white/70"
                            >
                              {feature}
                            </span>
                          ))}
                        </div>

                        {/* Arrow indicator */}
                        <div className="absolute top-6 right-6 opacity-0 group-hover:opacity-100 transition-opacity">
                          <ChevronRight className="w-5 h-5 text-white/60" />
                        </div>
                      </motion.button>
                    );
                  })}
                </div>
              </motion.div>
            ) : (
              /* Configuration Panel */
              <motion.div
                key="config"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                className="max-w-3xl w-full"
              >
                {/* Title */}
                <div className="text-center mb-8">
                  <div className={cn(
                    "w-16 h-16 rounded-2xl bg-gradient-to-br flex items-center justify-center mx-auto mb-4",
                    selectedMode === "video" ? "from-violet-500 to-purple-600" : "from-pink-500 to-rose-600"
                  )}>
                    {selectedMode === "video" ? (
                      <Video className="w-8 h-8 text-white" />
                    ) : (
                      <Music className="w-8 h-8 text-white" />
                    )}
                  </div>
                  <h2 className="text-3xl font-bold mb-2">
                    {selectedMode === "video" ? "Configure Your Video" : "Configure Your Music"}
                  </h2>
                  <p className="text-white/60">
                    {selectedMode === "video"
                      ? "Choose a preset or customize your video settings"
                      : "Choose a preset or customize your music style"
                    }
                  </p>
                </div>

                {/* Quick Presets */}
                <div className="mb-8">
                  <Label className="text-sm text-white/60 mb-3 block">Quick Presets</Label>
                  <div className="grid grid-cols-3 md:grid-cols-6 gap-2">
                    {(selectedMode === "video" ? VIDEO_PRESETS : MUSIC_PRESETS).map((preset) => (
                      <button
                        key={preset.id}
                        onClick={() => handlePresetSelect(preset)}
                        className={cn(
                          "px-3 py-2 rounded-lg text-sm font-medium transition-all",
                          "bg-white/5 hover:bg-white/10 border border-white/10",
                          ((selectedMode === "video" && "purpose" in preset && videoPurpose === preset.purpose) ||
                            (selectedMode === "music" && "style" in preset && musicStyle === preset.style)) &&
                          "bg-violet-500/20 border-violet-500/50"
                        )}
                      >
                        {preset.label}
                      </button>
                    ))}
                  </div>
                </div>

                {/* Configuration Form */}
                <div className="bg-white/5 rounded-2xl p-6 border border-white/10 mb-6">
                  {selectedMode === "video" ? (
                    <div className="space-y-6">
                      {/* Topic Input */}
                      <div>
                        <Label className="text-sm text-white/80 mb-2 block">
                          What's your video about? (optional)
                        </Label>
                        <Input
                          value={topic}
                          onChange={(e) => setTopic(e.target.value)}
                          placeholder="e.g., The history of coffee, A day in Tokyo..."
                          className="bg-white/5 border-white/10 text-white placeholder:text-white/40"
                        />
                        <p className="text-xs text-white/40 mt-1">
                          Leave empty to describe it to the AI later
                        </p>
                      </div>

                      {/* Purpose & Style */}
                      <div className="grid md:grid-cols-2 gap-4">
                        <div>
                          <Label className="text-sm text-white/80 mb-2 block">
                            <Users className="w-4 h-4 inline mr-2" />
                            Video Purpose
                          </Label>
                          <Select value={videoPurpose} onValueChange={(v) => setVideoPurpose(v as VideoPurpose)}>
                            <SelectTrigger className="bg-white/5 border-white/10 text-white">
                              <SelectValue />
                            </SelectTrigger>
                            <SelectContent className="bg-zinc-900 border-white/10">
                              {VIDEO_PURPOSES.map((p) => (
                                <SelectItem key={p.value} value={p.value} className="text-white focus:bg-white/10 focus:text-white">
                                  <span>{p.icon} {p.label}</span>
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                        </div>

                        <div>
                          <Label className="text-sm text-white/80 mb-2 block">
                            <Palette className="w-4 h-4 inline mr-2" />
                            Visual Style
                          </Label>
                          <Select value={visualStyle} onValueChange={setVisualStyle}>
                            <SelectTrigger className="bg-white/5 border-white/10 text-white">
                              <SelectValue />
                            </SelectTrigger>
                            <SelectContent className="bg-zinc-900 border-white/10">
                              {ART_STYLES.map((style) => (
                                <SelectItem key={style} value={style} className="text-white focus:bg-white/10 focus:text-white">
                                  <span>{style}</span>
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                        </div>
                      </div>

                      {/* Duration */}
                      <div>
                        <Label className="text-sm text-white/80 mb-2 block">
                          <Clock className="w-4 h-4 inline mr-2" />
                          Target Duration: {duration}s
                        </Label>
                        <Slider
                          value={[duration]}
                          onValueChange={(v) => v[0] !== undefined && setDuration(v[0])}
                          min={15}
                          max={180}
                          step={15}
                          className="py-4"
                        />
                        <div className="flex justify-between text-xs text-white/40">
                          <span>15s (Short)</span>
                          <span>60s</span>
                          <span>180s (Long)</span>
                        </div>
                      </div>
                    </div>
                  ) : (
                    <div className="space-y-6">
                      {/* Model Selection */}
                      <div>
                        <Label className="text-sm text-white/80 mb-2 block">
                          AI Model
                        </Label>
                        <div className="grid grid-cols-5 gap-2">
                          {[
                            { id: "V5", label: "V5", desc: "Latest" },
                            { id: "V4_5PLUS", label: "V4.5+", desc: "Rich tones" },
                            { id: "V4_5ALL", label: "V4.5 All", desc: "Structure" },
                            { id: "V4_5", label: "V4.5", desc: "Smart" },
                            { id: "V4", label: "V4", desc: "Vocals" },
                          ].map((model) => (
                            <button
                              key={model.id}
                              onClick={() => setMusicModel(model.id as any)}
                              className={cn(
                                "p-2 rounded-lg text-center transition-all",
                                musicModel === model.id
                                  ? "bg-pink-500/30 border-2 border-pink-500"
                                  : "bg-white/5 border border-white/10 hover:bg-white/10"
                              )}
                            >
                              <p className="text-sm font-medium">{model.label}</p>
                              <p className="text-xs text-white/50">{model.desc}</p>
                            </button>
                          ))}
                        </div>
                      </div>

                      {/* Music Prompt */}
                      <div>
                        <Label className="text-sm text-white/80 mb-2 block">
                          What kind of music? (optional)
                        </Label>
                        <Input
                          value={musicPrompt}
                          onChange={(e) => setMusicPrompt(e.target.value.slice(0, charLimits.prompt))}
                          placeholder="e.g., A summer beach vibe, Epic battle theme..."
                          className="bg-white/5 border-white/10 text-white placeholder:text-white/40"
                        />
                        <p className="text-xs text-white/40 mt-1">
                          Leave empty to describe it to the AI later
                        </p>
                      </div>

                      {/* Style */}
                      <div>
                        <Label className="text-sm text-white/80 mb-2 block">
                          <Palette className="w-4 h-4 inline mr-2" />
                          Music Style
                        </Label>
                        <Input
                          value={musicStyle}
                          onChange={(e) => setMusicStyle(e.target.value.slice(0, charLimits.style))}
                          placeholder="e.g., Pop, Upbeat, Catchy"
                          className="bg-white/5 border-white/10 text-white placeholder:text-white/40"
                        />
                        <p className="text-xs text-white/40 mt-1 text-right">
                          {musicStyle.length}/{charLimits.style}
                        </p>
                      </div>

                      {/* Instrumental Toggle */}
                      <div className="flex items-center justify-between p-4 rounded-xl bg-white/5">
                        <div>
                          <p className="font-medium">Instrumental Only</p>
                          <p className="text-sm text-white/60">No vocals, just music</p>
                        </div>
                        <button
                          onClick={() => setInstrumental(!instrumental)}
                          className={cn(
                            "w-12 h-6 rounded-full transition-colors relative",
                            instrumental ? "bg-violet-500" : "bg-white/20"
                          )}
                        >
                          <span
                            className={cn(
                              "absolute top-1 w-4 h-4 rounded-full bg-white transition-transform",
                              instrumental ? "left-7" : "left-1"
                            )}
                          />
                        </button>
                      </div>

                      {/* Lyrics Input - shown when not instrumental */}
                      {!instrumental && (
                        <div>
                          <Label className="text-sm text-white/80 mb-2 block">
                            <Music className="w-4 h-4 inline mr-2" />
                            Lyrics
                          </Label>
                          <textarea
                            value={lyrics}
                            onChange={(e) => setLyrics(e.target.value.slice(0, charLimits.prompt))}
                            placeholder="Write your own lyrics, two verses (8 lines) for the best result"
                            rows={5}
                            className="w-full bg-white/5 border border-white/10 rounded-lg p-3 text-white placeholder:text-white/40 resize-none focus:outline-none focus:ring-2 focus:ring-violet-500/50"
                          />
                          <p className="text-xs text-white/40 mt-1 text-right">
                            {lyrics.length}/{charLimits.prompt}
                          </p>
                        </div>
                      )}
                    </div>
                  )}
                </div>

                {/* Start Button */}
                <Button
                  onClick={handleStartCreation}
                  size="lg"
                  className={cn(
                    "w-full h-14 text-lg font-semibold rounded-xl",
                    "bg-gradient-to-r shadow-lg",
                    selectedMode === "video"
                      ? "from-violet-500 to-purple-600 hover:from-violet-600 hover:to-purple-700"
                      : "from-pink-500 to-rose-600 hover:from-pink-600 hover:to-rose-700"
                  )}
                >
                  <Sparkles className="w-5 h-5 mr-2" />
                  Start Creating
                </Button>
              </motion.div>
            )}
          </AnimatePresence>
        </main>

        {/* Footer */}
        <footer className="p-6 text-center text-sm text-white/40">
          Powered by Gemini AI & Suno
        </footer>
      </div>
    </div>
  );
}

export default HomeView;
</file>

<file path="components/IntroAnimation.css">
/* Additional styles for the intro animation */
@keyframes float {
  0%, 100% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-10px);
  }
}

@keyframes glow {
  0%, 100% {
    box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
  }
  50% {
    box-shadow: 0 0 40px rgba(139, 92, 246, 0.6);
  }
}

@keyframes sparkle {
  0%, 100% {
    opacity: 0.3;
    transform: scale(0.8);
  }
  50% {
    opacity: 1;
    transform: scale(1.2);
  }
}

.intro-particle {
  animation: float 3s ease-in-out infinite;
}

.intro-particle:nth-child(odd) {
  animation-delay: 0.5s;
}

.intro-particle:nth-child(even) {
  animation-delay: 1s;
}

.intro-logo {
  animation: glow 2s ease-in-out infinite;
}

.intro-sparkle {
  animation: sparkle 1.5s ease-in-out infinite;
}
</file>

<file path="components/IntroAnimation.tsx">
import React, { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Music, Sparkles } from 'lucide-react';

interface IntroAnimationProps {
  onComplete: () => void;
  duration?: number;
}

export const IntroAnimation: React.FC<IntroAnimationProps> = ({ 
  onComplete, 
  duration = 2000 // Shortened from 4000ms for faster start
}) => {
  const [showSubtitle, setShowSubtitle] = useState(false);
  const [showSkipButton, setShowSkipButton] = useState(false);
  const [particles] = useState(() => 
    Array.from({ length: 12 }, (_, i) => ({
      id: i,
      x: (i - 6) * 8,
      y: Math.sin(i * 0.5) * 20,
      z: Math.cos(i * 0.3) * 15,
      color: ['#3B82F6', '#8B5CF6', '#06B6D4', '#F59E0B'][i % 4],
      delay: i * 0.1
    }))
  );

  useEffect(() => {
    const subtitleTimer = setTimeout(() => setShowSubtitle(true), duration * 0.4);
    const skipButtonTimer = setTimeout(() => setShowSkipButton(true), 500);
    const completeTimer = setTimeout(onComplete, duration);

    return () => {
      clearTimeout(subtitleTimer);
      clearTimeout(skipButtonTimer);
      clearTimeout(completeTimer);
    };
  }, [onComplete, duration]);

  return (
    <div className="fixed inset-0 z-50 bg-gradient-to-br from-slate-900 via-blue-900/20 to-slate-900 flex items-center justify-center overflow-hidden">
      {/* Background particles */}
      <div className="absolute inset-0">
        {particles.map((particle) => (
          <motion.div
            key={particle.id}
            className="absolute w-2 h-2 rounded-full"
            style={{
              backgroundColor: particle.color,
              boxShadow: `0 0 20px ${particle.color}`,
              left: `calc(50% + ${particle.x}px)`,
              top: `calc(50% + ${particle.y}px)`,
            }}
            initial={{ 
              opacity: 0, 
              scale: 0,
              y: particle.z 
            }}
            animate={{ 
              opacity: [0, 1, 1, 0],
              scale: [0, 1, 1, 0],
              y: [particle.z, particle.z - 20, particle.z + 20, particle.z],
            }}
            transition={{
              duration: duration / 1000,
              delay: particle.delay,
              ease: "easeInOut",
              repeat: Infinity,
              repeatType: "reverse"
            }}
          />
        ))}
      </div>

      {/* Skip Button */}
      <AnimatePresence>
        {showSkipButton && (
          <motion.button
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0 }}
            onClick={onComplete}
            aria-label="Skip introduction animation"
            className="absolute top-6 right-6 px-4 py-2 text-sm font-medium text-slate-400 hover:text-slate-200 bg-slate-800/50 hover:bg-slate-700/50 backdrop-blur-sm rounded-lg transition-all duration-200 border border-slate-700/50 hover:border-slate-600"
          >
            Skip
          </motion.button>
        )}
      </AnimatePresence>

      {/* Main content container */}
      <div className="relative z-10 text-center">
        {/* Main logo */}
        <motion.div
          className="relative mb-6"
          initial={{ scale: 0, rotateZ: -180 }}
          animate={{ scale: 1, rotateZ: 360 }}
          transition={{
            scale: { duration: 1, ease: "backOut" },
            rotateZ: { duration: duration / 1000, ease: "linear" }
          }}
        >
          {/* Logo background glow */}
          <motion.div
            className="absolute inset-0 bg-gradient-to-r from-blue-500/30 via-purple-500/20 to-blue-500/30 blur-3xl rounded-full"
            animate={{
              scale: [1, 1.2, 1],
              opacity: [0.3, 0.6, 0.3]
            }}
            transition={{
              duration: 2,
              repeat: Infinity,
              ease: "easeInOut"
            }}
          />
          
          {/* Main logo text */}
          <div className="relative flex items-center justify-center gap-3">
            <motion.div
              className="w-12 h-12 rounded-xl bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center shadow-lg shadow-blue-500/30"
              whileHover={{ scale: 1.05 }}
              animate={{
                boxShadow: [
                  "0 0 20px rgba(59, 130, 246, 0.3)",
                  "0 0 40px rgba(139, 92, 246, 0.5)",
                  "0 0 20px rgba(59, 130, 246, 0.3)"
                ]
              }}
              transition={{
                boxShadow: { duration: 2, repeat: Infinity }
              }}
            >
              <Music className="text-white w-6 h-6" />
            </motion.div>
            
            <motion.h1
              className="text-6xl md:text-8xl font-bold bg-gradient-to-r from-blue-400 via-purple-400 to-blue-400 bg-clip-text text-transparent tracking-tight"
              initial={{ opacity: 0, x: -50 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: 0.5, duration: 0.8 }}
            >
              LyricLens
            </motion.h1>
          </div>
        </motion.div>

        {/* Subtitle */}
        <AnimatePresence>
          {showSubtitle && (
            <motion.div
              className="flex items-center justify-center gap-2"
              initial={{ opacity: 0, y: 20, scale: 0.8 }}
              animate={{ opacity: 1, y: 0, scale: 1 }}
              exit={{ opacity: 0, y: -20, scale: 0.8 }}
              transition={{ duration: 0.6, ease: "backOut" }}
            >
              <Sparkles className="text-orange-400 w-5 h-5" />
              <span className="text-2xl md:text-3xl font-semibold text-orange-400 tracking-wide">
                AI Video Studio
              </span>
              <Sparkles className="text-orange-400 w-5 h-5" />
            </motion.div>
          )}
        </AnimatePresence>

        {/* Loading indicator */}
        <motion.div
          className="mt-12 flex justify-center"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 2 }}
        >
          <div className="flex space-x-1">
            {[0, 1, 2].map((i) => (
              <motion.div
                key={i}
                className="w-2 h-2 bg-blue-400 rounded-full"
                animate={{
                  scale: [1, 1.5, 1],
                  opacity: [0.5, 1, 0.5]
                }}
                transition={{
                  duration: 0.8,
                  repeat: Infinity,
                  delay: i * 0.2
                }}
              />
            ))}
          </div>
        </motion.div>
      </div>

      {/* Ambient light effects */}
      <div className="absolute top-1/4 left-1/4 w-96 h-96 bg-blue-500/10 rounded-full blur-3xl animate-pulse" />
      <div className="absolute bottom-1/4 right-1/4 w-96 h-96 bg-purple-500/10 rounded-full blur-3xl animate-pulse" style={{ animationDelay: '1s' }} />
    </div>
  );
};
</file>

<file path="components/layout/AppLayout.tsx">
import React, { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { cn } from "@/lib/utils";
import { Menu, X } from "lucide-react";
import { Button } from "@/components/ui/button";
import { SkipLink } from "@/components/ui/skip-link";
import { useLanguage } from "@/i18n/useLanguage";

export interface AppLayoutProps {
  sidebar: React.ReactNode;
  header: React.ReactNode;
  children: React.ReactNode;
  isSidebarOpen: boolean;
  onSidebarToggle: (open: boolean) => void;
}

export const AppLayout: React.FC<AppLayoutProps> = ({
  sidebar,
  header,
  children,
  isSidebarOpen,
  onSidebarToggle,
}) => {
  const { t, isRTL } = useLanguage();
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });

  // Parallax effect for the background
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      setMousePos({
        x: (e.clientX / window.innerWidth - 0.5) * 20,
        y: (e.clientY / window.innerHeight - 0.5) * 20,
      });
    };
    window.addEventListener("mousemove", handleMouseMove);
    return () => window.removeEventListener("mousemove", handleMouseMove);
  }, []);

  return (
    <div className="relative min-h-screen overflow-hidden bg-background text-foreground font-sans selection:bg-primary/30">

      {/* Skip to main content link for keyboard users */}
      <SkipLink targetId="main-content">
        {t('a11y.skipToContent')}
      </SkipLink>

      {/* Ambient Void Background */}
      <div className="fixed inset-0 z-0 pointer-events-none overflow-hidden" aria-hidden="true">
        {/* Deep Space Gradients */}
        <motion.div
          className="absolute top-[-20%] left-[-10%] w-[70%] h-[70%] bg-primary/5 rounded-full blur-[120px]"
          animate={{ x: mousePos.x * -1, y: mousePos.y * -1 }}
          transition={{ type: "spring", damping: 50, stiffness: 100 }}
        />
        <motion.div
          className="absolute bottom-[-20%] right-[-10%] w-[60%] h-[60%] bg-secondary/10 rounded-full blur-[100px]"
          animate={{ x: mousePos.x * -0.5, y: mousePos.y * -0.5 }}
          transition={{ type: "spring", damping: 50, stiffness: 100 }}
        />

        {/* Stars / Dust Particles */}
        <div className="absolute inset-0 opacity-20 bg-[url('/noise.svg')] mix-blend-overlay" />
      </div>

      {/* Floating Dock (Desktop Sidebar) */}
      <div className="hidden md:block fixed left-4 top-1/2 -translate-y-1/2 z-50">
        <div className="glass-panel rounded-2xl p-2 transition-all duration-500 hover:shadow-[0_0_40px_rgba(var(--primary),0.2)]">
          {sidebar}
        </div>
      </div>

      {/* Mobile Header */}
      <header
        className="md:hidden fixed top-0 left-0 right-0 h-16 z-40 px-4 flex items-center justify-between glass-panel border-b-0"
        role="banner"
      >
        <span className="font-bold text-lg tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-primary to-accent">
          LyricLens
        </span>
        <Button
          variant="ghost"
          size="icon"
          onClick={() => onSidebarToggle(!isSidebarOpen)}
          className="hover:bg-white/5"
          aria-label={isSidebarOpen ? t('a11y.closeMenu') : t('a11y.openMenu')}
          aria-expanded={isSidebarOpen}
        >
          {isSidebarOpen ? <X aria-hidden="true" /> : <Menu aria-hidden="true" />}
        </Button>
      </header>

      {/* Mobile Sidebar Overlay */}
      <AnimatePresence>
        {isSidebarOpen && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 z-50 bg-black/80 backdrop-blur-xl md:hidden flex items-center justify-center p-6"
            onClick={() => onSidebarToggle(false)}
          >
            <div
              className="w-full max-w-sm"
              onClick={(e) => e.stopPropagation()}
            >
              {sidebar}
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Main Content Area */}
      <main
        id="main-content"
        className="relative z-10 min-h-screen flex flex-col md:pl-24"
        role="main"
        aria-label="Main content"
      >
        {/* Contextual Header (floats at top) */}
        <div className="sticky top-0 z-30 px-6 py-4">
          {header}
        </div>

        {/* Workspace */}
        <div className="flex-1 flex flex-col relative px-4 md:px-8 pb-8">
          {children}
        </div>
      </main>
    </div>
  );
};
</file>

<file path="components/layout/AppShell.tsx">
import React, { useEffect } from 'react';
import { useLanguage } from '@/i18n/useLanguage';
import { cn } from '@/lib/utils';

export interface AppShellProps {
  children: React.ReactNode;
  className?: string;
}

/**
 * SkipToContent - Accessibility link to skip navigation and jump to main content
 * Requirements: 9.1 - Add skip-to-content link
 */
const SkipToContent: React.FC = () => {
  const { t } = useLanguage();
  
  return (
    <a
      href="#main-content"
      className={cn(
        'sr-only focus:not-sr-only',
        'focus:fixed focus:top-4 focus:left-4 focus:z-[100]',
        'focus:px-4 focus:py-2 focus:rounded-lg',
        'focus:bg-primary focus:text-primary-foreground',
        'focus:outline-none focus:ring-2 focus:ring-primary-foreground',
        'transition-all duration-200'
      )}
    >
      {t('a11y.skipToContent')}
    </a>
  );
};

/**
 * AppShell is the root layout wrapper that handles:
 * - RTL/LTR direction based on current language
 * - HTML lang and dir attribute updates
 * - Base layout structure for the application
 * - Skip-to-content accessibility link
 * 
 * Requirements: 9.1 - Use semantic HTML elements
 * Requirements: 9.3 - Update lang and dir attributes on HTML element
 */
export const AppShell: React.FC<AppShellProps> = ({ children, className }) => {
  const { language, direction, isRTL } = useLanguage();

  // Update HTML document attributes when language changes
  useEffect(() => {
    const html = document.documentElement;
    html.setAttribute('lang', language);
    html.setAttribute('dir', direction);
    
    // Update body class for RTL-specific styles
    if (isRTL) {
      document.body.classList.add('rtl');
    } else {
      document.body.classList.remove('rtl');
    }

    return () => {
      document.body.classList.remove('rtl');
    };
  }, [language, direction, isRTL]);

  return (
    <div
      className={cn(
        'min-h-screen bg-background text-foreground font-sans',
        isRTL && 'rtl',
        className
      )}
      dir={direction}
    >
      {/* Skip to content link for keyboard/screen reader users */}
      <SkipToContent />
      {children}
    </div>
  );
};

export default AppShell;
</file>

<file path="components/layout/DirectionalIcon.tsx">
import React from 'react';
import {
  ChevronRight,
  ChevronLeft,
  ArrowRight,
  ArrowLeft,
  ArrowRightCircle,
  ArrowLeftCircle,
  ChevronsRight,
  ChevronsLeft,
  CornerDownRight,
  CornerDownLeft,
  CornerUpRight,
  CornerUpLeft,
  type LucideIcon,
} from 'lucide-react';
import { useLanguage } from '@/i18n/useLanguage';
import { cn } from '@/lib/utils';

/**
 * Map of directional icons and their RTL counterparts.
 * When RTL is active, these icons are swapped to their mirrored versions.
 */
const directionalIconPairs: Record<string, LucideIcon> = {
  ChevronRight: ChevronLeft,
  ChevronLeft: ChevronRight,
  ArrowRight: ArrowLeft,
  ArrowLeft: ArrowRight,
  ArrowRightCircle: ArrowLeftCircle,
  ArrowLeftCircle: ArrowRightCircle,
  ChevronsRight: ChevronsLeft,
  ChevronsLeft: ChevronsRight,
  CornerDownRight: CornerDownLeft,
  CornerDownLeft: CornerDownRight,
  CornerUpRight: CornerUpLeft,
  CornerUpLeft: CornerUpRight,
};

/**
 * List of icon names that should be flipped (mirrored) in RTL mode
 */
const flipInRTL = new Set([
  'ChevronRight',
  'ChevronLeft',
  'ArrowRight',
  'ArrowLeft',
  'ArrowRightCircle',
  'ArrowLeftCircle',
  'ChevronsRight',
  'ChevronsLeft',
  'CornerDownRight',
  'CornerDownLeft',
  'CornerUpRight',
  'CornerUpLeft',
]);

export interface DirectionalIconProps {
  /** The Lucide icon component to render */
  icon: LucideIcon;
  /** Size of the icon in pixels */
  size?: number;
  /** Additional CSS classes */
  className?: string;
  /** Stroke width for the icon */
  strokeWidth?: number;
  /** Whether to use swap mode (swap icon) or flip mode (CSS transform) */
  mode?: 'swap' | 'flip';
}

/**
 * DirectionalIcon component that handles RTL-aware icon rendering.
 * 
 * Supports two modes:
 * - 'swap': Swaps the icon with its RTL counterpart (e.g., ChevronRight ‚Üí ChevronLeft)
 * - 'flip': Applies CSS transform to mirror the icon horizontally
 * 
 * @example
 * ```tsx
 * // Swap mode (default) - icon is replaced with RTL counterpart
 * <DirectionalIcon icon={ChevronRight} size={16} />
 * 
 * // Flip mode - icon is mirrored using CSS transform
 * <DirectionalIcon icon={ChevronRight} size={16} mode="flip" />
 * ```
 */
export const DirectionalIcon: React.FC<DirectionalIconProps> = ({
  icon: Icon,
  size = 16,
  className,
  strokeWidth = 2,
  mode = 'swap',
}) => {
  const { isRTL } = useLanguage();

  // Get the icon name for lookup
  const iconName = Icon.displayName || Icon.name || '';
  const shouldTransform = flipInRTL.has(iconName);

  if (mode === 'swap' && isRTL && shouldTransform) {
    // Swap mode: use the RTL counterpart icon
    const RTLIcon = directionalIconPairs[iconName];
    if (RTLIcon) {
      return (
        <RTLIcon
          size={size}
          strokeWidth={strokeWidth}
          className={className}
        />
      );
    }
  }

  // Flip mode or no swap available: apply CSS transform if needed
  return (
    <Icon
      size={size}
      strokeWidth={strokeWidth}
      className={cn(
        className,
        mode === 'flip' && isRTL && shouldTransform && 'rtl-flip'
      )}
    />
  );
};

/**
 * Pre-configured directional icon components for common use cases
 */

export const DirectionalChevronRight: React.FC<Omit<DirectionalIconProps, 'icon'>> = (props) => (
  <DirectionalIcon icon={ChevronRight} {...props} />
);

export const DirectionalChevronLeft: React.FC<Omit<DirectionalIconProps, 'icon'>> = (props) => (
  <DirectionalIcon icon={ChevronLeft} {...props} />
);

export const DirectionalArrowRight: React.FC<Omit<DirectionalIconProps, 'icon'>> = (props) => (
  <DirectionalIcon icon={ArrowRight} {...props} />
);

export const DirectionalArrowLeft: React.FC<Omit<DirectionalIconProps, 'icon'>> = (props) => (
  <DirectionalIcon icon={ArrowLeft} {...props} />
);

/**
 * BackArrow component - always points "back" in the current reading direction
 * In LTR: points left (‚Üê)
 * In RTL: points right (‚Üí)
 */
export const BackArrow: React.FC<Omit<DirectionalIconProps, 'icon' | 'mode'>> = (props) => {
  const { isRTL } = useLanguage();
  const Icon = isRTL ? ArrowRight : ArrowLeft;
  return <Icon size={props.size || 16} strokeWidth={props.strokeWidth || 2} className={props.className} />;
};

/**
 * ForwardArrow component - always points "forward" in the current reading direction
 * In LTR: points right (‚Üí)
 * In RTL: points left (‚Üê)
 */
export const ForwardArrow: React.FC<Omit<DirectionalIconProps, 'icon' | 'mode'>> = (props) => {
  const { isRTL } = useLanguage();
  const Icon = isRTL ? ArrowLeft : ArrowRight;
  return <Icon size={props.size || 16} strokeWidth={props.strokeWidth || 2} className={props.className} />;
};

/**
 * BackChevron component - always points "back" in the current reading direction
 */
export const BackChevron: React.FC<Omit<DirectionalIconProps, 'icon' | 'mode'>> = (props) => {
  const { isRTL } = useLanguage();
  const Icon = isRTL ? ChevronRight : ChevronLeft;
  return <Icon size={props.size || 16} strokeWidth={props.strokeWidth || 2} className={props.className} />;
};

/**
 * ForwardChevron component - always points "forward" in the current reading direction
 */
export const ForwardChevron: React.FC<Omit<DirectionalIconProps, 'icon' | 'mode'>> = (props) => {
  const { isRTL } = useLanguage();
  const Icon = isRTL ? ChevronLeft : ChevronRight;
  return <Icon size={props.size || 16} strokeWidth={props.strokeWidth || 2} className={props.className} />;
};

export default DirectionalIcon;
</file>

<file path="components/layout/Header.tsx">
import React from "react";
import { useNavigate } from "react-router-dom";
import {
  Music,
  Download,
  Video,
  MoreVertical,
  Share2,
  FolderOpen,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { AppState, SongData } from "@/types";
import { cn } from "@/lib/utils";
import { useLanguage } from "@/i18n/useLanguage";
import { LanguageSwitcher } from "./LanguageSwitcher";
import { BackArrow, ForwardChevron } from "./DirectionalIcon";
import { UserMenu } from "@/components/auth";
import { useAuth } from "@/hooks/useAuth";

// Legacy Header Props for backward compatibility
export interface LegacyHeaderProps {
  songData: SongData | null;
  contentType: "music" | "story";
  appState: AppState;
  onDownloadSRT: () => void;
  onExportVideo: () => void;
}

// New Header Props for i18n-aware header
export interface HeaderProps {
  showBackButton?: boolean;
  title?: string;
  actions?: React.ReactNode;
  onBack?: () => void;
  className?: string;
}

/**
 * DirectionalChevron - Renders the correct chevron based on RTL/LTR
 * Uses the ForwardChevron from DirectionalIcon
 */
const DirectionalChevron: React.FC<{ size?: number; className?: string }> = ({ 
  size = 12, 
  className 
}) => {
  return <ForwardChevron size={size} className={className} />;
};

/**
 * DirectionalBackArrow - Renders the correct back arrow based on RTL/LTR
 * Uses the BackArrow from DirectionalIcon
 */
const DirectionalBackArrow: React.FC<{ size?: number; className?: string }> = ({ 
  size = 18, 
  className 
}) => {
  return <BackArrow size={size} className={className} />;
};

/**
 * New i18n-aware Header component
 * Includes language switcher and supports RTL layout
 * Requirements: 9.2 - Add ARIA labels for navigation elements
 */
export const Header: React.FC<HeaderProps> = ({
  showBackButton = false,
  title,
  actions,
  onBack,
  className,
}) => {
  const { t, isRTL } = useLanguage();
  const navigate = useNavigate();
  const { user } = useAuth();

  return (
    <header 
      className={cn(
        "glass-panel rounded-2xl h-16 px-6 flex items-center justify-between transition-all duration-500 hover:shadow-[0_0_30px_rgba(var(--primary),0.1)]",
        className
      )}
      role="banner"
      aria-label={t('a11y.mainNav')}
    >
      {/* Left side - Back button and title */}
      <nav 
        className={cn(
          "flex items-center gap-4",
          isRTL && "flex-row-reverse"
        )}
        aria-label={t('a11y.mainNav')}
      >
        {showBackButton && onBack && (
          <Button
            variant="ghost"
            size="icon"
            onClick={onBack}
            className="text-muted-foreground hover:text-foreground hover:bg-white/[0.05] h-9 w-9 rounded-lg focus:ring-2 focus:ring-primary/50 focus:ring-offset-2 focus:ring-offset-background"
            aria-label={t('nav.back')}
          >
            <DirectionalBackArrow size={18} aria-hidden="true" />
          </Button>
        )}
        
        {title && (
          <h1 className="font-semibold text-foreground tracking-tight text-lg">
            {title}
          </h1>
        )}

        {!title && (
          <span className="font-bold text-lg tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-primary to-accent" aria-label={t('home.title')}>
            {t('home.title')}
          </span>
        )}
      </nav>

      {/* Right side - Actions, User Menu, and Language Switcher */}
      <div
        className={cn(
          "flex items-center gap-2",
          isRTL && "flex-row-reverse"
        )}
        role="toolbar"
        aria-label="Header actions"
      >
        {actions}

        {user && (
          <>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => navigate('/projects')}
              className="text-muted-foreground hover:text-foreground hover:bg-white/[0.05] h-9 gap-2 rounded-lg"
            >
              <FolderOpen size={16} aria-hidden="true" />
              <span className="hidden sm:inline">{t('nav.projects') || 'My Projects'}</span>
            </Button>
            <div className="h-4 w-[1px] bg-white/[0.1] mx-1" aria-hidden="true" />
          </>
        )}

        <UserMenu />

        <LanguageSwitcher variant="dropdown" />
      </div>
    </header>
  );
};

/**
 * Legacy Editor Header - maintains backward compatibility
 * Used in the visualizer/editor view with project-specific controls
 * Requirements: 9.2 - Add ARIA labels for navigation elements
 */
export const EditorHeader: React.FC<LegacyHeaderProps> = ({
  songData,
  contentType,
  appState,
  onDownloadSRT,
  onExportVideo,
}) => {
  const { t, isRTL } = useLanguage();

  if (!songData) return null;

  return (
    <header 
      className="glass-panel rounded-2xl h-16 px-6 flex items-center justify-between transition-all duration-500 hover:shadow-[0_0_30px_rgba(var(--primary),0.1)]"
      role="banner"
      aria-label={t('a11y.mainNav')}
    >
      {/* Project Context */}
      <div className={cn(
        "flex items-center gap-4",
        isRTL && "flex-row-reverse"
      )}>
        <div className="relative group" aria-hidden="true">
          <div className="absolute inset-0 bg-primary/20 blur-lg rounded-lg opacity-0 group-hover:opacity-100 transition-opacity" />
          <div className="relative w-10 h-10 rounded-xl bg-gradient-to-br from-white/[0.08] to-transparent border border-white/[0.05] flex items-center justify-center">
            <Music size={18} className="text-primary" />
          </div>
        </div>
        
        <div className={cn(
          "flex flex-col",
          isRTL && "items-end"
        )}>
          <div className={cn(
            "flex items-center gap-2",
            isRTL && "flex-row-reverse"
          )}>
            <h2 className="font-semibold text-foreground tracking-tight">
              {songData.fileName}
            </h2>
            <span className="px-1.5 py-0.5 rounded-md bg-white/[0.05] text-[10px] font-medium text-muted-foreground uppercase tracking-wider border border-white/[0.05]">
              {contentType}
            </span>
          </div>
          
          {/* Breadcrumb navigation */}
          <nav 
            className={cn(
              "flex items-center gap-1.5 text-xs text-muted-foreground",
              isRTL && "flex-row-reverse"
            )}
            aria-label="Breadcrumb"
          >
            <span className="hover:text-primary transition-colors cursor-pointer">
              {t('nav.home')}
            </span>
            <DirectionalChevron size={12} className="opacity-50" aria-hidden="true" />
            <span className="text-foreground/80" aria-current="page">{t('studio.edit')}</span>
          </nav>
        </div>
      </div>

      {/* Action Island */}
      <div 
        className={cn(
          "flex items-center gap-2",
          isRTL && "flex-row-reverse"
        )}
        role="toolbar"
        aria-label="Editor actions"
      >
        {appState === AppState.READY && (
          <>
            <Button
              onClick={onDownloadSRT}
              variant="ghost"
              size="sm"
              className="text-muted-foreground hover:text-foreground hover:bg-white/[0.05] h-9 gap-2 rounded-lg focus:ring-2 focus:ring-primary/50"
              aria-label={t('common.download')}
            >
              <Download size={16} aria-hidden="true" />
              <span className="hidden sm:inline">{t('common.download')}</span>
            </Button>
            
            <div className="h-4 w-[1px] bg-white/[0.1] mx-1" aria-hidden="true" />
            
            <Button
              onClick={onExportVideo}
              className="bg-primary text-primary-foreground hover:bg-primary/90 shadow-[0_0_20px_rgba(var(--primary),0.3)] hover:shadow-[0_0_30px_rgba(var(--primary),0.5)] h-9 px-4 rounded-lg font-semibold gap-2 transition-all duration-300 hover:scale-105 focus:ring-2 focus:ring-primary/50"
              aria-label={t('studio.export')}
            >
              <Video size={16} aria-hidden="true" />
              {t('studio.export')}
            </Button>
            
            <Button
              variant="ghost"
              size="icon"
              className="text-muted-foreground hover:text-foreground hover:bg-white/[0.05] h-9 w-9 rounded-lg focus:ring-2 focus:ring-primary/50"
              aria-label="Share"
            >
              <Share2 size={16} aria-hidden="true" />
            </Button>
            
            <Button
              variant="ghost"
              size="icon"
              className="text-muted-foreground hover:text-foreground hover:bg-white/[0.05] h-9 w-9 rounded-lg focus:ring-2 focus:ring-primary/50"
              aria-label="More options"
            >
              <MoreVertical size={16} aria-hidden="true" />
            </Button>
          </>
        )}
        
        <div className="h-4 w-[1px] bg-white/[0.1] mx-1" aria-hidden="true" />
        
        <LanguageSwitcher variant="icon" />
      </div>
    </header>
  );
};
</file>

<file path="components/layout/index.ts">
/**
 * Layout components for the LyricLens application.
 * These components provide the structural layout for the app.
 *
 * @example
 * import { AppLayout, Sidebar, AppShell, LanguageSwitcher, DirectionalIcon } from './components/layout';
 */

export { Sidebar, type SidebarProps } from "./Sidebar";
export { Header, EditorHeader, type HeaderProps, type LegacyHeaderProps } from "./Header";
export { AppLayout, type AppLayoutProps } from "./AppLayout";
export { AppShell, type AppShellProps } from "./AppShell";
export { LanguageSwitcher, type LanguageSwitcherProps } from "./LanguageSwitcher";
export {
  DirectionalIcon,
  DirectionalChevronRight,
  DirectionalChevronLeft,
  DirectionalArrowRight,
  DirectionalArrowLeft,
  BackArrow,
  ForwardArrow,
  BackChevron,
  ForwardChevron,
  type DirectionalIconProps,
} from "./DirectionalIcon";
</file>

<file path="components/layout/LanguageSwitcher.tsx">
import React from 'react';
import { Globe } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { useLanguage } from '@/i18n/useLanguage';
import { SupportedLanguage } from '@/i18n/index';
import { cn } from '@/lib/utils';

export interface LanguageSwitcherProps {
  variant?: 'icon' | 'dropdown' | 'toggle';
  className?: string;
}

/**
 * LanguageSwitcher component for toggling between Arabic and English.
 * Supports three variants:
 * - icon: Shows only a globe icon with dropdown
 * - dropdown: Shows current language with dropdown
 * - toggle: Simple toggle button between languages
 * 
 * Requirements: 9.2 - Add ARIA labels for navigation elements
 */
export const LanguageSwitcher: React.FC<LanguageSwitcherProps> = ({
  variant = 'dropdown',
  className,
}) => {
  const { language, setLanguage, t, languageConfig, supportedLanguages, isRTL } = useLanguage();

  const currentConfig = languageConfig[language];

  // Toggle variant - simple button that switches between languages
  if (variant === 'toggle') {
    const nextLanguage: SupportedLanguage = language === 'en' ? 'ar' : 'en';
    const nextConfig = languageConfig[nextLanguage];

    return (
      <Button
        variant="ghost"
        size="sm"
        onClick={() => setLanguage(nextLanguage)}
        className={cn(
          'gap-2 text-muted-foreground hover:text-foreground hover:bg-white/[0.05] focus:ring-2 focus:ring-primary/50',
          className
        )}
        aria-label={t('a11y.languageSwitch')}
      >
        <span className="text-base" aria-hidden="true">{nextConfig.flag}</span>
        <span className="text-sm font-medium">{nextConfig.name}</span>
      </Button>
    );
  }

  // Icon variant - globe icon with dropdown
  if (variant === 'icon') {
    return (
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button
            variant="ghost"
            size="icon"
            className={cn(
              'text-muted-foreground hover:text-foreground hover:bg-white/[0.05] h-9 w-9 rounded-lg focus:ring-2 focus:ring-primary/50',
              className
            )}
            aria-label={t('a11y.languageSwitch')}
            aria-haspopup="menu"
          >
            <Globe size={18} aria-hidden="true" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align={isRTL ? 'start' : 'end'} className="min-w-[140px]" role="menu">
          {supportedLanguages.map((lang) => {
            const config = languageConfig[lang];
            const isActive = language === lang;
            return (
              <DropdownMenuItem
                key={lang}
                onClick={() => setLanguage(lang)}
                className={cn(
                  'gap-2 cursor-pointer',
                  isActive && 'bg-accent'
                )}
                role="menuitemradio"
                aria-checked={isActive}
                aria-current={isActive ? 'true' : undefined}
              >
                <span className="text-base" aria-hidden="true">{config.flag}</span>
                <span>{config.name}</span>
              </DropdownMenuItem>
            );
          })}
        </DropdownMenuContent>
      </DropdownMenu>
    );
  }

  // Default dropdown variant - shows current language with dropdown
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="ghost"
          size="sm"
          className={cn(
            'gap-2 text-muted-foreground hover:text-foreground hover:bg-white/[0.05] h-9 px-3 rounded-lg focus:ring-2 focus:ring-primary/50',
            className
          )}
          aria-label={`${t('a11y.currentLanguage', { language: currentConfig.name })}. ${t('a11y.languageSwitch')}`}
          aria-haspopup="menu"
        >
          <span className="text-base" aria-hidden="true">{currentConfig.flag}</span>
          <span className="text-sm font-medium hidden sm:inline">{currentConfig.name}</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align={isRTL ? 'start' : 'end'} className="min-w-[140px]" role="menu">
        {supportedLanguages.map((lang) => {
          const config = languageConfig[lang];
          const isActive = language === lang;
          return (
            <DropdownMenuItem
              key={lang}
              onClick={() => setLanguage(lang)}
              className={cn(
                'gap-2 cursor-pointer',
                isActive && 'bg-accent'
              )}
              role="menuitemradio"
              aria-checked={isActive}
              aria-current={isActive ? 'true' : undefined}
            >
              <span className="text-base" aria-hidden="true">{config.flag}</span>
              <span>{config.name}</span>
            </DropdownMenuItem>
          );
        })}
      </DropdownMenuContent>
    </DropdownMenu>
  );
};

export default LanguageSwitcher;
</file>

<file path="components/layout/ScreenLayout.tsx">
/**
 * ScreenLayout - Unified screen layout wrapper
 *
 * Provides consistent layout structure for all screens with:
 * - Header integration
 * - Main content area with focus management
 * - Footer area for inputs/actions
 * - Background effects
 */

import React, { useRef, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { cn } from '@/lib/utils';
import { useLanguage } from '@/i18n/useLanguage';
import { AmbientBackground } from '@/components/AmbientBackground';
import { Header } from '@/components/layout/Header';

export interface ScreenLayoutProps {
  /** Screen title for header */
  title: string;
  /** Show back button in header */
  showBackButton?: boolean;
  /** Custom back navigation handler */
  onBack?: () => void;
  /** Header action buttons */
  headerActions?: React.ReactNode;
  /** Main content */
  children: React.ReactNode;
  /** Footer content (e.g., input area) */
  footer?: React.ReactNode;
  /** Additional class names for main content */
  contentClassName?: string;
  /** Whether to show ambient background */
  showBackground?: boolean;
  /** Max width for content area */
  maxWidth?: 'sm' | 'md' | 'lg' | 'xl' | '2xl' | '3xl' | 'full';
  /** Center content vertically */
  centerContent?: boolean;
  /** ARIA label for main content */
  ariaLabel?: string;
}

const maxWidthClasses = {
  sm: 'max-w-sm',
  md: 'max-w-md',
  lg: 'max-w-lg',
  xl: 'max-w-xl',
  '2xl': 'max-w-2xl',
  '3xl': 'max-w-3xl',
  full: 'max-w-full',
};

/**
 * Unified screen layout with header, content, and footer areas
 *
 * @example
 * ```tsx
 * <ScreenLayout
 *   title="Studio"
 *   showBackButton
 *   headerActions={<Button>Export</Button>}
 *   footer={<ChatInput ... />}
 * >
 *   <ChatMessages ... />
 * </ScreenLayout>
 * ```
 */
export function ScreenLayout({
  title,
  showBackButton = false,
  onBack,
  headerActions,
  children,
  footer,
  contentClassName,
  showBackground = true,
  maxWidth = '3xl',
  centerContent = false,
  ariaLabel,
}: ScreenLayoutProps) {
  const { isRTL } = useLanguage();
  const navigate = useNavigate();
  const location = useLocation();
  const mainContentRef = useRef<HTMLElement>(null);

  // Focus main content on navigation (Requirement 9.4)
  useEffect(() => {
    const timer = setTimeout(() => {
      mainContentRef.current?.focus();
    }, 100);
    return () => clearTimeout(timer);
  }, [location.pathname]);

  const handleBack = () => {
    if (onBack) {
      onBack();
    } else {
      navigate('/');
    }
  };

  return (
    <div className={cn('h-screen relative overflow-hidden flex flex-col', isRTL && 'rtl')}>
      {/* Background */}
      {showBackground && <AmbientBackground />}

      {/* Header */}
      <div className="p-4 shrink-0 z-20">
        <Header
          showBackButton={showBackButton}
          onBack={handleBack}
          title={title}
          actions={headerActions}
        />
      </div>

      {/* Main Content */}
      <main
        id="main-content"
        ref={mainContentRef}
        className={cn(
          'flex-1 overflow-hidden flex flex-col',
          centerContent && 'justify-center'
        )}
        tabIndex={-1}
        aria-label={ariaLabel || title}
      >
        <div className={cn("flex-1 overflow-y-auto", contentClassName?.includes('h-full') && 'flex flex-col')}>
          <div
            className={cn(
              'mx-auto',
              maxWidth !== 'full' && 'px-4',
              maxWidthClasses[maxWidth],
              contentClassName
            )}
          >
            {children}
          </div>
        </div>
      </main>

      {/* Footer */}
      {footer && footer}
    </div>
  );
}

export default ScreenLayout;
</file>

<file path="components/layout/Sidebar.tsx">
import React from "react";
import { Music, Settings, Home, FolderOpen, HelpCircle, Bot, Zap, Palette } from "lucide-react";
import { motion } from "framer-motion";
import { useNavigate, useLocation } from "react-router-dom";
import { cn } from "@/lib/utils";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { useLanguage } from "@/i18n/useLanguage";

export interface SidebarProps {
  // No props needed - navigation handled internally
}

interface NavItemProps {
  icon: React.ReactNode;
  label: string;
  onClick?: () => void;
  isActive?: boolean;
  isDisabled?: boolean;
  variant?: "default" | "primary" | "accent";
  isRTL?: boolean;
  t: (key: string) => string; // Add translation function
}

const NavItem = React.memo<NavItemProps>(({
  icon,
  label,
  onClick,
  isActive,
  isDisabled,
  variant = "default",
  isRTL = false,
  t,
}) => {
  const baseStyles = "relative flex items-center justify-center w-10 h-10 rounded-xl cursor-pointer transition-all duration-300 group";
  const disabledStyles = "opacity-40 cursor-not-allowed pointer-events-none";

  const variantStyles = {
    default: cn(
      "text-muted-foreground hover:text-foreground hover:bg-white/[0.08]",
      isActive && "text-primary bg-primary/10 shadow-[0_0_15px_rgba(var(--primary),0.3)]"
    ),
    primary: "bg-gradient-to-br from-primary to-purple-600 text-white shadow-lg shadow-primary/30 hover:shadow-primary/50 hover:scale-110",
    accent: "text-accent-foreground bg-accent/10 border border-accent/20 hover:bg-accent/20 hover:border-accent/40",
  };

  // Handle keyboard activation
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if ((e.key === 'Enter' || e.key === ' ') && !isDisabled) {
      e.preventDefault();
      onClick?.();
    }
  };

  const handleClick = () => {
    if (!isDisabled) {
      onClick?.();
    }
  };

  return (
    <Tooltip delayDuration={0}>
      <TooltipTrigger asChild>
        <motion.div
          role="button"
          tabIndex={isDisabled ? -1 : 0}
          aria-label={label}
          aria-pressed={isActive}
          aria-disabled={isDisabled}
          className={cn(
            baseStyles, 
            variantStyles[variant], 
            isDisabled && disabledStyles,
            // Add visible focus indicator (Addresses Design Review Issue #2)
            "focus-visible:outline-none focus-visible:ring-3 focus-visible:ring-[var(--cinema-spotlight)] focus-visible:ring-offset-2 focus-visible:ring-offset-[var(--cinema-void)]"
          )}
          onClick={handleClick}
          onKeyDown={handleKeyDown}
          whileTap={isDisabled ? undefined : { scale: 0.9 }}
          whileHover={isDisabled ? undefined : { scale: 1.05 }}
        >
          {icon}

          {/* Active Indicator Dot - RTL aware positioning */}
          {isActive && !isDisabled && (
            <motion.div
              layoutId="active-dot"
              aria-hidden="true"
              className={cn(
                "absolute top-1 w-2 h-2 rounded-full bg-primary shadow-[0_0_8px_var(--primary)]",
                isRTL ? "-left-1" : "-right-1"
              )}
            />
          )}
        </motion.div>
      </TooltipTrigger>
      <TooltipContent
        side={isRTL ? "left" : "right"}
        sideOffset={16}
        className="glass-panel border-white/10 text-xs font-medium tracking-wide"
      >
        {isDisabled ? `${label} (${t('common.comingSoon')})` : label}
      </TooltipContent>
    </Tooltip>
  );
});
NavItem.displayName = "NavItem";

// Navigation item configuration interface
interface NavItemConfig {
  icon: React.ComponentType<{ size?: number; strokeWidth?: number }>;
  labelKey: string;
  route?: string;
  variant?: "default" | "primary" | "accent";
  isExact?: boolean;
}

// Active route detection function
function isRouteActive(currentPath: string, itemRoute: string | undefined, isExact: boolean): boolean {
  if (!itemRoute) return false;
  
  if (isExact) {
    return currentPath === itemRoute;
  }
  return currentPath.startsWith(itemRoute);
}

export const Sidebar: React.FC<SidebarProps> = () => {
  const { isRTL, t } = useLanguage();
  const navigate = useNavigate();
  const location = useLocation();

  // Navigation items configuration
  const navItems: NavItemConfig[] = [
    // Main navigation
    { icon: Home, labelKey: 'nav.home', route: '/', variant: 'default', isExact: true },
    { icon: FolderOpen, labelKey: 'nav.projects', route: '/projects', variant: 'default', isExact: true },

    // Creation tools
    { icon: Bot, labelKey: 'nav.studio', route: '/studio', variant: 'primary', isExact: false },
    { icon: Zap, labelKey: 'nav.quickCreate', route: '/visualizer', variant: 'default', isExact: false },
    { icon: Palette, labelKey: 'nav.gradientGenerator', route: '/gradient-generator', variant: 'default', isExact: true },
  ];

  // Bottom actions
  const bottomNavItems: NavItemConfig[] = [
    { icon: HelpCircle, labelKey: 'nav.help', route: undefined }, // disabled
    { icon: Settings, labelKey: 'nav.settings', route: '/settings', variant: 'default', isExact: true },
  ];

  return (
    <TooltipProvider>
      <nav
        className="flex flex-col items-center gap-6 py-2"
        aria-label="Main navigation"
        role="navigation"
      >
        {/* Logo Mark */}
        <div className="mb-2 relative group cursor-pointer" aria-hidden="true">
          <div className="absolute inset-0 bg-primary/40 blur-xl rounded-full opacity-50 group-hover:opacity-100 transition-opacity duration-500" />
          <div className="relative w-10 h-10 rounded-xl bg-gradient-to-br from-primary via-purple-500 to-accent flex items-center justify-center shadow-lg shadow-primary/25">
            <Music className="text-white w-5 h-5" />
          </div>
        </div>

        {/* Main Nav */}
        <div className="flex flex-col gap-3 w-full items-center">
          {navItems.slice(0, 2).map((item) => {
            const Icon = item.icon;
            const isActive = isRouteActive(location.pathname, item.route, item.isExact ?? false);
            const isDisabled = item.route === undefined;

            return (
              <NavItem
                key={item.labelKey}
                icon={<Icon size={20} strokeWidth={1.5} />}
                label={t(item.labelKey)}
                onClick={item.route ? () => navigate(item.route!) : undefined}
                isActive={isActive}
                isDisabled={isDisabled}
                variant={item.variant}
                isRTL={isRTL}
                t={t}
              />
            );
          })}
        </div>

        {/* Separator */}
        <div className="w-8 h-[1px] bg-white/[0.08] rounded-full" role="separator" aria-hidden="true" />

        {/* Creation Tools */}
        <div className="flex flex-col gap-3 w-full items-center">
          {navItems.slice(2).map((item) => {
            const Icon = item.icon;
            const isActive = isRouteActive(location.pathname, item.route, item.isExact ?? false);
            const isDisabled = item.route === undefined;

            return (
              <NavItem
                key={item.labelKey}
                icon={<Icon size={20} strokeWidth={1.5} />}
                label={t(item.labelKey)}
                onClick={item.route ? () => navigate(item.route!) : undefined}
                isActive={isActive}
                isDisabled={isDisabled}
                variant={item.variant}
                isRTL={isRTL}
                t={t}
              />
            );
          })}
        </div>

        {/* Bottom Actions */}
        <div className="mt-auto flex flex-col gap-3 w-full items-center pt-6">
          {bottomNavItems.map((item) => {
            const Icon = item.icon;
            const isActive = isRouteActive(location.pathname, item.route, item.isExact ?? false);
            const isDisabled = item.route === undefined;

            return (
              <NavItem
                key={item.labelKey}
                icon={<Icon size={20} strokeWidth={1.5} />}
                label={t(item.labelKey)}
                onClick={item.route ? () => navigate(item.route!) : undefined}
                isActive={isActive}
                isDisabled={isDisabled}
                variant={item.variant}
                isRTL={isRTL}
                t={t}
              />
            );
          })}
        </div>
      </nav>
    </TooltipProvider>
  );
};
</file>

<file path="components/MusicChatModalV2.tsx">
/**
 * MusicChatModalV2 Component
 * 
 * Enhanced chat interface using MusicProducerAgentV2 with direct Suno API integration.
 * The agent can directly generate music after the conversation.
 */

import { useState, useCallback, useRef, useEffect } from "react";
import {
  Send,
  Sparkles,
  Loader2,
  AlertCircle,
  Play,
  Pause,
  Check,
  Plus,
  MessageSquare,
  Bot,
  User,
  Coins,
} from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Progress } from "@/components/ui/progress";
import { cn } from "@/lib/utils";
import {
  MusicProducerAgentV2,
  createMusicProducerAgentV2,
  type PendingToolCall,
} from "@/services/musicProducerAgentV2";
import { getCredits, getTaskStatus, type SunoGeneratedTrack } from "@/services/sunoService";

interface MusicChatModalV2Props {
  open: boolean;
  onClose: () => void;
  onMusicGenerated?: (track: SunoGeneratedTrack) => void;
  initialPrompt?: string;
}

interface ChatMessage {
  id: string;
  role: "user" | "assistant";
  content: string;
  isGenerating?: boolean;
}

let messageCounter = 0;
const generateMessageId = () => `msg-${Date.now()}-${++messageCounter}`;

type ModalPhase = "chatting" | "confirming" | "generating" | "complete";

export function MusicChatModalV2({
  open,
  onClose,
  onMusicGenerated,
  initialPrompt = "",
}: MusicChatModalV2Props) {
  // Agent instance
  const agentRef = useRef<MusicProducerAgentV2 | null>(null);

  // State
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [inputValue, setInputValue] = useState("");
  const [isThinking, setIsThinking] = useState(false);
  const [phase, setPhase] = useState<ModalPhase>("chatting");
  const [credits, setCredits] = useState<number | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Generation state
  const [taskId, setTaskId] = useState<string | null>(null);
  const [generationProgress, setGenerationProgress] = useState(0);
  const [generatedTracks, setGeneratedTracks] = useState<SunoGeneratedTrack[]>([]);
  const [selectedTrackId, setSelectedTrackId] = useState<string | null>(null);

  // Confirmation state (human-in-the-loop)
  const [pendingAction, setPendingAction] = useState<PendingToolCall | null>(null);

  // Audio playback
  const [playingTrackId, setPlayingTrackId] = useState<string | null>(null);
  const [audioElement, setAudioElement] = useState<HTMLAudioElement | null>(null);

  // Refs
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  // Initialize on open
  useEffect(() => {
    if (open) {
      agentRef.current = createMusicProducerAgentV2({
        onTaskStarted: (id) => {
          setTaskId(id);
          setPhase("generating");
        },
      });

      setMessages([{
        id: generateMessageId(),
        role: "assistant",
        content: "ŸÖÿ±ÿ≠ÿ®ÿßŸã! üéµ I'm your AI music producer. Tell me about the song you want to create - what genre, mood, language, or style are you going for?\n\nI specialize in Arabic/Khaliji music but can create any genre!",
      }]);
      setInputValue(initialPrompt);
      setPhase("chatting");
      setError(null);
      setTaskId(null);
      setGeneratedTracks([]);
      setGenerationProgress(0);

      // Fetch credits
      fetchCredits();
    }
  }, [open, initialPrompt]);

  // Scroll to bottom
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  // Poll for completion when generating
  useEffect(() => {
    if (phase !== "generating" || !taskId) return;

    let cancelled = false;
    const pollInterval = 10000; // 10 seconds between polls
    let elapsed = 0;
    const maxWait = 10 * 60 * 1000; // 10 minutes total

    const poll = async () => {
      if (cancelled) return;

      try {
        // Update progress based on elapsed time
        elapsed += pollInterval;
        const progress = Math.min(90, (elapsed / maxWait) * 100 + 10);
        setGenerationProgress(progress);

        // Check if we've exceeded max wait time
        if (elapsed >= maxWait) {
          throw new Error("Music generation timed out. Please try again.");
        }

        // Use getTaskStatus for individual status checks instead of waitForCompletion
        const result = await getTaskStatus(taskId);

        if (cancelled) return;

        const tracks = result.tracks;
        if (result.status === "SUCCESS" && tracks && tracks.length > 0) {
          const firstTrack = tracks[0];
          if (firstTrack) {
            setGeneratedTracks(tracks);
            setSelectedTrackId(firstTrack.id);
            setGenerationProgress(100);
            setPhase("complete");

            // Add completion message
            setMessages(prev => [...prev, {
              id: generateMessageId(),
              role: "assistant",
              content: `üéâ Your song is ready! I've generated ${tracks.length} variation${tracks.length > 1 ? 's' : ''} for you. Listen and pick your favorite!`,
            }]);
          }
        } else if (result.status === "FAILED") {
          throw new Error(result.errorMessage || "Music generation failed");
        } else {
          // Still PENDING or PROCESSING - continue polling
          console.log(`[MusicChatV2] Status: ${result.status}, elapsed: ${elapsed / 1000}s`);
          setTimeout(poll, pollInterval);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err instanceof Error ? err.message : "Generation failed");
          setPhase("chatting");
        }
      }
    };

    // Start polling after initial delay
    const timer = setTimeout(poll, pollInterval);

    return () => {
      cancelled = true;
      clearTimeout(timer);
    };
  }, [phase, taskId]);

  // Cleanup audio
  useEffect(() => {
    return () => {
      if (audioElement) {
        audioElement.pause();
        audioElement.src = "";
      }
    };
  }, [audioElement]);

  const fetchCredits = async () => {
    try {
      const result = await getCredits();
      if (result.credits >= 0) {
        setCredits(result.credits);
      }
    } catch {
      // Ignore
    }
  };

  const handleSend = useCallback(async () => {
    if (!inputValue.trim() || isThinking || !agentRef.current) return;

    const userMessage = inputValue.trim();
    setInputValue("");
    setError(null);

    // Add user message
    setMessages(prev => [...prev, { id: generateMessageId(), role: "user", content: userMessage }]);
    setIsThinking(true);

    try {
      const response = await agentRef.current.chat(userMessage);

      if (response.type === "error") {
        setError(response.error || response.message);
        setMessages(prev => [...prev, {
          id: generateMessageId(),
          role: "assistant",
          content: response.message
        }]);
      } else if (response.type === "confirmation_required") {
        // Show confirmation UI
        console.log("[MusicChatV2] Received confirmation_required:", {
          message: response.message,
          pendingAction: response.pendingAction,
        });
        setMessages(prev => [...prev, {
          id: generateMessageId(),
          role: "assistant",
          content: response.message
        }]);
        setPendingAction(response.pendingAction || null);
        setPhase("confirming");
        console.log("[MusicChatV2] Set phase to confirming");
      } else if (response.type === "generating") {
        setMessages(prev => [...prev, {
          id: generateMessageId(),
          role: "assistant",
          content: response.message,
          isGenerating: true,
        }]);
        // Phase change handled by callback
      } else {
        setMessages(prev => [...prev, {
          id: generateMessageId(),
          role: "assistant",
          content: response.message
        }]);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Something went wrong");
    } finally {
      setIsThinking(false);
    }
  }, [inputValue, isThinking]);

  const handlePlayTrack = useCallback((track: SunoGeneratedTrack) => {
    if (playingTrackId === track.id) {
      audioElement?.pause();
      setPlayingTrackId(null);
    } else {
      if (audioElement) audioElement.pause();
      const audio = new Audio(track.audio_url);
      audio.onended = () => setPlayingTrackId(null);
      audio.play();
      setAudioElement(audio);
      setPlayingTrackId(track.id);
    }
  }, [playingTrackId, audioElement]);

  const handleAddToTimeline = useCallback(() => {
    const track = generatedTracks.find(t => t.id === selectedTrackId);
    if (track && onMusicGenerated) {
      onMusicGenerated(track);
    }
    onClose();
  }, [generatedTracks, selectedTrackId, onMusicGenerated, onClose]);

  const handleReset = useCallback(() => {
    agentRef.current = createMusicProducerAgentV2();
    setMessages([{
      id: generateMessageId(),
      role: "assistant",
      content: "Let's create something new! üéµ What kind of music would you like?",
    }]);
    setPhase("chatting");
    setTaskId(null);
    setGeneratedTracks([]);
    setPendingAction(null);
    setError(null);
  }, []);

  // Handle user confirming the pending action
  const handleConfirm = useCallback(async () => {
    if (!agentRef.current) return;

    setIsThinking(true);
    setError(null);

    try {
      const response = await agentRef.current.confirmAndExecute();

      if (response.type === "error") {
        setError(response.error || response.message);
        setPhase("chatting");
      } else if (response.type === "generating") {
        setMessages(prev => [...prev, {
          id: generateMessageId(),
          role: "assistant",
          content: response.message,
          isGenerating: true,
        }]);
        // Phase change handled by callback (onTaskStarted)
      }

      setPendingAction(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to confirm");
      setPhase("chatting");
    } finally {
      setIsThinking(false);
    }
  }, []);

  // Handle user cancelling the pending action
  const handleCancelConfirmation = useCallback(async () => {
    if (!agentRef.current) return;

    agentRef.current.cancelPendingAction();
    setPendingAction(null);
    setPhase("chatting");

    // Get the agent to respond to the cancellation
    setIsThinking(true);
    try {
      const response = await agentRef.current.chat("I want to change something before generating.");
      setMessages(prev => [...prev, {
        id: generateMessageId(),
        role: "assistant",
        content: response.message
      }]);
    } catch {
      // Ignore
    } finally {
      setIsThinking(false);
    }
  }, []);

  return (
    <Dialog open={open} onOpenChange={(isOpen) => !isOpen && phase !== "generating" && phase !== "confirming" && onClose()}>
      <DialogContent className="sm:max-w-xl md:max-w-2xl bg-background border-border text-foreground max-h-[90vh] flex flex-col">
        <DialogHeader className="shrink-0">
          <DialogTitle className="flex items-center gap-2 text-xl">
            <MessageSquare className="w-5 h-5 text-cyan-400" />
            AI Music Producer
            {credits !== null && credits >= 0 && (
              <span className={cn(
                "ml-auto text-sm font-normal flex items-center gap-1.5",
                credits < 10 ? "text-amber-500" : "text-muted-foreground"
              )}>
                <Coins className="w-3.5 h-3.5" />
                {credits} credits
              </span>
            )}
          </DialogTitle>
          <DialogDescription>
            Chat with AI to create your perfect song. I'll handle everything from lyrics to generation.
          </DialogDescription>
        </DialogHeader>

        {/* Chat Messages */}
        <div className="flex-1 overflow-y-auto py-4 space-y-4 min-h-[300px] max-h-[400px]">
          {messages.map((msg) => (
            <div
              key={msg.id}
              className={cn("flex gap-3", msg.role === "user" ? "justify-end" : "justify-start")}
            >
              {msg.role === "assistant" && (
                <div className="w-8 h-8 rounded-full bg-cyan-500/10 flex items-center justify-center shrink-0">
                  <Bot className="w-4 h-4 text-cyan-400" />
                </div>
              )}
              <div
                className={cn(
                  "max-w-[80%] rounded-2xl px-4 py-2.5 text-sm whitespace-pre-wrap",
                  msg.role === "user"
                    ? "bg-primary text-primary-foreground rounded-br-md"
                    : "bg-muted rounded-bl-md"
                )}
              >
                {msg.content}
                {msg.isGenerating && (
                  <div className="mt-2 flex items-center gap-2 text-cyan-400">
                    <Loader2 className="w-3 h-3 animate-spin" />
                    <span className="text-xs">Generating...</span>
                  </div>
                )}
              </div>
              {msg.role === "user" && (
                <div className="w-8 h-8 rounded-full bg-muted flex items-center justify-center shrink-0">
                  <User className="w-4 h-4" />
                </div>
              )}
            </div>
          ))}

          {isThinking && (
            <div className="flex gap-3">
              <div className="w-8 h-8 rounded-full bg-cyan-500/10 flex items-center justify-center shrink-0">
                <Bot className="w-4 h-4 text-cyan-400" />
              </div>
              <div className="bg-muted rounded-2xl rounded-bl-md px-4 py-2.5">
                <Loader2 className="w-4 h-4 animate-spin text-cyan-400" />
              </div>
            </div>
          )}

          <div ref={messagesEndRef} />
        </div>

        {/* Error */}
        {error && (
          <div className="bg-destructive/10 border border-destructive/20 rounded-lg p-3 flex items-start gap-2">
            <AlertCircle className="w-4 h-4 text-destructive shrink-0 mt-0.5" />
            <p className="text-sm text-destructive">{error}</p>
          </div>
        )}

        {/* Confirmation UI (Human-in-the-Loop) */}
        {phase === "confirming" && pendingAction && (
          <div className="bg-cyan-500/10 border border-cyan-500/30 rounded-lg p-4 space-y-3">
            <div className="flex items-start gap-3">
              <div className="w-8 h-8 rounded-full bg-cyan-500/20 flex items-center justify-center shrink-0">
                <Sparkles className="w-4 h-4 text-cyan-400" />
              </div>
              <div className="flex-1 min-w-0">
                <p className="text-sm font-medium text-cyan-400 mb-2">Ready to generate your song!</p>
                <div className="bg-background/50 rounded-md p-3 text-sm whitespace-pre-wrap font-mono">
                  {pendingAction.summary}
                </div>
              </div>
            </div>
            <div className="flex gap-2 justify-end">
              <Button
                variant="ghost"
                size="sm"
                onClick={handleCancelConfirmation}
                disabled={isThinking}
              >
                Modify
              </Button>
              <Button
                size="sm"
                onClick={handleConfirm}
                disabled={isThinking}
                className="bg-cyan-500 hover:bg-cyan-600"
              >
                {isThinking ? (
                  <>
                    <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    Starting...
                  </>
                ) : (
                  <>
                    <Check className="w-4 h-4 mr-2" />
                    Generate Now
                  </>
                )}
              </Button>
            </div>
          </div>
        )}

        {/* Generation Progress */}
        {phase === "generating" && (
          <div className="space-y-2 py-2">
            <div className="flex justify-between text-xs">
              <span className="text-cyan-400 font-medium flex items-center gap-2">
                <Sparkles className="w-3 h-3 animate-pulse" />
                Creating your song...
              </span>
              <span className="text-muted-foreground">{Math.round(generationProgress)}%</span>
            </div>
            <Progress value={generationProgress} className="h-2" />
            <p className="text-xs text-muted-foreground text-center">
              This usually takes 2-4 minutes. The AI is composing your music!
            </p>
          </div>
        )}

        {/* Generated Tracks */}
        {phase === "complete" && generatedTracks.length > 0 && (
          <div className="space-y-3 py-2">
            <p className="text-sm font-medium text-muted-foreground">Your Generated Tracks</p>
            <div className="space-y-2">
              {generatedTracks.map((track) => (
                <div
                  key={track.id}
                  className={cn(
                    "flex items-center gap-3 p-3 rounded-lg border transition-all cursor-pointer",
                    selectedTrackId === track.id
                      ? "border-cyan-500 bg-cyan-500/10"
                      : "border-border bg-card hover:border-cyan-500/50"
                  )}
                  onClick={() => setSelectedTrackId(track.id)}
                >
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-10 w-10 shrink-0"
                    onClick={(e) => { e.stopPropagation(); handlePlayTrack(track); }}
                  >
                    {playingTrackId === track.id ? <Pause className="w-5 h-5" /> : <Play className="w-5 h-5" />}
                  </Button>
                  <div className="flex-1 min-w-0">
                    <p className="font-medium truncate">{track.title}</p>
                    <p className="text-xs text-muted-foreground">
                      {track.style && `${track.style} ‚Ä¢ `}
                      {Math.floor(track.duration / 60)}:{String(Math.floor(track.duration % 60)).padStart(2, "0")}
                    </p>
                  </div>
                  {selectedTrackId === track.id && <Check className="w-5 h-5 text-cyan-400 shrink-0" />}
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Input - hidden during confirmation and generation */}
        {(phase === "chatting") && (
          <div className="shrink-0 pt-2 border-t border-border">
            <div className="flex gap-2">
              <Input
                ref={inputRef}
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                placeholder="Describe your music..."
                className="flex-1"
                disabled={isThinking}
                onKeyDown={(e) => e.key === "Enter" && !e.shiftKey && handleSend()}
              />
              <Button onClick={handleSend} disabled={!inputValue.trim() || isThinking} className="bg-cyan-500 hover:bg-cyan-600">
                <Send className="w-4 h-4" />
              </Button>
            </div>
          </div>
        )}

        <DialogFooter className="shrink-0 pt-2">
          {phase === "chatting" && (
            <Button variant="ghost" onClick={onClose}>Cancel</Button>
          )}

          {phase === "confirming" && (
            <Button variant="ghost" onClick={onClose} disabled={isThinking}>Cancel</Button>
          )}

          {phase === "generating" && (
            <Button variant="ghost" disabled>
              <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              Generating...
            </Button>
          )}

          {phase === "complete" && (
            <>
              <Button variant="ghost" onClick={handleReset}>Create Another</Button>
              <Button onClick={handleAddToTimeline} disabled={!selectedTrackId} className="bg-cyan-500 hover:bg-cyan-600">
                <Plus className="w-4 h-4 mr-2" />
                Add to Timeline
              </Button>
            </>
          )}
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

export default MusicChatModalV2;
</file>

<file path="components/MusicGeneratorModal.tsx">
/**
 * MusicGeneratorModal Component
 * 
 * Modal for generating AI music using Suno API.
 * Features topic/prompt input, style selection, vocal mode, and advanced options.
 */

import { useState, useCallback, useEffect } from "react";
import {
  Music,
  Sparkles,
  Mic,
  MicOff,
  Settings2,
  ChevronDown,
  ChevronUp,
  Loader2,
  AlertCircle,
  RefreshCw,
  Play,
  Pause,
  Check,
  Plus,
  Upload,
  Layers,
} from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Progress } from "@/components/ui/progress";
import { cn } from "@/lib/utils";
import type { SunoModel, SunoGeneratedTrack, SunoGenerationConfig, SunoTaskStatus } from "@/services/sunoService";

// Music style/genre options
const MUSIC_STYLES = [
  "Pop",
  "Rock",
  "Electronic",
  "Hip Hop",
  "R&B",
  "Jazz",
  "Classical",
  "Country",
  "Folk",
  "Ambient",
  "Cinematic",
  "Lo-Fi",
  "Indie",
  "Metal",
  "Reggae",
  "Latin",
  "World",
  "Blues",
] as const;

// Suno model versions
const MODEL_VERSIONS: { value: SunoModel; label: string; description: string }[] = [
  { value: "V5", label: "V5 (Latest)", description: "Highest quality, recommended" },
  { value: "V4_5ALL", label: "V4.5 All", description: "All styles supported" },
  { value: "V4_5PLUS", label: "V4.5 Plus", description: "Enhanced quality" },
  { value: "V4_5", label: "V4.5", description: "Standard quality" },
  { value: "V4", label: "V4", description: "Legacy model" },
];

interface MusicGeneratorModalProps {
  open: boolean;
  onClose: () => void;
  onMusicGenerated?: (track: SunoGeneratedTrack) => void;
  initialTopic?: string;
  // Hook integration
  musicState: {
    isGenerating: boolean;
    status: SunoTaskStatus | string | null;
    progress: number;
    generatedTracks: SunoGeneratedTrack[];
    selectedTrackId: string | null;
    lyrics: string | null;
    lyricsTaskId?: string | null;
    credits: number | null;
    error: string | null;
  };
  onGenerateMusic: (config: Partial<SunoGenerationConfig> & { prompt: string }) => Promise<void>;
  onGenerateLyrics: (prompt: string) => Promise<void>;
  onSelectTrack: (trackId: string) => void;
  onAddToTimeline: () => void;
  onRefreshCredits: () => Promise<void>;
  // New props for Extended features (optional)
  onUploadAudio?: (file: File) => Promise<string>;
  onUploadAndCover?: (config: any) => Promise<string>;
  onAddVocals?: (config: any) => Promise<string>;
  onAddInstrumental?: (config: any) => Promise<string>;
  /** Initial mode to start the modal in */
  initialMode?: "generate" | "remix";
}

interface MusicFormState {
  topic: string;
  style: string;
  title: string;
  vocalMode: "vocal-male" | "vocal-female" | "instrumental";
  customLyrics: string;
  useCustomLyrics: boolean;
  // Advanced options
  model: SunoModel;
  styleWeight: number;
  weirdnessConstraint: number;
  negativeTags: string;
}

export function MusicGeneratorModal({
  open,
  onClose,
  onMusicGenerated,
  initialTopic = "",
  musicState,
  onGenerateMusic,
  onGenerateLyrics,
  onSelectTrack,
  onAddToTimeline,
  onRefreshCredits,
  onUploadAudio,
  onUploadAndCover,
  onAddVocals,
  onAddInstrumental,
  initialMode = "generate",
}: MusicGeneratorModalProps) {
  // Mode state - use initialMode prop
  const [mode, setMode] = useState<"generate" | "remix">(initialMode);
  const [uploadedUrl, setUploadedUrl] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [remixAction, setRemixAction] = useState<"cover" | "vocals" | "instrumental">("cover");

  // Form state
  const [formState, setFormState] = useState<MusicFormState>({
    topic: initialTopic,
    style: "Cinematic",
    title: "",
    vocalMode: "vocal-male",
    customLyrics: "",
    useCustomLyrics: false,
    model: "V5",
    styleWeight: 0.65,
    weirdnessConstraint: 0.5,
    negativeTags: "",
  });

  // UI state
  const [showAdvanced, setShowAdvanced] = useState(false);
  const [isGeneratingLyrics, setIsGeneratingLyrics] = useState(false);
  const [playingTrackId, setPlayingTrackId] = useState<string | null>(null);
  const [audioElement, setAudioElement] = useState<HTMLAudioElement | null>(null);

  // Update topic when initialTopic changes
  useEffect(() => {
    if (initialTopic) {
      setFormState(prev => ({ ...prev, topic: initialTopic }));
    }
  }, [initialTopic]);

  // Sync mode when initialMode changes (e.g., when modal opens)
  useEffect(() => {
    setMode(initialMode);
  }, [initialMode, open]);

  // Update lyrics from musicState
  useEffect(() => {
    if (musicState.lyrics && !formState.customLyrics) {
      setFormState(prev => ({ ...prev, customLyrics: musicState.lyrics || "" }));
    }
  }, [musicState.lyrics]);

  // Fetch credits on mount
  useEffect(() => {
    if (open && musicState.credits === null) {
      onRefreshCredits();
    }
  }, [open, musicState.credits, onRefreshCredits]);

  // Cleanup audio on unmount
  useEffect(() => {
    return () => {
      if (audioElement) {
        audioElement.pause();
        audioElement.src = "";
      }
    };
  }, [audioElement]);

  // Handle form field changes
  const updateField = useCallback(<K extends keyof MusicFormState>(
    field: K,
    value: MusicFormState[K]
  ) => {
    setFormState(prev => ({ ...prev, [field]: value }));
  }, []);

  // Handle music generation
  const handleGenerate = useCallback(async () => {
    if (!formState.topic.trim()) return;

    // Use lyrics as prompt when not instrumental and lyrics are provided
    const isInstrumental = formState.vocalMode === "instrumental";
    const hasLyrics = formState.customLyrics.trim().length > 0;

    const config: Partial<SunoGenerationConfig> & { prompt: string } = {
      prompt: (!isInstrumental && hasLyrics)
        ? formState.customLyrics
        : formState.topic,
      model: formState.model,
      style: formState.style,
      styleWeight: formState.styleWeight,
      weirdnessConstraint: formState.weirdnessConstraint,
      instrumental: isInstrumental,
      vocalGender: formState.vocalMode === "vocal-male" ? "m" : formState.vocalMode === "vocal-female" ? "f" : undefined,
      customMode: true, // Always custom when using this advanced modal form
    };

    if (formState.title.trim()) {
      config.title = formState.title;
    }

    if (formState.negativeTags.trim()) {
      config.negativeTags = formState.negativeTags;
    }

    await onGenerateMusic(config);
  }, [formState, onGenerateMusic]);

  // Handle lyrics generation
  const handleGenerateLyrics = useCallback(async () => {
    if (!formState.topic.trim()) return;

    setIsGeneratingLyrics(true);
    try {
      await onGenerateLyrics(formState.topic);
    } finally {
      setIsGeneratingLyrics(false);
    }
  }, [formState.topic, onGenerateLyrics]);

  // Handle file upload
  const handleFileUpload = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setIsUploading(true);
    try {
      if (!onUploadAudio) throw new Error("Audio upload not supported");
      const url = await onUploadAudio(file);
      setUploadedUrl(url);
    } catch (error) {
      console.error("Upload failed", error);
      // Error state handling is implicit via musicState.error usually, 
      // but here we might want local feedback. 
      // Ideally we'd set a local error or reuse the parent's error mechanism if exposed settable.
      // For now just console.
    } finally {
      setIsUploading(false);
    }
  }, [onUploadAudio]);

  // Handle Remix Actions
  const handleRemix = useCallback(async () => {
    if (!uploadedUrl) return;

    if (remixAction === "cover") {
      // Cover requires: uploadUrl, customMode, instrumental, model, callBackUrl
      // If not instrumental: style, prompt (lyrics), title required
      // If instrumental: style, title required
      const isInstrumental = formState.vocalMode === "instrumental";

      if (!onUploadAndCover) throw new Error("Cover generation not supported");
      await onUploadAndCover({
        uploadUrl: uploadedUrl,
        style: formState.style,
        title: formState.title || "Cover",
        instrumental: isInstrumental,
        // prompt is the lyrics when not instrumental
        prompt: isInstrumental ? undefined : formState.customLyrics,
        model: formState.model || "V4_5ALL",
        styleWeight: formState.styleWeight,
        weirdnessConstraint: formState.weirdnessConstraint,
        negativeTags: formState.negativeTags,
        vocalGender: formState.vocalMode === "vocal-male" ? "m" : formState.vocalMode === "vocal-female" ? "f" : undefined,
      });
    } else if (remixAction === "vocals") {
      if (!onAddVocals) throw new Error("Adding vocals not supported");
      await onAddVocals({
        uploadUrl: uploadedUrl,
        prompt: formState.topic || "Add vocals",
        title: formState.title || "With Vocals",
        model: formState.model || "V4_5PLUS",
        style: formState.style,
      });
    } else if (remixAction === "instrumental") {
      if (!onAddInstrumental) throw new Error("Adding instrumental not supported");
      await onAddInstrumental({
        uploadUrl: uploadedUrl,
        prompt: formState.topic || "Instrumental version",
        title: formState.title || "Instrumental",
        model: formState.model || "V4_5PLUS",
        style: formState.style,
      });
    }
  }, [uploadedUrl, remixAction, onUploadAndCover, onAddVocals, onAddInstrumental, formState]);

  // Handle track playback
  const handlePlayTrack = useCallback((track: SunoGeneratedTrack) => {
    if (playingTrackId === track.id) {
      // Pause current track
      audioElement?.pause();
      setPlayingTrackId(null);
    } else {
      // Play new track
      if (audioElement) {
        audioElement.pause();
      }
      const audio = new Audio(track.audio_url);
      audio.onended = () => setPlayingTrackId(null);
      audio.play();
      setAudioElement(audio);
      setPlayingTrackId(track.id);
    }
  }, [playingTrackId, audioElement]);

  // Handle adding track to timeline
  const handleAddToTimeline = useCallback(() => {
    onAddToTimeline();
    const selectedTrack = musicState.generatedTracks.find(
      t => t.id === musicState.selectedTrackId
    );
    if (selectedTrack && onMusicGenerated) {
      onMusicGenerated(selectedTrack);
    }
    onClose();
  }, [onAddToTimeline, musicState.generatedTracks, musicState.selectedTrackId, onMusicGenerated, onClose]);

  // Calculate lyrics stats
  const lyricsStats = {
    chars: formState.customLyrics.length,
    lines: formState.customLyrics.split("\n").filter(l => l.trim()).length,
  };

  const isGenerating = musicState.isGenerating;
  const hasGeneratedTracks = musicState.generatedTracks.length > 0;
  const canGenerate = formState.topic.trim().length > 0 && !isGenerating;

  return (
    <Dialog open={open} onOpenChange={(isOpen) => !isOpen && !isGenerating && onClose()}>
      <DialogContent className="sm:max-w-xl md:max-w-2xl bg-background border-border text-foreground max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2 text-xl">
            <Music className="w-5 h-5 text-primary" />
            Generate AI Music
            {/* Credit Display */}
            {musicState.credits !== null && musicState.credits >= 0 && (
              <span className={cn(
                "ml-auto text-sm font-normal flex items-center gap-1.5",
                musicState.credits < 10 ? "text-amber-500" : "text-muted-foreground"
              )}>
                {musicState.credits < 10 && (
                  <AlertCircle className="w-3.5 h-3.5" />
                )}
                {musicState.credits} credits
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6"
                  onClick={onRefreshCredits}
                >
                  <RefreshCw className="w-3 h-3" />
                </Button>
              </span>
            )}
            {musicState.credits === null && (
              <span className="ml-auto text-sm font-normal text-muted-foreground flex items-center gap-1.5">
                Credits: Unknown
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6"
                  onClick={onRefreshCredits}
                >
                  <RefreshCw className="w-3 h-3" />
                </Button>
              </span>
            )}
          </DialogTitle>
          <DialogDescription className="text-muted-foreground">
            Create custom AI-generated music for your video using Suno.
          </DialogDescription>
        </DialogHeader>

        <div className="py-4 space-y-6">
          {/* Error Display */}
          {musicState.error && (
            <div className="bg-destructive/10 border border-destructive/20 rounded-lg p-4 flex items-start gap-3">
              <AlertCircle className="w-5 h-5 text-destructive shrink-0 mt-0.5" />
              <div className="flex-1">
                <p className="text-sm text-destructive">{musicState.error}</p>
                <Button
                  variant="outline"
                  size="sm"
                  className="mt-2"
                  onClick={handleGenerate}
                  disabled={!canGenerate}
                >
                  Retry
                </Button>
              </div>
            </div>
          )}

          {/* Progress Display */}
          {isGenerating && (
            <div className="space-y-3">
              <div className="flex justify-between text-xs uppercase tracking-wider">
                <span className="text-primary font-medium flex items-center gap-2">
                  <Loader2 className="w-3 h-3 animate-spin" />
                  {musicState.status || "Generating..."}
                </span>
                <span className="text-muted-foreground">
                  {Math.round(musicState.progress)}%
                </span>
              </div>
              <Progress value={musicState.progress} className="h-2" />
              <p className="text-xs text-muted-foreground text-center">
                This may take a few minutes. Please wait...
              </p>
            </div>
          )}

          {/* Generated Tracks Preview */}
          {hasGeneratedTracks && !isGenerating && (
            <div className="space-y-3">
              <Label className="text-muted-foreground">Generated Tracks</Label>
              <div className="space-y-2">
                {musicState.generatedTracks.map((track) => (
                  <div
                    key={track.id}
                    className={cn(
                      "flex items-center gap-3 p-3 rounded-lg border transition-all cursor-pointer",
                      musicState.selectedTrackId === track.id
                        ? "border-primary bg-primary/10"
                        : "border-border bg-card hover:border-primary/50"
                    )}
                    onClick={() => onSelectTrack(track.id)}
                  >
                    <Button
                      variant="ghost"
                      size="icon"
                      className="h-10 w-10 shrink-0"
                      onClick={(e) => {
                        e.stopPropagation();
                        handlePlayTrack(track);
                      }}
                    >
                      {playingTrackId === track.id ? (
                        <Pause className="w-5 h-5" />
                      ) : (
                        <Play className="w-5 h-5" />
                      )}
                    </Button>
                    <div className="flex-1 min-w-0">
                      <p className="font-medium truncate">{track.title}</p>
                      <p className="text-xs text-muted-foreground">
                        {track.style && `${track.style} ‚Ä¢ `}
                        {Math.floor(track.duration / 60)}:{String(Math.floor(track.duration % 60)).padStart(2, "0")}
                      </p>
                    </div>
                    {musicState.selectedTrackId === track.id && (
                      <Check className="w-5 h-5 text-primary shrink-0" />
                    )}
                  </div>
                ))}
              </div>
              <div className="flex gap-2">
                <Button
                  className="flex-1"
                  onClick={handleAddToTimeline}
                  disabled={!musicState.selectedTrackId}
                >
                  <Plus className="w-4 h-4 mr-2" />
                  Add to Timeline
                </Button>
                <Button
                  variant="outline"
                  onClick={handleGenerate}
                  disabled={!canGenerate}
                >
                  <RefreshCw className="w-4 h-4 mr-2" />
                  Regenerate
                </Button>
              </div>
            </div>
          )}

          {/* Mode Switcher */}
          {!hasGeneratedTracks && !isGenerating && (
            <div className="flex bg-muted p-1 rounded-lg mb-4">
              <button
                onClick={() => setMode("generate")}
                className={cn(
                  "flex-1 flex items-center justify-center gap-2 py-2 text-sm font-medium rounded-md transition-all",
                  mode === "generate" ? "bg-background text-foreground shadow-sm" : "text-muted-foreground hover:text-foreground"
                )}
              >
                <Sparkles className="w-4 h-4" />
                Generate New
              </button>
              <button
                onClick={() => setMode("remix")}
                className={cn(
                  "flex-1 flex items-center justify-center gap-2 py-2 text-sm font-medium rounded-md transition-all",
                  mode === "remix" ? "bg-background text-foreground shadow-sm" : "text-muted-foreground hover:text-foreground"
                )}
              >
                <RefreshCw className="w-4 h-4" />
                Upload & Remix
              </button>
            </div>
          )}

          {/* Form Content */}
          {!hasGeneratedTracks && !isGenerating && mode === "generate" && (
            <>
              {/* Topic/Prompt Input */}
              <div className="space-y-2">
                <Label htmlFor="topic" className="text-muted-foreground">
                  Topic / Prompt <span className="text-destructive">*</span>
                </Label>
                <Textarea
                  id="topic"
                  value={formState.topic}
                  onChange={(e) => updateField("topic", e.target.value)}
                  placeholder="Describe the music you want... e.g., 'An upbeat summer anthem about freedom and adventure'"
                  className="min-h-[80px] resize-none"
                />
              </div>

              {/* Style/Genre Selection */}
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label className="text-muted-foreground">Style / Genre</Label>
                  <Select
                    value={formState.style}
                    onValueChange={(value) => updateField("style", value)}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Select style" />
                    </SelectTrigger>
                    <SelectContent>
                      {MUSIC_STYLES.map((style) => (
                        <SelectItem key={style} value={style}>
                          {style}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                {/* Title Input */}
                <div className="space-y-2">
                  <Label htmlFor="title" className="text-muted-foreground">
                    Title (optional)
                  </Label>
                  <Input
                    id="title"
                    value={formState.title}
                    onChange={(e) => updateField("title", e.target.value)}
                    placeholder="Song title..."
                  />
                </div>
              </div>

              {/* Vocal Mode Selection */}
              <div className="space-y-2">
                <Label className="text-muted-foreground">Vocal Mode</Label>
                <div className="grid grid-cols-3 gap-2">
                  {[
                    { id: "vocal-male", label: "Male Vocal", icon: Mic },
                    { id: "vocal-female", label: "Female Vocal", icon: Mic },
                    { id: "instrumental", label: "Instrumental", icon: MicOff },
                  ].map(({ id, label, icon: Icon }) => (
                    <button
                      key={id}
                      onClick={() => updateField("vocalMode", id as MusicFormState["vocalMode"])}
                      className={cn(
                        "flex flex-col items-center gap-1.5 p-3 rounded-lg border transition-all text-sm",
                        formState.vocalMode === id
                          ? "border-primary bg-primary/10 text-primary"
                          : "border-border bg-card text-muted-foreground hover:border-primary/30"
                      )}
                    >
                      <Icon className="w-5 h-5" />
                      <span>{label}</span>
                    </button>
                  ))}
                </div>
              </div>

              {/* Instrumental Toggle */}
              <div className="flex items-center justify-between py-2">
                <Label htmlFor="instrumental-toggle" className="text-muted-foreground cursor-pointer">
                  Instrumental
                </Label>
                <Switch
                  id="instrumental-toggle"
                  checked={formState.vocalMode === "instrumental"}
                  onCheckedChange={(checked) => {
                    if (checked) {
                      updateField("vocalMode", "instrumental");
                    } else {
                      updateField("vocalMode", "vocal-male");
                    }
                  }}
                />
              </div>

              {/* Lyrics Prompt - Shows when NOT instrumental */}
              {formState.vocalMode !== "instrumental" && (
                <div className="space-y-2">
                  <Label htmlFor="lyrics" className="text-muted-foreground">
                    Lyrics (Prompt) <span className="text-destructive">*</span>
                  </Label>
                  <div className="relative">
                    <Textarea
                      id="lyrics"
                      value={formState.customLyrics}
                      onChange={(e) => updateField("customLyrics", e.target.value)}
                      placeholder="Enter your lyrics here...&#10;&#10;[Verse 1]&#10;Your lyrics go here...&#10;&#10;[Chorus]&#10;The catchy part..."
                      className="min-h-[150px] resize-none pb-10"
                    />
                    <div className="absolute bottom-2 left-3 right-3 flex items-center justify-between text-xs text-muted-foreground">
                      <span>{lyricsStats.chars}/3000</span>
                      <Button
                        variant="ghost"
                        size="sm"
                        className="h-6 text-xs"
                        onClick={handleGenerateLyrics}
                        disabled={isGeneratingLyrics || !formState.topic.trim()}
                      >
                        {isGeneratingLyrics ? (
                          <>
                            <Loader2 className="w-3 h-3 mr-1 animate-spin" />
                            Generating...
                          </>
                        ) : (
                          <>
                            <Sparkles className="w-3 h-3 mr-1" />
                            Generate Lyrics
                          </>
                        )}
                      </Button>
                    </div>
                  </div>
                </div>
              )}

              {/* Legacy Custom Lyrics Section - Hidden, keeping for backwards compatibility */}
              {/* Lyrics Section */}
              <div className="space-y-3 pt-2 border-t border-border/50 hidden">
                <div className="flex items-center justify-between">
                  <Label className="text-muted-foreground flex items-center gap-2">
                    Custom Lyrics
                  </Label>
                  <div className="flex items-center gap-2">
                    <span className="text-xs text-muted-foreground">
                      {formState.vocalMode === "instrumental" ? "Disabled for instrumental" : "Use custom lyrics"}
                    </span>
                    <Switch
                      checked={formState.useCustomLyrics}
                      onCheckedChange={(checked) => updateField("useCustomLyrics", checked)}
                      disabled={formState.vocalMode === "instrumental"}
                    />
                  </div>
                </div>

                {formState.useCustomLyrics && formState.vocalMode !== "instrumental" && (
                  <div className="space-y-2">
                    <div className="relative">
                      <Textarea
                        value={formState.customLyrics}
                        onChange={(e) => updateField("customLyrics", e.target.value)}
                        placeholder="Enter your lyrics here..."
                        className="min-h-[120px] resize-none pb-8"
                      />
                      <div className="absolute bottom-2 left-3 right-3 flex items-center justify-between text-xs text-muted-foreground">
                        <span>{lyricsStats.chars} chars ‚Ä¢ {lyricsStats.lines} lines</span>
                        <Button
                          variant="ghost"
                          size="sm"
                          className="h-6 text-xs"
                          onClick={handleGenerateLyrics}
                          disabled={isGeneratingLyrics || !formState.topic.trim()}
                        >
                          {isGeneratingLyrics ? (
                            <>
                              <Loader2 className="w-3 h-3 mr-1 animate-spin" />
                              Generating...
                            </>
                          ) : (
                            <>
                              <Sparkles className="w-3 h-3 mr-1" />
                              Generate Lyrics
                            </>
                          )}
                        </Button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </>
          )}

          {/* Remix / Upload Mode */}
          {!hasGeneratedTracks && !isGenerating && mode === "remix" && (
            <div className="space-y-5 animate-in fade-in cursor-default">

              {/* File Upload Area */}
              <div className="space-y-2">
                <Label className="text-muted-foreground">1. Upload Audio Reference</Label>
                <div className="flex gap-2 items-center">
                  <Button variant="outline" className="relative overflow-hidden" disabled={isUploading}>
                    {isUploading ? <Loader2 className="w-4 h-4 animate-spin mr-2" /> : <Upload className="w-4 h-4 mr-2" />}
                    {uploadedUrl ? "Change File" : "Upload MP3/WAV"}
                    <input
                      type="file"
                      accept="audio/*"
                      className="absolute inset-0 opacity-0 cursor-pointer"
                      onChange={handleFileUpload}
                    />
                  </Button>
                  {uploadedUrl && <span className="text-sm text-green-500 flex items-center gap-1"><Check className="w-3 h-3" /> Upload Complete</span>}
                </div>
                <p className="text-xs text-muted-foreground">Upload a track to cover, remix, or add vocals to. Supported: mp3, wav.</p>
              </div>

              {/* Action Selector */}
              {uploadedUrl && (
                <div className="space-y-2">
                  <Label className="text-muted-foreground">2. Select Action</Label>
                  <div className="grid grid-cols-3 gap-2">
                    {[
                      { id: "cover", label: "Change Style", desc: "Cover/Remix" },
                      { id: "vocals", label: "Add Vocals", desc: "To Instrumental" },
                      { id: "instrumental", label: "Add Backing", desc: "To Vocals" }
                    ].map((act) => (
                      <button
                        key={act.id}
                        onClick={() => setRemixAction(act.id as any)}
                        className={cn(
                          "flex flex-col items-center gap-1 p-3 rounded-lg border transition-all text-sm",
                          remixAction === act.id
                            ? "border-primary bg-primary/10 text-primary"
                            : "border-border bg-card text-muted-foreground hover:border-primary/30"
                        )}
                      >
                        <span className="font-medium">{act.label}</span>
                        <span className="text-[10px] opacity-70">{act.desc}</span>
                      </button>
                    ))}
                  </div>
                </div>
              )}

              {/* Dynamic Configuration based on Action */}
              {uploadedUrl && (
                <div className="space-y-4 pt-2 border-t border-white/5">
                  <Label className="text-muted-foreground">3. Configuration</Label>

                  {remixAction === "cover" && (
                    <div className="space-y-4">
                      {/* Style Selection */}
                      <div className="space-y-1">
                        <Label className="text-xs">Style of Music <span className="text-destructive">*</span></Label>
                        <Textarea
                          value={formState.style}
                          onChange={(e) => updateField("style", e.target.value)}
                          placeholder="Style: Khaleeji Tarab, Emotional, Maqam, Soulful Male Vocal, Acoustic, Qanun, Nay, Kamanja Takasim, Melancholic, Traditional Arabic Percussion, High Quality, Cinematic."
                          className="min-h-[80px] resize-none"
                        />
                        <p className="text-[10px] text-muted-foreground">{formState.style.length}/1000</p>
                      </div>

                      {/* Instrumental Toggle */}
                      <div className="flex items-center justify-between py-2">
                        <Label htmlFor="cover-instrumental" className="text-xs cursor-pointer">
                          Instrumental
                        </Label>
                        <Switch
                          id="cover-instrumental"
                          checked={formState.vocalMode === "instrumental"}
                          onCheckedChange={(checked) => {
                            if (checked) {
                              updateField("vocalMode", "instrumental");
                            } else {
                              updateField("vocalMode", "vocal-male");
                            }
                          }}
                        />
                      </div>

                      {/* Lyrics Prompt - Shows when NOT instrumental */}
                      {formState.vocalMode !== "instrumental" && (
                        <div className="space-y-1">
                          <Label className="text-xs">Lyrics (Prompt) <span className="text-destructive">*</span></Label>
                          <div className="relative">
                            <Textarea
                              value={formState.customLyrics}
                              onChange={(e) => updateField("customLyrics", e.target.value)}
                              placeholder="[Verse 1]&#10;Your lyrics go here...&#10;&#10;[Chorus]&#10;The catchy part..."
                              className="min-h-[150px] resize-none pb-8"
                            />
                            <div className="absolute bottom-2 left-3 right-3 flex items-center justify-between text-xs text-muted-foreground">
                              <span>{formState.customLyrics.length}/5000</span>
                              <Button
                                variant="ghost"
                                size="sm"
                                className="h-6 text-xs"
                                onClick={handleGenerateLyrics}
                                disabled={isGeneratingLyrics || !formState.style.trim()}
                              >
                                {isGeneratingLyrics ? (
                                  <>
                                    <Loader2 className="w-3 h-3 mr-1 animate-spin" />
                                    Generating...
                                  </>
                                ) : (
                                  <>
                                    <Sparkles className="w-3 h-3 mr-1" />
                                    Generate Lyrics
                                  </>
                                )}
                              </Button>
                            </div>
                          </div>
                        </div>
                      )}

                      {/* Title */}
                      <div className="space-y-1">
                        <Label className="text-xs">Title <span className="text-destructive">*</span></Label>
                        <Input
                          value={formState.title}
                          onChange={(e) => updateField("title", e.target.value)}
                          placeholder="Cover Title"
                        />
                        <p className="text-[10px] text-muted-foreground">{formState.title.length}/100</p>
                      </div>
                    </div>
                  )}

                  {(remixAction === "vocals" || remixAction === "instrumental") && (
                    <div className="space-y-1">
                      <Label className="text-xs">
                        {remixAction === "vocals" ? "Vocal Description / Lyrics" : "Instrumental Description"}
                      </Label>
                      <Textarea
                        value={formState.topic}
                        onChange={(e) => updateField("topic", e.target.value)}
                        placeholder={remixAction === "vocals" ? "Describe the vocals or paste lyrics..." : "Describe the backing track style..."}
                      />
                    </div>
                  )}

                  {remixAction !== "cover" && (
                    <div className="space-y-1">
                      <Label className="text-xs">Title (Optional)</Label>
                      <Input value={formState.title} onChange={(e) => updateField("title", e.target.value)} placeholder="Remix Title" />
                    </div>
                  )}
                </div>
              )}
            </div>
          )}

          {/* Advanced Options (Shared) */}
          {!hasGeneratedTracks && !isGenerating && (
            <div className="space-y-3 pt-2 border-t border-border/50">
              {/* ... existing advanced options content ... */}
              {/* I need to make sure I don't break the layout. The original code had the dropdown here. */}
              {/* Since I am replacing the block, I should re-add the advanced options functionality or leave it flexible. 
                    The existing code block I'm replacing ENDS at the advanced options start usually?
                    Let's check the target replacement block. 
                */}
              <button
                onClick={() => setShowAdvanced(!showAdvanced)}
                className="flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors w-full"
              >
                <Settings2 className="w-4 h-4" />
                Advanced Options
                {showAdvanced ? (
                  <ChevronUp className="w-4 h-4 ml-auto" />
                ) : (
                  <ChevronDown className="w-4 h-4 ml-auto" />
                )}
              </button>

              {showAdvanced && (
                <div className="space-y-4 pl-6 animate-in slide-in-from-top-2">
                  {/* Model Version */}
                  <div className="space-y-2">
                    <Label className="text-muted-foreground text-xs uppercase">Model Version</Label>
                    <Select
                      value={formState.model}
                      onValueChange={(value) => updateField("model", value as SunoModel)}
                    >
                      <SelectTrigger className="h-9">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        {MODEL_VERSIONS.map((model) => (
                          <SelectItem key={model.value} value={model.value}>
                            <div className="flex flex-col">
                              <span>{model.label}</span>
                              <span className="text-xs text-muted-foreground">{model.description}</span>
                            </div>
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>

                  {/* Style Weight */}
                  <div className="space-y-2">
                    <div className="flex justify-between">
                      <Label className="text-muted-foreground text-xs uppercase">Style Weight</Label>
                      <span className="text-xs font-mono">{formState.styleWeight.toFixed(2)}</span>
                    </div>
                    <Slider
                      min={0}
                      max={1}
                      step={0.05}
                      value={[formState.styleWeight]}
                      onValueChange={([val]) => val !== undefined && updateField("styleWeight", val)}
                    />
                    <p className="text-[10px] text-muted-foreground">
                      How strongly the style influences the generation
                    </p>
                  </div>

                  {/* Weirdness Constraint */}
                  <div className="space-y-2">
                    <div className="flex justify-between">
                      <Label className="text-muted-foreground text-xs uppercase">Creativity</Label>
                      <span className="text-xs font-mono">{formState.weirdnessConstraint.toFixed(2)}</span>
                    </div>
                    <Slider
                      min={0}
                      max={1}
                      step={0.05}
                      value={[formState.weirdnessConstraint]}
                      onValueChange={([val]) => val !== undefined && updateField("weirdnessConstraint", val)}
                    />
                    <p className="text-[10px] text-muted-foreground">
                      Higher values produce more creative/experimental results
                    </p>
                  </div>

                  {/* Negative Tags */}
                  <div className="space-y-2">
                    <Label className="text-muted-foreground text-xs uppercase">Negative Tags</Label>
                    <Input
                      value={formState.negativeTags}
                      onChange={(e) => updateField("negativeTags", e.target.value)}
                      placeholder="e.g., Heavy Metal, Screaming, Distortion"
                      className="h-9"
                    />
                    <p className="text-[10px] text-muted-foreground">
                      Comma-separated styles to exclude from generation
                    </p>
                  </div>
                </div>
              )}
            </div>
          )}
        </div>

        <DialogFooter>
          <Button
            variant="ghost"
            onClick={onClose}
            disabled={isGenerating}
          >
            Cancel
          </Button>
          {!hasGeneratedTracks && (
            <Button
              onClick={mode === "generate" ? handleGenerate : handleRemix}
              disabled={mode === "generate" ? !canGenerate : (!uploadedUrl || isUploading)}
              className="bg-primary hover:bg-primary/90"
            >
              {isGenerating || isUploading ? (
                <>
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                  Processing...
                </>
              ) : (
                <>
                  <Sparkles className="w-4 h-4 mr-2" />
                  {mode === "generate" ? "Generate Music" : `Create ${remixAction === "cover" ? "Cover" : remixAction === "vocals" ? "Vocals" : "Instrumental"}`}
                </>
              )}
            </Button>
          )}
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

export default MusicGeneratorModal;
</file>

<file path="components/PipelineProgress.test.ts">
/**
 * PipelineProgress Unit Tests
 *
 * Feature: multi-format-pipeline
 *
 * Tests progress display, concurrent task tracking, cancellation flow,
 * and estimated time formatting.
 *
 * Validates: Requirements 16.1, 16.2, 16.3, 16.4
 */

import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import type { ExecutionProgress } from '@/services/parallelExecutionEngine';
import type { PipelineTask } from './PipelineProgress';

// ============================================================================
// Helpers (testing the logic, not the React rendering)
// ============================================================================

function computeOverallProgress(progress: ExecutionProgress): number {
  if (progress.totalTasks === 0) return 0;
  return Math.round(
    ((progress.completedTasks + progress.failedTasks) / progress.totalTasks) * 100,
  );
}

function formatTimeRemaining(ms: number): string {
  if (ms <= 0) return '';
  const seconds = Math.ceil(ms / 1000);
  if (seconds < 60) return `${seconds}s remaining`;
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds}s remaining`;
}

// ============================================================================
// Arbitraries
// ============================================================================

const arbTaskStatus = fc.constantFrom<PipelineTask['status']>(
  'queued',
  'in-progress',
  'completed',
  'failed',
  'cancelled',
);

const arbTaskType = fc.constantFrom<PipelineTask['type']>(
  'research',
  'script',
  'visual',
  'audio',
  'assembly',
);

const arbPipelineTask: fc.Arbitrary<PipelineTask> = fc.record({
  id: fc.uuid(),
  name: fc.string({ minLength: 1, maxLength: 30 }),
  type: arbTaskType,
  status: arbTaskStatus,
  progress: fc.option(fc.integer({ min: 0, max: 100 }), { nil: undefined }),
});

/** Generate a valid ExecutionProgress where totals are consistent */
function arbExecutionProgress(): fc.Arbitrary<ExecutionProgress> {
  return fc
    .record({
      executionId: fc.uuid(),
      completedTasks: fc.integer({ min: 0, max: 50 }),
      failedTasks: fc.integer({ min: 0, max: 10 }),
      inProgressTasks: fc.integer({ min: 0, max: 5 }),
      queuedTasks: fc.integer({ min: 0, max: 50 }),
      estimatedTimeRemaining: fc.integer({ min: 0, max: 600_000 }),
    })
    .map((r) => ({
      ...r,
      totalTasks:
        r.completedTasks + r.failedTasks + r.inProgressTasks + r.queuedTasks,
    }));
}

// ============================================================================
// Tests: Progress Calculation (Req 16.1)
// ============================================================================

describe('Feature: multi-format-pipeline, Pipeline Progress Calculation', () => {
  it('overall progress is 0 when no tasks exist', () => {
    const progress: ExecutionProgress = {
      executionId: 'test',
      totalTasks: 0,
      completedTasks: 0,
      failedTasks: 0,
      inProgressTasks: 0,
      queuedTasks: 0,
      estimatedTimeRemaining: 0,
    };
    expect(computeOverallProgress(progress)).toBe(0);
  });

  it('overall progress is 100 when all tasks are completed', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 1, max: 100 }),
        (total) => {
          const progress: ExecutionProgress = {
            executionId: 'test',
            totalTasks: total,
            completedTasks: total,
            failedTasks: 0,
            inProgressTasks: 0,
            queuedTasks: 0,
            estimatedTimeRemaining: 0,
          };
          expect(computeOverallProgress(progress)).toBe(100);
        },
      ),
      { numRuns: 100 },
    );
  });

  it('overall progress is between 0 and 100 for any valid state', () => {
    fc.assert(
      fc.property(arbExecutionProgress(), (progress) => {
        const overall = computeOverallProgress(progress);
        expect(overall).toBeGreaterThanOrEqual(0);
        expect(overall).toBeLessThanOrEqual(100);
      }),
      { numRuns: 100 },
    );
  });

  it('totalTasks always equals sum of task states (Property 4)', () => {
    fc.assert(
      fc.property(arbExecutionProgress(), (progress) => {
        expect(progress.totalTasks).toBe(
          progress.completedTasks +
            progress.failedTasks +
            progress.inProgressTasks +
            progress.queuedTasks,
        );
      }),
      { numRuns: 100 },
    );
  });
});

// ============================================================================
// Tests: Concurrent Task Display (Req 16.2)
// ============================================================================

describe('Feature: multi-format-pipeline, Concurrent Task Display', () => {
  it('can categorize tasks by status', () => {
    fc.assert(
      fc.property(
        fc.array(arbPipelineTask, { minLength: 0, maxLength: 20 }),
        (tasks) => {
          const inProgress = tasks.filter((t) => t.status === 'in-progress');
          const completed = tasks.filter((t) => t.status === 'completed');
          const failed = tasks.filter((t) => t.status === 'failed');
          const queued = tasks.filter((t) => t.status === 'queued');
          const cancelled = tasks.filter((t) => t.status === 'cancelled');

          // All tasks are accounted for
          expect(
            inProgress.length +
              completed.length +
              failed.length +
              queued.length +
              cancelled.length,
          ).toBe(tasks.length);
        },
      ),
      { numRuns: 100 },
    );
  });
});

// ============================================================================
// Tests: Estimated Time (Req 16.5)
// ============================================================================

describe('Feature: multi-format-pipeline, Time Remaining Formatting', () => {
  it('returns empty string for zero or negative time', () => {
    expect(formatTimeRemaining(0)).toBe('');
    expect(formatTimeRemaining(-1000)).toBe('');
  });

  it('formats seconds-only values correctly', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 1, max: 59_000 }),
        (ms) => {
          const result = formatTimeRemaining(ms);
          expect(result).toContain('remaining');
          if (ms < 60_000) {
            expect(result).toContain('s remaining');
          }
        },
      ),
      { numRuns: 50 },
    );
  });

  it('formats minutes and seconds for larger values', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 60_000, max: 600_000 }),
        (ms) => {
          const result = formatTimeRemaining(ms);
          expect(result).toContain('m');
          expect(result).toContain('remaining');
        },
      ),
      { numRuns: 50 },
    );
  });
});

// ============================================================================
// Tests: Cancellation (Req 16.3, 16.4)
// ============================================================================

describe('Feature: multi-format-pipeline, Cancellation Flow', () => {
  it('cancel requires confirmation (two-step)', () => {
    // Simulates the cancel state machine
    let showCancelConfirm = false;
    let cancelled = false;

    const handleCancel = () => {
      if (showCancelConfirm) {
        cancelled = true;
        showCancelConfirm = false;
      } else {
        showCancelConfirm = true;
      }
    };

    // First click: show confirmation
    handleCancel();
    expect(showCancelConfirm).toBe(true);
    expect(cancelled).toBe(false);

    // Second click: actually cancel
    handleCancel();
    expect(cancelled).toBe(true);
    expect(showCancelConfirm).toBe(false);
  });

  it('cancel confirmation auto-dismisses (conceptual)', () => {
    // The component uses a 5-second timeout to dismiss the confirmation.
    // We verify the state machine resets correctly.
    let showCancelConfirm = false;

    // First click
    showCancelConfirm = true;
    expect(showCancelConfirm).toBe(true);

    // Simulate timeout dismiss
    showCancelConfirm = false;
    expect(showCancelConfirm).toBe(false);

    // Should require two clicks again
    showCancelConfirm = true;
    expect(showCancelConfirm).toBe(true);
  });
});
</file>

<file path="components/PipelineProgress.tsx">
/**
 * Pipeline Progress Component
 *
 * Displays real-time progress for multi-format pipeline execution.
 * Shows concurrent task progress, estimated time remaining, and cancellation UI.
 *
 * Requirements: 16.1, 16.2, 16.3, 16.4, 16.5
 */

import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Loader2,
  Check,
  X,
  AlertTriangle,
  Clock,
  Layers,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import type { ExecutionProgress } from '@/services/parallelExecutionEngine';

export interface PipelineTask {
  id: string;
  name: string;
  type: 'research' | 'script' | 'visual' | 'audio' | 'assembly';
  status: 'queued' | 'in-progress' | 'completed' | 'failed' | 'cancelled';
  progress?: number; // 0-100 for individual task
}

export interface PipelineProgressProps {
  /** Current execution progress from the parallel engine */
  executionProgress: ExecutionProgress | null;
  /** Individual task details for concurrent display */
  tasks: PipelineTask[];
  /** Current phase name */
  currentPhase: string;
  /** Whether the pipeline is actively running */
  isRunning: boolean;
  /** Called when user clicks cancel */
  onCancel: () => void;
  /** Whether cancellation is in progress */
  isCancelling?: boolean;
  /** When true, only renders the task list and summary stats (no header or progress bar) */
  summaryOnly?: boolean;
  className?: string;
}

const TASK_TYPE_COLORS: Record<PipelineTask['type'], string> = {
  research: 'text-purple-400',
  script: 'text-cyan-400',
  visual: 'text-amber-400',
  audio: 'text-green-400',
  assembly: 'text-blue-400',
};

const TASK_TYPE_BG: Record<PipelineTask['type'], string> = {
  research: 'bg-purple-500/10',
  script: 'bg-cyan-500/10',
  visual: 'bg-amber-500/10',
  audio: 'bg-green-500/10',
  assembly: 'bg-blue-500/10',
};

function formatTimeRemaining(ms: number): string {
  if (ms <= 0) return '';
  const seconds = Math.ceil(ms / 1000);
  if (seconds < 60) return `${seconds}s remaining`;
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds}s remaining`;
}

export function PipelineProgress({
  executionProgress,
  tasks,
  currentPhase,
  isRunning,
  onCancel,
  isCancelling = false,
  summaryOnly = false,
  className,
}: PipelineProgressProps) {
  const [showCancelConfirm, setShowCancelConfirm] = useState(false);

  const overallProgress = executionProgress
    ? executionProgress.totalTasks > 0
      ? Math.round(
          ((executionProgress.completedTasks + executionProgress.failedTasks) /
            executionProgress.totalTasks) *
            100,
        )
      : 0
    : 0;

  const estimatedTime = executionProgress?.estimatedTimeRemaining ?? 0;

  const handleCancel = useCallback(() => {
    if (showCancelConfirm) {
      onCancel();
      setShowCancelConfirm(false);
    } else {
      setShowCancelConfirm(true);
    }
  }, [showCancelConfirm, onCancel]);

  // Auto-dismiss cancel confirmation after 5 seconds
  useEffect(() => {
    if (!showCancelConfirm) return;
    const timer = setTimeout(() => setShowCancelConfirm(false), 5000);
    return () => clearTimeout(timer);
  }, [showCancelConfirm]);

  const inProgressTasks = tasks.filter((t) => t.status === 'in-progress');
  const completedTasks = tasks.filter((t) => t.status === 'completed');
  const failedTasks = tasks.filter((t) => t.status === 'failed');

  return (
    <div
      className={cn('w-full max-w-2xl mx-auto', className)}
      role="status"
      aria-live="polite"
      aria-label={`Pipeline progress: ${overallProgress}% complete`}
    >
      {/* Header */}
      {!summaryOnly && (
        <div className="flex items-center justify-between mb-6">
          <div>
            <h2 className="text-lg font-medium text-zinc-100">
              {currentPhase || 'Pipeline'}
            </h2>
            <div className="flex items-center gap-3 mt-1">
              <span className="font-mono text-xs text-zinc-500">
                {executionProgress
                  ? `${executionProgress.completedTasks}/${executionProgress.totalTasks} tasks`
                  : 'Initializing...'}
              </span>
              {estimatedTime > 0 && (
                <span className="flex items-center gap-1 font-mono text-xs text-zinc-600">
                  <Clock className="w-3 h-3" />
                  {formatTimeRemaining(estimatedTime)}
                </span>
              )}
            </div>
          </div>

          {/* Cancel button */}
          {isRunning && (
            <div className="relative">
              <button
                type="button"
                onClick={handleCancel}
                disabled={isCancelling}
                className={cn(
                  'flex items-center gap-2 px-3 py-1.5 rounded-sm border text-xs font-mono transition-colors duration-200',
                  'disabled:opacity-50 disabled:cursor-not-allowed',
                  showCancelConfirm
                    ? 'bg-red-500/10 border-red-500/50 text-red-400'
                    : 'border-zinc-700 text-zinc-400 hover:border-zinc-500 hover:text-zinc-200',
                )}
              >
                {isCancelling ? (
                  <>
                    <Loader2 className="w-3 h-3 animate-spin" />
                    <span>Cancelling...</span>
                  </>
                ) : showCancelConfirm ? (
                  <>
                    <AlertTriangle className="w-3 h-3" />
                    <span>Confirm cancel?</span>
                  </>
                ) : (
                  <>
                    <X className="w-3 h-3" />
                    <span>Cancel</span>
                  </>
                )}
              </button>
            </div>
          )}
        </div>
      )}

      {/* Overall Progress Bar */}
      {!summaryOnly && (
        <div className="mb-6">
          <div className="flex justify-between text-xs mb-1.5">
            <span className="font-mono text-zinc-500">Overall</span>
            <span className="font-mono text-zinc-400">{overallProgress}%</span>
          </div>
          <div
            className="h-1.5 bg-zinc-900 rounded-sm overflow-hidden"
            role="progressbar"
            aria-valuenow={overallProgress}
            aria-valuemin={0}
            aria-valuemax={100}
          >
            <motion.div
              className="h-full bg-blue-500 rounded-sm"
              initial={{ width: 0 }}
              animate={{ width: `${overallProgress}%` }}
              transition={{ duration: 0.3, ease: 'easeOut' }}
            />
          </div>
        </div>
      )}

      {/* Concurrent Task List */}
      {tasks.length > 0 && (
        <div className="space-y-2">
          <div className="flex items-center gap-2 mb-3">
            <Layers className="w-3.5 h-3.5 text-zinc-500" />
            <span className="font-mono text-[11px] font-medium tracking-[0.15em] uppercase text-zinc-500">
              Tasks
            </span>
          </div>

          <div className="space-y-1.5">
            {tasks.map((task) => (
              <motion.div
                key={task.id}
                layout
                initial={{ opacity: 0, y: 4 }}
                animate={{ opacity: 1, y: 0 }}
                className={cn(
                  'flex items-center gap-3 px-3 py-2 rounded-sm border',
                  task.status === 'in-progress'
                    ? 'border-zinc-700 bg-zinc-900/80'
                    : task.status === 'completed'
                      ? 'border-zinc-800 bg-zinc-900/40'
                      : task.status === 'failed'
                        ? 'border-red-900/50 bg-red-950/20'
                        : 'border-zinc-800/50 bg-zinc-950/50',
                )}
              >
                {/* Status icon */}
                <div className="shrink-0">
                  {task.status === 'in-progress' ? (
                    <Loader2
                      className={cn(
                        'w-3.5 h-3.5 animate-spin',
                        TASK_TYPE_COLORS[task.type],
                      )}
                    />
                  ) : task.status === 'completed' ? (
                    <Check className="w-3.5 h-3.5 text-emerald-400" />
                  ) : task.status === 'failed' ? (
                    <X className="w-3.5 h-3.5 text-red-400" />
                  ) : task.status === 'cancelled' ? (
                    <X className="w-3.5 h-3.5 text-zinc-600" />
                  ) : (
                    <div className="w-3.5 h-3.5 rounded-full border border-zinc-700" />
                  )}
                </div>

                {/* Task info */}
                <div className="flex-1 min-w-0">
                  <div className="flex items-center gap-2">
                    <span
                      className={cn(
                        'text-[13px] font-medium truncate',
                        task.status === 'completed'
                          ? 'text-zinc-400'
                          : task.status === 'failed'
                            ? 'text-red-400'
                            : task.status === 'in-progress'
                              ? 'text-zinc-200'
                              : 'text-zinc-600',
                      )}
                    >
                      {task.name}
                    </span>
                    <span
                      className={cn(
                        'text-[10px] font-mono px-1.5 py-0.5 rounded-sm',
                        TASK_TYPE_BG[task.type],
                        TASK_TYPE_COLORS[task.type],
                      )}
                    >
                      {task.type}
                    </span>
                  </div>
                </div>

                {/* Task progress */}
                {task.status === 'in-progress' && task.progress != null && (
                  <span className="font-mono text-[10px] text-zinc-500 shrink-0">
                    {task.progress}%
                  </span>
                )}
              </motion.div>
            ))}
          </div>
        </div>
      )}

      {/* Summary stats */}
      {(completedTasks.length > 0 || failedTasks.length > 0) && (
        <div className="flex items-center gap-4 mt-4 pt-4 border-t border-zinc-800">
          {completedTasks.length > 0 && (
            <span className="flex items-center gap-1.5 text-xs font-mono text-emerald-400">
              <Check className="w-3 h-3" />
              {completedTasks.length} completed
            </span>
          )}
          {inProgressTasks.length > 0 && (
            <span className="flex items-center gap-1.5 text-xs font-mono text-blue-400">
              <Loader2 className="w-3 h-3 animate-spin" />
              {inProgressTasks.length} running
            </span>
          )}
          {failedTasks.length > 0 && (
            <span className="flex items-center gap-1.5 text-xs font-mono text-red-400">
              <X className="w-3 h-3" />
              {failedTasks.length} failed
            </span>
          )}
        </div>
      )}
    </div>
  );
}

export default PipelineProgress;
</file>

<file path="components/projects/ProjectCard.tsx">
/**
 * Project Card Component
 *
 * Displays a project with thumbnail, title, metadata, and quick actions.
 * Uses the cinematic design system tokens for consistent visual language.
 */

import React from 'react';
import { motion } from 'framer-motion';
import {
  Video,
  Music,
  AudioWaveform,
  MoreVertical,
  Trash2,
  Star,
  Edit3,
  Download,
  Clock,
  Image as ImageIcon,
  Mic,
  Film,
} from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { cn } from '@/lib/utils';
import { useLanguage } from '@/i18n/useLanguage';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import type { Project, ProjectType } from '@/services/projectService';

interface ProjectCardProps {
  project: Project;
  onDelete: (projectId: string) => void;
  onToggleFavorite: (projectId: string) => void;
  onExport?: (projectId: string) => void;
}

// Type-to-icon mapping
const TYPE_ICONS: Record<ProjectType, typeof Video> = {
  production: Video,
  story: Film,
  visualizer: AudioWaveform,
};

// Type-to-gradient mapping using design tokens
const TYPE_GRADIENTS: Record<ProjectType, string> = {
  production: 'from-primary/60 to-primary/20',
  story: 'from-accent/60 to-accent/20',
  visualizer: 'from-ring/60 to-ring/20',
};

// Type-to-accent color for badges
const TYPE_ACCENT: Record<ProjectType, string> = {
  production: 'text-primary bg-primary/10 border-primary/20',
  story: 'text-accent bg-accent/10 border-accent/20',
  visualizer: 'text-ring bg-ring/10 border-ring/20',
};

// Type-to-route mapping
const TYPE_ROUTES: Record<ProjectType, string> = {
  production: '/studio?mode=video',
  story: '/studio?mode=story',
  visualizer: '/visualizer',
};

function formatDate(date: Date): string {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

  if (diffDays === 0) {
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    if (diffHours === 0) {
      const diffMins = Math.floor(diffMs / (1000 * 60));
      return diffMins <= 1 ? 'Just now' : `${diffMins}m ago`;
    }
    return `${diffHours}h ago`;
  }

  if (diffDays === 1) return 'Yesterday';
  if (diffDays < 7) return `${diffDays}d ago`;

  return date.toLocaleDateString(undefined, {
    month: 'short',
    day: 'numeric',
    year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined,
  });
}

function formatDuration(seconds: number | undefined): string {
  if (!seconds) return '';
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

export function ProjectCard({
  project,
  onDelete,
  onToggleFavorite,
  onExport,
}: ProjectCardProps) {
  const navigate = useNavigate();
  const { t, isRTL } = useLanguage();

  const Icon = TYPE_ICONS[project.type];
  const gradientClass = TYPE_GRADIENTS[project.type];
  const accentClass = TYPE_ACCENT[project.type];

  const handleOpen = () => {
    const route = TYPE_ROUTES[project.type];
    // Append project ID to route
    const separator = route.includes('?') ? '&' : '?';
    navigate(`${route}${separator}projectId=${project.id}`);
  };

  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (window.confirm(t('projects.confirmDelete') || 'Delete this project?')) {
      onDelete(project.id);
    }
  };

  const handleToggleFavorite = (e: React.MouseEvent) => {
    e.stopPropagation();
    onToggleFavorite(project.id);
  };

  const handleExport = (e: React.MouseEvent) => {
    e.stopPropagation();
    onExport?.(project.id);
  };

  return (
    <motion.div
      layout
      initial={{ opacity: 0, scale: 0.95 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.95 }}
      whileHover={{ scale: 1.02, y: -4 }}
      whileTap={{ scale: 0.98 }}
      onClick={handleOpen}
      className={cn(
        'group relative cursor-pointer rounded-xl overflow-hidden',
        'bg-card hover:bg-card/80 border border-border hover:border-primary/30',
        'transition-all duration-300',
        'focus-within:ring-2 focus-within:ring-primary/50',
        'shadow-lg shadow-black/20 hover:shadow-xl hover:shadow-primary/5',
        isRTL && 'text-right'
      )}
    >
      {/* Hover glow effect */}
      <div className="absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-500 pointer-events-none">
        <div
          className="absolute top-0 left-1/2 -translate-x-1/2 w-[80%] h-[1px]"
          style={{
            background: 'linear-gradient(90deg, transparent, oklch(0.70 0.15 190 / 0.4), transparent)',
          }}
        />
      </div>

      {/* Thumbnail Area */}
      <div className="relative aspect-video bg-gradient-to-br from-secondary to-muted overflow-hidden">
        {project.thumbnailUrl ? (
          <img
            src={project.thumbnailUrl}
            alt={project.title}
            className="w-full h-full object-cover"
          />
        ) : (
          <div
            className={cn(
              'w-full h-full flex items-center justify-center bg-gradient-to-br',
              gradientClass
            )}
          >
            <Icon className="w-12 h-12 text-foreground/30" />
          </div>
        )}

        {/* Duration Badge */}
        {project.duration && (
          <div className="absolute bottom-2 right-2 px-2 py-1 rounded-md bg-black/70 backdrop-blur-sm text-xs text-foreground font-code">
            {formatDuration(project.duration)}
          </div>
        )}

        {/* Favorite Star */}
        {project.isFavorite && (
          <div className="absolute top-2 right-2">
            <Star className="w-5 h-5 text-accent fill-accent drop-shadow-lg" />
          </div>
        )}

        {/* Type Badge */}
        <div
          className={cn(
            'absolute top-2 left-2 px-2.5 py-1 rounded-full text-[10px] font-code font-medium uppercase tracking-wider',
            'border backdrop-blur-sm capitalize',
            accentClass
          )}
        >
          {project.type}
        </div>
      </div>

      {/* Content Area */}
      <div className="p-4">
        {/* Title */}
        <h3 className="font-editorial font-semibold text-foreground truncate mb-1">{project.title}</h3>

        {/* Topic/Description */}
        {project.topic && (
          <p className="text-sm text-muted-foreground truncate mb-2.5">{project.topic}</p>
        )}

        {/* Metadata Row */}
        <div
          className={cn(
            'flex items-center gap-3 text-xs text-muted-foreground',
            isRTL && 'flex-row-reverse'
          )}
        >
          {/* Last Updated */}
          <span className="flex items-center gap-1 font-code">
            <Clock className="w-3 h-3" />
            {formatDate(project.updatedAt)}
          </span>

          {/* Progress Indicators */}
          <div className="flex items-center gap-1.5">
            {project.hasVisuals && (
              <span title="Has visuals"><ImageIcon className="w-3 h-3 text-primary/70" /></span>
            )}
            {project.hasNarration && (
              <span title="Has narration"><Mic className="w-3 h-3 text-ring/70" /></span>
            )}
            {project.hasMusic && (
              <span title="Has music"><Music className="w-3 h-3 text-accent/70" /></span>
            )}
            {project.hasExport && (
              <span title="Has export"><Download className="w-3 h-3 text-primary/70" /></span>
            )}
          </div>
        </div>

        {/* Status Badge */}
        {project.status !== 'draft' && (
          <div className="mt-2.5">
            <span
              className={cn(
                'px-2 py-0.5 rounded-full text-xs font-code',
                project.status === 'completed' && 'bg-primary/15 text-primary',
                project.status === 'in_progress' && 'bg-ring/15 text-ring',
                project.status === 'archived' && 'bg-muted text-muted-foreground'
              )}
            >
              {project.status.replace('_', ' ')}
            </span>
          </div>
        )}
      </div>

      {/* Actions Menu */}
      <div
        className={cn(
          'absolute top-2 opacity-0 group-hover:opacity-100 transition-opacity',
          isRTL ? 'left-2' : 'right-2'
        )}
        style={{ top: 'calc(100% - 40px)' }}
      >
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <button
              onClick={(e) => e.stopPropagation()}
              className="p-1.5 rounded-lg bg-black/50 hover:bg-black/70 backdrop-blur-sm transition-colors"
              aria-label="Project actions"
            >
              <MoreVertical className="w-4 h-4 text-foreground/70" />
            </button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end" className="w-48">
            <DropdownMenuItem onClick={handleOpen}>
              <Edit3 className="w-4 h-4 mr-2" />
              {t('projects.open') || 'Open'}
            </DropdownMenuItem>
            <DropdownMenuItem onClick={handleToggleFavorite}>
              <Star
                className={cn(
                  'w-4 h-4 mr-2',
                  project.isFavorite && 'fill-accent text-accent'
                )}
              />
              {project.isFavorite
                ? t('projects.unfavorite') || 'Remove from favorites'
                : t('projects.favorite') || 'Add to favorites'}
            </DropdownMenuItem>
            {project.hasExport && onExport && (
              <DropdownMenuItem onClick={handleExport}>
                <Download className="w-4 h-4 mr-2" />
                {t('projects.export') || 'Export'}
              </DropdownMenuItem>
            )}
            <DropdownMenuSeparator />
            <DropdownMenuItem
              onClick={handleDelete}
              className="text-destructive focus:text-destructive"
            >
              <Trash2 className="w-4 h-4 mr-2" />
              {t('projects.delete') || 'Delete'}
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </div>
    </motion.div>
  );
}
</file>

<file path="components/QualityDashboard.tsx">
/**
 * QualityDashboard Component
 * 
 * Displays detailed quality metrics and insights for video production.
 * Helps users understand and improve AI output quality.
 */

import React, { useMemo } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  BarChart3,
  TrendingUp,
  TrendingDown,
  Minus,
  AlertTriangle,
  CheckCircle2,
  Lightbulb,
  Clock,
  FileText,
  Image as ImageIcon,
  Volume2,
  Music,
  ChevronDown,
  ChevronUp,
  X,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  ProductionQualityReport,
  SceneQualityMetrics,
  getHistoricalAverages,
} from "@/services/qualityMonitorService";

interface QualityDashboardProps {
  report: ProductionQualityReport;
  isOpen: boolean;
  onClose: () => void;
}

// Score color helper
function getScoreColor(score: number): string {
  if (score >= 80) return "text-green-400";
  if (score >= 60) return "text-yellow-400";
  return "text-red-400";
}

function getScoreBg(score: number): string {
  if (score >= 80) return "bg-green-500/20 border-green-500/30";
  if (score >= 60) return "bg-yellow-500/20 border-yellow-500/30";
  return "bg-red-500/20 border-red-500/30";
}

// Quality badge component
const QualityBadge = React.memo(({ quality }: { quality: "poor" | "fair" | "good" | "excellent" }) => {
  const config = {
    poor: { color: "bg-red-500/20 text-red-400", label: "Poor" },
    fair: { color: "bg-yellow-500/20 text-yellow-400", label: "Fair" },
    good: { color: "bg-blue-500/20 text-blue-400", label: "Good" },
    excellent: { color: "bg-green-500/20 text-green-400", label: "Excellent" },
  };

  return (
    <span className={cn("px-2 py-0.5 rounded text-xs font-medium", config[quality].color)}>
      {config[quality].label}
    </span>
  );
});
QualityBadge.displayName = "QualityBadge";

// Score ring component
const ScoreRing = React.memo(({ score, label, size = "md" }: { score: number; label: string; size?: "sm" | "md" | "lg" }) => {
  const sizeConfig = {
    sm: { ring: 40, stroke: 4, text: "text-sm", label: "text-xs" },
    md: { ring: 60, stroke: 5, text: "text-xl", label: "text-xs" },
    lg: { ring: 80, stroke: 6, text: "text-2xl", label: "text-sm" },
  };

  const config = sizeConfig[size];
  const radius = (config.ring - config.stroke) / 2;
  const circumference = radius * 2 * Math.PI;
  const offset = circumference - (score / 100) * circumference;

  return (
    <div className="flex flex-col items-center gap-1">
      <div className="relative" style={{ width: config.ring, height: config.ring }}>
        <svg className="transform -rotate-90" width={config.ring} height={config.ring}>
          <circle
            cx={config.ring / 2}
            cy={config.ring / 2}
            r={radius}
            stroke="currentColor"
            strokeWidth={config.stroke}
            fill="none"
            className="text-white/10"
          />
          <circle
            cx={config.ring / 2}
            cy={config.ring / 2}
            r={radius}
            stroke="currentColor"
            strokeWidth={config.stroke}
            fill="none"
            strokeDasharray={circumference}
            strokeDashoffset={offset}
            strokeLinecap="round"
            className={getScoreColor(score)}
          />
        </svg>
        <div className="absolute inset-0 flex items-center justify-center">
          <span className={cn("font-bold", config.text, getScoreColor(score))}>{score}</span>
        </div>
      </div>
      <span className={cn("text-slate-400", config.label)}>{label}</span>
    </div>
  );
});
ScoreRing.displayName = "ScoreRing";

export function QualityDashboard({ report, isOpen, onClose }: QualityDashboardProps) {
  const [expandedScene, setExpandedScene] = React.useState<string | null>(null);
  const historicalAverages = useMemo(() => getHistoricalAverages(), []);
  
  if (!isOpen) return null;
  
  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4"
        onClick={onClose}
      >
        <motion.div
          initial={{ scale: 0.95, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.95, opacity: 0 }}
          className="bg-[#12121a] border border-white/10 rounded-xl max-w-4xl w-full max-h-[90vh] overflow-hidden"
          onClick={(e) => e.stopPropagation()}
        >
          {/* Header */}
          <div className="p-4 border-b border-white/10 flex items-center justify-between">
            <div className="flex items-center gap-3">
              <BarChart3 className="w-5 h-5 text-cyan-400" />
              <div>
                <h2 className="font-semibold">Quality Report</h2>
                <p className="text-xs text-slate-400">{report.title}</p>
              </div>
            </div>
            <Button variant="ghost" size="sm" onClick={onClose}>
              <X className="w-4 h-4" />
            </Button>
          </div>
          
          <div className="overflow-y-auto max-h-[calc(90vh-60px)] p-4 space-y-6">
            {/* Overall Scores */}
            <div className="grid grid-cols-5 gap-4">
              <div className="col-span-1 flex justify-center">
                <ScoreRing score={report.overallScore} label="Overall" size="lg" />
              </div>
              <div className="col-span-4 grid grid-cols-4 gap-4">
                <ScoreRing score={report.contentScore} label="Content" />
                <ScoreRing score={report.timingScore} label="Timing" />
                <ScoreRing score={report.visualScore} label="Visual" />
                <ScoreRing score={report.audioScore} label="Audio" />
              </div>
            </div>
            
            {/* Historical Trend */}
            {historicalAverages && (
              <div className={cn(
                "p-3 rounded-lg border flex items-center justify-between",
                historicalAverages.trend === "improving" ? "bg-green-500/10 border-green-500/20" :
                historicalAverages.trend === "declining" ? "bg-red-500/10 border-red-500/20" :
                "bg-slate-500/10 border-slate-500/20"
              )}>
                <div className="flex items-center gap-2">
                  {historicalAverages.trend === "improving" && <TrendingUp className="w-4 h-4 text-green-400" />}
                  {historicalAverages.trend === "declining" && <TrendingDown className="w-4 h-4 text-red-400" />}
                  {historicalAverages.trend === "stable" && <Minus className="w-4 h-4 text-slate-400" />}
                  <span className="text-sm">
                    Quality trend: <span className="font-medium capitalize">{historicalAverages.trend}</span>
                  </span>
                </div>
                <span className="text-xs text-slate-400">
                  Avg: {Math.round(historicalAverages.avgOverall)}/100
                </span>
              </div>
            )}
            
            {/* Strengths & Weaknesses */}
            <div className="grid grid-cols-2 gap-4">
              {/* Strengths */}
              <div className="p-4 rounded-lg bg-green-500/10 border border-green-500/20">
                <div className="flex items-center gap-2 mb-3">
                  <CheckCircle2 className="w-4 h-4 text-green-400" />
                  <span className="font-medium text-green-400">Strengths</span>
                </div>
                {report.strengths.length > 0 ? (
                  <ul className="space-y-1">
                    {report.strengths.map((s) => (
                      <li key={s} className="text-sm text-slate-300 flex items-start gap-2">
                        <span className="text-green-400 mt-1">‚Ä¢</span>
                        {s}
                      </li>
                    ))}
                  </ul>
                ) : (
                  <p className="text-sm text-slate-400">No notable strengths identified</p>
                )}
              </div>
              
              {/* Weaknesses */}
              <div className="p-4 rounded-lg bg-red-500/10 border border-red-500/20">
                <div className="flex items-center gap-2 mb-3">
                  <AlertTriangle className="w-4 h-4 text-red-400" />
                  <span className="font-medium text-red-400">Areas to Improve</span>
                </div>
                {report.weaknesses.length > 0 ? (
                  <ul className="space-y-1">
                    {report.weaknesses.map((w) => (
                      <li key={w} className="text-sm text-slate-300 flex items-start gap-2">
                        <span className="text-red-400 mt-1">‚Ä¢</span>
                        {w}
                      </li>
                    ))}
                  </ul>
                ) : (
                  <p className="text-sm text-slate-400">No major issues found</p>
                )}
              </div>
            </div>
            
            {/* Actionable Improvements */}
            {report.actionableImprovements.length > 0 && (
              <div className="p-4 rounded-lg bg-cyan-500/10 border border-cyan-500/20">
                <div className="flex items-center gap-2 mb-3">
                  <Lightbulb className="w-4 h-4 text-cyan-400" />
                  <span className="font-medium text-cyan-400">Suggestions to Improve</span>
                </div>
                <ul className="space-y-2">
                  {report.actionableImprovements.map((imp, i) => (
                    <li key={imp} className="text-sm text-slate-300 flex items-start gap-2">
                      <span className="text-cyan-400 font-bold">{i + 1}.</span>
                      {imp}
                    </li>
                  ))}
                </ul>
              </div>
            )}
            
            {/* Technical Metrics */}
            <div className="grid grid-cols-4 gap-3">
              <div className="p-3 rounded-lg bg-white/5 border border-white/10 text-center">
                <Clock className="w-4 h-4 mx-auto mb-1 text-slate-400" />
                <div className="text-lg font-bold">{report.avgWordsPerSecond.toFixed(1)}</div>
                <div className="text-xs text-slate-400">Words/sec</div>
              </div>
              <div className="p-3 rounded-lg bg-white/5 border border-white/10 text-center">
                <FileText className="w-4 h-4 mx-auto mb-1 text-slate-400" />
                <div className="text-lg font-bold">{report.avgSceneDuration.toFixed(0)}s</div>
                <div className="text-xs text-slate-400">Avg Scene</div>
              </div>
              <div className="p-3 rounded-lg bg-white/5 border border-white/10 text-center">
                <Volume2 className="w-4 h-4 mx-auto mb-1 text-slate-400" />
                <div className="text-lg font-bold">{Math.round(report.audioCoverage)}%</div>
                <div className="text-xs text-slate-400">Audio Coverage</div>
              </div>
              <div className="p-3 rounded-lg bg-white/5 border border-white/10 text-center">
                <Music className="w-4 h-4 mx-auto mb-1 text-slate-400" />
                <div className="text-lg font-bold">{Math.round(report.sfxCoverage)}%</div>
                <div className="text-xs text-slate-400">SFX Coverage</div>
              </div>
            </div>
            
            {/* Per-Scene Breakdown */}
            <div>
              <h3 className="font-medium mb-3 flex items-center gap-2">
                <ImageIcon className="w-4 h-4 text-slate-400" />
                Scene-by-Scene Analysis
              </h3>
              <div className="space-y-2">
                {report.sceneMetrics.map((scene, index) => (
                  <div
                    key={scene.sceneId}
                    className="rounded-lg border border-white/10 bg-white/5 overflow-hidden"
                  >
                    <button
                      onClick={() => setExpandedScene(expandedScene === scene.sceneId ? null : scene.sceneId)}
                      className="w-full p-3 flex items-center justify-between hover:bg-white/5 transition-colors"
                    >
                      <div className="flex items-center gap-3">
                        <span className="text-xs text-slate-500 w-6">{index + 1}</span>
                        <span className="font-medium text-sm">{scene.sceneName}</span>
                        <QualityBadge quality={scene.visualDescriptionQuality} />
                        {scene.issues.length > 0 && (
                          <span className="text-xs text-yellow-400 flex items-center gap-1">
                            <AlertTriangle className="w-3 h-3" />
                            {scene.issues.length}
                          </span>
                        )}
                      </div>
                      <div className="flex items-center gap-4">
                        <span className="text-xs text-slate-400">{scene.duration}s</span>
                        <span className={cn("text-sm font-medium", getScoreColor(scene.timingSync))}>
                          {scene.timingSync}%
                        </span>
                        {expandedScene === scene.sceneId ? (
                          <ChevronUp className="w-4 h-4 text-slate-400" />
                        ) : (
                          <ChevronDown className="w-4 h-4 text-slate-400" />
                        )}
                      </div>
                    </button>
                    
                    <AnimatePresence>
                      {expandedScene === scene.sceneId && (
                        <motion.div
                          initial={{ height: 0, opacity: 0 }}
                          animate={{ height: "auto", opacity: 1 }}
                          exit={{ height: 0, opacity: 0 }}
                          className="border-t border-white/10"
                        >
                          <div className="p-3 space-y-3">
                            {/* Scene metrics */}
                            <div className="grid grid-cols-4 gap-2 text-xs">
                              <div className="p-2 rounded bg-white/5">
                                <div className="text-slate-400">Visual</div>
                                <div className="font-medium">{scene.visualDescriptionLength} chars</div>
                              </div>
                              <div className="p-2 rounded bg-white/5">
                                <div className="text-slate-400">Narration</div>
                                <div className="font-medium">{scene.narrationWordCount} words</div>
                              </div>
                              <div className="p-2 rounded bg-white/5">
                                <div className="text-slate-400">Pacing</div>
                                <div className="font-medium">{scene.wordsPerSecond.toFixed(1)} w/s</div>
                              </div>
                              <div className="p-2 rounded bg-white/5">
                                <div className="text-slate-400">SFX</div>
                                <div className="font-medium flex items-center gap-1">
                                  {scene.hasSfx ? (
                                    <>
                                      <CheckCircle2 className="w-3 h-3 text-green-400" />
                                      {scene.hasAudioUrl ? "Loaded" : "Pending"}
                                    </>
                                  ) : (
                                    <span className="text-slate-500">None</span>
                                  )}
                                </div>
                              </div>
                            </div>
                            
                            {/* Issues */}
                            {scene.issues.length > 0 && (
                              <div className="p-2 rounded bg-yellow-500/10 border border-yellow-500/20">
                                <div className="text-xs text-yellow-400 font-medium mb-1">Issues:</div>
                                <ul className="text-xs text-slate-300 space-y-1">
                                  {scene.issues.map((issue) => (
                                    <li key={issue}>‚Ä¢ {issue}</li>
                                  ))}
                                </ul>
                              </div>
                            )}
                          </div>
                        </motion.div>
                      )}
                    </AnimatePresence>
                  </div>
                ))}
              </div>
            </div>
            
            {/* AI Performance */}
            <div className="p-4 rounded-lg bg-purple-500/10 border border-purple-500/20">
              <h3 className="font-medium mb-2 text-purple-400">AI Performance</h3>
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <span className="text-slate-400">Content Creativity:</span>
                  <span className={cn(
                    "ml-2 font-medium capitalize",
                    report.contentPlannerCreativity === "high" ? "text-green-400" :
                    report.contentPlannerCreativity === "medium" ? "text-yellow-400" : "text-red-400"
                  )}>
                    {report.contentPlannerCreativity}
                  </span>
                </div>
                <div>
                  <span className="text-slate-400">SFX Suggestion Accuracy:</span>
                  <span className={cn(
                    "ml-2 font-medium",
                    report.aiSfxAccuracy >= 80 ? "text-green-400" :
                    report.aiSfxAccuracy >= 50 ? "text-yellow-400" : "text-red-400"
                  )}>
                    {Math.round(report.aiSfxAccuracy)}%
                  </span>
                </div>
              </div>
            </div>
          </div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  );
}

export default QualityDashboard;
</file>

<file path="components/QuickExport.tsx">
/**
 * QuickExport Component
 * 
 * One-click export with visual presets instead of technical options.
 * Users pick a platform, we handle the codec details.
 */

import React, { useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  Download,
  Smartphone,
  Monitor,
  Youtube,
  Instagram,
  Film,
  Check,
  Loader2,
  X,
  Sparkles,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

interface ExportPreset {
  id: string;
  name: string;
  description: string;
  icon: React.ReactNode;
  resolution: string;
  format: string;
  color: string;
  // Export config
  width: number;
  height: number;
  orientation: "landscape" | "portrait";
  quality: "draft" | "standard" | "high";
}

const EXPORT_PRESETS: ExportPreset[] = [
  {
    id: "social",
    name: "Social Media",
    description: "TikTok, Reels, Shorts",
    icon: <Smartphone className="w-5 h-5 sm:w-6 sm:h-6" />,
    resolution: "1080p",
    format: "MP4 (H.264)",
    color: "from-pink-500 to-rose-500",
    width: 1080,
    height: 1920,
    orientation: "portrait",
    quality: "standard",
  },
  {
    id: "youtube",
    name: "YouTube",
    description: "Full HD, optimized",
    icon: <Youtube className="w-5 h-5 sm:w-6 sm:h-6" />,
    resolution: "1080p",
    format: "MP4 (H.264)",
    color: "from-red-500 to-red-600",
    width: 1920,
    height: 1080,
    orientation: "landscape",
    quality: "high",
  },
  {
    id: "4k",
    name: "4K Master",
    description: "Highest quality",
    icon: <Monitor className="w-5 h-5 sm:w-6 sm:h-6" />,
    resolution: "4K",
    format: "MP4 (H.265)",
    color: "from-purple-500 to-violet-500",
    width: 3840,
    height: 2160,
    orientation: "landscape",
    quality: "high",
  },
  {
    id: "fast",
    name: "Quick Export",
    description: "Fast rendering",
    icon: <Film className="w-5 h-5 sm:w-6 sm:h-6" />,
    resolution: "720p",
    format: "MP4",
    color: "from-slate-500 to-slate-600",
    width: 1280,
    height: 720,
    orientation: "landscape",
    quality: "draft",
  },
];

/** Export configuration returned to parent */
export interface QuickExportConfig {
  presetId: string;
  width: number;
  height: number;
  orientation: "landscape" | "portrait";
  quality: "draft" | "standard" | "high";
}

interface QuickExportProps {
  isOpen: boolean;
  onClose: () => void;
  onExport: (config: QuickExportConfig, onProgress: (percent: number) => void) => Promise<void>;
  videoTitle?: string;
  duration?: number;
  className?: string;
}

export const QuickExport: React.FC<QuickExportProps> = ({
  isOpen,
  onClose,
  onExport,
  videoTitle = "Your Video",
  duration = 60,
  className,
}) => {
  const [selectedPreset, setSelectedPreset] = useState<string>("youtube");
  const [isExporting, setIsExporting] = useState(false);
  const [exportProgress, setExportProgress] = useState(0);
  const [exportComplete, setExportComplete] = useState(false);
  const [exportError, setExportError] = useState<string | null>(null);

  const handleExport = async () => {
    const preset = EXPORT_PRESETS.find(p => p.id === selectedPreset);
    if (!preset) return;

    setIsExporting(true);
    setExportProgress(0);
    setExportError(null);

    // Progress callback for real-time updates from the export process
    const handleProgress = (percent: number) => {
      setExportProgress(Math.min(99, percent)); // Cap at 99 until complete
    };

    try {
      await onExport(
        {
          presetId: preset.id,
          width: preset.width,
          height: preset.height,
          orientation: preset.orientation,
          quality: preset.quality,
        },
        handleProgress
      );

      setExportProgress(100);
      setExportComplete(true);
    } catch (error: any) {
      console.error("Export failed:", error);
      setExportError(error.message || "Export failed. Please try again.");
      setIsExporting(false);
    }
  };

  const handleReset = () => {
    setIsExporting(false);
    setExportProgress(0);
    setExportComplete(false);
    setExportError(null);
  };

  const formatDuration = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, "0")}`;
  };

  if (!isOpen) return null;

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 z-50 flex items-end sm:items-center justify-center p-0 sm:p-4 bg-black/60 backdrop-blur-sm"
        onClick={onClose}
      >
        <motion.div
          initial={{ scale: 0.95, opacity: 0, y: 100 }}
          animate={{ scale: 1, opacity: 1, y: 0 }}
          exit={{ scale: 0.95, opacity: 0, y: 100 }}
          onClick={(e) => e.stopPropagation()}
          className={cn(
            "w-full sm:max-w-lg bg-card border border-border/50 rounded-t-3xl sm:rounded-3xl shadow-2xl overflow-hidden max-h-[90vh] overflow-y-auto",
            className
          )}
        >
          {/* Header */}
          <div className="p-4 sm:p-6 border-b border-border/30 sticky top-0 bg-card z-10">
            <div className="flex items-center justify-between">
              <div>
                <h2 className="text-lg sm:text-xl font-bold">Export Video</h2>
                <p className="text-xs sm:text-sm text-muted-foreground mt-1">
                  {videoTitle} ‚Ä¢ {formatDuration(duration)}
                </p>
              </div>
              <button
                onClick={onClose}
                className="p-2 hover:bg-muted/30 rounded-xl transition-colors"
              >
                <X className="w-5 h-5 text-muted-foreground" />
              </button>
            </div>
          </div>

          {/* Content */}
          <div className="p-4 sm:p-6">
            {exportError ? (
              /* Error State */
              <div className="py-6 sm:py-8 text-center">
                <div className="w-14 h-14 sm:w-16 sm:h-16 mx-auto mb-4 sm:mb-6 rounded-full bg-red-500/20 flex items-center justify-center">
                  <X className="w-7 h-7 sm:w-8 sm:h-8 text-red-500" />
                </div>

                <h3 className="text-base sm:text-lg font-semibold mb-2">Export Failed</h3>
                <p className="text-xs sm:text-sm text-muted-foreground mb-4 sm:mb-6 px-4">
                  {exportError}
                </p>

                <div className="flex gap-2 justify-center">
                  <Button
                    onClick={handleReset}
                    variant="outline"
                    className="rounded-xl"
                  >
                    Try Again
                  </Button>
                  <Button
                    onClick={onClose}
                    variant="ghost"
                    className="rounded-xl"
                  >
                    Close
                  </Button>
                </div>
              </div>
            ) : !isExporting && !exportComplete ? (
              <>
                {/* Preset Grid */}
                <div className="grid grid-cols-2 gap-2 sm:gap-3 mb-4 sm:mb-6">
                  {EXPORT_PRESETS.map((preset) => (
                    <button
                      key={preset.id}
                      onClick={() => setSelectedPreset(preset.id)}
                      className={cn(
                        "relative p-3 sm:p-4 rounded-xl sm:rounded-2xl border-2 transition-all text-left group",
                        selectedPreset === preset.id
                          ? "border-primary bg-primary/5"
                          : "border-border/30 hover:border-border/50 hover:bg-muted/20"
                      )}
                    >
                      {/* Gradient Background */}
                      <div
                        className={cn(
                          "absolute inset-0 rounded-xl sm:rounded-2xl opacity-0 transition-opacity bg-gradient-to-br",
                          preset.color,
                          selectedPreset === preset.id && "opacity-10"
                        )}
                      />

                      <div className="relative">
                        <div
                          className={cn(
                            "w-10 h-10 sm:w-12 sm:h-12 rounded-lg sm:rounded-xl flex items-center justify-center mb-2 sm:mb-3 transition-colors",
                            selectedPreset === preset.id
                              ? "bg-primary/20 text-primary"
                              : "bg-muted/30 text-muted-foreground group-hover:text-foreground"
                          )}
                        >
                          {preset.icon}
                        </div>

                        <h3 className="font-semibold text-sm sm:text-base mb-0.5 sm:mb-1">{preset.name}</h3>
                        <p className="text-[10px] sm:text-xs text-muted-foreground">
                          {preset.description}
                        </p>

                        <div className="mt-2 sm:mt-3 flex items-center gap-1 sm:gap-2 text-[10px] sm:text-xs">
                          <span className="px-1.5 sm:px-2 py-0.5 rounded-full bg-muted/30">
                            {preset.resolution}
                          </span>
                          <span className="text-muted-foreground hidden sm:inline">
                            {preset.format}
                          </span>
                        </div>
                      </div>

                      {/* Selected Check */}
                      {selectedPreset === preset.id && (
                        <div className="absolute top-2 sm:top-3 right-2 sm:right-3 w-5 h-5 sm:w-6 sm:h-6 rounded-full bg-primary flex items-center justify-center">
                          <Check className="w-3 h-3 sm:w-4 sm:h-4 text-primary-foreground" />
                        </div>
                      )}
                    </button>
                  ))}
                </div>

                {/* Export Button */}
                <Button
                  onClick={handleExport}
                  size="lg"
                  className="w-full h-12 sm:h-14 rounded-xl sm:rounded-2xl font-bold text-base sm:text-lg bg-gradient-to-r from-primary to-purple-500 hover:from-primary/90 hover:to-purple-500/90"
                >
                  <Download className="w-4 h-4 sm:w-5 sm:h-5 mr-2" />
                  Export Now
                </Button>
              </>
            ) : isExporting && !exportComplete ? (
              /* Exporting State */
              <div className="py-6 sm:py-8 text-center">
                <motion.div
                  animate={{ rotate: 360 }}
                  transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
                  className="w-14 h-14 sm:w-16 sm:h-16 mx-auto mb-4 sm:mb-6 rounded-full border-4 border-primary/20 border-t-primary"
                />

                <h3 className="text-base sm:text-lg font-semibold mb-2">Exporting...</h3>
                <p className="text-xs sm:text-sm text-muted-foreground mb-4 sm:mb-6">
                  This may take a few minutes
                </p>

                {/* Progress Bar */}
                <div className="h-2 bg-muted/30 rounded-full overflow-hidden mb-2">
                  <motion.div
                    className="h-full bg-gradient-to-r from-primary to-purple-500"
                    initial={{ width: 0 }}
                    animate={{ width: `${exportProgress}%` }}
                  />
                </div>
                <span className="text-xs sm:text-sm font-mono text-muted-foreground">
                  {Math.round(exportProgress)}%
                </span>
              </div>
            ) : (
              /* Complete State */
              <div className="py-6 sm:py-8 text-center">
                <motion.div
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  className="w-14 h-14 sm:w-16 sm:h-16 mx-auto mb-4 sm:mb-6 rounded-full bg-green-500/20 flex items-center justify-center"
                >
                  <Check className="w-7 h-7 sm:w-8 sm:h-8 text-green-500" />
                </motion.div>

                <h3 className="text-base sm:text-lg font-semibold mb-2">Export Complete!</h3>
                <p className="text-xs sm:text-sm text-muted-foreground mb-4 sm:mb-6">
                  Your video has been downloaded
                </p>

                <div className="flex gap-2 justify-center">
                  <Button
                    onClick={() => {
                      handleReset();
                    }}
                    variant="outline"
                    className="rounded-xl"
                  >
                    Export Another
                  </Button>
                  <Button
                    onClick={onClose}
                    className="rounded-xl"
                  >
                    Done
                  </Button>
                </div>
              </div>
            )}
          </div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  );
};

export default QuickExport;
</file>

<file path="components/QuickUpload.tsx">
import React, { useState, useCallback } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Upload, Music, Monitor, Smartphone, Sparkles, ChevronRight, Youtube, Loader2, FileVideo } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { cn } from "@/lib/utils";
import { SERVER_URL } from "@/services/ffmpeg";
import { MusicGeneratorModal } from "./MusicGeneratorModal";
import { MusicChatModalV2 } from "./MusicChatModalV2";
import { isSunoConfigured } from "@/services/sunoService";
import type { SunoGeneratedTrack, SunoGenerationConfig, SunoTaskStatus } from "@/services/sunoService";
import {
  generateMusic as sunoGenerateMusic,
  waitForCompletion,
  generateLyrics as sunoGenerateLyrics,
  getLyricsStatus,
  getCredits,
} from "@/services/sunoService";

interface QuickUploadProps {
  onFileSelect: (file: File, aspectRatio: string) => void;
  onLoadDemo: (aspectRatio: string) => void;
  onSwitchToProduction?: () => void;
  disabled?: boolean;
}

export const QuickUpload: React.FC<QuickUploadProps> = ({
  onFileSelect,
  onLoadDemo,
  onSwitchToProduction,
  disabled = false,
}) => {
  const [aspectRatio, setAspectRatio] = useState<"16:9" | "9:16">("16:9");
  const [activeTab, setActiveTab] = useState<"upload" | "youtube" | "production" | "music">("upload");
  const [isDragging, setIsDragging] = useState(false);
  const [youtubeUrl, setYoutubeUrl] = useState("");
  const [isImporting, setIsImporting] = useState(false);
  const [showMusicModal, setShowMusicModal] = useState(false);
  const [showMusicChat, setShowMusicChat] = useState(false);

  // Music generation state
  const [musicState, setMusicState] = useState<{
    isGenerating: boolean;
    taskId: string | null;
    status: SunoTaskStatus | null;
    progress: number;
    generatedTracks: SunoGeneratedTrack[];
    selectedTrackId: string | null;
    lyrics: string | null;
    lyricsTaskId: string | null;
    credits: number | null;
    error: string | null;
  }>({
    isGenerating: false,
    taskId: null,
    status: null,
    progress: 0,
    generatedTracks: [],
    selectedTrackId: null,
    lyrics: null,
    lyricsTaskId: null,
    credits: null,
    error: null,
  });

  // Music generation handlers
  const handleGenerateMusic = useCallback(async (config: Partial<SunoGenerationConfig> & { prompt: string }) => {
    if (!isSunoConfigured()) {
      setMusicState(prev => ({
        ...prev,
        error: "Suno API key not configured. Add VITE_SUNO_API_KEY to .env.local",
      }));
      return;
    }

    setMusicState(prev => ({
      ...prev,
      isGenerating: true,
      taskId: null,
      status: "PENDING",
      progress: 0,
      generatedTracks: [],
      error: null,
    }));

    try {
      const taskId = await sunoGenerateMusic(config);
      setMusicState(prev => ({ ...prev, taskId, status: "PROCESSING" as SunoTaskStatus, progress: 25 }));
      const tracks = await waitForCompletion(taskId);
      setMusicState(prev => ({
        ...prev,
        isGenerating: false,
        status: "SUCCESS" as SunoTaskStatus,
        progress: 100,
        generatedTracks: tracks,
        selectedTrackId: tracks[0]?.id ?? null,
      }));
    } catch (err) {
      setMusicState(prev => ({
        ...prev,
        isGenerating: false,
        status: "FAILED",
        progress: 0,
        error: err instanceof Error ? err.message : String(err),
      }));
    }
  }, []);

  const handleGenerateLyrics = useCallback(async (prompt: string) => {
    if (!isSunoConfigured()) return;

    setMusicState(prev => ({ ...prev, lyricsTaskId: null, lyrics: null, error: null }));

    try {
      const taskId = await sunoGenerateLyrics(prompt);
      setMusicState(prev => ({ ...prev, lyricsTaskId: taskId }));

      const pollIntervalMs = 5000;
      const maxWaitMs = 2 * 60 * 1000;
      const startTime = Date.now();

      while (Date.now() - startTime < maxWaitMs) {
        const result = await getLyricsStatus(taskId);
        if (result.status === "SUCCESS" && result.text) {
          setMusicState(prev => ({ ...prev, lyrics: result.text || null }));
          return;
        }
        if (result.status === "FAILED") {
          throw new Error(result.errorMessage || "Lyrics generation failed");
        }
        await new Promise(resolve => setTimeout(resolve, pollIntervalMs));
      }
      throw new Error("Lyrics generation timed out");
    } catch (err) {
      setMusicState(prev => ({
        ...prev,
        error: err instanceof Error ? err.message : String(err),
      }));
    }
  }, []);

  const handleSelectTrack = useCallback((trackId: string) => {
    setMusicState(prev => ({ ...prev, selectedTrackId: trackId }));
  }, []);

  const handleAddToTimeline = useCallback(() => {
    const selectedTrack = musicState.generatedTracks.find(t => t.id === musicState.selectedTrackId);
    if (selectedTrack) {
      // Download the track or copy URL to clipboard
      window.open(selectedTrack.audio_url, '_blank');
    }
    setShowMusicModal(false);
  }, [musicState.generatedTracks, musicState.selectedTrackId]);

  const handleRefreshCredits = useCallback(async () => {
    if (!isSunoConfigured()) return;
    try {
      const result = await getCredits();
      // Only update if we got a valid credits value (not -1 for unknown)
      if (result.credits >= 0) {
        setMusicState(prev => ({ ...prev, credits: result.credits }));
      }
    } catch {
      // Silently fail - credits display is optional
      console.warn("[QuickUpload] Could not fetch Suno credits");
    }
  }, []);

  const handleDrop = useCallback(
    (e: React.DragEvent) => {
      e.preventDefault();
      setIsDragging(false);
      if (disabled) return;
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith("audio/")) {
        onFileSelect(file, aspectRatio);
      }
    },
    [disabled, onFileSelect, aspectRatio]
  );

  const handleFileInput = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (file) {
        onFileSelect(file, aspectRatio);
      }
    },
    [onFileSelect, aspectRatio]
  );

  const handleYoutubeImport = async () => {
    if (!youtubeUrl.trim() || isImporting) return;

    setIsImporting(true);
    try {
      const response = await fetch(`${SERVER_URL}/api/import/youtube`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ url: youtubeUrl }),
      });

      if (!response.ok) {
        throw new Error("Failed to import from YouTube");
      }

      const blob = await response.blob();
      const file = new File([blob], "youtube_audio.mp3", {
        type: "audio/mpeg",
      });
      onFileSelect(file, aspectRatio);
    } catch (error) {
      console.error(error);
      alert(
        "Failed to import YouTube video. Make sure the backend server is running (npm run server) and yt-dlp is installed.",
      );
    } finally {
      setIsImporting(false);
      setYoutubeUrl("");
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 30 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.6, ease: "easeOut" }}
      className="max-w-2xl mx-auto mt-12 flex flex-col items-center px-4 relative z-10"
    >
      {/* Background Glows */}
      <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-full h-full max-w-[600px] max-h-[600px] -z-10 pointer-events-none" aria-hidden="true">
        <div className="absolute top-0 right-0 w-64 h-64 bg-primary/20 rounded-full blur-[100px] opacity-50 animate-pulse-slow" />
        <div className="absolute bottom-0 left-0 w-64 h-64 bg-accent/20 rounded-full blur-[100px] opacity-50 animate-pulse-slow delay-1000" />
      </div>

      {/* Header */}
      <div className="text-center mb-12">
        <motion.div
          initial={{ scale: 0.9, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          transition={{ delay: 0.2 }}
          className="inline-flex items-center justify-center p-3 mb-6 rounded-2xl bg-background/50 backdrop-blur-md border border-white/10 shadow-xl shadow-primary/5"
        >
          <Sparkles className="w-8 h-8 text-primary" aria-hidden="true" />
        </motion.div>
        <h1 className="text-5xl md:text-6xl font-bold mb-4 tracking-tight bg-clip-text text-transparent bg-linear-to-b from-foreground to-foreground/70">
          Create Your <span className="text-transparent bg-clip-text bg-linear-to-r from-primary via-purple-500 to-accent">Video</span>
        </h1>
        <p className="text-xl text-muted-foreground/80 max-w-lg mx-auto leading-relaxed">
          Transform your audio into cinematic visual storytelling with the power of AI.
        </p>
      </div>

      {/* Main Card */}
      <div className="w-full bg-card/40 backdrop-blur-xl border border-white/10 rounded-3xl shadow-2xl overflow-hidden ring-1 ring-white/5">

        {/* Navigation Tabs - Segmented Control */}
        <nav
          className="p-2 bg-black/20 m-2 rounded-2xl flex relative"
          role="tablist"
          aria-label="Video creation options"
        >
          <div className="absolute inset-0 rounded-2xl border border-white/5 pointer-events-none" aria-hidden="true" />
          {[
            { id: "upload", icon: Upload, label: "Upload File", color: "text-foreground" },
            { id: "youtube", icon: Youtube, label: "YouTube", color: "text-red-500" },
            { id: "music", icon: Music, label: "Song Generator", color: "text-cyan-400" },
            { id: "production", icon: FileVideo, label: "Studio Mode", color: "text-purple-400" }
          ].map((tab) => (
            <button
              key={tab.id}
              role="tab"
              aria-selected={activeTab === tab.id}
              aria-controls={`${tab.id}-panel`}
              id={`${tab.id}-tab`}
              onClick={() => setActiveTab(tab.id as any)}
              className={cn(
                "flex-1 py-3 text-sm font-semibold transition-all relative z-10 rounded-xl flex items-center justify-center gap-2",
                activeTab === tab.id ? "text-foreground shadow-sm" : "text-muted-foreground hover:text-foreground/80"
              )}
            >
              {activeTab === tab.id && (
                <motion.div
                  layoutId="active-tab"
                  className="absolute inset-0 bg-background/80 shadow-[0_0_20px_rgba(0,0,0,0.1)] rounded-xl -z-10"
                  transition={{ type: "spring", bounce: 0.2, duration: 0.6 }}
                />
              )}
              <tab.icon size={16} className={cn(activeTab === tab.id ? tab.color : "opacity-70")} aria-hidden="true" />
              <span>{tab.label}</span>
            </button>
          ))}
        </nav>

        {/* Content Area */}
        <div className="p-8 min-h-[340px] flex flex-col">

          {/* Aspect Ratio Config (Hidden in Studio Mode and Music) */}
          {activeTab !== "production" && activeTab !== "music" && (
            <div className="flex justify-center mb-10">
              <div
                className="inline-flex bg-muted/30 p-1.5 rounded-full border border-white/5"
                role="radiogroup"
                aria-label="Video aspect ratio"
              >
                {[
                  { id: "16:9", icon: Monitor, label: "Landscape" },
                  { id: "9:16", icon: Smartphone, label: "Portrait" }
                ].map((ratio) => (
                  <button
                    key={ratio.id}
                    role="radio"
                    aria-checked={aspectRatio === ratio.id}
                    aria-label={`${ratio.label} (${ratio.id})`}
                    onClick={() => setAspectRatio(ratio.id as any)}
                    className={cn(
                      "px-6 py-2 rounded-full text-xs font-semibold transition-all flex items-center gap-2",
                      aspectRatio === ratio.id
                        ? "bg-primary text-primary-foreground shadow-lg shadow-primary/25"
                        : "text-muted-foreground hover:text-foreground/80 hover:bg-white/5"
                    )}
                  >
                    <ratio.icon size={14} aria-hidden="true" /> {ratio.label}
                  </button>
                ))}
              </div>
            </div>
          )}

          <div className="flex-1 flex flex-col justify-center">
            <AnimatePresence mode="wait">
              {activeTab === "upload" && (
                <motion.div
                  key="upload"
                  id="upload-panel"
                  role="tabpanel"
                  aria-labelledby="upload-tab"
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: 20 }}
                  transition={{ duration: 0.3 }}
                  className="flex flex-col items-center"
                >
                  <button
                    type="button"
                    onDragOver={(e) => {
                      e.preventDefault();
                      setIsDragging(true);
                    }}
                    onDragLeave={() => setIsDragging(false)}
                    onDrop={handleDrop}
                    onClick={() => !disabled && document.getElementById("audio-input")?.click()}
                    disabled={disabled}
                    aria-label="Click to upload audio file or drag and drop. Supports MP3, WAV, M4A formats."
                    className={cn(
                      "w-full h-56 border-2 border-dashed rounded-2xl flex flex-col items-center justify-center cursor-pointer transition-all duration-300 group relative overflow-hidden",
                      isDragging
                        ? "border-primary bg-primary/10 shadow-[0_0_40px_rgba(var(--primary),0.2)]"
                        : "border-border/40 hover:border-primary/50 hover:bg-primary/5 hover:shadow-lg",
                      disabled && "opacity-50 cursor-not-allowed"
                    )}
                  >
                    <div className="absolute inset-0 bg-linear-to-br from-primary/5 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-500" aria-hidden="true" />

                    <input
                      id="audio-input"
                      type="file"
                      accept="audio/*"
                      onChange={handleFileInput}
                      className="hidden"
                      disabled={disabled}
                      aria-label="Select audio file"
                    />

                    <div className={cn(
                      "w-20 h-20 rounded-full flex items-center justify-center mb-6 transition-all duration-300 shadow-md",
                      isDragging ? "bg-primary text-primary-foreground scale-110" : "bg-muted/50 text-muted-foreground group-hover:bg-primary/20 group-hover:text-primary group-hover:scale-110"
                    )}>
                      <Upload size={32} aria-hidden="true" />
                    </div>

                    <h3 className="font-semibold text-lg mb-2 text-foreground/90">Click to upload or drag audio</h3>
                    <p className="text-sm text-muted-foreground/70">
                      Supports MP3, WAV, M4A
                    </p>
                  </button>
                </motion.div>
              )}

              {activeTab === "youtube" && (
                <motion.div
                  key="youtube"
                  id="youtube-panel"
                  role="tabpanel"
                  aria-labelledby="youtube-tab"
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: 20 }}
                  className="space-y-6 max-w-md mx-auto w-full py-4"
                >
                  <div className="relative group">
                    <div className="absolute inset-y-0 left-4 flex items-center pointer-events-none">
                      <Youtube className={cn("w-5 h-5 transition-colors", youtubeUrl ? "text-red-500" : "text-muted-foreground")} aria-hidden="true" />
                    </div>
                    <Input
                      type="text"
                      value={youtubeUrl}
                      onChange={(e) => setYoutubeUrl(e.target.value)}
                      placeholder="https://youtube.com/watch?v=..."
                      aria-label="YouTube video URL"
                      className="pl-12 h-14 bg-background/30 border-white/10 focus:border-red-500/50 focus:ring-red-500/20 rounded-xl text-lg shadow-inner"
                      disabled={isImporting || disabled}
                      onKeyDown={(e) => e.key === "Enter" && handleYoutubeImport()}
                    />
                  </div>

                  <Button
                    onClick={handleYoutubeImport}
                    disabled={!youtubeUrl || isImporting}
                    aria-label={isImporting ? "Importing from YouTube..." : "Import audio from YouTube"}
                    className={cn(
                      "w-full h-14 rounded-xl text-white font-semibold text-lg shadow-lg transition-all",
                      "bg-linear-to-r from-red-600 to-red-500 hover:from-red-500 hover:to-red-400 hover:shadow-red-500/25 hover:scale-[1.02] active:scale-[0.98]"
                    )}
                  >
                    {isImporting ? <Loader2 className="animate-spin w-5 h-5" aria-hidden="true" /> : "Import from YouTube"}
                  </Button>

                  <div className="flex items-center justify-center gap-2 text-xs text-muted-foreground/60">
                    <div className="w-1.5 h-1.5 rounded-full bg-green-500/50" aria-hidden="true" />
                    <span>Requires backend server (npm run server)</span>
                  </div>
                </motion.div>
              )}

              {activeTab === "production" && (
                <motion.div
                  key="production"
                  id="production-panel"
                  role="tabpanel"
                  aria-labelledby="production-tab"
                  initial={{ opacity: 0, scale: 0.95 }}
                  animate={{ opacity: 1, scale: 1 }}
                  exit={{ opacity: 0, scale: 0.95 }}
                  className="flex flex-col items-center py-2"
                >
                  <div className="relative mb-6" aria-hidden="true">
                    <div className="absolute inset-0 bg-purple-500 blur-2xl opacity-20" />
                    <div className="relative w-24 h-24 rounded-3xl bg-linear-to-br from-purple-500/10 to-blue-500/10 border border-purple-500/20 flex items-center justify-center shadow-inner">
                      <FileVideo size={40} className="text-purple-400" />
                    </div>
                  </div>

                  <h3 className="text-2xl font-bold mb-3 bg-clip-text text-transparent bg-linear-to-r from-purple-400 to-blue-400">
                    Professional Studio
                  </h3>

                  <p className="text-muted-foreground text-center mb-8 max-w-sm leading-relaxed">
                    Access advanced tools for multi-agent orchestration, detailed scene control, and granular editing.
                  </p>

                  <Button
                    onClick={() => onSwitchToProduction?.()}
                    aria-label="Enter Professional Studio mode"
                    className="w-full max-w-sm h-14 rounded-xl font-semibold text-lg bg-white/5 border border-white/10 hover:bg-white/10 hover:border-purple-500/30 text-foreground shadow-xl shadow-purple-900/10 hover:shadow-purple-500/10 transition-all group"
                  >
                    Enter Studio <ChevronRight className="ml-2 w-5 h-5 group-hover:translate-x-1 transition-transform text-purple-400" aria-hidden="true" />
                  </Button>
                </motion.div>
              )}

              {activeTab === "music" && (
                <motion.div
                  key="music"
                  id="music-panel"
                  role="tabpanel"
                  aria-labelledby="music-tab"
                  initial={{ opacity: 0, scale: 0.95 }}
                  animate={{ opacity: 1, scale: 1 }}
                  exit={{ opacity: 0, scale: 0.95 }}
                  className="flex flex-col items-center py-2"
                >
                  <div className="relative mb-6" aria-hidden="true">
                    <div className="absolute inset-0 bg-cyan-500 blur-2xl opacity-20" />
                    <div className="relative w-24 h-24 rounded-3xl bg-linear-to-br from-cyan-500/10 to-blue-500/10 border border-cyan-500/20 flex items-center justify-center shadow-inner">
                      <Music size={40} className="text-cyan-400" />
                    </div>
                  </div>

                  <h3 className="text-2xl font-bold mb-3 bg-clip-text text-transparent bg-linear-to-r from-cyan-400 to-blue-400">
                    AI Song Generator
                  </h3>

                  <p className="text-muted-foreground text-center mb-6 max-w-sm leading-relaxed">
                    Create custom AI-generated music from topics, lyrics, and style preferences using Suno AI.
                  </p>

                  <div className="w-full max-w-sm space-y-3">
                    {/* Chat-based generator (recommended) */}
                    <Button
                      onClick={() => setShowMusicChat(true)}
                      aria-label="Open AI Music Producer chat interface (recommended)"
                      className="w-full h-14 rounded-xl font-semibold text-lg bg-linear-to-r from-cyan-500/20 to-blue-500/20 border border-cyan-500/30 hover:from-cyan-500/30 hover:to-blue-500/30 text-foreground shadow-xl shadow-cyan-900/10 hover:shadow-cyan-500/10 transition-all group"
                    >
                      <Sparkles className="mr-2 w-5 h-5 text-cyan-400" aria-hidden="true" />
                      Chat with AI Producer
                      <span className="ml-2 text-xs bg-cyan-500/20 px-2 py-0.5 rounded-full text-cyan-300">Recommended</span>
                    </Button>

                    {/* Quick generator */}
                    <Button
                      onClick={() => setShowMusicModal(true)}
                      variant="outline"
                      aria-label="Open quick music generation form"
                      className="w-full h-12 rounded-xl font-medium bg-white/5 border border-white/10 hover:bg-white/10 hover:border-cyan-500/20 text-muted-foreground hover:text-foreground transition-all"
                    >
                      Quick Generate (Form)
                    </Button>
                  </div>

                  {!isSunoConfigured() && (
                    <p className="mt-4 text-xs text-amber-400/80 text-center" role="alert">
                      ‚ö†Ô∏è Add VITE_SUNO_API_KEY to .env.local to enable
                    </p>
                  )}
                </motion.div>
              )}
            </AnimatePresence>
          </div>
        </div>
      </div>

      {/* Footer Demo Link */}
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ delay: 0.5 }}
        className="mt-16"
      >
        <button
          onClick={() => onLoadDemo(aspectRatio)}
          aria-label="Load demo project for development testing"
          className="group flex items-center gap-3 px-6 py-3 rounded-full bg-accent/5 hover:bg-accent/10 border border-accent/10 hover:border-accent/20 transition-all duration-300"
        >
          <Sparkles size={14} className="text-accent group-hover:scale-110 transition-transform" aria-hidden="true" />
          <span className="text-xs font-medium uppercase tracking-widest text-muted-foreground group-hover:text-accent transition-colors">Load Demo Project (Dev)</span>
        </button>
      </motion.div>

      {/* Music Generator Modal */}
      <MusicGeneratorModal
        open={showMusicModal}
        onClose={() => setShowMusicModal(false)}
        onMusicGenerated={(track) => {
          console.log("[QuickUpload] Music generated:", track.title);
        }}
        musicState={musicState}
        onGenerateMusic={handleGenerateMusic}
        onGenerateLyrics={handleGenerateLyrics}
        onSelectTrack={handleSelectTrack}
        onAddToTimeline={handleAddToTimeline}
        onRefreshCredits={handleRefreshCredits}
      />

      {/* Music Chat Modal V2 (AI Producer with direct Suno API) */}
      <MusicChatModalV2
        open={showMusicChat}
        onClose={() => setShowMusicChat(false)}
        onMusicGenerated={(track) => {
          console.log("[QuickUpload] Music generated via chat:", track.title);
        }}
      />
    </motion.div>
  );
};
</file>

<file path="components/ReferenceDocumentUpload.tsx">
/**
 * Reference Document Upload Component
 *
 * Drag-and-drop upload for PDF, TXT, DOCX reference documents.
 * Parses documents into indexed chunks for the Research Service.
 *
 * Requirements: 22.4
 */

import React, { useState, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Upload,
  FileText,
  X,
  AlertCircle,
  Check,
  Loader2,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import {
  parseDocument,
  getSupportedTypes,
  DocumentParseError,
  type IndexedDocument,
} from '@/services/documentParser';

export interface ReferenceDocumentUploadProps {
  documents: IndexedDocument[];
  onDocumentsChange: (docs: IndexedDocument[]) => void;
  maxFiles?: number;
  maxSizeMB?: number;
  className?: string;
}

interface UploadStatus {
  filename: string;
  status: 'parsing' | 'done' | 'error';
  error?: string;
}

const ACCEPT = '.pdf,.txt,.docx';

export function ReferenceDocumentUpload({
  documents,
  onDocumentsChange,
  maxFiles = 5,
  maxSizeMB = 10,
  className,
}: ReferenceDocumentUploadProps) {
  const [dragOver, setDragOver] = useState(false);
  const [uploadStatuses, setUploadStatuses] = useState<UploadStatus[]>([]);
  const inputRef = useRef<HTMLInputElement>(null);

  const maxSizeBytes = maxSizeMB * 1024 * 1024;

  const handleFiles = useCallback(
    async (files: FileList | File[]) => {
      const fileArray = Array.from(files);
      const remaining = maxFiles - documents.length;

      if (remaining <= 0) {
        setUploadStatuses([
          { filename: '', status: 'error', error: `Maximum ${maxFiles} files allowed` },
        ]);
        return;
      }

      const toProcess = fileArray.slice(0, remaining);
      const newStatuses: UploadStatus[] = toProcess.map((f) => ({
        filename: f.name,
        status: 'parsing' as const,
      }));

      setUploadStatuses(newStatuses);

      const results: IndexedDocument[] = [];

      for (let i = 0; i < toProcess.length; i++) {
        const file = toProcess[i]!;

        // Size check
        if (file.size > maxSizeBytes) {
          newStatuses[i] = {
            filename: file.name,
            status: 'error',
            error: `File exceeds ${maxSizeMB}MB limit`,
          };
          setUploadStatuses([...newStatuses]);
          continue;
        }

        try {
          const doc = await parseDocument(file);
          results.push(doc);
          newStatuses[i] = { filename: file.name, status: 'done' };
        } catch (err) {
          const msg =
            err instanceof DocumentParseError
              ? err.message
              : err instanceof Error
                ? err.message
                : 'Unknown parsing error';
          newStatuses[i] = { filename: file.name, status: 'error', error: msg };
        }

        setUploadStatuses([...newStatuses]);
      }

      if (results.length > 0) {
        onDocumentsChange([...documents, ...results]);
      }

      // Clear statuses after a delay
      setTimeout(() => setUploadStatuses([]), 3000);
    },
    [documents, onDocumentsChange, maxFiles, maxSizeBytes, maxSizeMB],
  );

  const handleDrop = useCallback(
    (e: React.DragEvent) => {
      e.preventDefault();
      setDragOver(false);
      if (e.dataTransfer.files.length > 0) {
        handleFiles(e.dataTransfer.files);
      }
    },
    [handleFiles],
  );

  const handleRemove = useCallback(
    (docId: string) => {
      onDocumentsChange(documents.filter((d) => d.id !== docId));
    },
    [documents, onDocumentsChange],
  );

  return (
    <div className={cn('w-full', className)}>
      {/* Drop zone */}
      <div
        onDragOver={(e) => {
          e.preventDefault();
          setDragOver(true);
        }}
        onDragLeave={() => setDragOver(false)}
        onDrop={handleDrop}
        onClick={() => inputRef.current?.click()}
        className={cn(
          'flex flex-col items-center justify-center gap-2 px-4 py-6 rounded-sm border-2 border-dashed cursor-pointer transition-colors duration-200',
          dragOver
            ? 'border-blue-500/50 bg-blue-500/10'
            : 'border-zinc-700 bg-zinc-900/40 hover:border-zinc-500',
        )}
        role="button"
        aria-label="Upload reference documents"
        tabIndex={0}
        onKeyDown={(e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            inputRef.current?.click();
          }
        }}
      >
        <Upload
          className={cn(
            'w-5 h-5',
            dragOver ? 'text-blue-400' : 'text-zinc-500',
          )}
        />
        <div className="text-center">
          <span className="text-[13px] text-zinc-300">
            Drop files here or click to browse
          </span>
          <span className="block font-mono text-[10px] text-zinc-500 mt-1">
            PDF, TXT, DOCX ‚Äî max {maxSizeMB}MB, {maxFiles} files
          </span>
        </div>
        <input
          ref={inputRef}
          type="file"
          accept={ACCEPT}
          multiple
          className="hidden"
          onChange={(e) => {
            if (e.target.files?.length) {
              handleFiles(e.target.files);
              e.target.value = '';
            }
          }}
        />
      </div>

      {/* Upload statuses */}
      <AnimatePresence>
        {uploadStatuses.length > 0 && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            className="mt-2 space-y-1 overflow-hidden"
          >
            {uploadStatuses.map((s, i) => (
              <div
                key={`${s.filename}-${i}`}
                className={cn(
                  'flex items-center gap-2 px-3 py-1.5 rounded-sm border text-xs font-mono',
                  s.status === 'parsing'
                    ? 'border-zinc-700 text-zinc-400'
                    : s.status === 'done'
                      ? 'border-emerald-500/30 text-emerald-400'
                      : 'border-red-500/30 text-red-400',
                )}
              >
                {s.status === 'parsing' && <Loader2 className="w-3 h-3 animate-spin" />}
                {s.status === 'done' && <Check className="w-3 h-3" />}
                {s.status === 'error' && <AlertCircle className="w-3 h-3" />}
                <span className="truncate">{s.filename || s.error}</span>
                {s.error && s.filename && (
                  <span className="text-red-500 truncate ml-auto">{s.error}</span>
                )}
              </div>
            ))}
          </motion.div>
        )}
      </AnimatePresence>

      {/* Document list */}
      {documents.length > 0 && (
        <div className="mt-3 space-y-1.5">
          <span className="font-mono text-[10px] font-medium tracking-[0.15em] uppercase text-zinc-500">
            Reference Documents ({documents.length}/{maxFiles})
          </span>
          {documents.map((doc) => (
            <motion.div
              key={doc.id}
              layout
              initial={{ opacity: 0, y: 4 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -4 }}
              className="flex items-center gap-3 px-3 py-2 rounded-sm border border-zinc-700 bg-zinc-900/60"
            >
              <FileText className="w-3.5 h-3.5 text-zinc-400 shrink-0" />
              <div className="flex-1 min-w-0">
                <span className="text-[13px] text-zinc-200 truncate block">
                  {doc.filename}
                </span>
                <span className="font-mono text-[10px] text-zinc-500">
                  {doc.chunks.length} chunks, {doc.metadata.wordCount ?? '?'} words
                </span>
              </div>
              <button
                type="button"
                onClick={() => handleRemove(doc.id)}
                className={cn(
                  'shrink-0 p-1 rounded-sm border border-transparent',
                  'text-zinc-500 hover:text-red-400 hover:border-red-500/30',
                  'transition-colors duration-150',
                  'focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-red-500',
                )}
                aria-label={`Remove ${doc.filename}`}
              >
                <X className="w-3 h-3" />
              </button>
            </motion.div>
          ))}
        </div>
      )}
    </div>
  );
}

export default ReferenceDocumentUpload;
</file>

<file path="components/SceneEditor.tsx">
/**
 * SceneEditor Component
 * 
 * Editable scene cards for reviewing and modifying content plans.
 * Allows editing visual descriptions, narration scripts, and timing.
 */

import React, { useState, useCallback } from "react";
import { motion, AnimatePresence, Reorder } from "framer-motion";
import {
    GripVertical,
    Trash2,
    Plus,
    Play,
    Pause,
    Clock,
    Image,
    Mic,
    ChevronDown,
    ChevronUp,
    Eye,
    Download,
    RefreshCw,
    Loader2
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { cn, isRTL, getTextDirection } from "@/lib/utils";
import { Scene, EmotionalTone, TransitionType, InstructionTriplet } from "@/types";
import { getEffectiveLegacyTone } from "@/services/tripletUtils";

interface SceneEditorProps {
    scenes: Scene[];
    onChange: (scenes: Scene[]) => void;
    onPlayNarration?: (sceneId: string) => void;
    onRegenerateNarration?: (sceneId: string) => Promise<void>;
    playingSceneId?: string | null;
    regeneratingSceneId?: string | null;
    visuals?: Record<string, string>; // sceneId -> imageUrl
    narrationUrls?: Record<string, string>; // sceneId -> audioUrl
    className?: string;
}

interface SceneCardProps {
    scene: Scene;
    index: number;
    isExpanded: boolean;
    isPlaying: boolean;
    isRegenerating: boolean;
    imageUrl?: string;
    audioUrl?: string;
    onToggleExpand: () => void;
    onChange: (updates: Partial<Scene>) => void;
    onDelete: () => void;
    onPlayNarration?: () => void;
    onRegenerateNarration?: () => void;
    onDownloadAudio?: () => void;
}

const EMOTIONAL_TONES: EmotionalTone[] = ["professional", "dramatic", "friendly", "urgent", "calm"];
const TRANSITIONS: TransitionType[] = ["none", "fade", "dissolve", "zoom", "slide"];

function SceneCard({
    scene,
    index,
    isExpanded,
    isPlaying,
    isRegenerating,
    imageUrl,
    audioUrl,
    onToggleExpand,
    onChange,
    onDelete,
    onPlayNarration,
    onRegenerateNarration,
    onDownloadAudio,
}: SceneCardProps) {
    const handleDownloadAudio = (e: React.MouseEvent) => {
        e.stopPropagation();
        if (audioUrl) {
            const a = document.createElement('a');
            a.href = audioUrl;
            a.download = `${scene.name.replace(/\s+/g, '_')}_narration.wav`;
            a.click();
        }
    };

    return (
        <Reorder.Item
            value={scene}
            className="glass-panel rounded-xl overflow-hidden mb-3"
        >
            {/* Header */}
            <div
                className="flex items-center gap-3 p-4 cursor-pointer hover:bg-white/5 transition-colors"
                onClick={onToggleExpand}
            >
                <GripVertical className="w-4 h-4 text-slate-500 cursor-grab" />

                <div className="w-8 h-8 rounded-full bg-linear-to-br from-cyan-500 to-purple-500 flex items-center justify-center text-sm font-bold">
                    {index + 1}
                </div>

                <div className="flex-1 min-w-0">
                    <Input
                        value={scene.name}
                        onChange={(e) => onChange({ name: e.target.value })}
                        onClick={(e) => e.stopPropagation()}
                        className={cn(
                            "bg-transparent border-none p-0 h-auto text-base font-medium focus:ring-0",
                            isRTL(scene.name) && "text-right"
                        )}
                        dir={getTextDirection(scene.name)}
                        placeholder="Scene name... | ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ¥ŸáÿØ..."
                    />
                </div>

                <div className="flex items-center gap-2 text-sm text-slate-400">
                    <Clock className="w-4 h-4" />
                    <Input
                        type="number"
                        value={scene.duration}
                        onChange={(e) => onChange({ duration: parseInt(e.target.value) || 0 })}
                        onClick={(e) => e.stopPropagation()}
                        className="w-16 bg-white/5 border-white/10 h-7 text-center rounded-md"
                        min={1}
                        max={120}
                    />
                    <span>sec</span>
                </div>

                <div className="flex items-center gap-1">
                    {onPlayNarration && (
                        <Button
                            size="sm"
                            variant="ghost"
                            onClick={(e) => { e.stopPropagation(); onPlayNarration(); }}
                            className="h-8 w-8 p-0"
                        >
                            {isPlaying ? (
                                <Pause className="w-4 h-4 text-cyan-400" />
                            ) : (
                                <Play className="w-4 h-4" />
                            )}
                        </Button>
                    )}
                    <Button
                        size="sm"
                        variant="ghost"
                        onClick={(e) => { e.stopPropagation(); onDelete(); }}
                        className="h-8 w-8 p-0 hover:text-red-400"
                    >
                        <Trash2 className="w-4 h-4" />
                    </Button>
                    {isExpanded ? (
                        <ChevronUp className="w-4 h-4 text-slate-400" />
                    ) : (
                        <ChevronDown className="w-4 h-4 text-slate-400" />
                    )}
                </div>
            </div>

            {/* Expanded content */}
            <AnimatePresence>
                {isExpanded && (
                    <motion.div
                        initial={{ height: 0, opacity: 0 }}
                        animate={{ height: "auto", opacity: 1 }}
                        exit={{ height: 0, opacity: 0 }}
                        transition={{ duration: 0.2 }}
                        className="overflow-hidden"
                    >
                        <div className="p-4 pt-0 space-y-4 border-t border-white/10">
                            {/* Generated Image Preview */}
                            {imageUrl && (
                                <div className="mb-4">
                                    <label className="flex items-center gap-2 text-sm text-slate-400 mb-2">
                                        <Eye className="w-4 h-4" />
                                        Generated Image
                                    </label>
                                    <div className="relative aspect-video rounded-lg overflow-hidden bg-slate-900">
                                        <img
                                            src={imageUrl}
                                            alt={scene.name}
                                            className="w-full h-full object-cover"
                                        />
                                    </div>
                                </div>
                            )}

                            {/* Audio Preview & Download */}
                            {audioUrl && (
                                <div className="mb-4">
                                    <label className="flex items-center gap-2 text-sm text-slate-400 mb-2">
                                        <Mic className="w-4 h-4" />
                                        Narration Audio
                                    </label>
                                    <div className="flex items-center gap-3 p-3 rounded-lg bg-slate-700/30">
                                        <audio
                                            src={audioUrl}
                                            controls
                                            className="flex-1 h-8"
                                        />
                                        <Button
                                            size="sm"
                                            variant="glass"
                                            onClick={handleDownloadAudio}
                                            className="gap-2"
                                        >
                                            <Download className="w-4 h-4" />
                                            Download
                                        </Button>
                                    </div>
                                </div>
                            )}

                            {/* Visual Description */}
                            <div>
                                <label className="flex items-center gap-2 text-sm text-slate-400 mb-2">
                                    <Image className="w-4 h-4" />
                                    Visual Description
                                </label>
                                <Textarea
                                    value={scene.visualDescription}
                                    onChange={(e) => onChange({ visualDescription: e.target.value })}
                                    placeholder="Describe what should be shown visually... | ÿµŸÅ ŸÖÿß Ÿäÿ¨ÿ® ÿπÿ±ÿ∂Ÿá ÿ®ÿµÿ±ŸäŸãÿß..."
                                    className={cn(
                                        "min-h-[80px] bg-white/5 border-white/10 focus:border-primary/50 rounded-xl",
                                        isRTL(scene.visualDescription) && "text-right"
                                    )}
                                    dir={getTextDirection(scene.visualDescription)}
                                />
                                <p className={cn(
                                    "text-xs text-slate-500 mt-1",
                                    isRTL(scene.visualDescription) && "text-right"
                                )}>
                                    {scene.visualDescription.length}/200 characters
                                </p>
                            </div>

                            {/* Narration Script */}
                            <div>
                                <label className="flex items-center gap-2 text-sm text-slate-400 mb-2">
                                    <Mic className="w-4 h-4" />
                                    Narration Script
                                </label>
                                <Textarea
                                    value={scene.narrationScript}
                                    onChange={(e) => onChange({ narrationScript: e.target.value })}
                                    placeholder="Write what should be spoken... | ÿßŸÉÿ™ÿ® ŸÖÿß Ÿäÿ¨ÿ® ŸÇŸàŸÑŸá..."
                                    className={cn(
                                        "min-h-[100px] bg-white/5 border-white/10 focus:border-primary/50 rounded-xl",
                                        isRTL(scene.narrationScript) && "text-right"
                                    )}
                                    dir={getTextDirection(scene.narrationScript)}
                                />
                                <div className={cn(
                                    "flex items-center justify-between mt-2",
                                    isRTL(scene.narrationScript) && "flex-row-reverse"
                                )}>
                                    <p className="text-xs text-slate-500">
                                        ~{Math.ceil(scene.narrationScript.split(/\s+/).length / 2.5)} seconds of speech
                                    </p>
                                    {onRegenerateNarration && (
                                        <Button
                                            size="sm"
                                            variant="glass"
                                            onClick={onRegenerateNarration}
                                            disabled={isRegenerating}
                                            className="gap-2 h-8"
                                        >
                                            {isRegenerating ? (
                                                <>
                                                    <Loader2 className="w-3 h-3 animate-spin" />
                                                    Generating...
                                                </>
                                            ) : (
                                                <>
                                                    <RefreshCw className="w-3 h-3" />
                                                    Regenerate TTS
                                                </>
                                            )}
                                        </Button>
                                    )}
                                </div>
                            </div>

                            {/* Tone and Transition */}
                            <div className="flex gap-4">
                                <div className="flex-1">
                                    <label className="text-sm text-slate-400 mb-2 block">Emotional Tone</label>
                                    <Select
                                        value={getEffectiveLegacyTone(scene)}
                                        onValueChange={(v) => onChange({ emotionalTone: v as EmotionalTone })}
                                    >
                                        <SelectTrigger className="glass-button w-full border-white/10">
                                            <SelectValue />
                                        </SelectTrigger>
                                        <SelectContent>
                                            {EMOTIONAL_TONES.map((tone) => (
                                                <SelectItem key={tone} value={tone}>
                                                    {tone.charAt(0).toUpperCase() + tone.slice(1)}
                                                </SelectItem>
                                            ))}
                                        </SelectContent>
                                    </Select>
                                </div>

                                <div className="flex-1">
                                    <label className="text-sm text-slate-400 mb-2 block">Transition</label>
                                    <Select
                                        value={scene.transitionTo || "dissolve"}
                                        onValueChange={(v) => onChange({ transitionTo: v as TransitionType })}
                                    >
                                        <SelectTrigger className="glass-button w-full border-white/10">
                                            <SelectValue />
                                        </SelectTrigger>
                                        <SelectContent>
                                            {TRANSITIONS.map((t) => (
                                                <SelectItem key={t} value={t}>
                                                    {t.charAt(0).toUpperCase() + t.slice(1)}
                                                </SelectItem>
                                            ))}
                                        </SelectContent>
                                    </Select>
                                </div>
                            </div>

                            {/* Instruction Triplet */}
                            {scene.instructionTriplet && (
                                <div className="space-y-2 mt-3 p-3 rounded-lg bg-white/5 border border-white/10">
                                    <label className="text-xs text-cyan-400 font-medium block">Instruction Triplet</label>
                                    <div className="grid grid-cols-3 gap-2">
                                        <div>
                                            <label className="text-[10px] text-slate-500 block mb-1">Emotion</label>
                                            <Input
                                                value={scene.instructionTriplet.primaryEmotion}
                                                onChange={(e) => onChange({
                                                    instructionTriplet: { ...scene.instructionTriplet!, primaryEmotion: e.target.value }
                                                })}
                                                className="glass-button text-xs h-8 border-white/10"
                                                placeholder="e.g. visceral-dread"
                                            />
                                        </div>
                                        <div>
                                            <label className="text-[10px] text-slate-500 block mb-1">Cinematic</label>
                                            <Input
                                                value={scene.instructionTriplet.cinematicDirection}
                                                onChange={(e) => onChange({
                                                    instructionTriplet: { ...scene.instructionTriplet!, cinematicDirection: e.target.value }
                                                })}
                                                className="glass-button text-xs h-8 border-white/10"
                                                placeholder="e.g. slow-push-in"
                                            />
                                        </div>
                                        <div>
                                            <label className="text-[10px] text-slate-500 block mb-1">Atmosphere</label>
                                            <Input
                                                value={scene.instructionTriplet.environmentalAtmosphere}
                                                onChange={(e) => onChange({
                                                    instructionTriplet: { ...scene.instructionTriplet!, environmentalAtmosphere: e.target.value }
                                                })}
                                                className="glass-button text-xs h-8 border-white/10"
                                                placeholder="e.g. foggy-ruins"
                                            />
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </Reorder.Item>
    );
}

export function SceneEditor({
    scenes,
    onChange,
    onPlayNarration,
    onRegenerateNarration,
    playingSceneId,
    regeneratingSceneId,
    visuals = {},
    narrationUrls = {},
    className,
}: SceneEditorProps) {
    const [expandedId, setExpandedId] = useState<string | null>(null);

    const handleSceneChange = useCallback((id: string, updates: Partial<Scene>) => {
        onChange(scenes.map(s => s.id === id ? { ...s, ...updates } : s));
    }, [scenes, onChange]);

    const handleDelete = useCallback((id: string) => {
        onChange(scenes.filter(s => s.id !== id));
    }, [scenes, onChange]);

    const handleAddScene = useCallback(() => {
        const newScene: Scene = {
            id: `scene-${Date.now()}`,
            name: `Scene ${scenes.length + 1}`,
            duration: 15,
            visualDescription: "",
            narrationScript: "",
            emotionalTone: "friendly",
            instructionTriplet: {
                primaryEmotion: "warm-welcome",
                cinematicDirection: "medium",
                environmentalAtmosphere: "soft-daylight",
            },
            transitionTo: "dissolve",
        };
        onChange([...scenes, newScene]);
        setExpandedId(newScene.id);
    }, [scenes, onChange]);

    const totalDuration = scenes.reduce((sum, s) => sum + s.duration, 0);

    return (
        <div className={cn("space-y-4", className)}>
            {/* Header */}
            <div className="flex items-center justify-between">
                <div>
                    <h3 className="text-lg font-semibold">Scenes</h3>
                    <p className="text-sm text-slate-400">
                        {scenes.length} scenes ‚Ä¢ {Math.floor(totalDuration / 60)}:{String(totalDuration % 60).padStart(2, '0')} total
                    </p>
                </div>
                <Button onClick={handleAddScene} size="sm" className="gap-2">
                    <Plus className="w-4 h-4" />
                    Add Scene
                </Button>
            </div>

            {/* Scene list */}
            <Reorder.Group
                axis="y"
                values={scenes}
                onReorder={onChange}
                className="space-y-2"
            >
                {scenes.map((scene, index) => (
                    <SceneCard
                        key={scene.id}
                        scene={scene}
                        index={index}
                        isExpanded={expandedId === scene.id}
                        isPlaying={playingSceneId === scene.id}
                        isRegenerating={regeneratingSceneId === scene.id}
                        imageUrl={visuals[scene.id]}
                        audioUrl={narrationUrls[scene.id]}
                        onToggleExpand={() => setExpandedId(expandedId === scene.id ? null : scene.id)}
                        onChange={(updates) => handleSceneChange(scene.id, updates)}
                        onDelete={() => handleDelete(scene.id)}
                        onPlayNarration={onPlayNarration ? () => onPlayNarration(scene.id) : undefined}
                        onRegenerateNarration={onRegenerateNarration ? () => onRegenerateNarration(scene.id) : undefined}
                    />
                ))}
            </Reorder.Group>

            {scenes.length === 0 && (
                <div className="text-center py-12 text-slate-500">
                    <Eye className="w-12 h-12 mx-auto mb-4 opacity-50" />
                    <p>No scenes yet. Click "Add Scene" to get started.</p>
                </div>
            )}
        </div>
    );
}

export default SceneEditor;
</file>

<file path="components/SEO/index.ts">
export { StructuredData, BreadcrumbStructuredData } from './StructuredData';
</file>

<file path="components/SEO/StructuredData.tsx">
/**
 * Structured Data (JSON-LD) component for SEO
 * Add this to your pages for better search engine understanding
 */

interface StructuredDataProps {
  type?: 'WebApplication' | 'WebSite' | 'Organization';
  name?: string;
  description?: string;
  url?: string;
}

export function StructuredData({
  type = 'WebApplication',
  name = 'LyricLens',
  description = 'AI-powered lyric video generator - Create stunning music videos with AI',
  url = 'https://yourdomain.com',
}: StructuredDataProps) {
  const structuredData = {
    '@context': 'https://schema.org',
    '@type': type,
    name,
    description,
    url,
    applicationCategory: 'MultimediaApplication',
    operatingSystem: 'Web Browser',
    offers: {
      '@type': 'Offer',
      price: '0',
      priceCurrency: 'USD',
    },
    featureList: [
      'AI-powered video generation',
      'Lyric synchronization',
      'Audio visualization',
      'Multi-language support',
    ],
  };

  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{ __html: JSON.stringify(structuredData) }}
    />
  );
}

/**
 * Breadcrumb structured data for navigation
 */
interface BreadcrumbItem {
  name: string;
  url: string;
}

interface BreadcrumbProps {
  items: BreadcrumbItem[];
}

export function BreadcrumbStructuredData({ items }: BreadcrumbProps) {
  const structuredData = {
    '@context': 'https://schema.org',
    '@type': 'BreadcrumbList',
    itemListElement: items.map((item, index) => ({
      '@type': 'ListItem',
      position: index + 1,
      name: item.name,
      item: item.url,
    })),
  };

  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{ __html: JSON.stringify(structuredData) }}
    />
  );
}
</file>

<file path="components/SettingsModal.tsx">
import React from "react";
import {
  Music,
  Speech,
  Smartphone,
  Monitor,
  Sparkles,
  Film,
  Zap,
  Target,
  User,
  X,
  Settings,
  Video,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogTitle,
} from "@/components/ui/dialog";
import { motion, AnimatePresence } from "framer-motion";
import { ART_STYLES, VIDEO_PURPOSES, type VideoPurpose } from "@/constants";
// cn utility removed - not used in this component

export interface SettingsModalProps {
  isOpen: boolean;
  onClose: () => void;
  contentType: "music" | "story";
  videoPurpose: VideoPurpose;
  generationMode: "image" | "video";
  videoProvider: "veo" | "deapi";
  veoVideoCount: number;
  aspectRatio: string;
  selectedStyle: string;
  globalSubject: string;
  onContentTypeChange: (type: "music" | "story") => void;
  onVideoPurposeChange: (purpose: VideoPurpose) => void;
  onGenerationModeChange: (mode: "image" | "video") => void;
  onVideoProviderChange: (provider: "veo" | "deapi") => void;
  onVeoVideoCountChange: (count: number) => void;
  onAspectRatioChange: (ratio: string) => void;
  onStyleChange: (style: string) => void;
  onGlobalSubjectChange: (subject: string) => void;
  targetAudience?: string;
  onTargetAudienceChange?: (audience: string) => void;
}

const SettingRow = ({ icon: Icon, label, children }: { icon: React.ElementType, label: string, children: React.ReactNode }) => (
  <div className="group relative">
    <div className="absolute -inset-2 bg-white/5 rounded-xl opacity-0 group-hover:opacity-100 transition-opacity" />
    <div className="relative flex items-center justify-between gap-4 p-1">
      <div className="flex items-center gap-3 text-muted-foreground group-hover:text-foreground transition-colors">
        <div className="w-8 h-8 rounded-lg bg-white/5 flex items-center justify-center">
          <Icon size={16} />
        </div>
        <span className="text-sm font-medium">{label}</span>
      </div>
      <div className="w-[200px]">
        {children}
      </div>
    </div>
  </div>
);

export const SettingsModal: React.FC<SettingsModalProps> = ({
  isOpen,
  onClose,
  contentType,
  videoPurpose,
  generationMode,
  videoProvider,
  veoVideoCount,
  aspectRatio,
  selectedStyle,
  globalSubject,
  onContentTypeChange,
  onVideoPurposeChange,
  onGenerationModeChange,
  onVideoProviderChange,
  onVeoVideoCountChange,
  onAspectRatioChange,
  onStyleChange,
  targetAudience, // Added prop
  onTargetAudienceChange, // Added prop
  onGlobalSubjectChange,
}) => {
  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent className="sm:max-w-2xl bg-background/80 backdrop-blur-2xl border-white/10 p-0 overflow-hidden gap-0 shadow-2xl shadow-black/50">
        {/* Header */}
        <div className="h-16 border-b border-white/10 flex items-center justify-between px-6 bg-white/5">
          <div className="flex items-center gap-3">
            <div className="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center">
              <Settings size={16} className="text-primary" />
            </div>
            <DialogTitle className="text-lg font-semibold tracking-tight">Studio Configuration</DialogTitle>
          </div>
          <button onClick={onClose} className="p-2 hover:bg-white/10 rounded-full transition-colors">
            <X size={18} className="text-muted-foreground" />
          </button>
        </div>

        <div className="p-6 space-y-8 max-h-[70vh] overflow-y-auto no-scrollbar">

          {/* Section: Project Basics */}
          <section className="space-y-4">
            <h3 className="text-xs font-bold text-muted-foreground/50 uppercase tracking-widest px-1">Core Settings</h3>

            <SettingRow icon={contentType === "music" ? Music : Speech} label="Content Mode">
              <Select value={contentType} onValueChange={onContentTypeChange}>
                <SelectTrigger className="h-9 bg-black/20 border-white/10">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="music">Music Video</SelectItem>
                  <SelectItem value="story">Story / Speech</SelectItem>
                </SelectContent>
              </Select>
            </SettingRow>

            <SettingRow icon={aspectRatio === "16:9" ? Monitor : Smartphone} label="Aspect Ratio">
              <Select value={aspectRatio} onValueChange={onAspectRatioChange}>
                <SelectTrigger className="h-9 bg-black/20 border-white/10">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="16:9">16:9 Landscape</SelectItem>
                  <SelectItem value="9:16">9:16 Portrait</SelectItem>
                </SelectContent>
              </Select>
            </SettingRow>

            <SettingRow icon={Target} label="Video Purpose">
              <Select value={videoPurpose} onValueChange={onVideoPurposeChange}>
                <SelectTrigger className="h-9 bg-black/20 border-white/10">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {VIDEO_PURPOSES.map((purpose) => (
                    <SelectItem key={purpose.value} value={purpose.value}>
                      {purpose.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </SettingRow>
            <SettingRow icon={User} label="Target Audience">
              <Input
                value={targetAudience || ""}
                onChange={(e) => onTargetAudienceChange?.(e.target.value)}
                placeholder="e.g. Children, Professionals, General"
                className="h-9 bg-black/20 border-white/10"
              />
            </SettingRow>
          </section>

          {/* Section: Output Pipeline */}
          <section className="space-y-4">
            <h3 className="text-xs font-bold text-muted-foreground/50 uppercase tracking-widest px-1">Rendering Engine</h3>

            <SettingRow icon={Film} label="Output Format">
              <Select value={generationMode} onValueChange={onGenerationModeChange}>
                <SelectTrigger className="h-9 bg-black/20 border-white/10">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="image">Static Images</SelectItem>
                  <SelectItem value="video">Motion Loops</SelectItem>
                </SelectContent>
              </Select>
            </SettingRow>

            <AnimatePresence>
              {generationMode === "video" && (
                <motion.div
                  initial={{ opacity: 0, height: 0 }}
                  animate={{ opacity: 1, height: "auto" }}
                  exit={{ opacity: 0, height: 0 }}
                >
                  <SettingRow icon={Zap} label="Video Engine">
                    <Select value={videoProvider} onValueChange={onVideoProviderChange}>
                      <SelectTrigger className="h-9 bg-black/20 border-white/10">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="veo">Google Veo (Premium)</SelectItem>
                        <SelectItem value="deapi">DeAPI (Fast)</SelectItem>
                      </SelectContent>
                    </Select>
                  </SettingRow>

                  {videoProvider === "veo" && (
                    <SettingRow icon={Video} label="Pro Video Scenes">
                      <div className="flex items-center gap-3">
                        <input
                          type="range"
                          min="0"
                          max="5"
                          value={veoVideoCount}
                          onChange={(e) => onVeoVideoCountChange(Number(e.target.value))}
                          className="w-24 h-2 bg-white/10 rounded-full appearance-none cursor-pointer [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:w-4 [&::-webkit-slider-thumb]:h-4 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-primary"
                        />
                        <span className="text-sm font-mono w-6 text-center">{veoVideoCount}</span>
                      </div>
                    </SettingRow>
                  )}
                </motion.div>
              )}
            </AnimatePresence>
          </section>

          {/* Section: Aesthetics */}
          <section className="space-y-4">
            <h3 className="text-xs font-bold text-muted-foreground/50 uppercase tracking-widest px-1">Art Direction</h3>

            <SettingRow icon={Sparkles} label="Visual Style">
              <Select value={selectedStyle} onValueChange={onStyleChange}>
                <SelectTrigger className="h-9 bg-black/20 border-white/10">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent className="max-h-[200px]">
                  {ART_STYLES.map((style) => (
                    <SelectItem key={style} value={style}>{style}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </SettingRow>

            <SettingRow icon={User} label="Main Subject">
              <Input
                value={globalSubject}
                onChange={(e) => onGlobalSubjectChange(e.target.value)}
                placeholder="e.g. A red robot"
                className="h-9 bg-black/20 border-white/10"
              />
            </SettingRow>
          </section>

        </div>

        {/* Footer */}
        <div className="p-6 border-t border-white/10 bg-white/5 flex justify-end">
          <Button onClick={onClose} className="bg-primary text-primary-foreground hover:bg-primary/90">
            Save Changes
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
};
</file>

<file path="components/story/BreakdownProgress.tsx">
/**
 * BreakdownProgress.tsx
 * Loading screen for story breakdown generation with stage tracking.
 */

import React from 'react';
import { motion } from 'framer-motion';
import { CheckCircle2, Circle, Loader2 } from 'lucide-react';
import { useLanguage } from '@/i18n/useLanguage';

export type BreakdownStage =
    | 'reading'
    | 'aligning'
    | 'identifying'
    | 'creating';

interface BreakdownProgressProps {
    currentStage: BreakdownStage;
    isComplete?: boolean;
    genre?: string;
}

interface StageConfig {
    id: BreakdownStage;
    label: string;
}

const STAGE_KEYS: Record<BreakdownStage, string> = {
    reading: 'story.breakdown_progress.readingIdea',
    aligning: 'story.breakdown_progress.aligningGenre',
    identifying: 'story.breakdown_progress.identifyingCharacters',
    creating: 'story.breakdown_progress.creatingBreakdown',
};

const STAGES: StageConfig[] = [
    { id: 'reading', label: 'Reading your story idea' },
    { id: 'aligning', label: 'Aligning with genre' },
    { id: 'identifying', label: 'Identifying characters' },
    { id: 'creating', label: 'Creating scene breakdown' },
];

const getStageIndex = (stage: BreakdownStage): number => {
    return STAGES.findIndex(s => s.id === stage);
};

export const BreakdownProgress: React.FC<BreakdownProgressProps> = ({
    currentStage,
    isComplete = false,
    genre = 'your genre',
}) => {
    const { t } = useLanguage();
    const currentIndex = getStageIndex(currentStage);

    const getStageStatus = (index: number): 'complete' | 'processing' | 'pending' => {
        if (isComplete) return 'complete';
        if (index < currentIndex) return 'complete';
        if (index === currentIndex) return 'processing';
        return 'pending';
    };

    const getStageLabel = (stage: StageConfig) => {
        if (stage.id === 'aligning') {
            return t('story.breakdown_progress.aligningWith', { genre });
        }
        return t(STAGE_KEYS[stage.id]);
    };

    return (
        <div className="flex flex-col items-center justify-center min-h-[70vh] p-8">
            <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.2, ease: 'easeOut' }}
                className="w-full max-w-lg"
            >
                {/* Header */}
                <div className="text-center mb-12">
                    <div className="flex items-center justify-center mb-6">
                        <Loader2 className="w-8 h-8 text-blue-500 animate-spin" />
                    </div>
                    <h2 className="font-sans text-2xl font-medium tracking-tight text-zinc-100 mb-3">
                        {t('story.breakdown_progress.developing')}
                    </h2>
                    <p className="text-zinc-500 text-sm">
                        {t('story.breakdown_progress.craftedFrameByFrame')}
                    </p>
                </div>

                {/* Stage List */}
                <div className="space-y-0">
                    {STAGES.map((stage, index) => {
                        const status = getStageStatus(index);
                        return (
                            <motion.div
                                key={stage.id}
                                initial={{ opacity: 0, x: -10 }}
                                animate={{ opacity: 1, x: 0 }}
                                transition={{ duration: 0.2, ease: 'easeOut', delay: index * 0.08 }}
                                className={`
                                    relative pl-8 py-4 border-l transition-all duration-200 ease-out
                                    ${status === 'complete'
                                        ? 'border-blue-500'
                                        : status === 'processing'
                                            ? 'border-zinc-400'
                                            : 'border-zinc-800'
                                    }
                                `}
                            >
                                {/* Frame Number */}
                                <span className="absolute left-3 top-4 font-mono text-[10px] text-zinc-700">
                                    {String(index + 1).padStart(2, '0')}
                                </span>

                                {/* Stage Content */}
                                <div className="flex items-center justify-between">
                                    <div className="flex items-center gap-3">
                                        {status === 'complete' && (
                                            <CheckCircle2 className="w-5 h-5 text-blue-400" />
                                        )}
                                        {status === 'processing' && (
                                            <Loader2 className="w-5 h-5 text-zinc-400 animate-spin" />
                                        )}
                                        {status === 'pending' && (
                                            <Circle className="w-5 h-5 text-zinc-700" />
                                        )}

                                        <span className={`
                                            font-sans text-sm transition-colors duration-200 ease-out
                                            ${status === 'complete' || status === 'processing'
                                                ? 'text-zinc-300'
                                                : 'text-zinc-600'
                                            }
                                        `}>
                                            {getStageLabel(stage)}
                                        </span>
                                    </div>

                                    {status === 'processing' && (
                                        <motion.span
                                            animate={{ opacity: [0.3, 1, 0.3] }}
                                            transition={{ duration: 1.5, repeat: Infinity }}
                                            className="font-mono text-[10px] text-zinc-500 uppercase tracking-widest"
                                        >
                                            {t('story.breakdown_progress.processing')}
                                        </motion.span>
                                    )}
                                </div>
                            </motion.div>
                        );
                    })}
                </div>

                {/* Footer */}
                <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    transition={{ delay: 0.4 }}
                    className="mt-12 text-center"
                >
                    <span className="font-mono text-[10px] text-zinc-700 tracking-widest">
                        PROCESSING
                    </span>
                </motion.div>
            </motion.div>
        </div>
    );
};

export default BreakdownProgress;
</file>

<file path="components/story/CharacterView.tsx">
import React from 'react';
import type { CharacterProfile, ConsistencyReport } from '@/types';
import { ShieldCheck, AlertCircle, UserPlus, Trash2, RotateCcw, ImagePlus, User, Sparkles } from 'lucide-react';
import { useLanguage } from '@/i18n/useLanguage';

interface CharacterViewProps {
    characters: CharacterProfile[];
    reports?: Record<string, ConsistencyReport>;
    onVerify?: (name: string) => void;
    isProcessing?: boolean;
    onAdd?: () => void;
    onEdit?: (character: CharacterProfile) => void;
    onDelete?: (characterId: string) => void;
    onGenerateImage?: (characterId: string) => void;
}

export const CharacterView: React.FC<CharacterViewProps> = ({
    characters,
    reports = {},
    onVerify,
    isProcessing = false,
    onAdd,
    onEdit,
    onDelete,
    onGenerateImage
}) => {
    const { t } = useLanguage();

    return (
        <div className="flex flex-col h-full bg-black">
            {/* Header */}
            <div className="flex justify-between items-center bg-zinc-950 border-b border-zinc-800 px-8 py-5">
                <div className="flex items-center gap-6">
                    <div>
                        <h2 className="font-sans text-xl font-medium tracking-tight text-zinc-100">
                            Characters
                        </h2>
                        <p className="text-zinc-500 text-xs mt-1">
                            Story ensemble
                        </p>
                    </div>
                    <div className="bg-zinc-900 border border-zinc-800 rounded-sm px-2 py-1">
                        <span className="font-mono text-xs text-blue-400">
                            {characters.length} MEMBER{characters.length !== 1 ? 'S' : ''}
                        </span>
                    </div>
                </div>
            </div>

            {/* Grid Content */}
            <div className="flex-1 p-8 overflow-y-auto">
                <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                    {characters.map((char) => {
                        const report = reports[char.name];
                        return (
                            <div
                                key={char.id}
                                className="group relative bg-zinc-900 border border-zinc-800 rounded-sm overflow-hidden hover:-translate-y-0.5 transition-transform duration-200 ease-out"
                            >
                                {/* Portrait Area - 2:3 Aspect */}
                                <div className="aspect-[2/3] w-full relative overflow-hidden bg-zinc-950">
                                    {char.referenceImageUrl ? (
                                        <img
                                            src={char.referenceImageUrl}
                                            alt={char.name}
                                            className="w-full h-full object-cover"
                                        />
                                    ) : (
                                        <div className="w-full h-full flex flex-col items-center justify-center gap-3">
                                            <User className="w-16 h-16 text-zinc-800" />
                                            <span className="font-mono text-[10px] text-zinc-700 uppercase tracking-widest">
                                                No Portrait
                                            </span>
                                        </div>
                                    )}

                                    {/* Name Plate */}
                                    <div className="absolute bottom-0 left-0 right-0 bg-zinc-950/90 p-3 border-t border-zinc-800">
                                        <h3 className="font-sans text-base font-medium text-zinc-100 leading-tight" dir="auto">
                                            {char.name}
                                        </h3>
                                        <p className="font-mono text-xs text-blue-400 mt-0.5" dir="auto">
                                            {char.role || 'Character'}
                                        </p>
                                    </div>

                                    {/* Consistency Score Badge */}
                                    {report && (
                                        <div className="absolute top-3 left-3">
                                            <div className={`
                                                px-2 py-1 rounded-sm
                                                font-mono text-[10px] uppercase tracking-wider
                                                flex items-center gap-1.5
                                                backdrop-blur-md border
                                                ${report.isConsistent
                                                    ? 'bg-emerald-500/10 border-emerald-500/30 text-emerald-400'
                                                    : 'bg-orange-500/10 border-orange-500/30 text-orange-400'}
                                            `}>
                                                {report.isConsistent
                                                    ? <ShieldCheck className="w-3 h-3" />
                                                    : <AlertCircle className="w-3 h-3" />
                                                }
                                                <span>{Math.round(report.score)}%</span>
                                            </div>
                                        </div>
                                    )}

                                    {/* Hover Actions Overlay */}
                                    <div className="
                                        absolute inset-0
                                        bg-black/80
                                        opacity-0 group-hover:opacity-100
                                        transition-opacity duration-200 ease-out
                                        flex items-center justify-center gap-3
                                    ">
                                        {onVerify && (
                                            <button
                                                onClick={() => onVerify(char.name)}
                                                disabled={isProcessing}
                                                className="rounded-sm bg-zinc-900 border border-zinc-800 p-2.5 text-zinc-400 hover:text-blue-400 transition-colors duration-200"
                                                title={t('story.verifyContinuity')}
                                            >
                                                {isProcessing
                                                    ? <div className="w-5 h-5 rounded-sm border-2 border-zinc-700 border-t-blue-400 animate-spin" />
                                                    : <RotateCcw className="w-5 h-5" />
                                                }
                                            </button>
                                        )}
                                        {onGenerateImage && (
                                            <button
                                                onClick={() => onGenerateImage(char.id)}
                                                disabled={isProcessing}
                                                className="bg-blue-500 text-white rounded-sm p-2.5 transition-colors duration-200"
                                                title={char.referenceImageUrl ? "Regenerate Portrait" : "Generate Portrait"}
                                            >
                                                {isProcessing
                                                    ? <div className="w-5 h-5 rounded-sm border-2 border-white/30 border-t-white animate-spin" />
                                                    : <ImagePlus className="w-5 h-5" />
                                                }
                                            </button>
                                        )}
                                        {onEdit && (
                                            <button
                                                onClick={() => onEdit(char)}
                                                className="rounded-sm bg-zinc-900 border border-zinc-800 p-2.5 text-zinc-400 hover:text-blue-400 transition-colors duration-200"
                                            >
                                                <Sparkles className="w-5 h-5" />
                                            </button>
                                        )}
                                        {onDelete && (
                                            <button
                                                onClick={() => onDelete(char.id)}
                                                className="rounded-sm p-2.5 bg-red-500/10 border border-red-500/30 text-red-400 hover:bg-red-500/20 transition-colors duration-200"
                                            >
                                                <Trash2 className="w-5 h-5" />
                                            </button>
                                        )}
                                    </div>
                                </div>
                            </div>
                        );
                    })}

                    {/* Add New Card */}
                    {onAdd && (
                        <button
                            onClick={onAdd}
                            className="
                                group relative
                                flex flex-col items-center justify-center
                                aspect-[2/3]
                                bg-zinc-950
                                rounded-sm
                                border border-dashed border-zinc-800
                                hover:border-blue-500/50
                                hover:-translate-y-0.5
                                transition-all duration-200 ease-out
                            "
                        >
                            <div className="
                                w-16 h-16 rounded-sm
                                bg-zinc-900 border border-zinc-800
                                flex items-center justify-center
                                mb-4
                            ">
                                <UserPlus className="w-7 h-7 text-zinc-500 group-hover:text-zinc-300 transition-colors duration-200" />
                            </div>
                            <span className="font-sans text-sm text-zinc-500 group-hover:text-zinc-300 transition-colors duration-200">
                                Add Character
                            </span>
                        </button>
                    )}
                </div>
            </div>
        </div>
    );
};

export default CharacterView;
</file>

<file path="components/story/ExportOptionsPanel.tsx">
/**
 * ExportOptionsPanel - Export options for Story Mode projects.
 */

import React, { useState, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Download,
  FileVideo,
  FileJson,
  Subtitles,
  Upload,
  Check,
  AlertCircle,
  Loader2,
  X,
  Globe,
  Wifi,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import type { StoryState } from '@/types';
import { useLanguage } from '@/i18n/useLanguage';
import { isNative } from '@/utils/platformUtils';
import {
  downloadSubtitles,
  downloadProjectJSON,
  importProjectFromJSON,
  downloadAsWebM,
} from '@/services/exportFormatsService';

interface ExportOptionsPanelProps {
  storyState: StoryState;
  videoBlob?: Blob | null;
  onImportProject?: (state: StoryState) => void;
  onExportVideo?: () => Promise<Blob | null | undefined>;
  className?: string;
}

type ExportStatus = 'idle' | 'loading' | 'success' | 'error';

interface ExportOption {
  id: string;
  name: string;
  description: string;
  icon: React.ReactNode;
  category: 'video' | 'subtitle' | 'project';
  action: () => Promise<void> | void;
  disabled?: boolean;
  disabledReason?: string;
}

export function ExportOptionsPanel({
  storyState,
  videoBlob,
  onImportProject,
  onExportVideo,
  className,
}: ExportOptionsPanelProps) {
  const { t } = useLanguage();
  const [exportStatus, setExportStatus] = useState<Record<string, ExportStatus>>({});
  const [error, setError] = useState<string | null>(null);
  const [showImportDialog, setShowImportDialog] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const hasShots = (storyState.shots?.length ?? 0) > 0;
  const hasVideo = videoBlob !== null && videoBlob !== undefined;

  const setStatus = (id: string, status: ExportStatus) => {
    setExportStatus(prev => ({ ...prev, [id]: status }));
  };

  const handleExportSRT = async () => {
    setStatus('srt', 'loading');
    try {
      downloadSubtitles(storyState, 'srt', 'shots');
      setStatus('srt', 'success');
      setTimeout(() => setStatus('srt', 'idle'), 2000);
    } catch {
      setStatus('srt', 'error');
      setError('Failed to export SRT subtitles');
    }
  };

  const handleExportVTT = async () => {
    setStatus('vtt', 'loading');
    try {
      downloadSubtitles(storyState, 'vtt', 'shots');
      setStatus('vtt', 'success');
      setTimeout(() => setStatus('vtt', 'idle'), 2000);
    } catch {
      setStatus('vtt', 'error');
      setError('Failed to export VTT subtitles');
    }
  };

  const handleExportJSON = async () => {
    setStatus('json', 'loading');
    try {
      downloadProjectJSON(storyState);
      setStatus('json', 'success');
      setTimeout(() => setStatus('json', 'idle'), 2000);
    } catch {
      setStatus('json', 'error');
      setError('Failed to export project');
    }
  };

  const handleExportWebM = async () => {
    if (!videoBlob) {
      setError('No video to export. Generate a video first.');
      return;
    }
    setStatus('webm', 'loading');
    try {
      const filename = storyState.script?.title || 'story';
      await downloadAsWebM(videoBlob, filename);
      setStatus('webm', 'success');
      setTimeout(() => setStatus('webm', 'idle'), 2000);
    } catch {
      setStatus('webm', 'error');
      setError('Failed to export WebM video');
    }
  };

  const handleExportMP4 = async () => {
    if (!onExportVideo) {
      setError('Video export not available');
      return;
    }
    setStatus('mp4', 'loading');
    try {
      const blob = await onExportVideo();
      if (blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${storyState.script?.title || 'story'}.mp4`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        setStatus('mp4', 'success');
        setTimeout(() => setStatus('mp4', 'idle'), 2000);
      } else {
        throw new Error('No video generated');
      }
    } catch (err) {
      setStatus('mp4', 'error');
      const detail = err instanceof Error ? err.message : String(err);
      setError(`Failed to export MP4 video: ${detail}`);
    }
  };

  const handleImportFile = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    setStatus('import', 'loading');
    try {
      const result = await importProjectFromJSON(file);
      if (result.success && result.state) {
        onImportProject?.(result.state);
        setStatus('import', 'success');
        setShowImportDialog(false);
        setTimeout(() => setStatus('import', 'idle'), 2000);
      } else {
        throw new Error(result.error || 'Failed to import project');
      }
    } catch (err) {
      setStatus('import', 'error');
      setError(err instanceof Error ? err.message : 'Failed to import project');
    }

    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const exportOptions: ExportOption[] = [
    {
      id: 'mp4',
      name: t('story.export_panel.mp4Video'),
      description: t('story.export_panel.mp4Desc'),
      icon: <FileVideo className="w-5 h-5" />,
      category: 'video',
      action: handleExportMP4,
      disabled: !onExportVideo,
      disabledReason: t('story.export_panel.generateVideoFirst'),
    },
    {
      id: 'webm',
      name: t('story.export_panel.webmVideo'),
      description: t('story.export_panel.webmDesc'),
      icon: <Globe className="w-5 h-5" />,
      category: 'video',
      action: handleExportWebM,
      disabled: !hasVideo,
      disabledReason: t('story.export_panel.generateVideoFirst'),
    },
    {
      id: 'srt',
      name: t('story.export_panel.srtSubtitles'),
      description: t('story.export_panel.srtDesc'),
      icon: <Subtitles className="w-5 h-5" />,
      category: 'subtitle',
      action: handleExportSRT,
      disabled: !hasShots,
      disabledReason: t('story.export_panel.generateShotsFirst'),
    },
    {
      id: 'vtt',
      name: t('story.export_panel.webvttSubtitles'),
      description: t('story.export_panel.webvttDesc'),
      icon: <Subtitles className="w-5 h-5" />,
      category: 'subtitle',
      action: handleExportVTT,
      disabled: !hasShots,
      disabledReason: t('story.export_panel.generateShotsFirst'),
    },
    {
      id: 'json',
      name: t('story.export_panel.projectFile'),
      description: t('story.export_panel.projectFileDesc'),
      icon: <FileJson className="w-5 h-5" />,
      category: 'project',
      action: handleExportJSON,
    },
  ];

  const getStatusIcon = (id: string) => {
    const status = exportStatus[id];
    switch (status) {
      case 'loading':
        return <Loader2 className="w-4 h-4 animate-spin" />;
      case 'success':
        return <Check className="w-4 h-4 text-emerald-400" />;
      case 'error':
        return <AlertCircle className="w-4 h-4 text-red-400" />;
      default:
        return <Download className="w-4 h-4" />;
    }
  };

  const videoOptions = exportOptions.filter(o => o.category === 'video');
  const subtitleOptions = exportOptions.filter(o => o.category === 'subtitle');
  const projectOptions = exportOptions.filter(o => o.category === 'project');

  const renderOptionGrid = (options: ExportOption[], accentClass: string) => (
    <div className="grid grid-cols-2 gap-2">
      {options.map((option) => (
        <button
          key={option.id}
          onClick={() => option.action()}
          disabled={option.disabled || exportStatus[option.id] === 'loading'}
          className={cn(
            'p-3 rounded-sm border text-left transition-all duration-200',
            option.disabled
              ? 'border-zinc-800/50 bg-zinc-900/50 opacity-50 cursor-not-allowed'
              : 'border-zinc-800 bg-zinc-900 hover:border-blue-500/40 hover:bg-blue-500/5'
          )}
        >
          <div className="flex items-center justify-between mb-1">
            <span className={accentClass}>{option.icon}</span>
            {getStatusIcon(option.id)}
          </div>
          <p className="text-sm font-medium text-zinc-100">{option.name}</p>
          <p className="text-xs text-zinc-600">
            {option.disabled ? option.disabledReason : option.description}
          </p>
        </button>
      ))}
    </div>
  );

  return (
    <div className={cn('bg-zinc-950 rounded-sm border border-zinc-800 p-4', className)}>
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-2">
          <Download className="w-5 h-5 text-blue-400" />
          <h3 className="font-sans font-medium text-zinc-100">{t('story.export_panel.exportOptions')}</h3>
        </div>
        {onImportProject && (
          <button
            onClick={() => setShowImportDialog(true)}
            className="flex items-center gap-1.5 px-3 py-1.5 text-sm text-zinc-500 hover:text-zinc-100 hover:bg-zinc-800 rounded-sm transition-colors duration-200"
          >
            <Upload className="w-4 h-4" />
            {t('common.import')}
          </button>
        )}
      </div>

      {/* Error Display */}
      <AnimatePresence>
        {error && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.15 }}
            className="mb-4 p-3 bg-red-500/10 border border-red-500/30 rounded-sm flex items-start gap-2"
          >
            <AlertCircle className="w-4 h-4 text-red-400 flex-shrink-0 mt-0.5" />
            <p className="flex-1 text-sm text-red-300">{error}</p>
            <button onClick={() => setError(null)} className="text-red-400 hover:text-red-300">
              <X className="w-4 h-4" />
            </button>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Native / mobile server URL warning */}
      {isNative() && !import.meta.env.VITE_SERVER_URL && (
        <div className="mb-4 p-3 bg-amber-500/10 border border-amber-500/30 rounded-sm flex items-start gap-2">
          <Wifi className="w-4 h-4 text-amber-400 flex-shrink-0 mt-0.5" />
          <p className="text-xs text-amber-300 leading-relaxed">
            <span className="font-semibold">Mobile export requires a LAN connection.</span>{' '}
            Add <code className="font-mono bg-amber-500/10 px-1 rounded">VITE_SERVER_URL=http://&lt;your-pc-ip&gt;:3001</code> to{' '}
            <code className="font-mono">.env.local</code> and rebuild the app so the device can reach the export server.
          </p>
        </div>
      )}

      {/* Video Exports */}
      <div className="mb-4">
        <h4 className="font-mono text-[10px] text-zinc-600 uppercase tracking-widest mb-2">
          {t('story.export_panel.videoFormats')}
        </h4>
        {renderOptionGrid(videoOptions, 'text-blue-400')}
      </div>

      {/* Subtitle Exports */}
      <div className="mb-4">
        <h4 className="font-mono text-[10px] text-zinc-600 uppercase tracking-widest mb-2">
          {t('story.export_panel.subtitles')}
        </h4>
        {renderOptionGrid(subtitleOptions, 'text-blue-400')}
      </div>

      {/* Project Exports */}
      <div>
        <h4 className="font-mono text-[10px] text-zinc-600 uppercase tracking-widest mb-2">
          {t('story.export_panel.project')}
        </h4>
        {renderOptionGrid(projectOptions, 'text-orange-400')}
      </div>

      {/* Import Dialog */}
      <AnimatePresence>
        {showImportDialog && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.15 }}
            className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 z-50"
            onClick={() => setShowImportDialog(false)}
          >
            <motion.div
              initial={{ scale: 0.97, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0.97, opacity: 0 }}
              transition={{ duration: 0.15 }}
              className="w-full max-w-md bg-zinc-900 rounded-sm border border-zinc-800 p-6"
              onClick={(e) => e.stopPropagation()}
            >
              <h4 className="font-sans text-lg font-medium text-zinc-100 mb-2">{t('story.export_panel.importProject')}</h4>
              <p className="text-sm text-zinc-500 mb-4">
                {t('story.export_panel.importProjectDesc')}
              </p>

              <input
                ref={fileInputRef}
                type="file"
                accept=".json"
                onChange={handleImportFile}
                className="hidden"
              />

              <div
                onClick={() => fileInputRef.current?.click()}
                className="border-2 border-dashed border-zinc-700 rounded-sm p-8 text-center cursor-pointer hover:border-blue-500/40 hover:bg-blue-500/5 transition-all duration-200"
              >
                <Upload className="w-10 h-10 mx-auto mb-3 text-zinc-600" />
                <p className="text-zinc-500">{t('story.export_panel.clickToSelect')}</p>
                <p className="text-xs text-zinc-700 mt-1">{t('story.export_panel.orDragDrop')}</p>
              </div>

              <div className="flex items-center justify-end gap-3 mt-6">
                <button
                  onClick={() => setShowImportDialog(false)}
                  className="px-4 py-2 text-zinc-500 hover:text-zinc-100 transition-colors duration-200"
                >
                  {t('common.cancel')}
                </button>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

export default ExportOptionsPanel;
</file>

<file path="components/story/IdeaView.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { Sparkles, Heart, Laugh, Skull, Rocket, Search, Sword, Ghost, Crown, Baby, BookOpen, Lightbulb, Wand2, ChevronRight, Layout, ArrowRight } from 'lucide-react';
import { TemplatesGallery } from './TemplatesGallery';
import type { StoryState } from '@/types';
import { useLanguage } from '@/i18n/useLanguage';

interface IdeaViewProps {
    initialTopic?: string;
    onGenerate: (topic: string, genre: string) => void;
    onApplyTemplate?: (state: Partial<StoryState>) => void;
    isProcessing?: boolean;
}

const GENRES = [
    { id: 'Drama', icon: Heart },
    { id: 'Comedy', icon: Laugh },
    { id: 'Thriller', icon: Skull },
    { id: 'Sci-Fi', icon: Rocket },
    { id: 'Mystery', icon: Search },
    { id: 'Action', icon: Sword },
    { id: 'Horror', icon: Ghost },
    { id: 'Fantasy', icon: Wand2 },
    { id: 'Romance', icon: Heart },
    { id: 'Historical', icon: Crown },
    { id: 'Documentary', icon: BookOpen },
    { id: 'Animation', icon: Baby },
];

const STORY_TEMPLATES = [
    { genre: 'Drama', prompt: 'A family reunites after 20 years to confront a secret that tore them apart...' },
    { genre: 'Thriller', prompt: 'A detective discovers that the murder they\'re investigating was committed by their own future self...' },
    { genre: 'Sci-Fi', prompt: 'In 2150, humanity discovers that Earth\'s moon is actually an ancient alien spacecraft...' },
    { genre: 'Mystery', prompt: 'A small town librarian finds coded messages hidden in returned books, leading to a decades-old conspiracy...' },
    { genre: 'Comedy', prompt: 'A wedding planner must organize the perfect ceremony for their ex and their new partner...' },
    { genre: 'Action', prompt: 'A retired spy is pulled back into the game when their grandchild is kidnapped by an old enemy...' },
    { genre: 'Horror', prompt: 'A family moves into their dream home, only to discover the previous owners never actually left...' },
    { genre: 'Fantasy', prompt: 'A young mapmaker discovers their drawings have the power to reshape reality...' },
    { genre: 'Romance', prompt: 'Two rival food truck owners compete for the same corner, but find themselves falling for each other...' },
    { genre: 'Historical', prompt: 'The untold story of the women codebreakers who helped win World War II...' },
    { genre: 'Documentary', prompt: 'An exploration of how a small village in Japan became the world\'s longest-living community...' },
    { genre: 'Animation', prompt: 'A young robot dreams of becoming a painter in a world where machines aren\'t supposed to create art...' },
];

export const IdeaView: React.FC<IdeaViewProps> = ({
    initialTopic = '',
    onGenerate,
    onApplyTemplate,
    isProcessing = false
}) => {
    const { t } = useLanguage();
    const [topic, setTopic] = useState(initialTopic);
    const [genre, setGenre] = useState('Drama');
    const [showAllGenres, setShowAllGenres] = useState(false);
    const [showTemplatesGallery, setShowTemplatesGallery] = useState(false);
    const [expandMessage, setExpandMessage] = useState<string | null>(null);
    const textareaRef = useRef<HTMLTextAreaElement>(null);

    const currentTemplate = STORY_TEMPLATES.find(t => t.genre === genre);
    const visibleGenres = showAllGenres ? GENRES : GENRES.slice(0, 6);

    const handleUseTemplate = () => {
        if (currentTemplate) {
            setTopic(currentTemplate.prompt);
            textareaRef.current?.focus();
        }
    };

    /** Smart Expand: enrich short prompts with narrative scaffolding */
    const handleSmartExpand = () => {
        if (!topic.trim()) return;
        if (topic.length < 50) {
            setTopic(
                'Expand this idea into a rich narrative: ' +
                topic +
                '... (include vivid settings, character motivations, and a surprising twist)'
            );
            textareaRef.current?.focus();
        } else {
            setExpandMessage('Prompt is already detailed enough');
            setTimeout(() => setExpandMessage(null), 2000);
        }
    };

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (topic.trim() && !isProcessing) {
            onGenerate(topic.trim(), genre);
        }
    };

    // Auto-resize textarea
    useEffect(() => {
        if (textareaRef.current) {
            textareaRef.current.style.height = 'auto';
            textareaRef.current.style.height = Math.max(120, textareaRef.current.scrollHeight) + 'px';
        }
    }, [topic]);

    return (
        <div className="flex flex-col items-center min-h-[70vh] px-6 py-12 bg-black">
            <div className="w-full max-w-2xl">
                {/* Header */}
                <div className="mb-10">
                    <h1 className="font-sans text-3xl font-medium tracking-tight text-zinc-100">
                        {t('story.whatsYourStory')}
                    </h1>
                    <p className="text-zinc-500 text-sm mt-2 leading-relaxed">
                        {t('story.describeYourConcept')}
                    </p>
                </div>

                <form onSubmit={handleSubmit} className="space-y-8">
                    {/* Textarea */}
                    <div>
                        <div className="bg-zinc-900 border border-zinc-800 rounded-sm focus-within:border-blue-500/50 transition-colors duration-200">
                            <textarea
                                ref={textareaRef}
                                id="topic-input"
                                value={topic}
                                onChange={(e) => setTopic(e.target.value)}
                                placeholder={t('story.placeholderStory')}
                                className="
                                    w-full min-h-[120px] px-5 py-4
                                    bg-transparent
                                    text-[15px] text-zinc-100 leading-relaxed
                                    placeholder:text-zinc-600
                                    focus:outline-none
                                    resize-none
                                "
                                disabled={isProcessing}
                                autoFocus
                            />

                            {/* Bottom bar */}
                            <div className="flex items-center justify-between px-5 pb-3.5 pt-0">
                                <div className="flex items-center gap-3">
                                    <button
                                        type="button"
                                        onClick={handleUseTemplate}
                                        disabled={isProcessing || !currentTemplate}
                                        className="flex items-center gap-1.5 text-xs font-mono text-zinc-500 hover:text-zinc-300 transition-colors duration-200 disabled:opacity-30 disabled:hover:text-zinc-500"
                                    >
                                        <Lightbulb className="w-3.5 h-3.5" />
                                        <span>{t('story.tryTemplate')}</span>
                                    </button>
                                    {onApplyTemplate && (
                                        <>
                                            <div className="w-px h-3 bg-zinc-800" />
                                            <button
                                                type="button"
                                                onClick={() => setShowTemplatesGallery(true)}
                                                disabled={isProcessing}
                                                className="flex items-center gap-1.5 text-xs font-mono text-zinc-500 hover:text-zinc-300 transition-colors duration-200 disabled:opacity-30"
                                            >
                                                <Layout className="w-3.5 h-3.5" />
                                                <span>{t('story.browseAll')}</span>
                                            </button>
                                        </>
                                    )}
                                </div>
                                <span className="font-mono text-[10px] text-zinc-600 tabular-nums">
                                    {topic.length}
                                </span>
                            </div>
                        </div>
                    </div>

                    {/* Smart Expand Button */}
                    <div className="relative">
                        <button
                            type="button"
                            onClick={handleSmartExpand}
                            disabled={isProcessing || !topic.trim()}
                            className="bg-zinc-900 border border-zinc-800 rounded-sm text-zinc-400 hover:text-blue-400 hover:border-blue-500/50 transition-colors duration-200 px-3 py-1.5 text-xs font-mono flex items-center gap-1.5 disabled:opacity-30 disabled:cursor-not-allowed"
                        >
                            <Sparkles className="w-3.5 h-3.5" />
                            <span>Smart Expand</span>
                        </button>
                        {expandMessage && (
                            <span className="absolute left-0 top-full mt-1.5 text-xs font-mono text-zinc-500 animate-pulse">
                                {expandMessage}
                            </span>
                        )}
                    </div>

                    {/* Genre Selection */}
                    <div>
                        <div className="flex items-center justify-between mb-3">
                            <span className="font-mono text-[11px] font-medium tracking-[0.15em] uppercase text-zinc-500">
                                {t('story.genre')}
                            </span>
                            {!showAllGenres && GENRES.length > 6 && (
                                <button
                                    type="button"
                                    onClick={() => setShowAllGenres(true)}
                                    className="flex items-center gap-1 text-xs font-mono text-zinc-500 hover:text-zinc-300 transition-colors duration-200"
                                >
                                    <span>{t('story.allCount', { count: GENRES.length })}</span>
                                    <ChevronRight className="w-3 h-3" />
                                </button>
                            )}
                        </div>

                        <div className="flex flex-wrap gap-2">
                            {visibleGenres.map((g) => {
                                const Icon = g.icon;
                                const isSelected = genre === g.id;
                                return (
                                    <button
                                        key={g.id}
                                        type="button"
                                        onClick={() => setGenre(g.id)}
                                        disabled={isProcessing}
                                        className={`
                                            flex items-center gap-2 px-3 py-1.5 rounded-sm
                                            border transition-colors duration-200
                                            disabled:opacity-40 disabled:cursor-not-allowed
                                            ${isSelected
                                                ? 'bg-blue-500/10 border-blue-500/50'
                                                : 'border-zinc-800 hover:border-zinc-600'
                                            }
                                        `}
                                    >
                                        <Icon
                                            className={`w-3.5 h-3.5 transition-colors duration-200 ${
                                                isSelected ? 'text-blue-400' : 'text-zinc-600'
                                            }`}
                                        />
                                        <span
                                            className={`text-[13px] font-medium transition-colors duration-200 ${
                                                isSelected ? 'text-blue-400' : 'text-zinc-500'
                                            }`}
                                        >
                                            {t(`story.genres.${g.id}`)}
                                        </span>
                                    </button>
                                );
                            })}
                        </div>
                    </div>

                    {/* Submit */}
                    <div>
                        <button
                            type="submit"
                            disabled={!topic.trim() || isProcessing}
                            className={`
                                w-full flex items-center justify-center gap-3
                                px-8 py-3 rounded-sm
                                font-mono text-sm font-medium
                                transition-colors duration-200
                                ${topic.trim() && !isProcessing
                                    ? 'bg-white text-black hover:bg-zinc-200'
                                    : 'bg-zinc-800 text-zinc-600 cursor-not-allowed'
                                }
                            `}
                        >
                            {isProcessing ? (
                                <>
                                    <div className="w-4 h-4 rounded-sm border-2 border-current border-t-transparent animate-spin" />
                                    <span>{t('story.buildingStory')}</span>
                                </>
                            ) : (
                                <>
                                    <span>{t('story.beginStory')}</span>
                                    <ArrowRight className="w-4 h-4" />
                                </>
                            )}
                        </button>
                    </div>
                </form>
            </div>

            {/* Templates Gallery Modal */}
            <AnimatePresence>
                {showTemplatesGallery && onApplyTemplate && (
                    <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        transition={{ duration: 0.15 }}
                        className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 z-50"
                        onClick={() => setShowTemplatesGallery(false)}
                    >
                        <motion.div
                            initial={{ scale: 0.97, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            exit={{ scale: 0.97, opacity: 0 }}
                            transition={{ duration: 0.2, ease: 'easeOut' }}
                            className="w-full max-w-5xl h-[80vh]"
                            onClick={(e) => e.stopPropagation()}
                        >
                            <TemplatesGallery
                                onApplyTemplate={(state) => {
                                    onApplyTemplate(state);
                                    setShowTemplatesGallery(false);
                                }}
                                onClose={() => setShowTemplatesGallery(false)}
                            />
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
    );
};

export default IdeaView;
</file>

<file path="components/story/index.ts">
export * from './IdeaView';
export * from './ShotEditorModal';
export * from './ScriptView';
export * from './CharacterView';
export * from './StoryboardView';
export * from './StoryWorkspace';
export * from './LockWarningDialog';
export * from './BreakdownProgress';
export * from './StyleSelector';
export * from './TemplatesGallery';
export * from './VersionHistoryPanel';
export * from './ExportOptionsPanel';
</file>

<file path="components/story/LockWarningDialog.tsx">
/**
 * LockWarningDialog.tsx
 * Warning dialog for screenplay locking with cost breakdown.
 */

import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Lock, Film, X, Info } from 'lucide-react';
import { useLanguage } from '@/i18n/useLanguage';

interface LockWarningDialogProps {
    isOpen: boolean;
    onClose: () => void;
    onConfirmLock: () => void;
    estimatedCost: number;
    sceneCount?: number;
    estimatedShots?: number;
}

export const LockWarningDialog: React.FC<LockWarningDialogProps> = ({
    isOpen,
    onClose,
    onConfirmLock,
    estimatedCost,
    sceneCount = 0,
    estimatedShots = 0,
}) => {
    const { t } = useLanguage();

    return (
        <AnimatePresence>
            {isOpen && (
                <div className="fixed inset-0 z-50 flex items-center justify-center">
                    {/* Backdrop */}
                    <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        transition={{ duration: 0.15 }}
                        className="absolute inset-0 bg-black/80 backdrop-blur-sm"
                        onClick={onClose}
                    />

                    {/* Modal */}
                    <motion.div
                        initial={{ opacity: 0, scale: 0.97 }}
                        animate={{ opacity: 1, scale: 1 }}
                        exit={{ opacity: 0, scale: 0.97 }}
                        transition={{ duration: 0.2, ease: 'easeOut' }}
                        className="relative w-full max-w-md mx-4 bg-zinc-900 border border-zinc-800 rounded-sm overflow-hidden"
                    >
                        {/* Close button */}
                        <button
                            onClick={onClose}
                            className="absolute top-4 right-4 p-2 text-zinc-600 hover:text-zinc-300 transition-colors duration-200 z-10"
                        >
                            <X className="w-5 h-5" />
                        </button>

                        <div className="relative p-8">
                            {/* Icon */}
                            <div className="flex justify-center mb-6">
                                <div className="relative">
                                    <div className="w-16 h-16 rounded-sm bg-orange-500/10 border border-orange-500/30 flex items-center justify-center">
                                        <Film className="w-8 h-8 text-orange-400" />
                                    </div>
                                    {/* Lock badge */}
                                    <div className="absolute -bottom-1 -right-1 w-7 h-7 rounded-sm bg-blue-500 flex items-center justify-center">
                                        <Lock className="w-3.5 h-3.5 text-white" />
                                    </div>
                                </div>
                            </div>

                            {/* Title */}
                            <h2 className="font-sans text-2xl font-medium tracking-tight text-zinc-100 text-center mb-3">
                                {t('story.lock_dialog.lockTheScript')}
                            </h2>

                            {/* Warning Message */}
                            <p className="text-zinc-500 text-sm text-center mb-8">
                                {t('story.lock_dialog.scriptFinalized')}
                            </p>

                            {/* Cost Breakdown */}
                            <div className="bg-zinc-950 border border-zinc-800 rounded-sm p-5 mb-6">
                                <div className="flex items-center gap-3 mb-4">
                                    <span className="font-mono text-[10px] text-zinc-600 uppercase tracking-widest">
                                        {t('story.lock_dialog.productionEstimate')}
                                    </span>
                                    <div className="flex-1 h-px bg-zinc-800" />
                                </div>

                                <div className="space-y-3">
                                    {sceneCount > 0 && (
                                        <div className="flex justify-between items-center">
                                            <span className="text-zinc-500 text-sm">{t('story.scenes')}</span>
                                            <span className="font-mono text-zinc-200">{sceneCount}</span>
                                        </div>
                                    )}
                                    {estimatedShots > 0 && (
                                        <div className="flex justify-between items-center">
                                            <span className="text-zinc-500 text-sm">{t('story.lock_dialog.estimatedShots')}</span>
                                            <span className="font-mono text-zinc-200">~{estimatedShots}</span>
                                        </div>
                                    )}
                                    <div className="h-px bg-zinc-800 my-3" />
                                    <div className="flex justify-between items-center">
                                        <span className="text-zinc-500 text-sm">{t('story.lock_dialog.totalBudget')}</span>
                                        <span className="font-sans text-xl text-blue-400">
                                            ${estimatedCost.toFixed(2)}
                                        </span>
                                    </div>
                                </div>
                            </div>

                            {/* Info Note */}
                            <div className="flex items-start gap-3 mb-8 p-4 bg-blue-500/5 border border-blue-500/20 rounded-sm">
                                <Info className="w-4 h-4 text-blue-400 mt-0.5 shrink-0" />
                                <p className="text-zinc-500 text-sm">
                                    {t('story.lock_dialog.shotBreakdownInfo')}
                                </p>
                            </div>

                            {/* Action Buttons */}
                            <div className="flex gap-4">
                                <button
                                    onClick={onClose}
                                    className="flex-1 px-6 py-3.5 rounded-sm text-zinc-300 bg-zinc-950 border border-zinc-800 hover:border-zinc-600 transition-colors duration-200"
                                >
                                    {t('story.lock_dialog.backToEdit')}
                                </button>
                                <button
                                    onClick={onConfirmLock}
                                    className="flex-1 flex items-center justify-center gap-2 px-6 py-3.5 rounded-sm bg-blue-500 hover:bg-blue-600 text-white font-mono text-sm font-medium transition-colors duration-200"
                                >
                                    <Lock className="w-4 h-4" />
                                    {t('story.lock_dialog.lockAndBegin')}
                                </button>
                            </div>
                        </div>
                    </motion.div>
                </div>
            )}
        </AnimatePresence>
    );
};

export default LockWarningDialog;
</file>

<file path="components/story/SceneCard.tsx">
import React from 'react';
import { RefreshCcw } from 'lucide-react';
import { MarkdownContent } from '@/components/ui/MarkdownContent';
import { cn } from '@/lib/utils';

interface SceneCardProps {
  sceneNumber: number;
  heading: string;
  content: string;
  onRegenerate?: (sceneNumber: number, feedback: string) => void;
  isProcessing?: boolean;
  children?: React.ReactNode;
  className?: string;
}

export function SceneCard({
  sceneNumber,
  heading,
  content,
  onRegenerate,
  isProcessing = false,
  children,
  className,
}: SceneCardProps) {
  const handleRegenerate = () => {
    const feedback = window.prompt(
      `How should we redo Scene ${sceneNumber}? (Optional)`,
      ''
    );
    if (feedback !== null) onRegenerate?.(sceneNumber, feedback);
  };

  return (
    <div className={cn('bg-zinc-900 border border-zinc-800 rounded-sm p-5', className)}>
      {/* Scene header */}
      <div className="flex justify-between items-start mb-4">
        <div className="flex items-center gap-3">
          <span className="font-mono text-xs text-blue-400">
            SCENE {String(sceneNumber).padStart(2, '0')}
          </span>
          <div className="w-6 h-px bg-zinc-700" />
        </div>
        {onRegenerate && (
          <button
            onClick={handleRegenerate}
            className="p-2 text-zinc-600 hover:text-blue-400 rounded-sm transition-colors duration-200 ease-out"
            disabled={isProcessing}
            aria-label={`Regenerate scene ${sceneNumber}`}
          >
            <RefreshCcw className="w-4 h-4" />
          </button>
        )}
      </div>

      {/* Scene heading */}
      <h3 className="font-sans text-base font-medium text-zinc-100 tracking-tight mb-3" dir="auto">
        {heading}
      </h3>

      {/* Scene content with markdown rendering */}
      <MarkdownContent content={content} className="text-zinc-400 text-sm" />

      {/* Slot for additional content (shots, audio, etc.) */}
      {children && <div className="mt-4 pt-4 border-t border-zinc-800">{children}</div>}
    </div>
  );
}

export default SceneCard;
</file>

<file path="components/story/ScriptView.tsx">
import React from 'react';
import type { ScreenplayScene } from '@/types';
import { FileText, GripVertical } from 'lucide-react';

interface ScriptViewProps {
    script: { title: string; scenes: ScreenplayScene[] } | null;
    onUpdate?: (script: any) => void;
}

export const ScriptView: React.FC<ScriptViewProps> = ({ script, onUpdate }) => {
    if (!script) {
        return (
            <div className="flex flex-col items-center justify-center min-h-[50vh] p-12">
                <FileText className="w-12 h-12 text-zinc-700 mb-4" />
                <p className="text-zinc-500 text-sm">
                    No script generated yet. Proceed to create your screenplay.
                </p>
            </div>
        );
    }

    // Detect if content is RTL (Arabic, Hebrew, etc.)
    const isRTL = script.scenes.some(s =>
        /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(
            s.heading + s.action + s.dialogue.map(d => d.text).join('')
        )
    );

    return (
        <div className="py-8 px-4">
            {/* Screenplay Container */}
            <div
                className="max-w-3xl mx-auto bg-zinc-900 border border-zinc-800 rounded-sm overflow-hidden"
                dir={isRTL ? 'rtl' : 'ltr'}
            >
                {/* Title Page Header */}
                <div className="p-8 border-b border-zinc-800 text-center">
                    <div className="flex items-center justify-center gap-3 mb-4">
                        <div className="w-12 h-px bg-zinc-800" />
                        <span className="font-mono text-[10px] text-zinc-600 tracking-[0.3em]">
                            SCREENPLAY
                        </span>
                        <div className="w-12 h-px bg-zinc-800" />
                    </div>
                    <h1
                        className="font-sans text-3xl font-medium tracking-tight text-zinc-100"
                        dir="auto"
                    >
                        {script.title}
                    </h1>
                </div>

                {/* Screenplay Content */}
                <div className="p-8 space-y-8">
                    {script.scenes.map((scene, sceneIdx) => (
                        <div
                            key={scene.id}
                            className="group relative"
                            data-scene-id={scene.id}
                            data-scene-index={sceneIdx}
                        >
                            {/* Scene Heading */}
                            <div
                                className={`
                                    relative mb-4 py-2 flex items-start gap-2
                                    ${isRTL
                                        ? 'border-r-2 pr-4 border-blue-500'
                                        : 'border-l-2 pl-4 border-blue-500'
                                    }
                                `}
                            >
                                {/* Drag Handle */}
                                <div className="text-zinc-700 hover:text-zinc-400 cursor-grab active:cursor-grabbing transition-colors duration-200 mt-0.5 shrink-0 opacity-0 group-hover:opacity-100">
                                    <GripVertical className="w-4 h-4" />
                                </div>

                                <div>
                                    <span className="font-mono text-xs text-blue-400 tracking-widest mb-1 block">
                                        SCENE {String(scene.sceneNumber).padStart(2, '0')}
                                    </span>
                                    <h2
                                        className="font-sans text-lg font-medium text-zinc-100 uppercase tracking-wide"
                                        dir="auto"
                                    >
                                        {scene.heading}
                                    </h2>
                                </div>
                            </div>

                            {/* Action / Description */}
                            <div
                                className="text-zinc-400 text-sm leading-relaxed mb-6 px-4"
                                dir="auto"
                            >
                                {scene.action}
                            </div>

                            {/* Dialogue Block */}
                            {scene.dialogue.length > 0 && (
                                <div className="space-y-6 my-6">
                                    {scene.dialogue.map((line, idx) => (
                                        <div
                                            key={`${scene.id}-dialogue-${idx}`}
                                            className="flex flex-col items-center"
                                        >
                                            <div
                                                className="font-mono text-xs text-blue-400 uppercase tracking-widest mb-2"
                                                dir="auto"
                                            >
                                                {line.speaker}
                                            </div>
                                            <div
                                                className="text-zinc-300 text-sm text-center max-w-md leading-relaxed"
                                                dir="auto"
                                            >
                                                &ldquo;{line.text}&rdquo;
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}

                            {/* Characters Present Tags */}
                            {scene.charactersPresent.length > 0 && (
                                <div
                                    className="flex items-center gap-2 mt-6 px-4"
                                    dir="ltr"
                                >
                                    <span className="font-mono text-[10px] text-zinc-700 uppercase tracking-wider">
                                        Present:
                                    </span>
                                    <div className="flex flex-wrap gap-1">
                                        {scene.charactersPresent.map((char, i) => (
                                            <span
                                                key={i}
                                                className="bg-zinc-950 rounded-sm px-2 py-0.5 text-[10px] font-mono text-zinc-600 border border-zinc-800"
                                            >
                                                {char}
                                            </span>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Scene Divider */}
                            {sceneIdx < script.scenes.length - 1 && (
                                <div className="mt-8 pt-8 border-t border-zinc-800" />
                            )}
                        </div>
                    ))}
                </div>

                {/* Footer */}
                <div className="p-6 border-t border-zinc-800 text-center">
                    <span className="font-mono text-[10px] text-zinc-700 tracking-widest">
                        {script.scenes.length} SCENE{script.scenes.length !== 1 ? 'S' : ''}
                    </span>
                </div>
            </div>
        </div>
    );
};

export default ScriptView;
</file>

<file path="components/story/ShotEditorModal.tsx">
/**
 * ShotEditorModal.tsx
 * Full-featured per-shot editor dialog matching the Storyboarder.ai design.
 * Opens from the StoryboardView floating panel or shot table rows.
 */

import React, { useState, useEffect, useCallback } from 'react';
import { motion } from 'framer-motion';
import {
    ChevronLeft, ChevronRight, Loader2, RefreshCw, Save, X
} from 'lucide-react';
import {
    Dialog,
    DialogContent,
    DialogHeader,
    DialogTitle,
} from '@/components/ui/dialog';
import type { ShotlistEntry } from '@/types';

export interface ShotEditorModalProps {
    shot: ShotlistEntry | null;
    sceneNumber: number;
    sceneHeading: string;
    sceneLighting?: string;
    shotIndexInScene: number;
    totalShotsInScene: number;
    onClose: () => void;
    onSave: (shotId: string, updates: Partial<ShotlistEntry>) => void;
    onRetry: (shotId: string) => void;
    onNavigate: (direction: 'prev' | 'next') => void;
    isProcessing?: boolean;
}

const SHOT_TYPE_OPTIONS = [
    'Wide',
    'Medium',
    'Close-up',
    'Extreme Close-up',
    'POV',
    'Over-the-shoulder',
];

const CAMERA_ANGLE_OPTIONS = [
    'Eye-level',
    'High',
    'Low',
    'Dutch',
    "Bird's-eye",
    "Worm's-eye",
];

const MOVEMENT_OPTIONS = [
    'Static',
    'Pan',
    'Tilt',
    'Zoom',
    'Dolly',
    'Tracking',
    'Handheld',
];

const ASPECT_RATIO_OPTIONS = ['16:9', '9:16', '1:1', '4:3'];

// Local editable state mirrors the shot fields
interface LocalEdits {
    description: string;
    dialogue: string;
    durationEst: number;
    shotType: string;
    cameraAngle: string;
    movement: string;
    equipment: string;
    focalLength: string;
    aspectRatio: string;
    notes: string;
}

function shotToLocal(shot: ShotlistEntry): LocalEdits {
    return {
        description: shot.description || '',
        dialogue: shot.dialogue || '',
        durationEst: shot.durationEst ?? 5,
        shotType: shot.shotType || '',
        cameraAngle: shot.cameraAngle || '',
        movement: shot.movement || '',
        equipment: shot.equipment || '',
        focalLength: shot.focalLength || '',
        aspectRatio: shot.aspectRatio || '16:9',
        notes: shot.notes || '',
    };
}

function LabelCell({ label }: { label: string }) {
    return (
        <td className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-500 whitespace-nowrap align-top pt-3 w-28">
            {label}
        </td>
    );
}

export const ShotEditorModal: React.FC<ShotEditorModalProps> = ({
    shot,
    sceneNumber,
    sceneHeading,
    sceneLighting,
    shotIndexInScene,
    totalShotsInScene,
    onClose,
    onSave,
    onRetry,
    onNavigate,
    isProcessing = false,
}) => {
    const [edits, setEdits] = useState<LocalEdits>(() =>
        shot ? shotToLocal(shot) : shotToLocal({} as ShotlistEntry)
    );
    const [dialogueOpen, setDialogueOpen] = useState(false);

    // Re-sync local state whenever the shot changes (navigation)
    useEffect(() => {
        if (shot) setEdits(shotToLocal(shot));
    }, [shot?.id]);

    const set = useCallback(<K extends keyof LocalEdits>(key: K, value: LocalEdits[K]) => {
        setEdits(prev => ({ ...prev, [key]: value }));
    }, []);

    const handleSave = () => {
        if (!shot) return;
        onSave(shot.id, {
            description: edits.description,
            dialogue: edits.dialogue || undefined,
            durationEst: edits.durationEst,
            shotType: edits.shotType || undefined,
            cameraAngle: edits.cameraAngle || undefined,
            movement: edits.movement || undefined,
            equipment: edits.equipment || undefined,
            focalLength: edits.focalLength || undefined,
            aspectRatio: edits.aspectRatio || undefined,
            notes: edits.notes || undefined,
        });
        onClose();
    };

    const handleRetry = () => {
        if (!shot) return;
        onRetry(shot.id);
    };

    const inputCls =
        'w-full bg-zinc-900 border border-zinc-700 rounded-sm px-2 py-1.5 text-xs text-zinc-200 focus:outline-none focus:border-zinc-500 transition-colors placeholder:text-zinc-600';
    const selectCls =
        'w-full bg-zinc-900 border border-zinc-700 rounded-sm px-2 py-1.5 text-xs text-zinc-200 focus:outline-none focus:border-zinc-500 transition-colors';

    return (
        <Dialog open={!!shot} onOpenChange={(open) => { if (!open) onClose(); }}>
            <DialogContent
                showCloseButton={false}
                className="max-w-5xl w-full bg-zinc-950 border border-zinc-800 text-zinc-100 p-0 gap-0 rounded-xl overflow-hidden"
            >
                {/* Header */}
                <div className="flex items-center justify-between px-6 py-4 border-b border-zinc-800">
                    <DialogTitle className="text-base font-semibold text-zinc-100">
                        Edit Your Shot
                    </DialogTitle>
                    <button
                        onClick={onClose}
                        className="p-1.5 rounded-sm text-zinc-500 hover:text-zinc-200 hover:bg-zinc-800 transition-colors"
                        aria-label="Close"
                    >
                        <X className="w-4 h-4" />
                    </button>
                </div>

                {/* Body */}
                <div className="flex gap-0 min-h-0">
                    {/* Left: Image Preview + Navigation */}
                    <div className="w-72 shrink-0 flex flex-col bg-zinc-900/50 border-r border-zinc-800">
                        {/* Image */}
                        <div className="relative aspect-video bg-zinc-950 overflow-hidden">
                            {shot?.imageUrl ? (
                                <motion.img
                                    key={shot.id}
                                    initial={{ opacity: 0 }}
                                    animate={{ opacity: 1 }}
                                    src={shot.imageUrl}
                                    alt={shot.description}
                                    className="w-full h-full object-cover"
                                />
                            ) : (
                                <div className="w-full h-full flex items-center justify-center">
                                    {isProcessing ? (
                                        <Loader2 className="w-8 h-8 text-zinc-700 animate-spin" />
                                    ) : (
                                        <div className="text-zinc-700 text-xs font-mono text-center">
                                            No visual generated
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>

                        {/* Navigation */}
                        <div className="flex items-center justify-between px-4 py-2 border-t border-zinc-800 bg-zinc-900/80">
                            <button
                                onClick={() => onNavigate('prev')}
                                disabled={shotIndexInScene === 0}
                                className="p-1 text-zinc-500 hover:text-zinc-200 disabled:text-zinc-700 transition-colors"
                                aria-label="Previous shot"
                            >
                                <ChevronLeft className="w-4 h-4" />
                            </button>
                            <span className="font-mono text-xs text-zinc-500">
                                {shotIndexInScene + 1} / {totalShotsInScene}
                            </span>
                            <button
                                onClick={() => onNavigate('next')}
                                disabled={shotIndexInScene >= totalShotsInScene - 1}
                                className="p-1 text-zinc-500 hover:text-zinc-200 disabled:text-zinc-700 transition-colors"
                                aria-label="Next shot"
                            >
                                <ChevronRight className="w-4 h-4" />
                            </button>
                        </div>

                        {/* Description textarea */}
                        <div className="p-4 flex-1 flex flex-col gap-2">
                            <label className="font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-500">
                                Description
                            </label>
                            <textarea
                                value={edits.description}
                                onChange={e => set('description', e.target.value)}
                                rows={4}
                                className={`${inputCls} resize-none flex-1`}
                                placeholder="Shot description..."
                            />
                        </div>
                    </div>

                    {/* Right: Scene info + shot metadata table */}
                    <div className="flex-1 flex flex-col min-w-0 overflow-y-auto">
                        {/* Scene heading */}
                        <div className="px-6 py-4 border-b border-zinc-800 bg-zinc-900/30">
                            <div className="flex items-center gap-3 mb-1">
                                <span className="font-mono text-[10px] font-bold text-blue-400 bg-blue-500/10 px-2 py-0.5 rounded-sm border border-blue-500/20 shrink-0">
                                    SCENE {sceneNumber}
                                </span>
                                <span className="font-mono text-sm font-medium text-zinc-100 truncate" dir="auto">
                                    {sceneHeading}
                                </span>
                            </div>
                            {sceneLighting && (
                                <div className="flex items-center gap-1.5 text-[11px] text-zinc-500">
                                    <span className="w-1.5 h-1.5 rounded-full bg-amber-400/70 shrink-0" />
                                    {sceneLighting}
                                </div>
                            )}
                        </div>

                        {/* Metadata table */}
                        <div className="px-4 py-4 overflow-x-auto">
                            <table className="w-full border-collapse">
                                <tbody>
                                    {/* Row 1: ERT + SIZE */}
                                    <tr>
                                        <LabelCell label="ERT (sec)" />
                                        <td className="py-2 px-3 align-top pt-3">
                                            <input
                                                type="number"
                                                value={edits.durationEst}
                                                onChange={e => set('durationEst', parseFloat(e.target.value) || 0)}
                                                className={`${inputCls} w-20 text-center`}
                                                min={1}
                                                max={120}
                                                step={0.5}
                                            />
                                        </td>
                                        <LabelCell label="Size" />
                                        <td className="py-2 px-3 align-top pt-3">
                                            <select
                                                value={edits.shotType}
                                                onChange={e => set('shotType', e.target.value)}
                                                className={selectCls}
                                            >
                                                <option value="">‚Äî</option>
                                                {SHOT_TYPE_OPTIONS.map(o => (
                                                    <option key={o} value={o}>{o}</option>
                                                ))}
                                            </select>
                                        </td>
                                    </tr>

                                    {/* Row 2: PERSPECTIVE + MOVEMENT */}
                                    <tr>
                                        <LabelCell label="Perspective" />
                                        <td className="py-2 px-3 align-top pt-3">
                                            <select
                                                value={edits.cameraAngle}
                                                onChange={e => set('cameraAngle', e.target.value)}
                                                className={selectCls}
                                            >
                                                <option value="">‚Äî</option>
                                                {CAMERA_ANGLE_OPTIONS.map(o => (
                                                    <option key={o} value={o}>{o}</option>
                                                ))}
                                            </select>
                                        </td>
                                        <LabelCell label="Movement" />
                                        <td className="py-2 px-3 align-top pt-3">
                                            <select
                                                value={edits.movement}
                                                onChange={e => set('movement', e.target.value)}
                                                className={selectCls}
                                            >
                                                <option value="">‚Äî</option>
                                                {MOVEMENT_OPTIONS.map(o => (
                                                    <option key={o} value={o}>{o}</option>
                                                ))}
                                            </select>
                                        </td>
                                    </tr>

                                    {/* Row 3: EQUIPMENT + FOCAL LENGTH */}
                                    <tr>
                                        <LabelCell label="Equipment" />
                                        <td className="py-2 px-3 align-top pt-3">
                                            <input
                                                type="text"
                                                value={edits.equipment}
                                                onChange={e => set('equipment', e.target.value)}
                                                className={inputCls}
                                                placeholder="e.g. Tripod"
                                            />
                                        </td>
                                        <LabelCell label="Focal Length" />
                                        <td className="py-2 px-3 align-top pt-3">
                                            <input
                                                type="text"
                                                value={edits.focalLength}
                                                onChange={e => set('focalLength', e.target.value)}
                                                className={inputCls}
                                                placeholder="e.g. 35mm"
                                            />
                                        </td>
                                    </tr>

                                    {/* Row 4: ASPECT RATIO + NOTES */}
                                    <tr>
                                        <LabelCell label="Aspect Ratio" />
                                        <td className="py-2 px-3 align-top pt-3">
                                            <select
                                                value={edits.aspectRatio}
                                                onChange={e => set('aspectRatio', e.target.value)}
                                                className={selectCls}
                                            >
                                                {ASPECT_RATIO_OPTIONS.map(o => (
                                                    <option key={o} value={o}>{o}</option>
                                                ))}
                                            </select>
                                        </td>
                                        <LabelCell label="Notes" />
                                        <td className="py-2 px-3 align-top pt-3">
                                            <input
                                                type="text"
                                                value={edits.notes}
                                                onChange={e => set('notes', e.target.value)}
                                                className={inputCls}
                                                placeholder="Production notes..."
                                            />
                                        </td>
                                    </tr>

                                    {/* Row 5: DIALOGUE (collapsible) */}
                                    <tr>
                                        <td colSpan={4} className="py-2 px-3 pt-3">
                                            <button
                                                type="button"
                                                onClick={() => setDialogueOpen(prev => !prev)}
                                                className="flex items-center gap-2 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-500 hover:text-zinc-300 transition-colors"
                                            >
                                                <ChevronRight
                                                    className={`w-3 h-3 transition-transform ${dialogueOpen ? 'rotate-90' : ''}`}
                                                />
                                                Dialogue
                                            </button>
                                            {dialogueOpen && (
                                                <textarea
                                                    value={edits.dialogue}
                                                    onChange={e => set('dialogue', e.target.value)}
                                                    rows={3}
                                                    className={`${inputCls} mt-2 resize-none w-full`}
                                                    placeholder="Character dialogue or voice-over..."
                                                />
                                            )}
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                {/* Footer */}
                <div className="flex items-center justify-end gap-3 px-6 py-4 border-t border-zinc-800 bg-zinc-950">
                    <button
                        type="button"
                        onClick={handleRetry}
                        disabled={isProcessing}
                        className="flex items-center gap-2 px-4 py-2 rounded-sm border border-zinc-700 text-zinc-400 hover:text-zinc-200 hover:border-zinc-500 text-sm font-medium transition-colors disabled:opacity-40"
                    >
                        {isProcessing ? (
                            <Loader2 className="w-4 h-4 animate-spin" />
                        ) : (
                            <RefreshCw className="w-4 h-4" />
                        )}
                        Retry
                    </button>
                    <button
                        type="button"
                        onClick={handleSave}
                        disabled={isProcessing}
                        className="flex items-center gap-2 px-5 py-2 rounded-sm bg-blue-500 hover:bg-blue-600 text-white text-sm font-semibold transition-colors disabled:opacity-40"
                    >
                        <Save className="w-4 h-4" />
                        Save
                    </button>
                </div>
            </DialogContent>
        </Dialog>
    );
};

export default ShotEditorModal;
</file>

<file path="components/story/StepProgressBar.tsx">
import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Loader2, Check } from 'lucide-react';

type StepStatus = 'completed' | 'active' | 'pending' | 'processing';

interface StepTab {
  id: string;
  label: string;
}

interface StepProgressBarProps {
  tabs: StepTab[];
  currentTabId: string;
  onTabClick: (tabId: string) => void;
  getStepStatus: (tabId: string) => StepStatus;
  isProcessing: boolean;
  progress: { message: string; percent: number };
}

export function StepProgressBar({
  tabs,
  currentTabId,
  onTabClick,
  getStepStatus,
  isProcessing,
  progress,
}: StepProgressBarProps) {
  const currentIndex = tabs.findIndex((t) => t.id === currentTabId);

  return (
    <div className="w-full bg-zinc-950 border-b border-zinc-800">
      <div className="max-w-5xl mx-auto px-6 py-5">
        {/* Step track */}
        <div className="relative flex items-center justify-between">
          {/* Background track line */}
          <div className="absolute top-[14px] left-0 right-0 h-px bg-zinc-800" />

          {/* Completed portion of track */}
          <motion.div
            className="absolute top-[14px] left-0 h-px bg-emerald-500"
            initial={false}
            animate={{
              width: `${(currentIndex / Math.max(tabs.length - 1, 1)) * 100}%`,
            }}
            transition={{ duration: 0.2, ease: 'easeOut' }}
          />

          {tabs.map((tab, index) => {
            const status = getStepStatus(tab.id);
            const isActive = tab.id === currentTabId;
            const isCompleted = status === 'completed';
            const isProcessingStep = status === 'processing';
            const isAccessible = index <= currentIndex || isCompleted;

            return (
              <div key={tab.id} className="relative flex flex-col items-center z-10">
                <button
                  onClick={() => isAccessible && onTabClick(tab.id)}
                  disabled={!isAccessible}
                  className={[
                    'relative w-7 h-7 rounded-sm flex items-center justify-center font-mono text-xs font-medium',
                    'transition-colors duration-200 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-blue-500',
                    isActive
                      ? 'bg-blue-500 text-white border border-blue-500'
                      : isCompleted
                        ? 'bg-emerald-500/20 text-emerald-400 border border-emerald-500/30'
                        : 'bg-zinc-900 text-zinc-600 border border-zinc-800',
                    isAccessible && !isActive ? 'cursor-pointer hover:border-zinc-600' : '',
                    !isAccessible ? 'cursor-not-allowed opacity-40' : '',
                  ].join(' ')}
                >
                  <AnimatePresence mode="wait">
                    {isProcessingStep ? (
                      <motion.div
                        key="processing"
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        transition={{ duration: 0.15 }}
                      >
                        <Loader2 className="w-3.5 h-3.5 animate-spin" />
                      </motion.div>
                    ) : isCompleted ? (
                      <motion.div
                        key="completed"
                        initial={{ opacity: 0, scale: 0.5 }}
                        animate={{ opacity: 1, scale: 1 }}
                        exit={{ opacity: 0, scale: 0.5 }}
                        transition={{ duration: 0.15 }}
                      >
                        <Check className="w-3.5 h-3.5 stroke-[2.5]" />
                      </motion.div>
                    ) : (
                      <motion.span
                        key="number"
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        transition={{ duration: 0.15 }}
                      >
                        {index + 1}
                      </motion.span>
                    )}
                  </AnimatePresence>
                </button>

                <span
                  className={[
                    'mt-2 text-xs font-medium tracking-tight whitespace-nowrap transition-colors duration-200',
                    isActive
                      ? 'text-white'
                      : isCompleted
                        ? 'text-emerald-400'
                        : 'text-zinc-600',
                  ].join(' ')}
                >
                  {tab.label}
                </span>
              </div>
            );
          })}
        </div>

        {/* Processing indicator */}
        <AnimatePresence>
          {isProcessing && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              transition={{ duration: 0.2, ease: 'easeOut' }}
              className="mt-4 pt-3 border-t border-zinc-800"
            >
              <div className="flex items-center gap-3">
                <Loader2 className="w-3.5 h-3.5 text-blue-500 animate-spin shrink-0" />
                <span className="font-mono text-xs text-zinc-500 truncate">
                  {progress.message || 'Processing...'}
                </span>
                <div className="flex-1 h-1 bg-zinc-900 rounded-sm overflow-hidden">
                  <motion.div
                    className="h-full bg-blue-500"
                    initial={{ width: 0 }}
                    animate={{ width: `${progress.percent}%` }}
                    transition={{ duration: 0.3, ease: 'easeOut' }}
                  />
                </div>
                <span className="font-mono text-xs text-zinc-500 min-w-[3rem] text-right shrink-0">
                  {progress.percent}%
                </span>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
}

export default StepProgressBar;
</file>

<file path="components/story/StoryboardProgress.tsx">
/**
 * StoryboardProgress.tsx
 * Loading screen for storyboard generation with stage tracking.
 */

import React from 'react';
import { motion } from 'framer-motion';
import { CheckCircle2, Circle, Loader2 } from 'lucide-react';
import { useLanguage } from '@/i18n/useLanguage';

export type StoryboardStage =
    | 'shotlist'
    | 'characters'
    | 'storyboard';

interface StoryboardProgressProps {
    currentStage: StoryboardStage;
    isComplete?: boolean;
}

interface StageConfig {
    id: StoryboardStage;
    label: string;
    description: string;
}

const STAGE_KEYS: Record<StoryboardStage, { label: string; description: string }> = {
    shotlist: { label: 'story.storyboard_progress.generatingShotList', description: 'story.storyboard_progress.breakingScenes' },
    characters: { label: 'story.storyboard_progress.preparingCast', description: 'story.storyboard_progress.loadingProfiles' },
    storyboard: { label: 'story.storyboard_progress.renderingStoryboard', description: 'story.storyboard_progress.creatingFrames' },
};

const STAGES: StageConfig[] = [
    { id: 'shotlist', label: 'Generating Shot List', description: 'Breaking down scenes into shots' },
    { id: 'characters', label: 'Preparing Cast', description: 'Loading character profiles' },
    { id: 'storyboard', label: 'Rendering Storyboard', description: 'Creating visual frames' },
];

const getStageIndex = (stage: StoryboardStage): number => {
    return STAGES.findIndex(s => s.id === stage);
};

export const StoryboardProgress: React.FC<StoryboardProgressProps> = ({
    currentStage,
    isComplete = false,
}) => {
    const { t } = useLanguage();
    const currentIndex = getStageIndex(currentStage);

    const getStageStatus = (index: number): 'complete' | 'processing' | 'pending' => {
        if (isComplete) return 'complete';
        if (index < currentIndex) return 'complete';
        if (index === currentIndex) return 'processing';
        return 'pending';
    };

    return (
        <div className="flex flex-col items-center justify-center min-h-[70vh] p-8">
            <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.2, ease: 'easeOut' }}
                className="w-full max-w-lg"
            >
                {/* Header */}
                <div className="text-center mb-12">
                    <div className="flex items-center justify-center mb-6">
                        <Loader2 className="w-8 h-8 text-blue-500 animate-spin" />
                    </div>
                    <h2 className="font-sans text-2xl font-medium tracking-tight text-zinc-100 mb-3">
                        {t('story.storyboard_progress.developingVision')}
                    </h2>
                    <p className="text-zinc-500 text-sm">
                        {t('story.storyboard_progress.renderedFrameByFrame')}
                    </p>
                </div>

                {/* Stage List */}
                <div className="space-y-6">
                    {STAGES.map((stage, index) => {
                        const status = getStageStatus(index);
                        return (
                            <motion.div
                                key={stage.id}
                                initial={{ opacity: 0, x: -10 }}
                                animate={{ opacity: 1, x: 0 }}
                                transition={{ duration: 0.2, ease: 'easeOut', delay: index * 0.08 }}
                                className="flex items-start gap-4"
                            >
                                {/* Status Icon */}
                                <div className="shrink-0 mt-1">
                                    {status === 'complete' && (
                                        <CheckCircle2 className="w-6 h-6 text-blue-400" />
                                    )}
                                    {status === 'processing' && (
                                        <Loader2 className="w-6 h-6 text-zinc-400 animate-spin" />
                                    )}
                                    {status === 'pending' && (
                                        <Circle className="w-6 h-6 text-zinc-700" />
                                    )}
                                </div>

                                {/* Content */}
                                <div className="flex-1">
                                    <span className={`
                                        font-sans text-base block mb-1 transition-colors duration-200 ease-out
                                        ${status === 'complete' || status === 'processing'
                                            ? 'text-zinc-300'
                                            : 'text-zinc-600'
                                        }
                                    `}>
                                        {t(STAGE_KEYS[stage.id].label)}
                                    </span>
                                    <span className={`
                                        text-xs transition-colors duration-200 ease-out
                                        ${status === 'pending' ? 'text-zinc-700' : 'text-zinc-600'}
                                    `}>
                                        {t(STAGE_KEYS[stage.id].description)}
                                    </span>
                                </div>
                            </motion.div>
                        );
                    })}
                </div>
            </motion.div>
        </div>
    );
};

export default StoryboardProgress;
</file>

<file path="components/story/StoryboardView.tsx">
/**
 * StoryboardView.tsx
 * Cinematic storyboard viewer ‚Äî full-bleed preview with floating info panel
 * and scene-grouped thumbnail strip.
 */

import React, { useState, useEffect, useMemo, useRef } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import type { ShotlistEntry, ScreenplayScene } from '@/types';
import {
    Play, SkipBack, SkipForward,
    ChevronLeft, ChevronRight,
    Wand2, Video, Loader2, ImageIcon, Maximize2, Pencil
} from 'lucide-react';

interface StoryboardViewProps {
    shots: ShotlistEntry[];
    scenes?: ScreenplayScene[];
    scenesWithVisuals?: string[];
    onGenerateVisuals?: (sceneIndex?: number) => void;
    onGenerateVideo?: (shotId: string) => void;
    onUpdateDuration?: (shotId: string, duration: number) => void;
    onEditShot?: (shotId: string) => void;
    isProcessing?: boolean;
}

interface SceneGroup {
    scene: ScreenplayScene;
    shots: ShotlistEntry[];
}

export const StoryboardView: React.FC<StoryboardViewProps> = ({
    shots,
    scenes = [],
    onGenerateVisuals,
    onGenerateVideo,
    onUpdateDuration,
    onEditShot,
    isProcessing = false,
}) => {
    const [selectedShotIndex, setSelectedShotIndex] = useState(0);
    const [localDuration, setLocalDuration] = useState<number>(0);
    const [isFullscreen, setIsFullscreen] = useState(false);
    const containerRef = useRef<HTMLDivElement>(null);
    const thumbnailStripRef = useRef<HTMLDivElement>(null);

    if (!shots || shots.length === 0) {
        return (
            <div className="flex flex-col items-center justify-center min-h-[60vh] gap-6">
                <div className="w-20 h-20 rounded-2xl bg-linear-to-br from-primary/10 to-accent/10 border border-border flex items-center justify-center">
                    <ImageIcon className="w-9 h-9 text-muted-foreground" />
                </div>
                <div className="text-center">
                    <p className="font-editorial text-lg text-foreground/70 mb-2">No Shots Available</p>
                    <p className="text-muted-foreground text-sm">
                        Generate a shot list to begin storyboarding
                    </p>
                </div>
            </div>
        );
    }

    const currentShot = shots[selectedShotIndex];
    const currentScene = currentShot ? scenes.find(s => s.id === currentShot.sceneId) : undefined;

    // Group shots by scene for the timeline strip
    const sceneGroups = useMemo<SceneGroup[]>(() => {
        if (scenes.length === 0) return [];
        return scenes
            .map(scene => ({
                scene,
                shots: shots.filter(s => s.sceneId === scene.id),
            }))
            .filter(g => g.shots.length > 0);
    }, [scenes, shots]);

    useEffect(() => {
        if (currentShot) {
            setLocalDuration(currentShot.durationEst || 5);
        }
    }, [currentShot?.id, currentShot?.durationEst]);

    // Scroll selected thumbnail into view
    useEffect(() => {
        if (thumbnailStripRef.current) {
            const selected = thumbnailStripRef.current.querySelector('[data-selected="true"]');
            if (selected) {
                selected.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            }
        }
    }, [selectedShotIndex]);

    const handleNext = () => {
        if (selectedShotIndex < shots.length - 1) {
            setSelectedShotIndex(prev => prev + 1);
        }
    };

    const handlePrev = () => {
        if (selectedShotIndex > 0) {
            setSelectedShotIndex(prev => prev - 1);
        }
    };

    // Keyboard navigation
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent): void => {
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                handlePrev();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                handleNext();
            } else if (e.key === 'f' || e.key === 'F') {
                setIsFullscreen(prev => !prev);
            } else if ((e.key === 'e' || e.key === 'E') && !e.ctrlKey && !e.metaKey) {
                const target = e.target as HTMLElement;
                const isEditing = ['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName);
                if (!isEditing && onEditShot && currentShot) {
                    e.preventDefault();
                    onEditShot(currentShot.id);
                }
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [selectedShotIndex, shots.length]);

    const handleDurationChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const val = parseFloat(e.target.value);
        if (!isNaN(val) && val > 0) {
            setLocalDuration(val);
        }
    };

    const handleSaveDuration = () => {
        if (onUpdateDuration && currentShot) {
            onUpdateDuration(currentShot.id, localDuration);
        }
    };

    const toggleFullscreen = () => {
        if (!document.fullscreenElement && containerRef.current) {
            containerRef.current.requestFullscreen?.();
            setIsFullscreen(true);
        } else if (document.fullscreenElement) {
            document.exitFullscreen?.();
            setIsFullscreen(false);
        }
    };

    return (
        <div ref={containerRef} className="flex flex-col h-full bg-background relative">
            {/* Main Preview Area */}
            <div className="flex-1 relative overflow-hidden min-h-0">
                {/* Full-bleed Image/Video */}
                <AnimatePresence mode="wait">
                    <motion.div
                        key={currentShot?.id || selectedShotIndex}
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        transition={{ duration: 0.2 }}
                        className="absolute inset-0"
                    >
                        {currentShot?.imageUrl ? (
                            <img
                                src={currentShot.imageUrl}
                                alt={currentShot.description}
                                className="w-full h-full object-cover"
                            />
                        ) : (
                            <div className="w-full h-full flex flex-col items-center justify-center gap-6 bg-background">
                                <div className="w-20 h-20 rounded-2xl bg-linear-to-br from-primary/10 to-accent/10 border border-border flex items-center justify-center">
                                    <Wand2 className="w-9 h-9 text-muted-foreground" />
                                </div>
                                <p className="font-code text-sm text-muted-foreground uppercase tracking-widest">
                                    No Visual Generated
                                </p>
                                {onGenerateVisuals && (
                                    <button
                                        onClick={() => onGenerateVisuals()}
                                        className="px-6 py-3 rounded-lg bg-primary hover:bg-primary/90 text-primary-foreground font-semibold text-sm transition-colors duration-200 shadow-lg shadow-primary/20"
                                    >
                                        Generate All Visuals
                                    </button>
                                )}
                            </div>
                        )}
                    </motion.div>
                </AnimatePresence>

                {/* Center Generate Video overlay button */}
                {currentShot?.imageUrl && onGenerateVideo && (
                    <div className="absolute inset-0 flex items-center justify-center z-10 pointer-events-none">
                        <button
                            onClick={() => onGenerateVideo(currentShot.id)}
                            disabled={isProcessing}
                            className="pointer-events-auto px-6 py-3 bg-accent hover:bg-accent/90 text-accent-foreground font-bold text-sm rounded-lg flex items-center gap-2 shadow-2xl disabled:opacity-40 disabled:cursor-not-allowed transition-colors"
                        >
                            {isProcessing ? <Loader2 className="w-4 h-4 animate-spin" /> : <Video className="w-4 h-4" />}
                            Generate Video
                        </button>
                    </div>
                )}

                {/* Floating Info Panel (bottom-left) */}
                {currentShot?.imageUrl && (
                    <motion.div
                        initial={{ x: -20, opacity: 0 }}
                        animate={{ x: 0, opacity: 1 }}
                        transition={{ delay: 0.1, duration: 0.3 }}
                        className="absolute bottom-4 left-4 z-20 w-[340px] max-h-[calc(100%-2rem)]"
                    >
                        <div className="bg-black/85 backdrop-blur-md border border-border rounded-xl overflow-hidden flex flex-col shadow-2xl">
                            {/* Mini thumbnail with navigation */}
                            <div className="relative aspect-video bg-secondary overflow-hidden border-b border-border">
                                <img
                                    src={currentShot.imageUrl}
                                    alt=""
                                    className="w-full h-full object-cover"
                                />
                                {/* Shot navigation overlay */}
                                <div className="absolute inset-x-0 bottom-0 flex items-center justify-center gap-3 py-2 bg-linear-to-t from-black/80 to-transparent">
                                    <button
                                        onClick={handlePrev}
                                        disabled={selectedShotIndex === 0}
                                        className="p-1 text-foreground/80 hover:text-foreground disabled:text-foreground/20 transition-colors"
                                    >
                                        <ChevronLeft className="w-5 h-5" />
                                    </button>
                                    <span className="font-code text-xs text-foreground/70">
                                        {selectedShotIndex + 1} / {shots.length}
                                    </span>
                                    <button
                                        onClick={handleNext}
                                        disabled={selectedShotIndex === shots.length - 1}
                                        className="p-1 text-foreground/80 hover:text-foreground disabled:text-foreground/20 transition-colors"
                                    >
                                        <ChevronRight className="w-5 h-5" />
                                    </button>
                                </div>
                            </div>

                            {/* Shot Details */}
                            <div className="p-4 space-y-3 overflow-y-auto max-h-[280px]">
                                {/* Scene / Shot label */}
                                <h3 className="font-editorial font-semibold text-foreground text-sm">
                                    Scene {currentScene?.sceneNumber || '?'} | Shot {currentShot.shotNumber}
                                </h3>

                                {/* Description */}
                                <div>
                                    <p className="text-[11px] font-code font-semibold text-muted-foreground uppercase tracking-wider mb-1">Description</p>
                                    <p className="text-foreground/80 text-sm leading-relaxed">
                                        {currentShot.description || 'No description'}
                                    </p>
                                </div>

                                {/* Dialogue */}
                                {currentShot.dialogue && (
                                    <div>
                                        <p className="text-[11px] font-code font-semibold text-muted-foreground uppercase tracking-wider mb-1">Dialogue</p>
                                        <p className="text-foreground/80 text-sm leading-relaxed italic">
                                            {currentShot.dialogue}
                                        </p>
                                    </div>
                                )}

                                {/* Duration */}
                                <div className="flex items-center gap-3">
                                    <span className="text-[11px] font-code font-semibold text-muted-foreground uppercase tracking-wider">
                                        Duration (ERT):
                                    </span>
                                    <input
                                        type="number"
                                        value={localDuration}
                                        onChange={handleDurationChange}
                                        onBlur={handleSaveDuration}
                                        className="w-14 px-2 py-1 bg-secondary border border-border rounded-md text-foreground text-sm text-center font-code focus:outline-none focus:border-primary"
                                        min={1}
                                        max={60}
                                    />
                                </div>

                                {/* Update ERT button */}
                                <button
                                    onClick={handleSaveDuration}
                                    className="w-full py-2 bg-secondary hover:bg-muted text-foreground/80 text-sm font-medium rounded-lg border border-border transition-colors"
                                >
                                    Update ERT
                                </button>

                                {/* Edit Shot button */}
                                {onEditShot && (
                                    <button
                                        onClick={() => currentShot && onEditShot(currentShot.id)}
                                        className="w-full py-2 bg-secondary hover:bg-muted text-foreground/80 text-sm font-medium rounded-lg border border-border flex items-center justify-center gap-2 transition-colors"
                                    >
                                        <Pencil className="w-3.5 h-3.5" />
                                        Edit Shot
                                    </button>
                                )}

                                {/* Generate Video button */}
                                <button
                                    onClick={() => currentShot && onGenerateVideo?.(currentShot.id)}
                                    disabled={isProcessing || !currentShot?.imageUrl}
                                    className="w-full py-2.5 bg-accent hover:bg-accent/90 text-accent-foreground font-semibold text-sm rounded-lg flex items-center justify-center gap-2 disabled:opacity-40 disabled:cursor-not-allowed transition-colors shadow-lg shadow-accent/20"
                                >
                                    {isProcessing ? (
                                        <Loader2 className="w-4 h-4 animate-spin" />
                                    ) : (
                                        <Video className="w-4 h-4" />
                                    )}
                                    Generate Video
                                </button>

                                <p className="text-[10px] text-muted-foreground text-center">
                                    Video length is limited to up to 12 seconds
                                </p>
                            </div>
                        </div>
                    </motion.div>
                )}

                {/* Navigation Arrows */}
                <button
                    onClick={handlePrev}
                    disabled={selectedShotIndex === 0}
                    className="absolute left-0 bottom-0 z-10 p-3 text-foreground/60 hover:text-foreground disabled:text-foreground/10 transition-colors"
                    style={{ bottom: '8px', left: currentShot?.imageUrl ? '360px' : '16px' }}
                    aria-label="Previous shot"
                >
                    <SkipBack className="w-6 h-6" />
                </button>

                <button
                    onClick={() => {/* play/pause ‚Äî placeholder */ }}
                    className="absolute z-10 p-3 text-foreground/60 hover:text-foreground transition-colors"
                    style={{ bottom: '8px', left: currentShot?.imageUrl ? '396px' : '52px' }}
                    aria-label="Play"
                >
                    <Play className="w-6 h-6" />
                </button>

                <button
                    onClick={handleNext}
                    disabled={selectedShotIndex === shots.length - 1}
                    className="absolute z-10 p-3 text-foreground/60 hover:text-foreground disabled:text-foreground/10 transition-colors"
                    style={{ bottom: '8px', left: currentShot?.imageUrl ? '432px' : '88px' }}
                    aria-label="Next shot"
                >
                    <SkipForward className="w-6 h-6" />
                </button>

                {/* Fullscreen toggle */}
                <button
                    onClick={toggleFullscreen}
                    className="absolute bottom-3 right-3 z-10 p-2 text-foreground/40 hover:text-foreground transition-colors"
                    aria-label="Toggle fullscreen"
                >
                    <Maximize2 className="w-5 h-5" />
                </button>
            </div>

            {/* Thumbnail Strip */}
            <div
                ref={thumbnailStripRef}
                className="h-24 shrink-0 bg-card/95 backdrop-blur border-t border-border flex items-center gap-1 px-3 overflow-x-auto no-scrollbar"
            >
                {sceneGroups.length > 0 ? (
                    sceneGroups.map((group) => (
                        <React.Fragment key={group.scene.id}>
                            {group.shots.map((shot) => {
                                const idx = shots.indexOf(shot);
                                const isSelected = idx === selectedShotIndex;
                                return (
                                    <button
                                        key={shot.id}
                                        data-selected={isSelected}
                                        onClick={() => setSelectedShotIndex(idx)}
                                        className={`
                                            relative flex-none h-16 w-24 rounded-md overflow-hidden border-2 transition-all duration-150
                                            ${isSelected
                                                ? 'border-primary ring-1 ring-primary/30 scale-105 z-10'
                                                : 'border-transparent opacity-60 hover:opacity-100 hover:border-border'
                                            }
                                        `}
                                    >
                                        {shot.imageUrl ? (
                                            <img
                                                src={shot.imageUrl}
                                                alt=""
                                                className="w-full h-full object-cover"
                                            />
                                        ) : (
                                            <div className="w-full h-full bg-secondary flex items-center justify-center">
                                                <ImageIcon className="w-4 h-4 text-muted-foreground" />
                                            </div>
                                        )}
                                    </button>
                                );
                            })}
                        </React.Fragment>
                    ))
                ) : (
                    shots.map((shot, idx) => {
                        const isSelected = idx === selectedShotIndex;
                        return (
                            <button
                                key={shot.id}
                                data-selected={isSelected}
                                onClick={() => setSelectedShotIndex(idx)}
                                className={`
                                    relative flex-none h-16 w-24 rounded-md overflow-hidden border-2 transition-all duration-150
                                    ${isSelected
                                        ? 'border-primary ring-1 ring-primary/30 scale-105 z-10'
                                        : 'border-transparent opacity-60 hover:opacity-100 hover:border-border'
                                    }
                                `}
                            >
                                {shot.imageUrl ? (
                                    <img
                                        src={shot.imageUrl}
                                        alt=""
                                        className="w-full h-full object-cover"
                                    />
                                ) : (
                                    <div className="w-full h-full bg-secondary flex items-center justify-center">
                                        <ImageIcon className="w-4 h-4 text-muted-foreground" />
                                    </div>
                                )}
                            </button>
                        );
                    })
                )}
            </div>
        </div>
    );
};

export default StoryboardView;
</file>

<file path="components/story/StoryWorkspace.tsx">
/**
 * StoryWorkspace.tsx
 * Main orchestrator for the story mode pipeline.
 */

import React, { useState, useEffect, useMemo, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { IdeaView } from './IdeaView';
import { ScriptView } from './ScriptView';
import { CharacterView } from './CharacterView';
import { StoryboardView } from './StoryboardView';
import { ShotEditorModal } from './ShotEditorModal';
import { LockWarningDialog } from './LockWarningDialog';
import { StyleSelector } from './StyleSelector';
import { BreakdownProgress } from './BreakdownProgress';
import { StoryboardProgress } from './StoryboardProgress';
import { SceneCard } from './SceneCard';
import { StepProgressBar } from './StepProgressBar';
import type { StoryState, StoryStep, CharacterProfile, ShotlistEntry } from '@/types';
import type { VisualStyleKey, AspectRatioId } from '@/constants/visualStyles';
import { estimateProjectCost } from '@/utils/costEstimator';
import { Download, RefreshCcw, Undo2, Redo2, Lock, CheckCircle2, Circle, Loader2, AlertCircle, X, Film, Mic, Video, Play, Check, History, ImageIcon, MessageCircle, GripVertical, Pencil } from 'lucide-react';
import { VersionHistoryPanel } from './VersionHistoryPanel';
import { ExportOptionsPanel } from './ExportOptionsPanel';
import { useLanguage } from '@/i18n/useLanguage';
import { FormatSelector } from '@/components/FormatSelector';
import { PipelineProgress } from '@/components/PipelineProgress';
import { CheckpointApproval } from '@/components/CheckpointApproval';
import { ReferenceDocumentUpload } from '@/components/ReferenceDocumentUpload';
import { formatRegistry } from '@/services/formatRegistry';
import type { UseFormatPipelineReturn } from '@/hooks/useFormatPipeline';

interface StageProgress {
    totalScenes: number;
    scenesWithShots: number;
    scenesWithVisuals: number;
    shotsComplete: boolean;
    visualsComplete: boolean;
}

interface StoryWorkspaceProps {
    storyState: StoryState;
    onNextStep: () => void;
    onGenerateIdea?: (topic: string, genre: string) => void;
    initialTopic?: string;
    onExportScript?: () => void;
    onRegenerateScene?: (sceneNumber: number, feedback: string) => void;
    onVerifyConsistency?: (characterName: string) => void;
    onGenerateScreenplay?: () => void;
    onGenerateCharacters?: () => void;
    onUndo?: () => void;
    onRedo?: () => void;
    canUndo?: boolean;
    canRedo?: boolean;
    isProcessing: boolean;
    progress: { message: string; percent: number };
    onLockStory?: () => void;
    onUpdateVisualStyle?: (style: string) => void;
    onUpdateAspectRatio?: (ratio: string) => void;
    onUpdateImageProvider?: (provider: 'gemini' | 'deapi') => void;
    onGenerateShots?: (sceneIndex?: number) => void;
    onGenerateVisuals?: (sceneIndex?: number) => void;
    stageProgress?: StageProgress;
    error?: string | null;
    onClearError?: () => void;
    onRetry?: () => void;
    onAddCharacter?: () => void;
    onEditCharacter?: (character: CharacterProfile) => void;
    onDeleteCharacter?: (characterId: string) => void;
    onGenerateCharacterImage?: (characterId: string) => void;
    onGenerateVideo?: (shotId: string) => void;
    onUpdateShotDuration?: (shotId: string, duration: number) => void;
    onUpdateShot?: (shotId: string, updates: Partial<ShotlistEntry>) => void;
    onGenerateNarration?: () => void;
    onAnimateShots?: (shotIndex?: number) => void;
    onExportFinalVideo?: () => Promise<Blob | null | undefined>;
    onDownloadVideo?: () => void;
    allScenesHaveNarration?: () => boolean;
    allShotsHaveAnimation?: () => boolean;
    onApplyTemplate?: (state: Partial<StoryState>) => void;
    onImportProject?: (state: StoryState) => void;
    projectId?: string;
    /** Format pipeline hook for multi-format support */
    formatPipelineHook?: UseFormatPipelineReturn;
    /** Called when user clicks "Start Production" in FormatSelector */
    onFormatExecute?: () => void;
    /** Transition to the advanced Video Editor */
    onOpenInEditor?: () => void;
}

type MainStep = 'idea' | 'breakdown' | 'storyboard';

const quickFade = {
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 },
    transition: { duration: 0.15 },
};

function deriveEquipment(movement: string): string {
    const m = movement.toLowerCase();
    if (m === 'static') return 'Tripod';
    if (m.includes('dolly')) return 'Dolly';
    if (m.includes('track')) return 'Steady cam';
    if (m.includes('handheld')) return 'Handheld';
    if (m.includes('pan') || m.includes('tilt')) return 'Tripod';
    return 'Steady cam';
}

function deriveFocalLength(shotType: string): string {
    const s = shotType.toLowerCase();
    if (s.includes('extreme')) return '85mm';
    if (s.includes('close')) return '50mm';
    if (s.includes('medium')) return '35mm';
    if (s.includes('wide') || s.includes('long')) return '24mm';
    if (s.includes('pov') || s.includes('shoulder')) return '40mm';
    return '35mm';
}

export const StoryWorkspace: React.FC<StoryWorkspaceProps> = ({
    storyState,
    onNextStep,
    onGenerateIdea,
    initialTopic,
    onExportScript,
    onRegenerateScene,
    onVerifyConsistency,
    onGenerateScreenplay,
    onGenerateCharacters,
    onUndo,
    onRedo,
    canUndo,
    canRedo,
    isProcessing,
    progress,
    onLockStory,
    onUpdateVisualStyle,
    onUpdateAspectRatio,
    onUpdateImageProvider,
    onGenerateShots,
    onGenerateVisuals,
    stageProgress,
    error,
    onClearError,
    onRetry,
    onAddCharacter,
    onEditCharacter,
    onDeleteCharacter,
    onGenerateCharacterImage,
    onGenerateVideo,
    onUpdateShotDuration,
    onUpdateShot,
    onGenerateNarration,
    onAnimateShots,
    onExportFinalVideo,
    onDownloadVideo,
    allScenesHaveNarration,
    allShotsHaveAnimation,
    onApplyTemplate,
    onImportProject,
    projectId,
    formatPipelineHook,
    onFormatExecute,
    onOpenInEditor,
}) => {
    const { t } = useLanguage();

    const getHighLevelStep = (step: StoryStep): MainStep => {
        if (step === 'idea') return 'idea';
        if (['breakdown', 'script', 'characters'].includes(step)) return 'breakdown';
        return 'storyboard';
    };

    const [activeMainTab, setActiveMainTab] = useState<MainStep>(getHighLevelStep(storyState.currentStep));
    const [subTab, setSubTab] = useState<StoryStep>(storyState.currentStep);
    const [showLockDialog, setShowLockDialog] = useState(false);
    const [showVersionHistory, setShowVersionHistory] = useState(false);
    const [editingShot, setEditingShot] = useState<ShotlistEntry | null>(null);
    // Fix #2: Keep a ref to the current editingShot so onNavigate never closes over a stale value.
    const editingShotRef = useRef(editingShot);
    useEffect(() => { editingShotRef.current = editingShot; }, [editingShot]);
    // Track which individual shots are being animated (by shot.id)
    const [animatingShotIds, setAnimatingShotIds] = useState<Set<string>>(new Set());

    // Clear per-shot animation trackers when global processing finishes
    useEffect(() => {
        if (!isProcessing) setAnimatingShotIds(new Set());
    }, [isProcessing]);

    // Fix #1: Memoize blob URLs from format-pipeline narration results.
    // URL.createObjectURL must never be called in render ‚Äî it creates a new URL
    // on every render that is never revoked, causing a memory leak.
    const narrationBlobUrlMap = useMemo<Map<string, string>>(() => {
        if (!formatPipelineHook?.result?.success) return new Map();
        const pr = formatPipelineHook.result.partialResults ?? {};
        const narrations = (pr.narrationSegments ?? []) as { sceneId: string; audioBlob: Blob }[];
        return new Map(narrations.map(n => [n.sceneId, URL.createObjectURL(n.audioBlob)]));
    }, [formatPipelineHook?.result]);
    // Revoke old blob URLs when the map changes or component unmounts
    useEffect(() => {
        return () => { narrationBlobUrlMap.forEach(url => URL.revokeObjectURL(url)); };
    }, [narrationBlobUrlMap]);

    // Fix #4: Pre-compute animatedShots lookup map to avoid O(n¬≤) in the animation grid.
    const animatedShotsMap = useMemo(() => {
        const m = new Map<string, NonNullable<typeof storyState.animatedShots>[number]>();
        storyState.animatedShots?.forEach(a => m.set(a.shotId, a));
        return m;
    }, [storyState.animatedShots]);

    useEffect(() => {
        const newMain = getHighLevelStep(storyState.currentStep);
        setActiveMainTab(newMain);
        setSubTab(storyState.currentStep);
    }, [storyState.currentStep]);

    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') {
                    if (e.shiftKey) {
                        if (canRedo && onRedo) { e.preventDefault(); onRedo(); }
                    } else {
                        if (canUndo && onUndo) { e.preventDefault(); onUndo(); }
                    }
                } else if (e.key === 'y') {
                    if (canRedo && onRedo) { e.preventDefault(); onRedo(); }
                }
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [onUndo, onRedo, canUndo, canRedo]);

    const mainTabs: { id: MainStep; label: string; number: string }[] = [
        { id: 'idea', label: t('story.storyIdea'), number: '1' },
        { id: 'breakdown', label: t('story.breakdown'), number: '2' },
        { id: 'storyboard', label: t('story.storyboard'), number: '3' },
    ];

    const handleProceed = () => {
        if (subTab === 'script' && !storyState.isLocked) {
            setShowLockDialog(true);
        } else {
            onNextStep();
        }
    };

    const handleTabNavigation = (tabId: StoryStep) => {
        if (tabId === 'script' && !storyState.script && !isProcessing) {
            onGenerateScreenplay?.();
        } else if (tabId === 'characters' && storyState.characters.length === 0 && !isProcessing) {
            onGenerateCharacters?.();
        }
        setSubTab(tabId);
    };

    const isBreakdownProcessing = isProcessing && activeMainTab === 'breakdown' && storyState.breakdown.length === 0;
    const isStoryboardProcessing = isProcessing && activeMainTab === 'storyboard' && (!storyState.shots || storyState.shots.length === 0);

    const getStepCompletionStatus = (stepId: StoryStep): 'completed' | 'active' | 'pending' | 'processing' => {
        const storyboardOrder: StoryStep[] = ['shots', 'style', 'storyboard', 'narration', 'animation', 'export'];
        const breakdownOrder: StoryStep[] = ['breakdown', 'script', 'characters'];
        const currentOrder = activeMainTab === 'storyboard' ? storyboardOrder : breakdownOrder;
        const currentIndex = currentOrder.indexOf(subTab);
        const stepIndex = currentOrder.indexOf(stepId);

        if (stepId === subTab) return isProcessing ? 'processing' : 'active';

        if (activeMainTab === 'storyboard') {
            switch (stepId) {
                case 'shots': return (storyState.shots?.length ?? 0) > 0 ? 'completed' : stepIndex < currentIndex ? 'completed' : 'pending';
                case 'style': return storyState.visualStyle ? 'completed' : stepIndex < currentIndex ? 'completed' : 'pending';
                case 'storyboard': return (storyState.scenesWithVisuals?.length ?? 0) > 0 ? 'completed' : stepIndex < currentIndex ? 'completed' : 'pending';
                case 'narration': return (storyState.narrationSegments?.length ?? 0) > 0 ? 'completed' : stepIndex < currentIndex ? 'completed' : 'pending';
                case 'animation': return (storyState.animatedShots?.length ?? 0) > 0 ? 'completed' : stepIndex < currentIndex ? 'completed' : 'pending';
                case 'export': return storyState.finalVideoUrl ? 'completed' : 'pending';
            }
        } else {
            switch (stepId) {
                case 'breakdown': return storyState.breakdown.length > 0 ? 'completed' : 'pending';
                case 'script': return storyState.script ? 'completed' : stepIndex < currentIndex ? 'completed' : 'pending';
                case 'characters': return storyState.characters.length > 0 ? 'completed' : 'pending';
            }
        }
        return stepIndex < currentIndex ? 'completed' : 'pending';
    };

    const renderSubNav = (tabs: { id: StoryStep; label: string }[]) => (
        <StepProgressBar
            tabs={tabs}
            currentTabId={subTab}
            onTabClick={(tabId) => handleTabNavigation(tabId as StoryStep)}
            getStepStatus={(tabId) => getStepCompletionStatus(tabId as StoryStep)}
            isProcessing={isProcessing}
            progress={progress}
        />
    );

    const renderMainContent = () => {
        if (activeMainTab === 'idea') {
            // If format pipeline hook is provided, use the multi-format flow
            if (formatPipelineHook) {
                const fpHook = formatPipelineHook;
                const isMovieAnimation = fpHook.selectedFormat === 'movie-animation';

                // State 1: Pipeline is running (non-movie format) ‚Üí PipelineProgress
                if (fpHook.isRunning && !isMovieAnimation) {
                    return (
                        <motion.div key="pipeline-progress" {...quickFade} className="h-full flex items-center justify-center p-8">
                            <PipelineProgress
                                executionProgress={fpHook.executionProgress}
                                tasks={fpHook.tasks}
                                currentPhase={fpHook.currentPhase}
                                isRunning={fpHook.isRunning}
                                onCancel={fpHook.cancel}
                                isCancelling={fpHook.isCancelling}
                            />
                        </motion.div>
                    );
                }

                // State 2: Pipeline completed (success) ‚Üí result view with asset preview
                if (!fpHook.isRunning && fpHook.result?.success) {
                    const pr = fpHook.result.partialResults ?? {};
                    const screenplay = (pr.screenplay ?? []) as { id: string; heading: string; action: string; dialogue?: { speaker: string; text: string }[] }[];
                    const visuals = (pr.visuals ?? []) as { sceneId: string; imageUrl: string }[];
                    const narrations = (pr.narrationSegments ?? []) as { sceneId: string; audioBlob: Blob; audioDuration: number; transcript: string }[];
                    const totalDuration = pr.totalDuration as number | undefined;
                    const research = pr.research as { sources?: { title: string }[]; citations?: { text: string }[] } | undefined;
                    const formatName = fpHook.selectedFormat ? formatRegistry.getFormat(fpHook.selectedFormat)?.name : 'video';

                    // Build a visual/narration lookup by sceneId for quick access
                    const visualMap = new Map(visuals.map(v => [v.sceneId, v.imageUrl]));
                    const narrationMap = new Map(narrations.map(n => [n.sceneId, n]));

                    return (
                        <motion.div key="pipeline-complete" {...quickFade} className="h-full overflow-y-auto">
                            <div className="w-full max-w-4xl mx-auto px-6 py-8">
                                {/* Header */}
                                <div className="text-center mb-8">
                                    <div className="w-14 h-14 mx-auto mb-4 rounded-full bg-emerald-500/10 border border-emerald-500/30 flex items-center justify-center">
                                        <Check className="w-7 h-7 text-emerald-400" />
                                    </div>
                                    <h2 className="text-2xl font-medium text-zinc-100 mb-1">Production Complete</h2>
                                    <p className="text-zinc-500 text-sm">
                                        {formatName} ‚Äî {screenplay.length} scene{screenplay.length !== 1 ? 's' : ''}
                                        {totalDuration != null && ` ‚Äî ${Math.round(totalDuration)}s`}
                                        {narrations.length > 0 && ` ‚Äî ${narrations.length} narration${narrations.length !== 1 ? 's' : ''}`}
                                    </p>
                                </div>

                                {/* Stats bar */}
                                <div className="flex flex-wrap justify-center gap-3 mb-8">
                                    <span className="px-3 py-1.5 bg-zinc-800/80 border border-zinc-700/50 rounded-sm text-xs font-mono text-zinc-300 flex items-center gap-1.5">
                                        <Film className="w-3.5 h-3.5 text-blue-400" />
                                        {screenplay.length} scenes
                                    </span>
                                    <span className="px-3 py-1.5 bg-zinc-800/80 border border-zinc-700/50 rounded-sm text-xs font-mono text-zinc-300 flex items-center gap-1.5">
                                        <ImageIcon className="w-3.5 h-3.5 text-purple-400" />
                                        {visuals.length} visuals
                                    </span>
                                    <span className="px-3 py-1.5 bg-zinc-800/80 border border-zinc-700/50 rounded-sm text-xs font-mono text-zinc-300 flex items-center gap-1.5">
                                        <Mic className="w-3.5 h-3.5 text-amber-400" />
                                        {narrations.length} narrations
                                    </span>
                                    {totalDuration != null && (
                                        <span className="px-3 py-1.5 bg-zinc-800/80 border border-zinc-700/50 rounded-sm text-xs font-mono text-zinc-300 flex items-center gap-1.5">
                                            <Play className="w-3.5 h-3.5 text-emerald-400" />
                                            {Math.floor(totalDuration / 60)}:{String(Math.round(totalDuration % 60)).padStart(2, '0')}
                                        </span>
                                    )}
                                    {research?.sources && (
                                        <span className="px-3 py-1.5 bg-zinc-800/80 border border-zinc-700/50 rounded-sm text-xs font-mono text-zinc-300">
                                            {research.sources.length} sources
                                        </span>
                                    )}
                                </div>

                                {/* Scene cards with visuals and audio */}
                                {screenplay.length > 0 && (
                                    <div className="space-y-4 mb-8">
                                        {screenplay.map((scene, i) => {
                                            const imageUrl = visualMap.get(scene.id);
                                            const narration = narrationMap.get(scene.id);
                                            return (
                                                <div key={scene.id} className="bg-zinc-900/60 border border-zinc-800 rounded-sm overflow-hidden">
                                                    <div className="flex flex-col sm:flex-row">
                                                        {/* Visual thumbnail */}
                                                        {imageUrl && (
                                                            <div className="sm:w-48 sm:shrink-0 aspect-video sm:aspect-auto sm:h-auto bg-zinc-950">
                                                                <img
                                                                    src={imageUrl}
                                                                    alt={`Scene ${i + 1}`}
                                                                    className="w-full h-full object-cover"
                                                                />
                                                            </div>
                                                        )}
                                                        {/* Scene content */}
                                                        <div className="flex-1 p-4 min-w-0">
                                                            <div className="flex items-start gap-2 mb-1.5">
                                                                <span className="font-mono text-[10px] text-blue-400 bg-blue-500/10 px-1.5 py-0.5 rounded shrink-0 mt-0.5">
                                                                    {String(i + 1).padStart(2, '0')}
                                                                </span>
                                                                <h4 className="text-sm font-medium text-zinc-200 leading-tight">{scene.heading}</h4>
                                                            </div>
                                                            <p className="text-xs text-zinc-400 line-clamp-3 mb-2" dir="auto">{scene.action}</p>

                                                            {/* Dialogue preview */}
                                                            {scene.dialogue && scene.dialogue.length > 0 && (
                                                                <div className="mb-2">
                                                                    {scene.dialogue.slice(0, 2).map((d, di) => (
                                                                        <p key={di} className="text-[11px] text-zinc-500 truncate">
                                                                            <span className="text-zinc-400 font-medium">{d.speaker}:</span> {d.text}
                                                                        </p>
                                                                    ))}
                                                                    {scene.dialogue.length > 2 && (
                                                                        <p className="text-[10px] text-zinc-600">+{scene.dialogue.length - 2} more</p>
                                                                    )}
                                                                </div>
                                                            )}

                                                            {/* Audio player for narration */}
                                                            {narration && narrationBlobUrlMap.get(scene.id) && (
                                                                <div className="flex items-center gap-2 mt-2">
                                                                    <Mic className="w-3 h-3 text-amber-400 shrink-0" />
                                                                    <audio
                                                                        controls
                                                                        className="h-7 w-full max-w-xs [&::-webkit-media-controls-panel]:bg-zinc-800 [&::-webkit-media-controls-panel]:rounded-sm"
                                                                        src={narrationBlobUrlMap.get(scene.id)}
                                                                    />
                                                                    <span className="text-[10px] text-zinc-500 font-mono shrink-0">{narration.audioDuration.toFixed(1)}s</span>
                                                                </div>
                                                            )}
                                                        </div>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                )}

                                {/* Completed task summary (collapsed) */}
                                {fpHook.tasks.length > 0 && (
                                    <details className="mb-8 group">
                                        <summary className="text-xs text-zinc-500 cursor-pointer hover:text-zinc-400 transition-colors font-mono text-center">
                                            Pipeline tasks
                                        </summary>
                                        <div className="mt-3">
                                            <PipelineProgress
                                                executionProgress={fpHook.executionProgress}
                                                tasks={fpHook.tasks}
                                                currentPhase="Complete"
                                                isRunning={false}
                                                onCancel={() => { }}
                                                summaryOnly
                                            />
                                        </div>
                                    </details>
                                )}

                                {/* Actions */}
                                <div className="flex items-center justify-center gap-3">
                                    {/* Download all visuals */}
                                    {visuals.length > 0 && (
                                        <button
                                            type="button"
                                            onClick={() => {
                                                visuals.forEach((v, i) => {
                                                    const a = document.createElement('a');
                                                    a.href = v.imageUrl;
                                                    a.download = `scene_${i + 1}.png`;
                                                    a.click();
                                                });
                                            }}
                                            className="inline-flex items-center gap-2 px-5 py-2.5 rounded-sm font-mono text-sm font-medium border border-zinc-700 text-zinc-300 hover:border-zinc-500 hover:text-zinc-100 transition-colors duration-200"
                                        >
                                            <Download className="w-4 h-4" />
                                            Download Images
                                        </button>
                                    )}
                                    {onOpenInEditor && (
                                        <button
                                            type="button"
                                            onClick={onOpenInEditor}
                                            className="inline-flex items-center gap-2 px-5 py-2.5 rounded-sm font-mono text-sm font-medium bg-blue-500/10 border border-blue-500/30 text-blue-400 hover:bg-blue-500/20 hover:text-blue-300 hover:border-blue-500/50 transition-colors duration-200"
                                        >
                                            <Film className="w-4 h-4" />
                                            Open in Editor
                                        </button>
                                    )}
                                    <button
                                        type="button"
                                        onClick={fpHook.reset}
                                        className="inline-flex items-center gap-2 px-5 py-2.5 rounded-sm font-mono text-sm font-medium bg-white text-black hover:bg-zinc-200 transition-colors duration-200"
                                    >
                                        <RefreshCcw className="w-4 h-4" />
                                        Start New Production
                                    </button>
                                </div>
                            </div>
                        </motion.div>
                    );
                }

                // State 3: Pipeline failed or cancelled ‚Üí error view with retry
                if (!fpHook.isRunning && (fpHook.error || fpHook.result?.success === false)) {
                    const errorMsg = fpHook.error || fpHook.result?.error || 'Pipeline failed';
                    const wasCancelled = fpHook.tasks.some(t => t.status === 'cancelled');
                    return (
                        <motion.div key="pipeline-error" {...quickFade} className="h-full flex items-center justify-center p-8">
                            <div className="w-full max-w-2xl mx-auto text-center">
                                <div className={`w-16 h-16 mx-auto mb-6 rounded-full flex items-center justify-center ${wasCancelled ? 'bg-zinc-500/10 border border-zinc-500/30' : 'bg-red-500/10 border border-red-500/30'}`}>
                                    {wasCancelled
                                        ? <X className="w-8 h-8 text-zinc-400" />
                                        : <AlertCircle className="w-8 h-8 text-red-400" />
                                    }
                                </div>
                                <h2 className="text-2xl font-medium text-zinc-100 mb-2">
                                    {wasCancelled ? 'Production Cancelled' : 'Production Failed'}
                                </h2>
                                <p className="text-zinc-400 text-sm mb-4">{errorMsg}</p>
                                {/* Task summary showing what completed */}
                                {fpHook.tasks.length > 0 && (
                                    <div className="mb-8">
                                        <PipelineProgress
                                            executionProgress={fpHook.executionProgress}
                                            tasks={fpHook.tasks}
                                            currentPhase={wasCancelled ? 'Cancelled' : 'Failed'}
                                            isRunning={false}
                                            onCancel={() => { }}
                                            summaryOnly
                                        />
                                    </div>
                                )}
                                <div className="flex items-center justify-center gap-3">
                                    <button
                                        type="button"
                                        onClick={fpHook.reset}
                                        className="inline-flex items-center gap-2 px-6 py-2.5 rounded-sm font-mono text-sm font-medium border border-zinc-700 text-zinc-300 hover:border-zinc-500 hover:text-zinc-100 transition-colors duration-200"
                                    >
                                        <RefreshCcw className="w-4 h-4" />
                                        Start Over
                                    </button>
                                </div>
                            </div>
                        </motion.div>
                    );
                }

                // State 4: movie-animation selected ‚Üí IdeaView with synced idea/genre
                if (isMovieAnimation) {
                    return (
                        <motion.div key="idea" {...quickFade} className="h-full">
                            <IdeaView
                                initialTopic={fpHook.idea || initialTopic}
                                onGenerate={(topic, genre) => onGenerateIdea?.(topic, genre)}
                                onApplyTemplate={onApplyTemplate}
                                isProcessing={isProcessing}
                            />
                        </motion.div>
                    );
                }

                // State 5: FormatSelector (no format yet, or a non-movie format selected but idle)
                const selectedMeta = fpHook.selectedFormat ? formatRegistry.getFormat(fpHook.selectedFormat) : null;
                return (
                    <motion.div key="format-selector" {...quickFade} className="h-full overflow-y-auto">
                        {/* Error banner from previous failed attempt */}
                        {fpHook.error && !fpHook.isRunning && !fpHook.result && (
                            <div className="mx-6 mt-6 p-4 rounded-sm bg-red-500/10 border border-red-500/30 flex items-start gap-3">
                                <AlertCircle className="w-5 h-5 text-red-400 shrink-0 mt-0.5" />
                                <div className="flex-1">
                                    <p className="text-sm text-zinc-100 font-medium">Something went wrong</p>
                                    <p className="text-xs text-zinc-500 mt-1">{fpHook.error}</p>
                                </div>
                            </div>
                        )}
                        <FormatSelector
                            selectedFormat={fpHook.selectedFormat}
                            onFormatSelect={fpHook.setFormat}
                            selectedGenre={fpHook.selectedGenre}
                            onGenreSelect={fpHook.setGenre}
                            idea={fpHook.idea}
                            onIdeaChange={fpHook.setIdea}
                            onExecute={() => onFormatExecute?.()}
                            isProcessing={fpHook.isRunning}
                        />
                        {/* Reference document upload for research formats */}
                        {selectedMeta?.requiresResearch && (
                            <div className="px-6 pb-12 max-w-3xl mx-auto">
                                <div className="mb-3">
                                    <span className="font-mono text-[11px] font-medium tracking-[0.15em] uppercase text-zinc-500">
                                        Reference Documents (Optional)
                                    </span>
                                </div>
                                <ReferenceDocumentUpload
                                    documents={fpHook.referenceDocuments}
                                    onDocumentsChange={fpHook.setReferenceDocuments}
                                />
                            </div>
                        )}
                    </motion.div>
                );
            }

            // Fallback: no format pipeline hook ‚Äî existing IdeaView (backward compat)
            return (
                <motion.div key="idea" {...quickFade} className="h-full">
                    <IdeaView
                        initialTopic={initialTopic}
                        onGenerate={(topic, genre) => onGenerateIdea?.(topic, genre)}
                        onApplyTemplate={onApplyTemplate}
                        isProcessing={isProcessing}
                    />
                </motion.div>
            );
        }

        if (activeMainTab === 'breakdown') {
            if (isBreakdownProcessing) {
                return (
                    <motion.div key="breakdown-progress" {...quickFade}>
                        <BreakdownProgress currentStage="creating" />
                    </motion.div>
                );
            }

            const breakdownTabs: { id: StoryStep; label: string }[] = [
                { id: 'breakdown', label: t('story.sceneBreakdown') },
                { id: 'script', label: t('story.script') },
                { id: 'characters', label: t('story.cast') },
            ];

            return (
                <motion.div key="breakdown" {...quickFade} className="flex flex-col h-full">
                    {renderSubNav(breakdownTabs)}
                    <div className="flex-1 overflow-y-auto bg-black">
                        <AnimatePresence mode="wait">
                            {subTab === 'breakdown' && (
                                <motion.div key="scene-breakdown" {...quickFade} className="p-8 max-w-5xl mx-auto w-full">
                                    <h2 className="font-sans text-2xl font-medium tracking-tight text-zinc-100 mb-8">
                                        {t('story.sceneBreakdown')}
                                    </h2>
                                    <div className="space-y-4">
                                        {storyState.breakdown.map((scene) => (
                                            <SceneCard
                                                key={scene.id}
                                                sceneNumber={scene.sceneNumber}
                                                heading={scene.heading}
                                                content={scene.action}
                                                onRegenerate={(num, feedback) => onRegenerateScene?.(num, feedback)}
                                                isProcessing={isProcessing}
                                            />
                                        ))}
                                    </div>
                                </motion.div>
                            )}
                            {subTab === 'script' && (
                                <motion.div key="script" {...quickFade}>
                                    <ScriptView script={storyState.script} />
                                </motion.div>
                            )}
                            {subTab === 'characters' && (
                                <motion.div key="characters" {...quickFade}>
                                    <CharacterView
                                        characters={storyState.characters}
                                        reports={storyState.consistencyReports}
                                        onVerify={onVerifyConsistency}
                                        isProcessing={isProcessing}
                                        onAdd={onAddCharacter}
                                        onEdit={onEditCharacter}
                                        onDelete={onDeleteCharacter}
                                        onGenerateImage={onGenerateCharacterImage}
                                    />
                                </motion.div>
                            )}
                        </AnimatePresence>
                    </div>
                </motion.div>
            );
        }

        if (activeMainTab === 'storyboard') {
            if (isStoryboardProcessing) {
                return (
                    <motion.div key="storyboard-progress" {...quickFade}>
                        <StoryboardProgress currentStage={storyState.shots?.length ? 'storyboard' : 'shotlist'} />
                    </motion.div>
                );
            }

            const storyboardTabs: { id: StoryStep; label: string }[] = [
                { id: 'shots', label: t('story.shotList') },
                { id: 'style', label: t('story.visualStyle') },
                { id: 'storyboard', label: t('story.storyboard') },
                { id: 'narration', label: t('story.narration') },
                { id: 'animation', label: t('story.animation') },
                { id: 'export', label: t('story.export') },
            ];

            return (
                <motion.div key="storyboard" {...quickFade} className="flex flex-col h-full">
                    {renderSubNav(storyboardTabs)}
                    <div className={`flex-1 bg-black ${subTab === 'storyboard' ? 'overflow-hidden flex flex-col' : 'overflow-y-auto'}`}>
                        <AnimatePresence mode="wait">
                            {subTab === 'shots' && (
                                <motion.div key="shots" {...quickFade} className="p-6">
                                    <div className="flex justify-between items-center mb-8">
                                        <h2 className="font-sans text-2xl font-medium tracking-tight text-zinc-100">
                                            {t('story.shotBreakdown')}
                                        </h2>
                                        {storyState.isLocked && (
                                            <div className="flex items-center gap-2.5 px-4 py-2.5 bg-blue-500/10 text-blue-400 rounded-sm border border-blue-500/30">
                                                <Lock className="w-4 h-4" />
                                                <div className="flex flex-col">
                                                    <span className="text-sm font-mono font-bold tracking-wide">{t('story.locked')}</span>
                                                    <span className="text-[10px] text-zinc-500">Structure finalized</span>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                    <div className="space-y-8">
                                        {storyState.breakdown.map((scene, idx) => {
                                            const sceneShots = storyState.shots?.filter(s => s.sceneId === scene.id) || [];
                                            const moodLighting = sceneShots[0]?.lighting || '';
                                            return (
                                                <div key={scene.id} className="rounded-sm overflow-hidden border border-zinc-800">
                                                    {/* Scene Header */}
                                                    <div className="px-5 py-3 bg-zinc-950 flex items-center justify-between border-b border-zinc-800">
                                                        <div className="flex items-center gap-3 min-w-0">
                                                            <span className="font-mono text-xs font-bold text-blue-400 bg-blue-500/10 px-2.5 py-1 rounded-sm border border-blue-500/20 shrink-0">
                                                                SCENE {scene.sceneNumber}
                                                            </span>
                                                            <span className="font-mono text-sm font-medium text-zinc-100 truncate" dir="auto">
                                                                {scene.heading}
                                                            </span>
                                                            {moodLighting && (
                                                                <span className="flex items-center gap-1.5 text-[11px] text-zinc-500 shrink-0">
                                                                    <span className="w-1.5 h-1.5 rounded-full bg-amber-400/70" />
                                                                    {moodLighting}
                                                                </span>
                                                            )}
                                                        </div>
                                                        {!sceneShots.length && onGenerateShots && (
                                                            <button
                                                                onClick={() => onGenerateShots(idx)}
                                                                className="text-xs px-4 py-1.5 rounded-sm bg-blue-500 hover:bg-blue-600 text-white font-medium transition-colors duration-200 shrink-0 ml-4"
                                                            >
                                                                {t('story.generateShots')}
                                                            </button>
                                                        )}
                                                    </div>

                                                    {/* Shots Table */}
                                                    {sceneShots.length > 0 ? (
                                                        <div className="overflow-x-auto">
                                                            <table className="w-full text-left border-collapse">
                                                                <thead>
                                                                    <tr className="border-b border-zinc-800 bg-zinc-900/60">
                                                                        <th className="py-2 px-2 w-6" />
                                                                        <th className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-600 w-16">Scene</th>
                                                                        <th className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-600 w-14">Shot</th>
                                                                        <th className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-600 min-w-[220px]">Description</th>
                                                                        <th className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-600 w-20">Dialogue</th>
                                                                        <th className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-600 w-16">ERT</th>
                                                                        <th className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-600 w-28">Size</th>
                                                                        <th className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-600 w-28">Perspective</th>
                                                                        <th className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-600 w-28">Movement</th>
                                                                        <th className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-600 w-28">Equipment</th>
                                                                        <th className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-600 w-28">Focal Length</th>
                                                                        <th className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-600 w-24">Aspect Ratio</th>
                                                                        <th className="py-2 px-3 font-mono text-[10px] tracking-[0.12em] uppercase text-zinc-600 w-16">Notes</th>
                                                                    </tr>
                                                                </thead>
                                                                <tbody>
                                                                    {sceneShots.map((shot) => {
                                                                        const equipment = shot.equipment ?? deriveEquipment(shot.movement);
                                                                        const focalLength = shot.focalLength ?? deriveFocalLength(shot.shotType ?? shot.cameraAngle ?? '');
                                                                        const hasDialogue = !!shot.scriptSegment;
                                                                        return (
                                                                            <tr
                                                                                key={shot.id}
                                                                                className="border-b border-zinc-800/50 hover:bg-zinc-800/25 transition-colors group"
                                                                            >
                                                                                <td className="py-3 px-2 text-zinc-700 group-hover:text-zinc-500">
                                                                                    <GripVertical className="w-3.5 h-3.5" />
                                                                                </td>
                                                                                <td className="py-3 px-3 font-mono text-xs text-zinc-500">
                                                                                    {scene.sceneNumber}
                                                                                </td>
                                                                                <td className="py-3 px-3 font-mono text-xs text-blue-400 font-bold">
                                                                                    {shot.shotNumber}
                                                                                </td>
                                                                                <td className="py-3 px-3 text-xs text-zinc-300 leading-relaxed" dir="auto">
                                                                                    {shot.description}
                                                                                </td>
                                                                                <td className="py-3 px-3">
                                                                                    <button
                                                                                        className={`p-1.5 rounded-sm transition-colors ${hasDialogue ? 'text-blue-400 hover:text-blue-300' : 'text-zinc-700 hover:text-zinc-500'}`}
                                                                                        title={shot.scriptSegment || undefined}
                                                                                    >
                                                                                        <MessageCircle className="w-3.5 h-3.5" />
                                                                                    </button>
                                                                                </td>
                                                                                <td className="py-3 px-3 text-xs text-zinc-400 whitespace-nowrap">
                                                                                    {shot.duration} sec
                                                                                </td>
                                                                                <td className="py-3 px-3 text-xs text-zinc-400 whitespace-nowrap">
                                                                                    {shot.shotType}
                                                                                </td>
                                                                                <td className="py-3 px-3 text-xs text-zinc-400 whitespace-nowrap">
                                                                                    {shot.cameraAngle}
                                                                                </td>
                                                                                <td className="py-3 px-3 text-xs text-zinc-400 whitespace-nowrap">
                                                                                    {shot.movement}
                                                                                </td>
                                                                                <td className="py-3 px-3 text-xs text-zinc-400 whitespace-nowrap">
                                                                                    {equipment}
                                                                                </td>
                                                                                <td className="py-3 px-3 text-xs text-zinc-400 whitespace-nowrap">
                                                                                    {focalLength}
                                                                                </td>
                                                                                <td className="py-3 px-3 text-xs text-zinc-400 whitespace-nowrap">
                                                                                    {shot.aspectRatio ?? storyState.aspectRatio ?? '16:9'}
                                                                                </td>
                                                                                <td className="py-3 px-3">
                                                                                    <div className="flex items-center gap-1.5">
                                                                                        {shot.notes && (
                                                                                            <span className="text-[10px] text-zinc-500 truncate max-w-[80px]" title={shot.notes}>
                                                                                                {shot.notes}
                                                                                            </span>
                                                                                        )}
                                                                                        <button
                                                                                            onClick={() => setEditingShot(shot)}
                                                                                            className="p-1.5 rounded-sm text-zinc-600 hover:text-zinc-300 hover:bg-zinc-800 transition-colors shrink-0"
                                                                                            title="Edit shot"
                                                                                        >
                                                                                            <Pencil className="w-3.5 h-3.5" />
                                                                                        </button>
                                                                                    </div>
                                                                                </td>
                                                                            </tr>
                                                                        );
                                                                    })}
                                                                </tbody>
                                                            </table>
                                                        </div>
                                                    ) : (
                                                        <div className="text-center py-12">
                                                            <ImageIcon className="w-12 h-12 mx-auto mb-4 text-zinc-800" />
                                                            <p className="text-zinc-600 text-sm">
                                                                {t('story.noShotsGenerated')}
                                                            </p>
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })}
                                    </div>
                                </motion.div>
                            )}
                            {subTab === 'style' && (
                                <motion.div key="style" {...quickFade}>
                                    <StyleSelector
                                        selectedStyle={(storyState.visualStyle || 'CINEMATIC') as VisualStyleKey}
                                        onSelectStyle={(style) => onUpdateVisualStyle?.(style)}
                                        aspectRatio={(storyState.aspectRatio || '16:9') as AspectRatioId}
                                        onSelectAspectRatio={(ratio) => onUpdateAspectRatio?.(ratio)}
                                        imageProvider={storyState.imageProvider || 'gemini'}
                                        onSelectImageProvider={onUpdateImageProvider}
                                    />
                                </motion.div>
                            )}
                            {subTab === 'storyboard' && (
                                <motion.div key="storyboard-view" {...quickFade} className="h-full">
                                    <StoryboardView
                                        shots={storyState.shotlist}
                                        scenes={storyState.breakdown}
                                        scenesWithVisuals={storyState.scenesWithVisuals}
                                        onGenerateVisuals={onGenerateVisuals}
                                        isProcessing={isProcessing}
                                        onUpdateDuration={onUpdateShotDuration}
                                        onGenerateVideo={onGenerateVideo}
                                        onEditShot={(shotId) => {
                                            const shot = storyState.shotlist.find(s => s.id === shotId);
                                            if (shot) setEditingShot(shot);
                                        }}
                                    />
                                </motion.div>
                            )}
                            {subTab === 'narration' && (
                                <motion.div key="narration-view" {...quickFade} className="p-8 max-w-5xl mx-auto w-full">
                                    <div className="flex justify-between items-center mb-8">
                                        <h2 className="font-sans text-2xl font-medium tracking-tight text-zinc-100">
                                            {t('story.narration')}
                                        </h2>
                                        {onGenerateNarration && (
                                            <button
                                                onClick={onGenerateNarration}
                                                disabled={isProcessing}
                                                className="px-5 py-2.5 rounded-sm text-sm font-medium flex items-center gap-2 bg-blue-500 hover:bg-blue-600 text-white disabled:opacity-50 transition-colors duration-200"
                                            >
                                                <Mic className="w-4 h-4" />
                                                {allScenesHaveNarration?.() ? t('story.regenerateNarration') : t('story.generateNarration')}
                                            </button>
                                        )}
                                    </div>
                                    <p className="text-zinc-500 text-sm mb-6">
                                        {t('story.narrationDescription')}
                                    </p>
                                    <div className="space-y-4">
                                        {storyState.narrationSegments?.map((segment, idx) => (
                                            <div
                                                key={segment.sceneId}
                                                className="bg-zinc-900 border border-zinc-800 p-5 rounded-sm"
                                            >
                                                <div className="flex items-center justify-between mb-3">
                                                    <span className="font-mono text-xs text-blue-400">
                                                        SCENE {String(idx + 1).padStart(2, '0')}
                                                    </span>
                                                    <span className="font-mono text-xs text-zinc-600">
                                                        {segment.duration.toFixed(1)}s
                                                    </span>
                                                </div>
                                                <p className="text-zinc-400 text-sm mb-3" dir="auto">
                                                    {segment.text}
                                                </p>
                                                {segment.audioUrl && (
                                                    <audio src={segment.audioUrl} controls className="w-full h-8 opacity-80" />
                                                )}
                                            </div>
                                        ))}
                                        {(!storyState.narrationSegments || storyState.narrationSegments.length === 0) && (
                                            <div className="text-center py-16 text-zinc-600">
                                                <Mic className="w-12 h-12 mx-auto mb-4 opacity-30" />
                                                <p className="text-sm">{t('story.noNarrationYet')}</p>
                                                <p className="text-xs mt-2 text-zinc-700">{t('story.clickGenerateNarration')}</p>
                                            </div>
                                        )}
                                    </div>
                                </motion.div>
                            )}
                            {subTab === 'animation' && (
                                <motion.div key="animation-view" {...quickFade} className="p-8 max-w-6xl mx-auto w-full">
                                    <div className="flex justify-between items-center mb-8">
                                        <h2 className="font-sans text-2xl font-medium tracking-tight text-zinc-100">
                                            {t('story.animation')}
                                        </h2>
                                        {onAnimateShots && (
                                            <button
                                                onClick={() => onAnimateShots()}
                                                disabled={isProcessing}
                                                className="px-5 py-2.5 rounded-sm text-sm font-medium flex items-center gap-2 bg-blue-500 hover:bg-blue-600 text-white disabled:opacity-50 transition-colors duration-200"
                                            >
                                                <Video className="w-4 h-4" />
                                                {allShotsHaveAnimation?.() ? t('story.regenerateAll') : t('story.animateAllShots')}
                                            </button>
                                        )}
                                    </div>
                                    <p className="text-zinc-500 text-sm mb-6">
                                        {t('story.animationDescription')}
                                    </p>
                                    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                                        {storyState.shotlist.map((shot, idx) => {
                                            const animated = animatedShotsMap.get(shot.id);
                                            return (
                                                <div
                                                    key={shot.id}
                                                    className="bg-zinc-900 border border-zinc-800 rounded-sm overflow-hidden group"
                                                >
                                                    <div className="aspect-video bg-zinc-950 relative">
                                                        {animated?.videoUrl ? (
                                                            <video
                                                                src={animated.videoUrl}
                                                                className="w-full h-full object-cover"
                                                                loop muted playsInline
                                                                onMouseEnter={(e) => e.currentTarget.play()}
                                                                onMouseLeave={(e) => { e.currentTarget.pause(); e.currentTarget.currentTime = 0; }}
                                                            />
                                                        ) : shot.imageUrl ? (
                                                            <img src={shot.imageUrl} alt={shot.description} className="w-full h-full object-cover opacity-60" />
                                                        ) : (
                                                            <div className="w-full h-full flex items-center justify-center">
                                                                <Video className="w-8 h-8 text-zinc-800" />
                                                            </div>
                                                        )}
                                                        {animatingShotIds.has(shot.id) && (
                                                            <div className="absolute inset-0 flex items-center justify-center bg-black/60">
                                                                <Loader2 className="w-8 h-8 text-white animate-spin" />
                                                            </div>
                                                        )}
                                                        {!animated && !animatingShotIds.has(shot.id) && shot.imageUrl && onAnimateShots && (
                                                            <button
                                                                onClick={() => {
                                                                    const shotId = shot.id;
                                                                    setAnimatingShotIds(prev => new Set(prev).add(shotId));
                                                                    try {
                                                                        onAnimateShots(idx);
                                                                    } catch {
                                                                        // Clear spinner immediately on synchronous failure;
                                                                        // async failures are cleared by the isProcessing ‚Üí false effect.
                                                                        setAnimatingShotIds(prev => {
                                                                            const next = new Set(prev);
                                                                            next.delete(shotId);
                                                                            return next;
                                                                        });
                                                                    }
                                                                }}
                                                                disabled={isProcessing}
                                                                className="absolute inset-0 flex items-center justify-center bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity duration-200"
                                                            >
                                                                <Play className="w-8 h-8 text-white" />
                                                            </button>
                                                        )}
                                                        {animated && (
                                                            <div className="absolute top-2 right-2 px-2 py-0.5 bg-emerald-500/80 text-white text-[10px] rounded-sm uppercase tracking-wider font-mono">
                                                                {t('story.animated')}
                                                            </div>
                                                        )}
                                                    </div>
                                                    <div className="p-3">
                                                        <span className="font-mono text-[10px] text-blue-400">
                                                            SHOT {shot.shotNumber}
                                                        </span>
                                                        <p className="text-xs text-zinc-500 truncate mt-1">
                                                            {shot.description}
                                                        </p>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                        {storyState.shotlist.length === 0 && (
                                            <div className="col-span-full text-center py-16 text-zinc-600">
                                                <Video className="w-12 h-12 mx-auto mb-4 opacity-30" />
                                                <p className="text-sm">{t('story.noShotsToAnimate')}</p>
                                                <p className="text-xs mt-2 text-zinc-700">{t('story.generateStoryboardFirst')}</p>
                                            </div>
                                        )}
                                    </div>
                                </motion.div>
                            )}
                            {subTab === 'export' && (
                                <motion.div key="export-view" {...quickFade} className="p-8 max-w-3xl mx-auto w-full">
                                    <h2 className="font-sans text-2xl font-medium tracking-tight text-zinc-100 mb-8 text-center">
                                        {t('story.exportVideo')}
                                    </h2>
                                    <div className="bg-zinc-900 border border-zinc-800 rounded-sm p-8">
                                        {/* Preview */}
                                        {storyState.finalVideoUrl ? (
                                            <div className="mb-8">
                                                <video src={storyState.finalVideoUrl} controls className="w-full rounded-sm" />
                                            </div>
                                        ) : (
                                            <div className="aspect-video bg-zinc-950 rounded-sm flex items-center justify-center mb-8 border border-zinc-800">
                                                <Film className="w-16 h-16 text-zinc-800" />
                                            </div>
                                        )}
                                        {/* Stats */}
                                        <div className="grid grid-cols-3 gap-4 mb-8">
                                            <div className="text-center p-4 bg-zinc-950 rounded-sm border border-zinc-800">
                                                <div className="text-2xl font-sans font-medium text-blue-400">
                                                    {storyState.breakdown.length}
                                                </div>
                                                <div className="font-mono text-[10px] text-zinc-600 uppercase tracking-widest">{t('story.scenes')}</div>
                                            </div>
                                            <div className="text-center p-4 bg-zinc-950 rounded-sm border border-zinc-800">
                                                <div className="text-2xl font-sans font-medium text-orange-400">
                                                    {storyState.shotlist.length}
                                                </div>
                                                <div className="font-mono text-[10px] text-zinc-600 uppercase tracking-widest">{t('story.shots')}</div>
                                            </div>
                                            <div className="text-center p-4 bg-zinc-950 rounded-sm border border-zinc-800">
                                                <div className="text-2xl font-sans font-medium text-emerald-400">
                                                    {storyState.narrationSegments?.reduce((sum, s) => sum + s.duration, 0).toFixed(0) || 0}s
                                                </div>
                                                <div className="font-mono text-[10px] text-zinc-600 uppercase tracking-widest">{t('story.duration')}</div>
                                            </div>
                                        </div>
                                        {/* Actions */}
                                        <div className="flex flex-col gap-3">
                                            {!storyState.finalVideoUrl ? (
                                                <button
                                                    onClick={onExportFinalVideo}
                                                    disabled={isProcessing || !storyState.narrationSegments?.length || !storyState.shotlist.some(s => s.imageUrl)}
                                                    className="w-full py-4 rounded-sm text-sm font-medium flex items-center justify-center gap-2 bg-blue-500 hover:bg-blue-600 text-white disabled:opacity-50 transition-colors duration-200"
                                                >
                                                    {isProcessing ? (
                                                        <><Loader2 className="w-5 h-5 animate-spin" />{t('story.renderingVideo')}</>
                                                    ) : (
                                                        <><Film className="w-5 h-5" />{t('story.exportVideo')}</>
                                                    )}
                                                </button>
                                            ) : (
                                                <button
                                                    onClick={onDownloadVideo}
                                                    className="w-full bg-emerald-600 hover:bg-emerald-500 text-white py-4 rounded-sm text-sm font-medium flex items-center justify-center gap-2 transition-colors duration-200"
                                                >
                                                    <Download className="w-5 h-5" />
                                                    {t('story.downloadVideo')}
                                                </button>
                                            )}
                                            {!storyState.shotlist.some(s => s.imageUrl) && (
                                                <p className="text-center text-xs text-orange-400">
                                                    {t('story.generateStoryboardFirst')}
                                                </p>
                                            )}
                                            {storyState.shotlist.some(s => s.imageUrl) && !storyState.narrationSegments?.length && (
                                                <p className="text-center text-xs text-orange-400">
                                                    {t('story.generateNarrationBeforeExport')}
                                                </p>
                                            )}
                                        </div>
                                    </div>

                                    <div className="mt-6">
                                        <ExportOptionsPanel
                                            storyState={storyState}
                                            onImportProject={onImportProject}
                                            onExportVideo={onExportFinalVideo}
                                        />
                                    </div>
                                </motion.div>
                            )}
                        </AnimatePresence>
                    </div>
                </motion.div>
            );
        }
        return null;
    };

    return (
        <div className="flex flex-col h-full bg-black font-sans relative overflow-hidden">
            {/* Main Top Navigation */}
            <div className="relative z-10 flex items-center justify-between px-6 py-3 border-b border-zinc-800 bg-zinc-950">
                {/* Step Navigation */}
                <div className="flex items-center gap-1">
                    {mainTabs.map((tab, index) => {
                        const isActive = activeMainTab === tab.id;
                        const stepOrder: MainStep[] = ['idea', 'breakdown', 'storyboard'];
                        const currentIdx = stepOrder.indexOf(getHighLevelStep(storyState.currentStep));
                        const tabIdx = stepOrder.indexOf(tab.id);
                        const isAccessible = tabIdx <= currentIdx;
                        const isCompleted = tabIdx < currentIdx;

                        return (
                            <React.Fragment key={tab.id}>
                                <button
                                    onClick={() => {
                                        if (isAccessible) {
                                            setActiveMainTab(tab.id);
                                            if (tab.id === 'breakdown') setSubTab('breakdown');
                                            if (tab.id === 'storyboard') setSubTab('shots');
                                            if (tab.id === 'idea') setSubTab('idea');
                                        }
                                    }}
                                    disabled={!isAccessible}
                                    className={`
                                        relative flex items-center gap-2.5 px-4 py-2 rounded-sm transition-all duration-200
                                        ${isActive ? 'bg-zinc-800 border border-zinc-700' : 'border border-transparent'}
                                        ${!isAccessible ? 'opacity-40 cursor-not-allowed' : isActive ? 'opacity-100' : 'opacity-70 hover:opacity-100'}
                                    `}
                                >
                                    <span className={`
                                        w-5 h-5 rounded-sm flex items-center justify-center text-[10px] font-mono font-bold shrink-0 transition-all duration-200
                                        ${isActive ? 'bg-white text-black' : isCompleted ? 'bg-emerald-500/20 text-emerald-400' : 'bg-zinc-800 text-zinc-400'}
                                    `}>
                                        {isCompleted ? <Check className="w-3 h-3" /> : tab.number}
                                    </span>
                                    <span className={`
                                        font-sans text-[13px] font-medium whitespace-nowrap transition-colors duration-200
                                        ${isActive ? 'text-zinc-100' : isCompleted ? 'text-emerald-400/80' : 'text-zinc-400'}
                                    `}>
                                        {tab.label}
                                    </span>
                                </button>

                                {index < mainTabs.length - 1 && (
                                    <div className={`w-6 h-px mx-0.5 shrink-0 ${isCompleted ? 'bg-emerald-500/30' : 'bg-zinc-800'}`} />
                                )}
                            </React.Fragment>
                        );
                    })}
                </div>

                {/* Action Buttons */}
                <div className="flex items-center gap-2">
                    {activeMainTab !== 'idea' && (
                        <div className="flex items-center gap-0.5 mr-1">
                            <button
                                onClick={onUndo}
                                disabled={!canUndo}
                                className="p-1.5 rounded-sm text-zinc-600 hover:text-zinc-300 hover:bg-zinc-800 disabled:opacity-20 transition-all duration-200"
                                title="Undo (Ctrl+Z)"
                            >
                                <Undo2 className="w-3.5 h-3.5" />
                            </button>
                            <button
                                onClick={onRedo}
                                disabled={!canRedo}
                                className="p-1.5 rounded-sm text-zinc-600 hover:text-zinc-300 hover:bg-zinc-800 disabled:opacity-20 transition-all duration-200"
                                title="Redo (Ctrl+Y)"
                            >
                                <Redo2 className="w-3.5 h-3.5" />
                            </button>
                            {projectId && (
                                <button
                                    onClick={() => setShowVersionHistory(true)}
                                    className="p-1.5 rounded-sm text-zinc-600 hover:text-zinc-300 hover:bg-zinc-800 transition-all duration-200"
                                    title="Version History"
                                >
                                    <History className="w-3.5 h-3.5" />
                                </button>
                            )}
                            <div className="w-px h-4 bg-zinc-800 mx-1" />
                        </div>
                    )}

                    {/* Context-sensitive action button */}
                    {activeMainTab === 'breakdown' && subTab === 'breakdown' && storyState.breakdown.length > 0 && (
                        <button
                            onClick={() => handleTabNavigation('script')}
                            disabled={isProcessing}
                            className="flex items-center gap-2 px-4 py-1.5 rounded-sm font-sans text-[12px] font-medium bg-white text-black hover:bg-zinc-200 disabled:opacity-40 transition-all duration-200"
                        >
                            {isProcessing ? t('studio.generating') : t('story.createScript')}
                        </button>
                    )}
                    {activeMainTab === 'breakdown' && subTab === 'script' && (
                        <div className="flex items-center gap-2">
                            {onExportScript && (
                                <button
                                    onClick={onExportScript}
                                    className="p-1.5 rounded-sm text-zinc-600 hover:text-zinc-300 hover:bg-zinc-800 transition-all duration-200"
                                    title="Export"
                                >
                                    <Download className="w-3.5 h-3.5" />
                                </button>
                            )}
                            <button
                                onClick={handleProceed}
                                className="flex items-center gap-2 px-4 py-1.5 rounded-sm font-sans text-[12px] font-medium bg-white text-black hover:bg-zinc-200 transition-all duration-200"
                            >
                                {!storyState.isLocked && <Lock className="w-3 h-3" />}
                                {storyState.isLocked ? t('story.continueToCast') : t('story.lockScript')}
                            </button>
                        </div>
                    )}
                    {activeMainTab === 'breakdown' && subTab === 'characters' && (
                        <button
                            onClick={onNextStep}
                            className="flex items-center gap-2 px-4 py-1.5 rounded-sm font-sans text-[12px] font-medium bg-white text-black hover:bg-zinc-200 transition-all duration-200"
                        >
                            {t('story.createShotList')}
                        </button>
                    )}
                    {activeMainTab === 'storyboard' && subTab === 'shots' && (
                        <button
                            onClick={() => setSubTab('style')}
                            className="flex items-center gap-2 px-4 py-1.5 rounded-sm font-sans text-[12px] font-medium bg-white text-black hover:bg-zinc-200 transition-all duration-200"
                        >
                            {t('story.selectStyle')}
                        </button>
                    )}
                    {activeMainTab === 'storyboard' && subTab === 'style' && (
                        <button
                            onClick={onNextStep}
                            className="flex items-center gap-2 px-4 py-1.5 rounded-sm font-sans text-[12px] font-medium bg-white text-black hover:bg-zinc-200 transition-all duration-200"
                        >
                            {t('story.generateStoryboard')}
                        </button>
                    )}
                    {activeMainTab === 'storyboard' && subTab === 'storyboard' && storyState.scenesWithVisuals?.length && (
                        <button
                            onClick={() => setSubTab('narration')}
                            className="flex items-center gap-2 px-4 py-1.5 rounded-sm font-sans text-[12px] font-medium bg-white text-black hover:bg-zinc-200 transition-all duration-200"
                        >
                            <Mic className="w-3 h-3" />
                            {t('story.addNarration')}
                        </button>
                    )}
                    {activeMainTab === 'storyboard' && subTab === 'narration' && storyState.narrationSegments?.length && (
                        <button
                            onClick={() => setSubTab('animation')}
                            className="flex items-center gap-2 px-4 py-1.5 rounded-sm font-sans text-[12px] font-medium bg-white text-black hover:bg-zinc-200 transition-all duration-200"
                        >
                            <Video className="w-3 h-3" />
                            {t('story.animateShots')}
                        </button>
                    )}
                    {activeMainTab === 'storyboard' && subTab === 'animation' && (
                        <button
                            onClick={() => setSubTab('export')}
                            className="flex items-center gap-2 px-4 py-1.5 rounded-sm font-sans text-[12px] font-medium bg-white text-black hover:bg-zinc-200 transition-all duration-200"
                        >
                            <Film className="w-3 h-3" />
                            {t('story.export')}
                        </button>
                    )}
                </div>
            </div>

            {/* Progress Bar */}
            {isProcessing && (
                <div className="h-0.5 w-full overflow-hidden relative z-10 bg-zinc-900">
                    <motion.div
                        className="h-full bg-blue-500"
                        initial={{ width: 0 }}
                        animate={{ width: `${progress.percent}%` }}
                        transition={{ duration: 0.3, ease: 'easeOut' }}
                    />
                </div>
            )}

            {/* Error Banner */}
            <AnimatePresence>
                {error && (
                    <motion.div
                        initial={{ opacity: 0, y: -20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -20 }}
                        transition={{ duration: 0.15 }}
                        className="relative z-10 mx-6 mt-4 p-4 rounded-sm bg-red-500/10 border border-red-500/30 flex items-start gap-3"
                    >
                        <AlertCircle className="w-5 h-5 text-red-400 shrink-0 mt-0.5" />
                        <div className="flex-1">
                            <p className="text-sm text-zinc-100 font-medium">{t('common.somethingWentWrong')}</p>
                            <p className="text-xs text-zinc-500 mt-1">{error}</p>
                        </div>
                        <div className="flex items-center gap-2 shrink-0">
                            {onRetry && (
                                <button
                                    onClick={onRetry}
                                    className="px-3 py-1.5 text-xs font-medium bg-zinc-800 hover:bg-zinc-700 text-zinc-300 rounded-sm transition-colors duration-200 flex items-center gap-1.5"
                                >
                                    <RefreshCcw className="w-3 h-3" />
                                    {t('common.retry')}
                                </button>
                            )}
                            {onClearError && (
                                <button onClick={onClearError} className="p-1.5 text-zinc-600 hover:text-zinc-300 transition-colors duration-200">
                                    <X className="w-4 h-4" />
                                </button>
                            )}
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>

            {/* Content Area */}
            <div className="flex-1 overflow-hidden relative z-10">
                <AnimatePresence mode="wait">
                    {renderMainContent()}
                </AnimatePresence>
            </div>

            {/* Stage Progress Helper */}
            {stageProgress && activeMainTab === 'storyboard' && !isProcessing && (
                <motion.div
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.2 }}
                    className="fixed bottom-6 right-6 z-50"
                >
                    <div className="bg-zinc-900 border border-zinc-800 rounded-sm p-4">
                        <div className="flex items-center gap-4 font-mono text-xs">
                            <span className="text-zinc-500">
                                SCENES: <span className="text-zinc-300">{stageProgress.totalScenes}</span>
                            </span>
                            <span className="w-px h-4 bg-zinc-800" />
                            <div className="flex items-center gap-2">
                                <span className={stageProgress.shotsComplete ? "text-emerald-400" : "text-blue-400"}>
                                    SHOTS: {stageProgress.scenesWithShots}/{stageProgress.totalScenes}
                                </span>
                                {stageProgress.shotsComplete
                                    ? <CheckCircle2 className="w-3 h-3 text-emerald-400" />
                                    : <Loader2 className="w-3 h-3 text-blue-400 animate-spin" />
                                }
                            </div>
                            <span className="w-px h-4 bg-zinc-800" />
                            <div className="flex items-center gap-2">
                                <span className={stageProgress.visualsComplete ? "text-emerald-400" : "text-orange-400"}>
                                    VISUALS: {stageProgress.scenesWithVisuals}/{stageProgress.totalScenes}
                                </span>
                                {stageProgress.visualsComplete
                                    ? <CheckCircle2 className="w-3 h-3 text-emerald-400" />
                                    : <Circle className="w-3 h-3 text-orange-400" />
                                }
                            </div>
                        </div>
                    </div>
                </motion.div>
            )}

            {/* Shot Editor Modal */}
            {editingShot && (() => {
                const sceneId = editingShot.sceneId;
                const scene = storyState.breakdown.find(s => s.id === sceneId);
                const shotsInScene = storyState.shotlist.filter(s => s.sceneId === sceneId);
                const shotIndexInScene = shotsInScene.findIndex(s => s.id === editingShot.id);
                return (
                    <ShotEditorModal
                        shot={editingShot}
                        sceneNumber={scene?.sceneNumber ?? 0}
                        sceneHeading={scene?.heading ?? ''}
                        sceneLighting={editingShot.lighting}
                        shotIndexInScene={shotIndexInScene >= 0 ? shotIndexInScene : 0}
                        totalShotsInScene={shotsInScene.length}
                        onClose={() => setEditingShot(null)}
                        onSave={(shotId, updates) => {
                            onUpdateShot?.(shotId, updates);
                            setEditingShot(null);
                        }}
                        onRetry={(shotId) => {
                            const idx = storyState.breakdown.findIndex(s => s.id === sceneId);
                            onGenerateVisuals?.(idx >= 0 ? idx : undefined);
                            setEditingShot(null);
                        }}
                        onNavigate={(dir) => {
                            // Use ref to avoid stale closure on rapid clicks
                            const currentShot = editingShotRef.current;
                            if (!currentShot) return;
                            const idx = shotsInScene.findIndex(s => s.id === currentShot.id);
                            const nextIdx = dir === 'next' ? idx + 1 : idx - 1;
                            const nextShot = shotsInScene[nextIdx];
                            if (nextShot) setEditingShot(nextShot);
                        }}
                        isProcessing={isProcessing}
                    />
                );
            })()}

            {/* Lock Warning Dialog */}
            <LockWarningDialog
                isOpen={showLockDialog}
                onClose={() => setShowLockDialog(false)}
                onConfirmLock={() => {
                    onLockStory?.();
                    setShowLockDialog(false);
                }}
                estimatedCost={estimateProjectCost(storyState)}
                sceneCount={storyState.breakdown.length}
                estimatedShots={storyState.breakdown.length * 5}
            />

            {/* Version History Panel */}
            <AnimatePresence>
                {showVersionHistory && projectId && (
                    <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        transition={{ duration: 0.15 }}
                        className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 z-50"
                        onClick={() => setShowVersionHistory(false)}
                    >
                        <motion.div
                            initial={{ scale: 0.97, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            exit={{ scale: 0.97, opacity: 0 }}
                            transition={{ duration: 0.15 }}
                            className="w-full max-w-xl h-[70vh]"
                            onClick={(e) => e.stopPropagation()}
                        >
                            <VersionHistoryPanel
                                projectId={projectId}
                                currentState={storyState}
                                onRestore={(state) => {
                                    onImportProject?.(state);
                                    setShowVersionHistory(false);
                                }}
                            />
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>

            {/* Checkpoint Approval Overlay */}
            <AnimatePresence>
                {formatPipelineHook?.activeCheckpoint && (() => {
                    const cp = formatPipelineHook.activeCheckpoint;
                    const d = cp.data ?? {};
                    const phase = cp.phase;

                    // Build preview content from checkpoint data
                    let previewContent: React.ReactNode = null;
                    const scenes = d.scenes as { heading: string; action: string }[] | undefined;
                    const visuals = d.visuals as { sceneId: string; imageUrl: string }[] | undefined;

                    if (scenes && scenes.length > 0) {
                        previewContent = (
                            <div className="space-y-2">
                                {d.sceneCount ? <p className="text-xs text-zinc-500 mb-2">{String(d.sceneCount)} scenes {d.estimatedDuration ? `¬∑ ${d.estimatedDuration}` : ''}</p> : null}
                                {scenes.map((s, i) => (
                                    <div key={i} className="flex gap-3 items-start">
                                        <span className="font-mono text-[10px] text-blue-400 shrink-0 mt-0.5">{String(i + 1).padStart(2, '0')}</span>
                                        <div className="min-w-0">
                                            <p className="text-sm text-zinc-200 font-medium">{s.heading}</p>
                                            <p className="text-xs text-zinc-500 line-clamp-2" dir="auto">{s.action}</p>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        );
                    }

                    if (visuals && visuals.length > 0) {
                        previewContent = (
                            <div>
                                {d.visualCount != null && <p className="text-xs text-zinc-500 mb-2">{d.visualCount as number}/{d.totalScenes as number ?? '?'} visuals generated</p>}
                                <div className="grid grid-cols-3 gap-2">
                                    {visuals.map((v, i) => (
                                        <div key={v.sceneId} className="aspect-video bg-zinc-950 rounded-sm overflow-hidden border border-zinc-800">
                                            <img src={v.imageUrl} alt={`Scene ${i + 1}`} className="w-full h-full object-cover" />
                                        </div>
                                    ))}
                                </div>
                            </div>
                        );
                    }

                    if (phase.includes('final') || phase.includes('assembly')) {
                        const stats = [
                            d.sceneCount != null && `${d.sceneCount} scenes`,
                            d.visualCount != null && `${d.visualCount} visuals`,
                            d.narrationCount != null && `${d.narrationCount} narrations`,
                            d.totalDuration != null && `${Math.round(d.totalDuration as number)}s total`,
                        ].filter(Boolean);
                        if (stats.length > 0 && !scenes && !visuals) {
                            previewContent = (
                                <div className="flex flex-wrap gap-3">
                                    {stats.map((s, i) => (
                                        <span key={i} className="px-2.5 py-1 bg-zinc-800 rounded-sm text-xs font-mono text-zinc-300">{s}</span>
                                    ))}
                                </div>
                            );
                        }
                    }

                    if (d.sourceCount != null && !scenes && !visuals) {
                        previewContent = (
                            <div className="space-y-1">
                                <p className="text-sm text-zinc-300">{d.sourceCount as number} sources found</p>
                                {d.confidence != null && <p className="text-xs text-zinc-500">Confidence: {Math.round((d.confidence as number) * 100)}%</p>}
                            </div>
                        );
                    }

                    return (
                        <motion.div
                            initial={{ opacity: 0 }}
                            animate={{ opacity: 1 }}
                            exit={{ opacity: 0 }}
                            transition={{ duration: 0.15 }}
                            className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 z-50"
                        >
                            <motion.div
                                initial={{ scale: 0.97, opacity: 0 }}
                                animate={{ scale: 1, opacity: 1 }}
                                exit={{ scale: 0.97, opacity: 0 }}
                                transition={{ duration: 0.15 }}
                                className={`w-full ${visuals && visuals.length > 0 ? 'max-w-3xl' : 'max-w-2xl'} max-h-[80vh] overflow-y-auto`}
                                onClick={(e) => e.stopPropagation()}
                            >
                                <div className="bg-zinc-900 border border-zinc-700 rounded-sm p-6">
                                    <CheckpointApproval
                                        checkpointId={cp.checkpointId}
                                        phase={cp.phase}
                                        title={`Review: ${cp.phase.replace(/-/g, ' ')}`}
                                        description={previewContent ? undefined : "Review the generated content before the pipeline continues to the next phase."}
                                        previewData={previewContent}
                                        onApprove={() => formatPipelineHook.approveCheckpoint()}
                                        onRequestChanges={(_id, changeRequest) => formatPipelineHook.rejectCheckpoint(changeRequest)}
                                    />
                                </div>
                            </motion.div>
                        </motion.div>
                    );
                })()}
            </AnimatePresence>
        </div>
    );
};

export default StoryWorkspace;
</file>

<file path="components/story/StoryWorkspaceErrorBoundary.tsx">
/**
 * StoryWorkspaceErrorBoundary.tsx
 * Error boundary with recovery options for StoryWorkspace.
 */

import React from "react";
import { AlertCircle, RotateCcw, RefreshCw } from "lucide-react";
import { Button } from "@/components/ui/button";
import type { StoryState } from "@/types";

interface StoryWorkspaceErrorBoundaryProps {
  children: React.ReactNode;
  storyState: StoryState;
  onRestore?: () => void;
}

interface StoryWorkspaceErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorId: string | null;
}

export class StoryWorkspaceErrorBoundary extends React.Component<
  StoryWorkspaceErrorBoundaryProps,
  StoryWorkspaceErrorBoundaryState
> {
  constructor(props: StoryWorkspaceErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null, errorId: null };
  }

  static getDerivedStateFromError(error: Error): StoryWorkspaceErrorBoundaryState {
    const errorId = `ERR-${Date.now().toString(36).toUpperCase()}-${Math.random().toString(36).substring(2, 6).toUpperCase()}`;
    return { hasError: true, error, errorId };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    console.error("[StoryWorkspaceError] Caught error:", error);
    console.error("[StoryWorkspaceError] Component stack:", errorInfo.componentStack);
    console.error("[StoryWorkspaceError] Story State at error:", {
      step: this.props.storyState.currentStep,
      hasBreakdownSteps: this.props.storyState.breakdown?.length || 0,
      hasBreakdown: !!this.props.storyState.breakdown,
      hasScript: !!this.props.storyState.script,
      charactersCount: this.props.storyState.characters?.length || 0,
      shotsCount: this.props.storyState.shotlist?.length || 0,
    });
  }

  handleRetry = (): void => {
    this.setState({ hasError: false, error: null, errorId: null });
  };

  handleRestore = (): void => {
    this.props.onRestore?.();
    this.setState({ hasError: false, error: null, errorId: null });
  };

  render(): React.ReactNode {
    if (this.state.hasError) {
      return (
        <div
          className="flex flex-col items-center justify-center min-h-[60vh] p-8 bg-black"
          role="alert"
          aria-live="assertive"
          aria-atomic="true"
        >
          {/* Error Icon */}
          <div className="mb-6">
            <div className="w-20 h-20 rounded-sm bg-red-500/10 border border-red-500/30 flex items-center justify-center">
              <AlertCircle className="w-10 h-10 text-red-400" />
            </div>
          </div>

          {/* Error Message */}
          <h2 className="font-sans text-2xl font-medium tracking-tight text-zinc-100 mb-2">
            Story Workspace Crashed
          </h2>

          <p className="text-zinc-500 text-sm text-center max-w-md mb-6">
            An unexpected error occurred while working on your story. Don't worry ‚Äî your work is auto-saved.
          </p>

          {/* Error Details */}
          {this.state.error && (
            <details className="mb-6 text-sm text-zinc-600 max-w-md w-full">
              <summary className="cursor-pointer hover:text-zinc-400 font-mono text-xs mb-2">
                Technical Details
              </summary>
              <pre className="mt-2 p-3 bg-zinc-900 rounded-sm text-xs overflow-auto max-h-32 border border-zinc-800 text-zinc-400">
                {this.state.error.message}
              </pre>
            </details>
          )}

          {/* Error Reference ID */}
          {this.state.errorId && (
            <p
              className="font-mono text-[10px] text-zinc-700 mb-8"
              aria-label={`Error reference ID: ${this.state.errorId}`}
            >
              Reference: <code className="px-2 py-1 bg-zinc-900 rounded-sm border border-zinc-800">{this.state.errorId}</code>
            </p>
          )}

          {/* Recovery Actions */}
          <div className="flex flex-col sm:flex-row gap-3">
            <Button
              onClick={this.handleRestore}
              className="bg-blue-500 hover:bg-blue-600 text-white rounded-sm font-sans"
            >
              <RotateCcw className="w-4 h-4 mr-2" />
              Restore Last Save
            </Button>

            <Button
              onClick={this.handleRetry}
              variant="outline"
              className="border-zinc-800 text-zinc-300 hover:bg-zinc-800 rounded-sm font-sans"
            >
              <RefreshCw className="w-4 h-4 mr-2" />
              Try Again
            </Button>

            <Button
              onClick={() => window.location.reload()}
              variant="outline"
              className="border-zinc-800 text-zinc-500 hover:bg-zinc-900 rounded-sm font-sans"
            >
              Refresh Page
            </Button>
          </div>

          {/* Help Text */}
          <p className="mt-8 text-xs text-zinc-700 text-center max-w-sm">
            If the problem persists, try refreshing the page or starting a new project.
            Your previous work is saved in version history.
          </p>
        </div>
      );
    }

    return this.props.children;
  }
}
</file>

<file path="components/story/StyleSelector.tsx">
/**
 * StyleSelector.tsx
 * Visual style gallery with sharp utility design.
 */

import React from 'react';
import { motion } from 'framer-motion';
import { Check, RectangleHorizontal, Cpu } from 'lucide-react';
import {
    VISUAL_STYLES,
    ASPECT_RATIOS,
    type VisualStyleKey,
    type AspectRatioId,
} from '@/constants/visualStyles';

interface StyleSelectorProps {
    selectedStyle: VisualStyleKey;
    onSelectStyle: (style: VisualStyleKey) => void;
    aspectRatio: AspectRatioId;
    onSelectAspectRatio: (ratio: AspectRatioId) => void;
    imageProvider?: 'gemini' | 'deapi';
    onSelectImageProvider?: (provider: 'gemini' | 'deapi') => void;
}

export const StyleSelector: React.FC<StyleSelectorProps> = ({
    selectedStyle,
    onSelectStyle,
    aspectRatio,
    onSelectAspectRatio,
    imageProvider = 'gemini',
    onSelectImageProvider,
}) => {
    const styles = Object.values(VISUAL_STYLES);

    const stylesByCategory = {
        cinematic: styles.filter(s => s.category === 'cinematic'),
        artistic: styles.filter(s => s.category === 'artistic'),
        stylized: styles.filter(s => s.category === 'stylized'),
        modern: styles.filter(s => s.category === 'modern'),
    };

    const categoryLabels: Record<string, string> = {
        cinematic: 'Cinematic',
        artistic: 'Artistic',
        stylized: 'Stylized',
        modern: 'Modern',
    };

    return (
        <div className="p-8 max-w-6xl mx-auto">
            {/* Header */}
            <div className="mb-12">
                <h2 className="font-sans text-2xl font-medium tracking-tight text-zinc-100 mb-2">
                    Visual Direction
                </h2>
                <p className="text-zinc-500 text-sm">
                    Choose a style that matches your story's mood
                </p>
            </div>

            {/* Aspect Ratio Selector */}
            <div className="mb-12">
                <div className="flex items-center gap-3 mb-4">
                    <RectangleHorizontal className="w-4 h-4 text-zinc-600" />
                    <span className="font-mono text-xs text-zinc-600 uppercase tracking-widest">
                        Frame Ratio
                    </span>
                </div>
                <div className="flex flex-wrap gap-3">
                    {ASPECT_RATIOS.slice(0, 4).map((ratio) => {
                        const isSelected = aspectRatio === ratio.id;
                        return (
                            <button
                                key={ratio.id}
                                onClick={() => onSelectAspectRatio(ratio.id)}
                                className={`
                                    px-5 py-3 rounded-sm transition-colors duration-200
                                    ${isSelected
                                        ? 'bg-blue-500/10 border border-blue-500/50 text-blue-400'
                                        : 'bg-zinc-900 border border-zinc-800 text-zinc-400 hover:border-zinc-600'
                                    }
                                `}
                            >
                                <span className="font-sans text-sm font-medium">
                                    {ratio.label}
                                </span>
                                <span className={`ml-2 text-xs ${isSelected ? 'text-blue-400/70' : 'text-zinc-600'}`}>
                                    {ratio.description}
                                </span>
                            </button>
                        );
                    })}
                </div>
            </div>

            {/* Image Provider Selector */}
            {onSelectImageProvider && (
                <div className="mb-12">
                    <div className="flex items-center gap-3 mb-4">
                        <Cpu className="w-4 h-4 text-zinc-600" />
                        <span className="font-mono text-xs text-zinc-600 uppercase tracking-widest">
                            Image Engine
                        </span>
                    </div>
                    <div className="flex flex-wrap gap-3">
                        {([
                            { id: 'gemini' as const, label: 'Imagen 4', desc: 'Google AI (default)' },
                            { id: 'deapi' as const, label: 'FLUX.2 Klein', desc: 'DeAPI, fast generation' },
                        ]).map((provider) => {
                            const isSelected = imageProvider === provider.id;
                            return (
                                <button
                                    key={provider.id}
                                    onClick={() => onSelectImageProvider(provider.id)}
                                    className={`
                                        px-5 py-3 rounded-sm transition-colors duration-200
                                        ${isSelected
                                            ? 'bg-blue-500/10 border border-blue-500/50 text-blue-400'
                                            : 'bg-zinc-900 border border-zinc-800 text-zinc-400 hover:border-zinc-600'
                                        }
                                    `}
                                >
                                    <span className="font-sans text-sm font-medium">
                                        {provider.label}
                                    </span>
                                    <span className={`ml-2 text-xs ${isSelected ? 'text-blue-400/70' : 'text-zinc-600'}`}>
                                        {provider.desc}
                                    </span>
                                </button>
                            );
                        })}
                    </div>
                </div>
            )}

            {/* Style Grid by Category */}
            <div className="space-y-12">
                {Object.entries(stylesByCategory).map(([category, categoryStyles]) => (
                    <div key={category}>
                        {/* Category Label */}
                        <div className="flex items-center gap-4 mb-6">
                            <span className="font-mono text-xs text-zinc-600 uppercase tracking-[0.2em]">
                                {categoryLabels[category]}
                            </span>
                            <div className="flex-1 h-px bg-zinc-800" />
                        </div>

                        {/* Style Cards Grid */}
                        <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
                            {categoryStyles.map((style) => {
                                const isSelected = selectedStyle === style.id;
                                return (
                                    <button
                                        key={style.id}
                                        onClick={() => onSelectStyle(style.id as VisualStyleKey)}
                                        className={`
                                            group relative flex flex-col overflow-hidden rounded-sm transition-all duration-200 ease-out
                                            hover:-translate-y-0.5
                                            ${isSelected
                                                ? 'border-2 border-blue-500 ring-1 ring-blue-500/20'
                                                : 'border border-zinc-800 hover:border-zinc-600'
                                            }
                                        `}
                                    >
                                        {/* Preview Area */}
                                        <div className="aspect-video relative overflow-hidden bg-zinc-950">
                                            {/* Gradient Background */}
                                            <div className={`absolute inset-0 ${getStyleGradient(style.id)}`} />

                                            {/* Sample Image */}
                                            {style.sampleImage && (
                                                <img
                                                    src={style.sampleImage}
                                                    alt={style.name}
                                                    className="absolute inset-0 w-full h-full object-cover"
                                                    onError={(e) => {
                                                        (e.target as HTMLImageElement).style.display = 'none';
                                                    }}
                                                />
                                            )}

                                            {/* Style Name Overlay */}
                                            <div className="absolute inset-x-0 bottom-0 p-3 bg-gradient-to-t from-black to-transparent">
                                                <span className="font-sans text-sm font-medium text-zinc-100">
                                                    {style.name}
                                                </span>
                                            </div>

                                            {/* Selection Checkmark */}
                                            {isSelected && (
                                                <div className="absolute top-2 right-2 w-6 h-6 rounded-sm bg-blue-500 flex items-center justify-center">
                                                    <Check className="w-3.5 h-3.5 text-white" />
                                                </div>
                                            )}
                                        </div>

                                        {/* Description */}
                                        <div className="p-3 bg-zinc-900">
                                            <p className="text-xs text-zinc-500 line-clamp-2">
                                                {style.description}
                                            </p>
                                        </div>
                                    </button>
                                );
                            })}
                        </div>
                    </div>
                ))}
            </div>

            {/* Selected Style Preview */}
            {selectedStyle && VISUAL_STYLES[selectedStyle] && (
                <div className="mt-12 p-6 bg-zinc-900 border border-zinc-800 rounded-sm">
                    <div className="flex items-center gap-6">
                        {/* Mini Preview */}
                        <div className="shrink-0 w-24 h-14 rounded-sm overflow-hidden relative">
                            <div className={`w-full h-full ${getStyleGradient(selectedStyle)}`} />
                        </div>

                        {/* Info */}
                        <div className="flex-1 min-w-0">
                            <h3 className="font-sans text-lg font-medium text-zinc-100 mb-1">
                                {VISUAL_STYLES[selectedStyle].name}
                            </h3>
                            <p className="text-sm text-zinc-500">
                                {VISUAL_STYLES[selectedStyle].description}
                            </p>
                        </div>

                        {/* Badge */}
                        <div className="shrink-0">
                            <span className="inline-flex items-center gap-2 px-3 py-1.5 rounded-sm bg-blue-500/10 border border-blue-500/30">
                                <Check className="w-4 h-4 text-blue-400" />
                                <span className="font-mono text-xs text-blue-400 uppercase tracking-wider">
                                    Selected
                                </span>
                            </span>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};

function getStyleGradient(styleId: string): string {
    const gradients: Record<string, string> = {
        CINEMATIC: 'bg-gradient-to-br from-amber-900/40 to-slate-900/60',
        NOIR: 'bg-gradient-to-br from-zinc-700 to-black',
        COMIC: 'bg-gradient-to-br from-red-500/30 to-yellow-500/30',
        ANIME: 'bg-gradient-to-br from-pink-500/30 to-blue-500/30',
        WATERCOLOR: 'bg-gradient-to-br from-blue-300/30 to-pink-300/30',
        OIL_PAINTING: 'bg-gradient-to-br from-amber-700/40 to-rose-800/40',
        CYBERPUNK: 'bg-gradient-to-br from-purple-600/40 to-cyan-500/40',
        DARK_FANTASY: 'bg-gradient-to-br from-slate-800 to-purple-950',
        PHOTOREALISTIC: 'bg-gradient-to-br from-emerald-800/30 to-blue-800/30',
        PIXEL_ART: 'bg-gradient-to-br from-green-500/30 to-blue-500/30',
        MINIMALIST: 'bg-gradient-to-br from-zinc-200/20 to-zinc-400/20',
        SURREALIST: 'bg-gradient-to-br from-orange-500/30 to-indigo-600/40',
    };

    return gradients[styleId] || 'bg-gradient-to-br from-zinc-700 to-zinc-900';
}

export default StyleSelector;
</file>

<file path="components/story/TemplatesGallery.tsx">
/**
 * TemplatesGallery - Browse and apply project templates.
 */

import React, { useState, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Layout,
  Film,
  ShoppingBag,
  GraduationCap,
  Smartphone,
  Palette,
  Clock,
  ChevronRight,
  Search,
  X,
  ArrowRight,
  Layers,
  Eye,
  Ratio,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import type { StoryState } from '@/types';
import { useLanguage } from '@/i18n/useLanguage';
import {
  getAllTemplates,
  getTemplatesByCategory,
  getTemplateCategories,
  applyTemplate,
  type ProjectTemplate,
} from '@/services/projectTemplatesService';

interface TemplatesGalleryProps {
  onApplyTemplate: (state: Partial<StoryState>) => void;
  onClose?: () => void;
  className?: string;
}

const categoryIcons: Record<string, React.ReactNode> = {
  narrative: <Film className="w-3.5 h-3.5" />,
  commercial: <ShoppingBag className="w-3.5 h-3.5" />,
  educational: <GraduationCap className="w-3.5 h-3.5" />,
  social: <Smartphone className="w-3.5 h-3.5" />,
  experimental: <Palette className="w-3.5 h-3.5" />,
};

const defaultDifficultyColor = { text: 'text-zinc-400', bg: 'bg-zinc-500/10' };
const difficultyColors: Record<string, { text: string; bg: string }> = {
  beginner: { text: 'text-emerald-400', bg: 'bg-emerald-500/10' },
  intermediate: { text: 'text-orange-400', bg: 'bg-orange-500/10' },
  advanced: { text: 'text-red-400', bg: 'bg-red-500/10' },
};

/** Translate a template field, falling back to the original value */
function useTemplateTranslation() {
  const { t } = useLanguage();

  return {
    tName: (template: ProjectTemplate) =>
      t(`story.templates.items.${template.id}.name`, { defaultValue: template.name }),
    tDesc: (template: ProjectTemplate) =>
      t(`story.templates.items.${template.id}.description`, { defaultValue: template.description }),
    tGenre: (genre: string) =>
      t(`story.templates.genres.${genre}`, { defaultValue: genre }),
    tTag: (tag: string) =>
      t(`story.templates.tags.${tag}`, { defaultValue: tag }),
    tDifficulty: (diff: string) =>
      t(`story.templates.difficulty.${diff}`, { defaultValue: diff }),
    tCategory: (cat: string) =>
      t(`story.templates.categories.${cat}`, { defaultValue: cat }),
    tStyle: (style: string) =>
      t(`story.templates.styles.${style}`, { defaultValue: style }),
    tSceneHeading: (template: ProjectTemplate, sceneNum: number) =>
      t(`story.templates.items.${template.id}.scene${sceneNum}_heading`, { defaultValue: '' }),
    tSceneAction: (template: ProjectTemplate, sceneNum: number) =>
      t(`story.templates.items.${template.id}.scene${sceneNum}_action`, { defaultValue: '' }),
  };
}

function TemplateCard({
  template,
  onClick,
  isSelected,
}: {
  template: ProjectTemplate;
  onClick: () => void;
  isSelected: boolean;
}) {
  const colors = difficultyColors[template.difficulty] ?? defaultDifficultyColor;
  const tt = useTemplateTranslation();

  return (
    <motion.div
      layout
      onClick={onClick}
      className={cn(
        'group relative cursor-pointer rounded-sm border transition-all duration-200 hover:-translate-y-0.5',
        isSelected
          ? 'border-blue-500/50 bg-blue-500/5'
          : 'border-zinc-800 bg-zinc-900 hover:border-zinc-700'
      )}
    >
      <div className="p-4">
        {/* Top row: difficulty + genre */}
        <div className="flex items-center gap-2 mb-3">
          <span className={cn('font-mono text-[10px] uppercase tracking-widest px-2 py-0.5 rounded-sm', colors.text, colors.bg)}>
            {tt.tDifficulty(template.difficulty)}
          </span>
          <span className="font-mono text-[10px] uppercase tracking-widest px-2 py-0.5 rounded-sm bg-zinc-800 text-zinc-500">
            {tt.tGenre(template.genre)}
          </span>
        </div>

        {/* Title */}
        <h4 className="font-sans text-sm font-medium text-zinc-100 mb-1.5 leading-snug">
          {tt.tName(template)}
        </h4>

        {/* Description */}
        <p className="text-xs text-zinc-600 leading-relaxed line-clamp-2 mb-3">
          {tt.tDesc(template)}
        </p>

        {/* Meta row */}
        <div className="flex items-center gap-4 text-zinc-700">
          <span className="flex items-center gap-1.5 font-mono text-[10px]">
            <Layers className="w-3 h-3" />
            {template.templateScenes.length}
          </span>
          <span className="flex items-center gap-1.5 font-mono text-[10px]">
            <Clock className="w-3 h-3" />
            {template.estimatedDuration}
          </span>
        </div>

        {/* Tags */}
        {template.tags.length > 0 && (
          <div className="flex flex-wrap gap-1.5 mt-3 pt-3 border-t border-zinc-800">
            {template.tags.slice(0, 3).map((tag) => (
              <span
                key={tag}
                className="font-mono text-[9px] text-zinc-600 px-1.5 py-0.5 rounded-sm bg-zinc-950 border border-zinc-800"
              >
                {tt.tTag(tag)}
              </span>
            ))}
            {template.tags.length > 3 && (
              <span className="font-mono text-[9px] text-zinc-700">
                +{template.tags.length - 3}
              </span>
            )}
          </div>
        )}
      </div>

      {/* Hover arrow */}
      <div className="absolute top-4 right-4 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
        <ChevronRight className="w-4 h-4 text-zinc-600" />
      </div>
    </motion.div>
  );
}

function TemplatePreview({
  template,
  onApply,
  onClose,
}: {
  template: ProjectTemplate;
  onApply: () => void;
  onClose: () => void;
}) {
  const { t } = useLanguage();
  const tt = useTemplateTranslation();
  const colors = difficultyColors[template.difficulty] ?? defaultDifficultyColor;

  return (
    <motion.div
      initial={{ opacity: 0, x: 12 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: 12 }}
      transition={{ duration: 0.15, ease: 'easeOut' }}
      className="h-full flex flex-col"
    >
      {/* Preview header */}
      <div className="flex items-start justify-between p-5 pb-0">
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2 mb-2">
            <span className={cn('font-mono text-[10px] uppercase tracking-widest px-2 py-0.5 rounded-sm', colors.text, colors.bg)}>
              {tt.tDifficulty(template.difficulty)}
            </span>
          </div>
          <h3 className="font-sans text-lg font-medium text-zinc-100 leading-snug">
            {tt.tName(template)}
          </h3>
        </div>
        <button
          onClick={onClose}
          className="p-1 -mr-1 text-zinc-700 hover:text-zinc-400 transition-colors duration-200"
        >
          <X className="w-4 h-4" />
        </button>
      </div>

      {/* Scrollable content */}
      <div className="flex-1 overflow-y-auto px-5 py-4 space-y-5">
        <p className="text-sm text-zinc-500 leading-relaxed">
          {tt.tDesc(template)}
        </p>

        {/* Stats grid */}
        <div className="grid grid-cols-2 gap-2">
          {[
            { label: t('story.templates.duration'), value: template.estimatedDuration, icon: Clock },
            { label: t('story.templates.scenes'), value: `${template.templateScenes.length}`, icon: Layers },
            { label: t('story.templates.style'), value: tt.tStyle(template.visualStyle), icon: Eye },
            { label: t('story.templates.ratio'), value: template.aspectRatio, icon: Ratio },
          ].map(({ label, value, icon: Icon }) => (
            <div
              key={label}
              className="p-3 rounded-sm bg-zinc-950 border border-zinc-800"
            >
              <div className="flex items-center gap-1.5 mb-1">
                <Icon className="w-3 h-3 text-zinc-700" />
                <span className="font-mono text-[10px] uppercase tracking-widest text-zinc-600">
                  {label}
                </span>
              </div>
              <p className="text-sm font-medium text-zinc-300">{value}</p>
            </div>
          ))}
        </div>

        {/* Scene breakdown */}
        <div>
          <span className="font-mono text-[10px] uppercase tracking-widest text-zinc-600 block mb-2.5">
            {t('story.templates.scenes')}
          </span>
          <div className="space-y-1.5">
            {template.templateScenes.map((scene, i) => (
              <div
                key={i}
                className="flex items-center gap-3 px-3 py-2.5 rounded-sm bg-zinc-950 border border-zinc-800"
              >
                <span className="w-5 h-5 rounded-sm flex items-center justify-center font-mono text-[10px] bg-zinc-800 text-zinc-500 flex-shrink-0">
                  {scene.sceneNumber}
                </span>
                <div className="flex-1 min-w-0">
                  <p className="font-mono text-[11px] text-zinc-400 truncate">
                    {tt.tSceneHeading(template, scene.sceneNumber) || scene.heading}
                  </p>
                  <p className="text-[11px] text-zinc-600 line-clamp-1 mt-0.5">
                    {tt.tSceneAction(template, scene.sceneNumber) || scene.action}
                  </p>
                </div>
                {scene.duration && (
                  <span className="font-mono text-[10px] text-zinc-700 flex-shrink-0">{scene.duration}s</span>
                )}
              </div>
            ))}
          </div>
        </div>

        {/* Suggested styles */}
        {template.suggestedVisualStyles.length > 0 && (
          <div>
            <span className="font-mono text-[10px] uppercase tracking-widest text-zinc-600 block mb-2.5">
              {t('story.templates.visualStyles')}
            </span>
            <div className="flex flex-wrap gap-1.5">
              {template.suggestedVisualStyles.map((style) => (
                <span
                  key={style}
                  className="text-xs px-2.5 py-1 rounded-sm text-zinc-400 bg-zinc-950 border border-zinc-800"
                >
                  {tt.tStyle(style)}
                </span>
              ))}
            </div>
          </div>
        )}
      </div>

      {/* Apply button */}
      <div className="p-4 pt-3 border-t border-zinc-800">
        <button
          onClick={onApply}
          className="w-full flex items-center justify-center gap-2.5 py-3 rounded-sm bg-white text-black font-sans text-sm font-medium hover:bg-zinc-200 transition-colors duration-200"
        >
          <span>{t('story.templates.useTemplate')}</span>
          <ArrowRight className="w-3.5 h-3.5" />
        </button>
      </div>
    </motion.div>
  );
}

export function TemplatesGallery({
  onApplyTemplate,
  onClose,
  className,
}: TemplatesGalleryProps) {
  const { t, language } = useLanguage();
  const tt = useTemplateTranslation();
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedTemplate, setSelectedTemplate] = useState<ProjectTemplate | null>(null);

  const categories = getTemplateCategories();

  const templates = useMemo(() => {
    if (searchQuery) {
      const lowerQuery = searchQuery.toLowerCase();
      return getAllTemplates().filter((tmpl) => {
        const name = tt.tName(tmpl).toLowerCase();
        const desc = tt.tDesc(tmpl).toLowerCase();
        const genre = tt.tGenre(tmpl.genre).toLowerCase();
        const tags = tmpl.tags.map((tag) => tt.tTag(tag).toLowerCase());
        return (
          name.includes(lowerQuery) ||
          desc.includes(lowerQuery) ||
          genre.includes(lowerQuery) ||
          tags.some((tag) => tag.includes(lowerQuery)) ||
          tmpl.name.toLowerCase().includes(lowerQuery) ||
          tmpl.description.toLowerCase().includes(lowerQuery) ||
          tmpl.genre.toLowerCase().includes(lowerQuery) ||
          tmpl.tags.some((tag) => tag.toLowerCase().includes(lowerQuery))
        );
      });
    }
    if (selectedCategory) {
      return getTemplatesByCategory(selectedCategory as ProjectTemplate['category']);
    }
    return getAllTemplates();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedCategory, searchQuery, language]);

  const handleApply = () => {
    if (!selectedTemplate) return;
    const state = applyTemplate(selectedTemplate);
    onApplyTemplate(state);
    onClose?.();
  };

  return (
    <div
      className={cn('flex flex-col h-full rounded-sm overflow-hidden bg-zinc-950 border border-zinc-800', className)}
    >
      {/* Header */}
      <div className="flex items-center justify-between px-5 py-4 border-b border-zinc-800">
        <div className="flex items-center gap-3">
          <div className="w-7 h-7 rounded-sm flex items-center justify-center bg-zinc-900 border border-zinc-800">
            <Layout className="w-3.5 h-3.5 text-zinc-500" />
          </div>
          <h3 className="font-sans text-sm font-medium text-zinc-100">{t('story.templates.title')}</h3>
          <span className="font-mono text-[10px] text-zinc-600">{templates.length}</span>
        </div>
        {onClose && (
          <button
            onClick={onClose}
            className="p-1.5 rounded-sm text-zinc-600 hover:text-zinc-300 hover:bg-zinc-800 transition-all duration-200"
          >
            <X className="w-4 h-4" />
          </button>
        )}
      </div>

      {/* Search + Filters */}
      <div className="px-5 py-3 space-y-3 border-b border-zinc-800">
        {/* Search */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-3.5 h-3.5 text-zinc-700" />
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => {
              setSearchQuery(e.target.value);
              setSelectedCategory(null);
            }}
            placeholder={t('story.templates.searchPlaceholder')}
            className="w-full pl-9 pr-8 py-2 rounded-sm font-sans text-sm text-zinc-200 bg-zinc-900 border border-zinc-800 placeholder:text-zinc-700 focus:outline-none focus:border-blue-500 transition-colors duration-200"
          />
          {searchQuery && (
            <button
              onClick={() => setSearchQuery('')}
              className="absolute right-2.5 top-1/2 -translate-y-1/2 text-zinc-600 hover:text-zinc-300 transition-colors"
            >
              <X className="w-3.5 h-3.5" />
            </button>
          )}
        </div>

        {/* Category pills */}
        <div className="flex items-center gap-1.5 overflow-x-auto pb-0.5 -mx-1 px-1">
          <button
            onClick={() => {
              setSelectedCategory(null);
              setSearchQuery('');
            }}
            className={cn(
              'px-3 py-1.5 rounded-sm text-xs font-sans whitespace-nowrap transition-all duration-200 border',
              !selectedCategory && !searchQuery
                ? 'bg-blue-500/10 border-blue-500/30 text-blue-400'
                : 'border-zinc-800 text-zinc-500 hover:text-zinc-300'
            )}
          >
            {t('common.all')}
          </button>
          {categories.map((cat) => (
            <button
              key={cat.id}
              onClick={() => {
                setSelectedCategory(cat.id);
                setSearchQuery('');
              }}
              className={cn(
                'flex items-center gap-1.5 px-3 py-1.5 rounded-sm text-xs font-sans whitespace-nowrap transition-all duration-200 border',
                selectedCategory === cat.id
                  ? 'bg-blue-500/10 border-blue-500/30 text-blue-400'
                  : 'border-zinc-800 text-zinc-500 hover:text-zinc-300'
              )}
            >
              {categoryIcons[cat.id]}
              {tt.tCategory(cat.id)}
            </button>
          ))}
        </div>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-hidden flex">
        {/* Template Grid */}
        <div className="flex-1 overflow-y-auto p-4">
          {templates.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-16">
              <div className="w-12 h-12 rounded-sm flex items-center justify-center bg-zinc-900 border border-zinc-800 mb-4">
                <Search className="w-5 h-5 text-zinc-700" />
              </div>
              <p className="text-sm text-zinc-500 mb-1">{t('story.templates.noTemplatesFound')}</p>
              {searchQuery && (
                <button
                  onClick={() => setSearchQuery('')}
                  className="text-xs text-zinc-600 hover:text-zinc-300 transition-colors mt-1"
                >
                  {t('story.templates.clearSearch')}
                </button>
              )}
            </div>
          ) : (
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              <AnimatePresence mode="popLayout">
                {templates.map((template) => (
                  <TemplateCard
                    key={template.id}
                    template={template}
                    isSelected={selectedTemplate?.id === template.id}
                    onClick={() => setSelectedTemplate(template)}
                  />
                ))}
              </AnimatePresence>
            </div>
          )}
        </div>

        {/* Preview Panel */}
        <AnimatePresence>
          {selectedTemplate && (
            <motion.div
              initial={{ width: 0, opacity: 0 }}
              animate={{ width: 320, opacity: 1 }}
              exit={{ width: 0, opacity: 0 }}
              transition={{ duration: 0.2, ease: 'easeOut' }}
              className="border-l border-zinc-800 overflow-hidden flex-shrink-0"
            >
              <div className="w-80 h-full">
                <TemplatePreview
                  template={selectedTemplate}
                  onApply={handleApply}
                  onClose={() => setSelectedTemplate(null)}
                />
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
}

export default TemplatesGallery;
</file>

<file path="components/story/VersionHistoryPanel.tsx">
/**
 * VersionHistoryPanel - Browse and restore project snapshots.
 */

import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  History,
  Clock,
  Save,
  RotateCcw,
  Trash2,
  Tag,
  X,
  Check,
  Edit3,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import type { StoryState } from '@/types';
import {
  getSnapshots,
  createSnapshot,
  deleteSnapshot,
  renameSnapshot,
  getHistoryStats,
  type VersionSnapshot,
  type VersionHistoryStats,
} from '@/services/versionHistoryService';
import { formatRelativeTime, formatAbsoluteTime } from '@/utils/timeFormatting';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';

interface VersionHistoryPanelProps {
  projectId: string;
  currentState: StoryState;
  onRestore: (state: StoryState) => void;
  className?: string;
}

export function VersionHistoryPanel({
  projectId,
  currentState,
  onRestore,
  className,
}: VersionHistoryPanelProps) {
  const [snapshots, setSnapshots] = useState<VersionSnapshot[]>([]);
  const [stats, setStats] = useState<VersionHistoryStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [selectedSnapshot, setSelectedSnapshot] = useState<VersionSnapshot | null>(null);
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [saveName, setSaveName] = useState('');
  const [saveDescription, setSaveDescription] = useState('');
  const [filter, setFilter] = useState<'all' | 'manual' | 'auto'>('all');
  const [confirmRestore, setConfirmRestore] = useState<string | null>(null);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [editName, setEditName] = useState('');

  const loadSnapshots = useCallback(async () => {
    setLoading(true);
    try {
      const type = filter === 'all' ? undefined : filter;
      const [snapshotList, historyStats] = await Promise.all([
        getSnapshots(projectId, { type, limit: 50 }),
        getHistoryStats(projectId),
      ]);
      setSnapshots(snapshotList);
      setStats(historyStats);
    } catch (error) {
      console.error('[VersionHistory] Failed to load snapshots:', error);
    } finally {
      setLoading(false);
    }
  }, [projectId, filter]);

  useEffect(() => {
    loadSnapshots();
  }, [loadSnapshots]);

  const handleSaveSnapshot = async () => {
    if (!saveName.trim()) return;
    try {
      await createSnapshot(projectId, currentState, saveName, saveDescription, 'manual');
      setShowSaveDialog(false);
      setSaveName('');
      setSaveDescription('');
      await loadSnapshots();
    } catch (error) {
      console.error('[VersionHistory] Failed to save snapshot:', error);
    }
  };

  const handleDelete = async (snapshotId: string) => {
    try {
      await deleteSnapshot(snapshotId);
      setSnapshots(prev => prev.filter(s => s.id !== snapshotId));
      if (selectedSnapshot?.id === snapshotId) {
        setSelectedSnapshot(null);
      }
    } catch (error) {
      console.error('[VersionHistory] Failed to delete snapshot:', error);
    }
  };

  const handleRestore = (snapshot: VersionSnapshot) => {
    onRestore(snapshot.state);
    setConfirmRestore(null);
    setSelectedSnapshot(null);
  };

  const handleRename = async (snapshotId: string) => {
    if (!editName.trim()) return;
    try {
      await renameSnapshot(snapshotId, editName);
      setSnapshots(prev =>
        prev.map(s => (s.id === snapshotId ? { ...s, name: editName } : s))
      );
      setEditingId(null);
      setEditName('');
    } catch (error) {
      console.error('[VersionHistory] Failed to rename snapshot:', error);
    }
  };

  const getTypeIcon = (type: VersionSnapshot['type']) => {
    switch (type) {
      case 'manual':
        return <Save className="w-3 h-3" />;
      case 'auto':
        return <Clock className="w-3 h-3" />;
      case 'checkpoint':
        return <Tag className="w-3 h-3" />;
    }
  };

  const getTypeColor = (type: VersionSnapshot['type']) => {
    switch (type) {
      case 'manual':
        return 'text-blue-400 bg-blue-500/20';
      case 'auto':
        return 'text-zinc-400 bg-zinc-500/20';
      case 'checkpoint':
        return 'text-orange-400 bg-orange-500/20';
    }
  };

  return (
    <div className={cn('flex flex-col h-full bg-zinc-950 rounded-sm border border-zinc-800', className)}>
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b border-zinc-800">
        <div className="flex items-center gap-2">
          <History className="w-5 h-5 text-blue-400" />
          <h3 className="font-sans font-medium text-zinc-100">Version History</h3>
        </div>
        <button
          onClick={() => setShowSaveDialog(true)}
          className="flex items-center gap-1.5 px-3 py-1.5 text-sm bg-blue-500 hover:bg-blue-600 text-white rounded-sm transition-colors duration-200"
        >
          <Save className="w-4 h-4" />
          Save Version
        </button>
      </div>

      {/* Stats */}
      {stats && (
        <div className="px-4 py-2 border-b border-zinc-800/50 font-mono text-[10px] text-zinc-600 flex items-center gap-4">
          <span>{stats.totalSnapshots} versions</span>
          <span>{stats.manualSnapshots} saved</span>
          <span>{stats.autoSnapshots} auto</span>
          {stats.totalSizeBytes > 0 && (
            <span>{(stats.totalSizeBytes / 1024 / 1024).toFixed(1)} MB</span>
          )}
        </div>
      )}

      {/* Filter Tabs */}
      <div className="flex items-center gap-1 p-2 border-b border-zinc-800/50">
        {(['all', 'manual', 'auto'] as const).map((f) => (
          <button
            key={f}
            onClick={() => setFilter(f)}
            className={cn(
              'px-3 py-1 text-xs rounded-sm transition-colors duration-200 capitalize',
              filter === f
                ? 'bg-blue-500 text-white'
                : 'text-zinc-500 hover:text-zinc-100 hover:bg-zinc-800'
            )}
          >
            {f}
          </button>
        ))}
      </div>

      {/* Snapshot List */}
      <div className="flex-1 overflow-y-auto p-2 space-y-1">
        {loading ? (
          <div className="flex items-center justify-center py-8">
            <div className="animate-spin w-6 h-6 border-2 border-blue-400 border-t-transparent rounded-full" />
          </div>
        ) : snapshots.length === 0 ? (
          <div className="text-center py-8 text-zinc-600">
            <History className="w-8 h-8 mx-auto mb-2 opacity-50" />
            <p className="text-sm">No versions saved yet</p>
            <p className="text-xs mt-1 text-zinc-700">Click "Save Version" to create a snapshot</p>
          </div>
        ) : (
          <AnimatePresence>
            {snapshots.map((snapshot) => (
              <motion.div
                key={snapshot.id}
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, height: 0 }}
                transition={{ duration: 0.15 }}
                className={cn(
                  'group p-3 rounded-sm border transition-colors duration-200 cursor-pointer',
                  selectedSnapshot?.id === snapshot.id
                    ? 'border-blue-500/50 bg-blue-500/10'
                    : 'border-zinc-800 hover:border-zinc-700 bg-zinc-900'
                )}
                onClick={() => setSelectedSnapshot(snapshot)}
              >
                <div className="flex items-start justify-between gap-2">
                  <div className="flex-1 min-w-0">
                    {editingId === snapshot.id ? (
                      <div className="flex items-center gap-2">
                        <input
                          type="text"
                          value={editName}
                          onChange={(e) => setEditName(e.target.value)}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter') handleRename(snapshot.id);
                            if (e.key === 'Escape') setEditingId(null);
                          }}
                          className="flex-1 px-2 py-1 text-sm bg-zinc-950 border border-zinc-700 rounded-sm text-zinc-100 focus:outline-none focus:border-blue-500"
                          autoFocus
                        />
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleRename(snapshot.id);
                          }}
                          className="p-1 text-emerald-400 hover:bg-emerald-500/20 rounded-sm"
                        >
                          <Check className="w-4 h-4" />
                        </button>
                      </div>
                    ) : (
                      <div className="flex items-center gap-2">
                        <span className={cn('p-1 rounded-sm', getTypeColor(snapshot.type))}>
                          {getTypeIcon(snapshot.type)}
                        </span>
                        <span className="font-sans font-medium text-zinc-100 text-sm truncate">
                          {snapshot.name}
                        </span>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            setEditingId(snapshot.id);
                            setEditName(snapshot.name);
                          }}
                          className="p-1 text-zinc-700 hover:text-zinc-400 opacity-0 group-hover:opacity-100 transition-opacity duration-200"
                        >
                          <Edit3 className="w-3 h-3" />
                        </button>
                      </div>
                    )}
                    <TooltipProvider>
                      <Tooltip delayDuration={200}>
                        <TooltipTrigger asChild>
                          <div className="flex items-center gap-2 mt-1 text-xs text-zinc-600 cursor-help">
                            <Clock className="w-3 h-3" />
                            <span>{formatRelativeTime(snapshot.timestamp)}</span>
                          </div>
                        </TooltipTrigger>
                        <TooltipContent side="right" className="text-xs">
                          {formatAbsoluteTime(snapshot.timestamp)}
                        </TooltipContent>
                      </Tooltip>
                    </TooltipProvider>
                    {snapshot.metadata && (
                      <div className="flex items-center gap-2 mt-1 font-mono text-[10px] text-zinc-700">
                        <span>{snapshot.metadata.sceneCount} scenes</span>
                        <span>¬∑</span>
                        <span>{snapshot.metadata.shotCount} shots</span>
                        <span>¬∑</span>
                        <span>{snapshot.metadata.step}</span>
                      </div>
                    )}
                  </div>
                  <div className="flex items-center gap-1">
                    {confirmRestore === snapshot.id ? (
                      <div className="flex items-center gap-1 bg-orange-500/10 border border-orange-500/20 rounded-sm p-1">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleRestore(snapshot);
                          }}
                          className="p-1.5 text-emerald-400 hover:bg-emerald-500/20 rounded-sm"
                          title="Confirm restore"
                        >
                          <Check className="w-4 h-4" />
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            setConfirmRestore(null);
                          }}
                          className="p-1.5 text-red-400 hover:bg-red-500/20 rounded-sm"
                          title="Cancel"
                        >
                          <X className="w-4 h-4" />
                        </button>
                      </div>
                    ) : (
                      <>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            setConfirmRestore(snapshot.id);
                          }}
                          className="p-1.5 text-zinc-700 hover:text-blue-400 hover:bg-blue-500/20 rounded-sm transition-colors duration-200"
                          title="Restore this version"
                        >
                          <RotateCcw className="w-4 h-4" />
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            handleDelete(snapshot.id);
                          }}
                          className="p-1.5 text-zinc-700 hover:text-red-400 hover:bg-red-500/20 rounded-sm transition-colors duration-200"
                          title="Delete"
                        >
                          <Trash2 className="w-4 h-4" />
                        </button>
                      </>
                    )}
                  </div>
                </div>
              </motion.div>
            ))}
          </AnimatePresence>
        )}
      </div>

      {/* Save Dialog */}
      <AnimatePresence>
        {showSaveDialog && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.15 }}
            className="absolute inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 z-50"
            onClick={() => setShowSaveDialog(false)}
          >
            <motion.div
              initial={{ scale: 0.97, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0.97, opacity: 0 }}
              transition={{ duration: 0.15 }}
              className="w-full max-w-md bg-zinc-900 rounded-sm border border-zinc-800 p-6"
              onClick={(e) => e.stopPropagation()}
            >
              <h4 className="font-sans text-lg font-medium text-zinc-100 mb-4">Save Version</h4>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm text-zinc-500 mb-1">Version Name</label>
                  <input
                    type="text"
                    value={saveName}
                    onChange={(e) => setSaveName(e.target.value)}
                    placeholder="e.g., Before major changes"
                    className="w-full px-3 py-2 bg-zinc-950 border border-zinc-800 rounded-sm text-zinc-100 placeholder:text-zinc-700 focus:outline-none focus:border-blue-500"
                    autoFocus
                  />
                </div>
                <div>
                  <label className="block text-sm text-zinc-500 mb-1">Description (optional)</label>
                  <textarea
                    value={saveDescription}
                    onChange={(e) => setSaveDescription(e.target.value)}
                    placeholder="Notes about this version..."
                    className="w-full px-3 py-2 bg-zinc-950 border border-zinc-800 rounded-sm text-zinc-100 placeholder:text-zinc-700 resize-none h-20 focus:outline-none focus:border-blue-500"
                  />
                </div>
              </div>

              <div className="flex items-center justify-end gap-3 mt-6">
                <button
                  onClick={() => setShowSaveDialog(false)}
                  className="px-4 py-2 text-zinc-500 hover:text-zinc-100 transition-colors duration-200"
                >
                  Cancel
                </button>
                <button
                  onClick={handleSaveSnapshot}
                  disabled={!saveName.trim()}
                  className="px-4 py-2 bg-blue-500 hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed text-white rounded-sm transition-colors duration-200"
                >
                  Save Version
                </button>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

export default VersionHistoryPanel;
</file>

<file path="components/TimelineEditor/AudioClip.tsx">
/**
 * AudioClip Component
 * 
 * Renders an audio clip in the Graphite Timeline with:
 * - Waveform visualization with vertical bars
 * - Cyan coloring consistent with plasma theme
 * - Clip title and duration display
 * 
 * Requirements: 5.5, 6.1, 6.2, 6.3
 */

import { useMemo } from "react";
import { TimelineClip } from "./graphite-timeline-utils";
import "./graphite-timeline.css";

// --- Types ---

export interface AudioClipProps {
  /** Clip data containing id, name, duration, etc. */
  clip: TimelineClip;
  /** Current zoom level (pixels per second) */
  zoom: number;
  /** Whether this clip is currently selected */
  isSelected: boolean;
  /** Callback when clip is clicked */
  onClick: () => void;
  /** Optional left position override (otherwise calculated from startTime * zoom) */
  left?: number;
  /** Number of waveform bars to generate (default: calculated from width) */
  waveformBars?: number;
  /** Optional amplitude data for waveform (values 0-1) */
  amplitudeData?: number[];
}

// --- Helper Functions ---

/**
 * Formats duration in seconds to a display string (e.g., "4.2s")
 */
function formatDuration(seconds: number): string {
  return `${seconds.toFixed(1)}s`;
}

/**
 * Generates pseudo-random waveform bar heights.
 * Uses a seeded approach based on clip ID for consistency.
 * 
 * @param count - Number of bars to generate
 * @param seed - Seed string for consistent randomization
 * @returns Array of heights (5-35 pixels)
 */
function generateWaveformHeights(count: number, seed: string): number[] {
  const heights: number[] = [];
  let hash = 0;
  
  // Simple hash from seed string
  for (let i = 0; i < seed.length; i++) {
    hash = ((hash << 5) - hash) + seed.charCodeAt(i);
    hash = hash & hash; // Convert to 32-bit integer
  }
  
  for (let i = 0; i < count; i++) {
    // Pseudo-random based on hash and index
    const pseudoRandom = Math.abs(Math.sin(hash + i * 0.1)) * 0.8 + 0.2;
    // Height between 5 and 35 pixels
    heights.push(5 + pseudoRandom * 30);
  }
  
  return heights;
}

/**
 * Calculates the number of waveform bars based on clip width.
 * Aims for approximately 1 bar every 4-5 pixels.
 */
function calculateBarCount(width: number): number {
  return Math.max(10, Math.floor(width / 5));
}

// --- Component ---

export function AudioClip({
  clip,
  zoom,
  isSelected,
  onClick,
  left,
  waveformBars,
  amplitudeData,
}: AudioClipProps) {
  // Calculate width based on duration and zoom level
  const width = clip.duration * zoom;
  
  // Calculate left position from startTime if not provided
  const leftPosition = left ?? clip.startTime * zoom;

  // Calculate number of bars
  const barCount = waveformBars ?? calculateBarCount(width);

  // Generate or use provided waveform heights
  const waveformHeights = useMemo(() => {
    if (amplitudeData && amplitudeData.length > 0) {
      // Use provided amplitude data, scale to pixel heights
      return amplitudeData.map(amp => 5 + amp * 30);
    }
    // Generate pseudo-random heights based on clip ID
    return generateWaveformHeights(barCount, clip.id);
  }, [amplitudeData, barCount, clip.id]);

  // Build class names for hover/selected states
  const classNames = [
    "graphite-clip",
    "graphite-audio-clip",
    isSelected ? "selected" : "",
  ].filter(Boolean).join(" ");

  return (
    <div
      className={classNames}
      style={{
        left: `${leftPosition}px`,
        width: `${width}px`,
      }}
      onClick={(e) => {
        e.stopPropagation();
        onClick();
      }}
      role="button"
      tabIndex={0}
      aria-label={`Audio clip: ${clip.name}`}
      aria-selected={isSelected}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          onClick();
        }
      }}
    >
      {/* Waveform Visualization - Requirements 6.1, 6.2, 6.3 */}
      <div className="graphite-audio-wave" aria-hidden="true">
        {waveformHeights.map((height, index) => (
          <div
            key={index}
            className="graphite-wave-bar"
            style={{ height: `${height}px` }}
          />
        ))}
      </div>

      {/* Clip Info - Requirement 5.5 */}
      <div className="graphite-clip-info">
        <span className="graphite-clip-title" title={clip.name}>
          {clip.name}
        </span>
        <span className="graphite-clip-duration">
          {formatDuration(clip.duration)}
        </span>
      </div>
    </div>
  );
}

export default AudioClip;
</file>

<file path="components/TimelineEditor/AudioTimelineEditor.tsx">
/**
 * AudioTimelineEditor Component
 *
 * Main wrapper component that provides a modernized timeline UI while maintaining
 * backward compatibility with the existing GraphiteTimeline props interface.
 *
 * This component:
 * 1. Accepts all GraphiteTimelineProps for backward compatibility
 * 2. Uses useTimelineAdapter hook to convert data to internal format
 * 3. Composes sub-components (TrackSidebar, VideoPreview, TimelinePanel, TimelineControls)
 * 4. Manages internal state (zoom, volume, import modal)
 * 5. Wires up callbacks to convert clip IDs back to scene IDs
 *
 * @see .kiro/specs/timeline-editor-replacement/design.md for architecture details
 * @requirements 10.1, 10.3, 10.4, 10.5
 */

"use client";

import { useState, useCallback, useRef, useEffect } from "react";
import { cn } from "@/lib/utils";
import type { Scene, NarrationSegment, VideoSFXPlan } from "@/types";
import type { MediaFile, SubtitleCue, VideoClip, AudioClip } from "@/types/audio-editor";
import { useTimelineAdapter } from "@/hooks/useTimelineAdapter";
import { useTimelineKeyboard } from "@/hooks/useTimelineKeyboard";
import {
  TrackSidebar,
  VideoPreview,
  TimelinePanel,
  TimelineControls,
  ImportMediaModal,
} from "./editor";

// --- Accessibility Helper Functions ---

/**
 * Format duration in seconds to a human-readable string for screen reader announcements.
 * Outputs format like "5 seconds", "1 minute 30 seconds", etc.
 *
 * @param seconds - Duration in seconds
 * @returns Human-readable duration string
 *
 * @requirements 8.3
 * @validates Property 15: Aria Announcement Content
 */
export function formatDurationForAnnouncement(seconds: number): string {
  if (seconds < 0 || !Number.isFinite(seconds)) {
    return "0 seconds";
  }

  const totalSeconds = Math.floor(seconds);
  const minutes = Math.floor(totalSeconds / 60);
  const remainingSeconds = totalSeconds % 60;

  if (minutes === 0) {
    return remainingSeconds === 1 ? "1 second" : `${remainingSeconds} seconds`;
  }

  const minuteStr = minutes === 1 ? "1 minute" : `${minutes} minutes`;
  
  if (remainingSeconds === 0) {
    return minuteStr;
  }

  const secondStr = remainingSeconds === 1 ? "1 second" : `${remainingSeconds} seconds`;
  return `${minuteStr} ${secondStr}`;
}

/**
 * Update the aria-live region with an announcement for screen readers.
 * The announcement will be read aloud by screen readers due to aria-live="assertive".
 *
 * @param message - The message to announce
 * @param regionId - The ID of the aria-live region element (default: "timeline-announcements")
 *
 * @requirements 8.3, 8.5
 */
export function announceToScreenReader(
  message: string,
  regionId: string = "timeline-announcements"
): void {
  const region = document.getElementById(regionId);
  if (region) {
    // Clear and set to trigger announcement even if same message
    region.textContent = "";
    // Use requestAnimationFrame to ensure the clear is processed first
    requestAnimationFrame(() => {
      region.textContent = message;
    });
  }
}

/**
 * Find a clip by ID from the combined video and audio clips arrays.
 *
 * @param clipId - The clip ID to find
 * @param videoClips - Array of video clips
 * @param audioClips - Array of audio clips
 * @returns The found clip with its name and duration, or null if not found
 */
function findClipById(
  clipId: string,
  videoClips: VideoClip[],
  audioClips: AudioClip[]
): { name: string; duration: number } | null {
  // Check video clips first
  const videoClip = videoClips.find((clip) => clip.id === clipId);
  if (videoClip) {
    return { name: videoClip.name, duration: videoClip.duration };
  }

  // Check audio clips
  const audioClip = audioClips.find((clip) => clip.id === clipId);
  if (audioClip) {
    // Audio clips don't have a name property, so we generate one from the ID
    const clipName = audioClip.id.startsWith("audio-")
      ? `Audio clip ${audioClip.id.replace("audio-", "")}`
      : `Clip ${audioClip.id}`;
    return { name: clipName, duration: audioClip.duration };
  }

  return null;
}

// --- Types ---

/**
 * Props interface for AudioTimelineEditor.
 * Maintains backward compatibility with GraphiteTimelineProps while adding
 * new optional props for extended functionality.
 *
 * @requirements 10.1, 10.5
 */
export interface AudioTimelineEditorProps {
  // Existing GraphiteTimeline props (backward compatible)
  /** Array of Scene objects from content plan */
  scenes: Scene[];
  /** Map of scene IDs to thumbnail URLs */
  visuals?: Record<string, string>;
  /** Array of NarrationSegment objects */
  narrationSegments?: NarrationSegment[];
  /** Current playback time in seconds */
  currentTime: number;
  /** Total duration in seconds */
  duration: number;
  /** Whether playback is currently active */
  isPlaying: boolean;
  /** Callback when play/pause is toggled */
  onPlayPause: () => void;
  /** Callback when user seeks to a new position */
  onSeek: (time: number) => void;
  /** Callback when a scene is selected */
  onSceneSelect?: (sceneId: string) => void;
  /** Currently selected scene ID */
  selectedSceneId?: string | null;
  /** Project name to display */
  projectName?: string;
  /** Optional additional CSS class */
  className?: string;
  /** SFX plan for ambient tracks */
  sfxPlan?: VideoSFXPlan | null;
  /** Callback when a clip should be deleted */
  onDeleteClip?: (clipId: string) => void;
  /** Optional data-testid for E2E testing */
  "data-testid"?: string;

  // New optional props for extended functionality
  /** Callback when a video file is imported */
  onImportVideo?: (file: MediaFile) => void;
  /** Callback when an image file is imported */
  onImportImage?: (file: MediaFile) => void;
  /** Callback when subtitles are imported */
  onImportSubtitles?: (cues: SubtitleCue[]) => void;
}

// --- Constants ---

const DEFAULT_ZOOM = 50;
const DEFAULT_VOLUME = 80;

// --- Component ---

/**
 * AudioTimelineEditor - Main timeline editor component.
 *
 * Provides a modernized timeline UI with video preview, track sidebar,
 * and media import capabilities while maintaining backward compatibility
 * with the existing application state and callbacks.
 *
 * @example
 * ```tsx
 * <AudioTimelineEditor
 *   scenes={contentPlan.scenes}
 *   visuals={generatedVisuals}
 *   narrationSegments={narrationSegments}
 *   currentTime={currentTime}
 *   duration={totalDuration}
 *   isPlaying={isPlaying}
 *   onPlayPause={handlePlayPause}
 *   onSeek={handleSeek}
 *   onSceneSelect={handleSceneSelect}
 *   selectedSceneId={selectedSceneId}
 *   sfxPlan={sfxPlan}
 * />
 * ```
 *
 * @requirements 10.1, 10.3, 10.4, 10.5
 */
export function AudioTimelineEditor({
  scenes,
  visuals = {},
  narrationSegments = [],
  currentTime,
  duration: _duration,
  isPlaying,
  onPlayPause,
  onSeek,
  onSceneSelect,
  selectedSceneId = null,
  projectName = "Untitled Project",
  className,
  sfxPlan = null,
  onDeleteClip,
  onImportVideo,
  onImportImage,
  onImportSubtitles,
  "data-testid": dataTestId,
}: AudioTimelineEditorProps) {
  // --- Internal State ---
  const [zoom, setZoom] = useState(DEFAULT_ZOOM);
  const [volume, setVolume] = useState(DEFAULT_VOLUME);
  const [isImportModalOpen, setIsImportModalOpen] = useState(false);
  const [selectedTrackId, setSelectedTrackId] = useState<string | null>(null);
  const [importedVideo, setImportedVideo] = useState<MediaFile | null>(null);
  const [importedSubtitles, setImportedSubtitles] = useState<SubtitleCue[]>([]);
  const [isFocused, setIsFocused] = useState(false);
  const [selectedClipIndex, setSelectedClipIndex] = useState<number | null>(null);

  // --- Refs ---
  const containerRef = useRef<HTMLDivElement>(null);
  const isInitialRenderRef = useRef(true);

  // --- Use Timeline Adapter ---
  // Convert external props to internal data model
  const {
    tracks,
    audioClips,
    videoClips,
    imageClips,
    subtitles: adapterSubtitles,
    selectedClipId,
    handleClipSelect,
    handleDeleteClip: _handleDeleteClip,
  } = useTimelineAdapter({
    scenes,
    visuals,
    narrationSegments,
    sfxPlan,
    selectedSceneId,
    onSceneSelect,
    onDeleteClip,
  });

  // Combine adapter subtitles with imported subtitles
  const allSubtitles = [...adapterSubtitles, ...importedSubtitles];

  // Calculate total clip count for keyboard navigation
  const allClips = [...videoClips, ...audioClips];
  const clipCount = allClips.length;

  // Calculate duration from scenes if not provided
  const calculatedDuration = scenes.reduce((sum, s) => sum + s.duration, 0) || _duration;

  // --- Screen Reader Announcements ---
  // Requirements: 8.3, 8.5
  // Property 15: Aria Announcement Content

  /**
   * Announce clip selection changes to screen readers.
   * When a clip is selected, announces the clip name and duration.
   *
   * @requirements 8.3
   * @validates Property 15: Aria Announcement Content
   */
  useEffect(() => {
    if (selectedClipId) {
      const clipInfo = findClipById(selectedClipId, videoClips, audioClips);
      if (clipInfo) {
        const durationStr = formatDurationForAnnouncement(clipInfo.duration);
        const announcement = `Selected: ${clipInfo.name}, duration ${durationStr}`;
        announceToScreenReader(announcement);
      }
    }
  }, [selectedClipId, videoClips, audioClips]);

  /**
   * Announce playback state changes to screen readers.
   * Announces "Playing" when playback starts and "Paused" when playback stops.
   * Skips the initial render to avoid announcing on component mount.
   *
   * @requirements 8.5
   */
  useEffect(() => {
    // Skip announcement on initial render
    if (isInitialRenderRef.current) {
      isInitialRenderRef.current = false;
      return;
    }
    
    const announcement = isPlaying ? "Playing" : "Paused";
    announceToScreenReader(announcement);
  }, [isPlaying]);

  // --- Keyboard Navigation ---
  // Integrate useTimelineKeyboard hook for keyboard shortcuts
  // Requirements: 7.1-7.7

  const handleNextClip = useCallback(() => {
    if (clipCount === 0) return;
    setSelectedClipIndex((prev) => {
      const next = prev === null ? 0 : (prev + 1) % clipCount;
      // Also update the clip selection
      const clip = allClips[next];
      if (clip) {
        handleClipSelect(clip.id);
      }
      return next;
    });
  }, [clipCount, allClips, handleClipSelect]);

  const handlePrevClip = useCallback(() => {
    if (clipCount === 0) return;
    setSelectedClipIndex((prev) => {
      const next = prev === null ? clipCount - 1 : (prev - 1 + clipCount) % clipCount;
      // Also update the clip selection
      const clip = allClips[next];
      if (clip) {
        handleClipSelect(clip.id);
      }
      return next;
    });
  }, [clipCount, allClips, handleClipSelect]);

  const handleJumpToStart = useCallback(() => {
    onSeek(0);
  }, [onSeek]);

  const handleJumpToEnd = useCallback(() => {
    onSeek(calculatedDuration);
  }, [onSeek, calculatedDuration]);

  const handleKeyboardDeleteClip = useCallback(
    (index: number) => {
      const clip = allClips[index];
      if (clip && onDeleteClip) {
        onDeleteClip(clip.id);
      }
    },
    [allClips, onDeleteClip]
  );

  const handleKeyboardSelectClip = useCallback(
    (index: number | null) => {
      setSelectedClipIndex(index);
      if (index !== null) {
        const clip = allClips[index];
        if (clip) {
          handleClipSelect(clip.id);
        }
      } else {
        handleClipSelect(null);
      }
    },
    [allClips, handleClipSelect]
  );

  // Use the keyboard navigation hook
  useTimelineKeyboard({
    isActive: isFocused && !isImportModalOpen,
    duration: calculatedDuration,
    currentTime,
    isPlaying,
    selectedClipIndex,
    clipCount,
    onTimeChange: onSeek,
    onPlayPause,
    onSelectClip: handleKeyboardSelectClip,
    onDeleteClip: handleKeyboardDeleteClip,
    onNextClip: handleNextClip,
    onPrevClip: handlePrevClip,
    onJumpToStart: handleJumpToStart,
    onJumpToEnd: handleJumpToEnd,
  });

  // --- Handlers ---

  /**
   * Handle zoom level change.
   * Clamps value to valid range [10, 100].
   */
  const handleZoomChange = useCallback((value: number) => {
    setZoom(Math.max(10, Math.min(100, value)));
  }, []);

  /**
   * Handle volume change.
   * Clamps value to valid range [0, 100].
   */
  const handleVolumeChange = useCallback((value: number) => {
    setVolume(Math.max(0, Math.min(100, value)));
  }, []);

  /**
   * Handle track selection in sidebar.
   */
  const handleSelectTrack = useCallback((trackId: string) => {
    setSelectedTrackId(trackId);
  }, []);

  /**
   * Handle text update for a track.
   * Currently a no-op as tracks are derived from scenes.
   * Future: Could update scene narration scripts.
   */
  const handleUpdateTrackText = useCallback(
    (trackId: string, text: string) => {
      // TODO: Implement track text editing
      // This would need to update the scene's narrationScript
      console.log("[AudioTimelineEditor] Track text update:", trackId, text);
    },
    []
  );

  /**
   * Handle generate audio request for a track.
   * Currently a no-op - would trigger narration generation.
   */
  const handleGenerateAudio = useCallback((trackId: string) => {
    // TODO: Implement audio generation trigger
    console.log("[AudioTimelineEditor] Generate audio for track:", trackId);
  }, []);

  /**
   * Handle adding a new voiceover track.
   */
  const handleAddVoiceoverTrack = useCallback(() => {
    // TODO: Implement adding new voiceover track
    console.log("[AudioTimelineEditor] Add voiceover track");
  }, []);

  /**
   * Handle adding a new SFX track.
   */
  const handleAddSfxTrack = useCallback(() => {
    // TODO: Implement adding new SFX track
    console.log("[AudioTimelineEditor] Add SFX track");
  }, []);

  /**
   * Handle adding a new subtitle track.
   */
  const handleAddSubtitleTrack = useCallback(() => {
    // TODO: Implement adding new subtitle track
    console.log("[AudioTimelineEditor] Add subtitle track");
  }, []);

  /**
   * Handle opening the import modal.
   */
  const handleOpenImportModal = useCallback(() => {
    setIsImportModalOpen(true);
  }, []);

  /**
   * Handle video import.
   * Stores the video locally and calls external callback if provided.
   */
  const handleImportVideo = useCallback(
    (file: MediaFile) => {
      setImportedVideo(file);
      onImportVideo?.(file);
    },
    [onImportVideo]
  );

  /**
   * Handle image import.
   * Calls external callback if provided.
   */
  const handleImportImage = useCallback(
    (file: MediaFile) => {
      onImportImage?.(file);
    },
    [onImportImage]
  );

  /**
   * Handle subtitle import.
   * Stores subtitles locally and calls external callback if provided.
   */
  const handleImportSubtitles = useCallback(
    (cues: SubtitleCue[]) => {
      setImportedSubtitles((prev) => [...prev, ...cues]);
      onImportSubtitles?.(cues);
    },
    [onImportSubtitles]
  );

  /**
   * Handle time update from video preview.
   * Syncs video playback with timeline.
   */
  const handleVideoTimeUpdate = useCallback(
    (time: number) => {
      // Only update if significantly different to avoid feedback loops
      if (Math.abs(time - currentTime) > 0.1) {
        onSeek(time);
      }
    },
    [currentTime, onSeek]
  );

  // --- Render ---

  // Unique ID for keyboard instructions (for aria-describedby)
  const keyboardInstructionsId = "timeline-keyboard-instructions";

  return (
    <div
      ref={containerRef}
      className={cn(
        "flex h-full flex-col overflow-hidden bg-background",
        className
      )}
      role="application"
      aria-label={`Audio Timeline Editor for ${projectName}`}
      aria-describedby={keyboardInstructionsId}
      tabIndex={0}
      data-testid={dataTestId}
      onFocus={() => setIsFocused(true)}
      onBlur={(e) => {
        // Only blur if focus is leaving the container entirely
        if (!containerRef.current?.contains(e.relatedTarget as Node)) {
          setIsFocused(false);
        }
      }}
    >
      {/* Visually hidden keyboard instructions for screen readers */}
      {/* Requirements: 8.2, 8.6 */}
      <div
        id={keyboardInstructionsId}
        className="sr-only"
        aria-live="polite"
      >
        Keyboard shortcuts: Space or K to play/pause, Left arrow to seek back 1 second, 
        Right arrow to seek forward 1 second, Home to jump to start, End to jump to end, 
        Tab to navigate between clips, Delete to remove selected clip.
      </div>

      {/* Aria-live region for dynamic announcements (selection, playback state) */}
      {/* Requirements: 8.3, 8.5 */}
      <div
        id="timeline-announcements"
        className="sr-only"
        aria-live="assertive"
        aria-atomic="true"
      />

      {/* Top Section: Sidebar + Video Preview */}
      <div className="flex flex-1 min-h-0">
        {/* Track Sidebar - Left Panel */}
        <TrackSidebar
          tracks={tracks}
          selectedTrackId={selectedTrackId}
          onSelectTrack={handleSelectTrack}
          onUpdateText={handleUpdateTrackText}
          onGenerateAudio={handleGenerateAudio}
        />

        {/* Video Preview - Center Panel */}
        <VideoPreview
          video={importedVideo}
          currentTime={currentTime}
          isPlaying={isPlaying}
          subtitles={allSubtitles}
          onTimeUpdate={handleVideoTimeUpdate}
          onPlayPause={onPlayPause}
        />
      </div>

      {/* Bottom Section: Timeline Controls + Timeline Panel */}
      <div className="flex flex-col border-t border-border">
        {/* Timeline Controls */}
        <TimelineControls
          isPlaying={isPlaying}
          onPlayPause={onPlayPause}
          zoom={zoom}
          onZoomChange={handleZoomChange}
          volume={volume}
          onVolumeChange={handleVolumeChange}
          selectedClipId={selectedClipId}
          onAddVoiceoverTrack={handleAddVoiceoverTrack}
          onAddSfxTrack={handleAddSfxTrack}
          onAddSubtitleTrack={handleAddSubtitleTrack}
          onOpenImportModal={handleOpenImportModal}
        />

        {/* Timeline Panel */}
        <TimelinePanel
          tracks={tracks}
          clips={audioClips}
          subtitles={allSubtitles}
          videoClips={videoClips}
          imageClips={imageClips}
          currentTime={currentTime}
          zoom={zoom}
          selectedClipId={selectedClipId}
          onSelectClip={handleClipSelect}
          onSeek={onSeek}
        />
      </div>

      {/* Import Media Modal */}
      <ImportMediaModal
        open={isImportModalOpen}
        onOpenChange={setIsImportModalOpen}
        onImportVideo={handleImportVideo}
        onImportImage={handleImportImage}
        onImportSubtitles={handleImportSubtitles}
      />
    </div>
  );
}

export default AudioTimelineEditor;
</file>

<file path="components/TimelineEditor/editor/ImageClipComponent.tsx">
"use client";

import { cn } from "@/lib/utils";
import { ImageIcon } from "lucide-react";
import type { ImageClip } from "@/types/audio-editor";

interface ImageClipProps {
  clip: ImageClip;
  pixelsPerSecond: number;
  isSelected: boolean;
  onSelect: () => void;
}

/**
 * Format duration in seconds to a human-readable string.
 */
function formatDuration(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  if (mins > 0) {
    return `${mins} minute${mins !== 1 ? "s" : ""} ${secs} second${secs !== 1 ? "s" : ""}`;
  }
  return `${secs} second${secs !== 1 ? "s" : ""}`;
}

export function ImageClipComponent({
  clip,
  pixelsPerSecond,
  isSelected,
  onSelect,
}: ImageClipProps) {
  const width = clip.duration * pixelsPerSecond;
  const left = clip.startTime * pixelsPerSecond;

  return (
    <div
      className={cn(
        "absolute top-1 bottom-1 cursor-pointer rounded-md overflow-hidden transition-all",
        "bg-amber-500/20 border-2",
        isSelected
          ? "border-amber-500 ring-2 ring-amber-500/30"
          : "border-amber-500/50 hover:border-amber-500/70"
      )}
      style={{ left, width, minWidth: 40 }}
      onClick={(e) => {
        e.stopPropagation();
        onSelect();
      }}
      role="button"
      tabIndex={0}
      aria-label={`Image clip: ${clip.name}, duration ${formatDuration(clip.duration)}`}
      aria-selected={isSelected}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          onSelect();
        }
      }}
    >
      {/* Image thumbnail */}
      <div
        className="h-full w-full bg-cover bg-center"
        style={{
          backgroundImage: `url(${clip.imageUrl || "/generic-image-thumbnail.png"})`,
        }}
      />

      {/* Icon badge */}
      <div className="absolute top-1 left-1 rounded bg-amber-500 p-0.5">
        <ImageIcon className="h-2.5 w-2.5 text-white" />
      </div>

      {/* Clip name overlay */}
      <div className="absolute inset-x-0 bottom-0 bg-gradient-to-t from-black/60 to-transparent px-1.5 py-0.5">
        <span className="text-[9px] font-medium text-white truncate block">
          {clip.name}
        </span>
      </div>

      {/* Resize handles when selected */}
      {isSelected && (
        <>
          <div className="absolute left-0 top-0 bottom-0 w-1.5 cursor-ew-resize bg-amber-500 hover:bg-amber-400" />
          <div className="absolute right-0 top-0 bottom-0 w-1.5 cursor-ew-resize bg-amber-500 hover:bg-amber-400" />
        </>
      )}
    </div>
  );
}
</file>

<file path="components/TimelineEditor/editor/ImportMediaModal.tsx">
"use client";

import type React from "react";

import { useState, useRef, useCallback } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Video, ImageIcon, FileText, Upload, Link, X } from "lucide-react";
import type { MediaFile, SubtitleCue } from "@/types/audio-editor";

interface ImportMediaModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onImportVideo: (file: MediaFile) => void;
  onImportImage: (file: MediaFile) => void;
  onImportSubtitles: (cues: SubtitleCue[]) => void;
}

export function ImportMediaModal({
  open,
  onOpenChange,
  onImportVideo,
  onImportImage,
  onImportSubtitles,
}: ImportMediaModalProps) {
  const [activeTab, setActiveTab] = useState("video");
  const [urlInput, setUrlInput] = useState("");
  const [dragOver, setDragOver] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileSelect = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file) return;

      const url = URL.createObjectURL(file);
      const mediaFile: MediaFile = {
        id: `media-${Date.now()}`,
        type: activeTab as "video" | "image" | "subtitle",
        name: file.name,
        url,
      };

      if (activeTab === "video") {
        onImportVideo(mediaFile);
      } else if (activeTab === "image") {
        onImportImage(mediaFile);
      } else if (activeTab === "subtitle") {
        // Parse subtitle file (simplified SRT parsing)
        const reader = new FileReader();
        reader.onload = (event) => {
          const content = event.target?.result as string;
          const cues = parseSubtitles(content);
          onImportSubtitles(cues);
        };
        reader.readAsText(file);
      }

      onOpenChange(false);
    },
    [activeTab, onImportVideo, onImportImage, onImportSubtitles, onOpenChange]
  );

  const handleUrlImport = useCallback(() => {
    if (!urlInput.trim()) return;

    const mediaFile: MediaFile = {
      id: `media-${Date.now()}`,
      type: activeTab as "video" | "image" | "subtitle",
      name: urlInput.split("/").pop() || "Imported Media",
      url: urlInput,
    };

    if (activeTab === "video") {
      onImportVideo(mediaFile);
    } else if (activeTab === "image") {
      onImportImage(mediaFile);
    }

    setUrlInput("");
    onOpenChange(false);
  }, [activeTab, urlInput, onImportVideo, onImportImage, onOpenChange]);

  const handleDrop = useCallback(
    (e: React.DragEvent) => {
      e.preventDefault();
      setDragOver(false);

      const file = e.dataTransfer.files[0];
      if (!file) return;

      const url = URL.createObjectURL(file);
      const mediaFile: MediaFile = {
        id: `media-${Date.now()}`,
        type: activeTab as "video" | "image" | "subtitle",
        name: file.name,
        url,
      };

      if (activeTab === "video" && file.type.startsWith("video/")) {
        onImportVideo(mediaFile);
        onOpenChange(false);
      } else if (activeTab === "image" && file.type.startsWith("image/")) {
        onImportImage(mediaFile);
        onOpenChange(false);
      } else if (activeTab === "subtitle") {
        const reader = new FileReader();
        reader.onload = (event) => {
          const content = event.target?.result as string;
          const cues = parseSubtitles(content);
          onImportSubtitles(cues);
          onOpenChange(false);
        };
        reader.readAsText(file);
      }
    },
    [activeTab, onImportVideo, onImportImage, onImportSubtitles, onOpenChange]
  );

  const getAcceptTypes = () => {
    switch (activeTab) {
      case "video":
        return "video/*";
      case "image":
        return "image/*";
      case "subtitle":
        return ".srt,.vtt,.txt";
      default:
        return "*/*";
    }
  };

  const getTabIcon = (tab: string) => {
    switch (tab) {
      case "video":
        return <Video className="h-4 w-4" />;
      case "image":
        return <ImageIcon className="h-4 w-4" />;
      case "subtitle":
        return <FileText className="h-4 w-4" />;
      default:
        return null;
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-lg">
        <DialogHeader>
          <DialogTitle>Import Media</DialogTitle>
          <DialogDescription>
            Upload or link video files, images, or subtitle files to your
            project.
          </DialogDescription>
        </DialogHeader>

        <Tabs value={activeTab} onValueChange={setActiveTab} className="mt-4">
          <TabsList className="grid w-full grid-cols-3">
            <TabsTrigger value="video" className="gap-2">
              {getTabIcon("video")}
              Video
            </TabsTrigger>
            <TabsTrigger value="image" className="gap-2">
              {getTabIcon("image")}
              Image
            </TabsTrigger>
            <TabsTrigger value="subtitle" className="gap-2">
              {getTabIcon("subtitle")}
              Subtitles
            </TabsTrigger>
          </TabsList>

          <TabsContent value={activeTab} className="mt-4 space-y-4">
            {/* Drag and drop zone */}
            <div
              className={`relative flex min-h-[160px] cursor-pointer flex-col items-center justify-center rounded-lg border-2 border-dashed transition-colors ${
                dragOver
                  ? "border-primary bg-primary/5"
                  : "border-muted-foreground/25 hover:border-muted-foreground/50"
              }`}
              onDragOver={(e) => {
                e.preventDefault();
                setDragOver(true);
              }}
              onDragLeave={() => setDragOver(false)}
              onDrop={handleDrop}
              onClick={() => fileInputRef.current?.click()}
            >
              <input
                ref={fileInputRef}
                type="file"
                accept={getAcceptTypes()}
                onChange={handleFileSelect}
                className="sr-only"
                aria-label={`Upload ${activeTab} file`}
              />
              <Upload className="mb-2 h-10 w-10 text-muted-foreground" />
              <p className="text-sm font-medium">
                Drag and drop or click to upload
              </p>
              <p className="mt-1 text-xs text-muted-foreground">
                {activeTab === "video" && "MP4, WebM, MOV up to 500MB"}
                {activeTab === "image" && "PNG, JPG, GIF up to 10MB"}
                {activeTab === "subtitle" && "SRT, VTT, or TXT files"}
              </p>
            </div>

            {/* URL import (not for subtitles) */}
            {activeTab !== "subtitle" && (
              <div className="space-y-2">
                <Label htmlFor="url-input" className="text-sm">
                  Or import from URL
                </Label>
                <div className="flex gap-2">
                  <div className="relative flex-1">
                    <Link className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
                    <Input
                      id="url-input"
                      placeholder={`Paste ${activeTab} URL...`}
                      value={urlInput}
                      onChange={(e) => setUrlInput(e.target.value)}
                      className="pl-9"
                    />
                    {urlInput && (
                      <Button
                        variant="ghost"
                        size="icon"
                        className="absolute right-1 top-1/2 h-6 w-6 -translate-y-1/2"
                        onClick={() => setUrlInput("")}
                      >
                        <X className="h-3 w-3" />
                      </Button>
                    )}
                  </div>
                  <Button onClick={handleUrlImport} disabled={!urlInput.trim()}>
                    Import
                  </Button>
                </div>
              </div>
            )}
          </TabsContent>
        </Tabs>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Simple SRT/VTT subtitle parser
 * Parses subtitle files and returns an array of SubtitleCue objects
 */
function parseSubtitles(content: string): SubtitleCue[] {
  const cues: SubtitleCue[] = [];
  const trackId = `subtitle-${Date.now()}`;

  // Try to detect format and parse
  const lines = content.trim().split("\n");
  let i = 0;

  // Skip VTT header if present
  if (lines[0]?.includes("WEBVTT")) {
    i = 1;
    while (i < lines.length && lines[i]?.trim() === "") i++;
  }

  while (i < lines.length) {
    const currentLine = lines[i];
    if (!currentLine) {
      i++;
      continue;
    }

    // Skip cue number for SRT
    if (/^\d+$/.test(currentLine.trim())) {
      i++;
    }

    // Look for timestamp line
    const timestampLine = lines[i];
    if (!timestampLine) {
      i++;
      continue;
    }

    const timestampMatch = timestampLine.match(
      /(\d{2}):(\d{2}):(\d{2})[,.](\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2})[,.](\d{3})/
    );

    if (timestampMatch) {
      const startTime =
        Number.parseInt(timestampMatch[1] || "0") * 3600 +
        Number.parseInt(timestampMatch[2] || "0") * 60 +
        Number.parseInt(timestampMatch[3] || "0") +
        Number.parseInt(timestampMatch[4] || "0") / 1000;

      const endTime =
        Number.parseInt(timestampMatch[5] || "0") * 3600 +
        Number.parseInt(timestampMatch[6] || "0") * 60 +
        Number.parseInt(timestampMatch[7] || "0") +
        Number.parseInt(timestampMatch[8] || "0") / 1000;

      i++;

      // Collect text lines until empty line
      const textLines: string[] = [];
      while (i < lines.length) {
        const textLine = lines[i];
        if (!textLine || textLine.trim() === "") break;
        textLines.push(textLine.trim());
        i++;
      }

      if (textLines.length > 0) {
        cues.push({
          id: `cue-${Date.now()}-${cues.length}`,
          trackId,
          startTime,
          endTime,
          text: textLines.join(" "),
        });
      }
    }

    i++;
  }

  return cues;
}
</file>

<file path="components/TimelineEditor/editor/index.ts">
/**
 * Editor Sub-Components
 *
 * This directory contains the sub-components for the AudioTimelineEditor.
 * These components are adapted from the new-time-line reference implementation
 * with imports updated to use the project's path aliases (@/).
 *
 * @see .kiro/specs/timeline-editor-replacement/design.md for architecture details
 */

// Main editor panels
export { TrackSidebar } from "./TrackSidebar";
export { VideoPreview } from "./VideoPreview";
export { TimelinePanel } from "./TimelinePanel";
export { TimelineControls } from "./TimelineControls";
export { ImportMediaModal } from "./ImportMediaModal";

// Clip components
export { WaveformClip } from "./WaveformClip";
export { SubtitleClip } from "./SubtitleClip";
export { VideoClipComponent } from "./VideoClipComponent";
export { ImageClipComponent } from "./ImageClipComponent";
</file>

<file path="components/TimelineEditor/editor/SubtitleClip.tsx">
"use client";

import type { SubtitleCue } from "@/types/audio-editor";
import { cn } from "@/lib/utils";

interface SubtitleClipProps {
  cue: SubtitleCue;
  pixelsPerSecond: number;
  isSelected: boolean;
  onSelect: () => void;
}

export function SubtitleClip({
  cue,
  pixelsPerSecond,
  isSelected,
  onSelect,
}: SubtitleClipProps) {
  const width = (cue.endTime - cue.startTime) * pixelsPerSecond;
  const left = cue.startTime * pixelsPerSecond;

  return (
    <div
      className={cn(
        "absolute top-1/2 -translate-y-1/2 h-8 rounded-md cursor-pointer transition-all overflow-hidden",
        "bg-emerald-500/20 border border-emerald-500/40",
        isSelected &&
          "ring-2 ring-emerald-500 ring-offset-1 ring-offset-background"
      )}
      style={{ left, width: Math.max(width, 20) }}
      onClick={(e) => {
        e.stopPropagation();
        onSelect();
      }}
      role="button"
      tabIndex={0}
      aria-label={`Subtitle: ${cue.text}`}
      aria-selected={isSelected}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          onSelect();
        }
      }}
    >
      <div className="flex h-full items-center px-2">
        <span className="text-[10px] text-emerald-700 dark:text-emerald-300 truncate font-medium">
          {cue.text}
        </span>
      </div>
      {/* Resize handles */}
      {isSelected && (
        <>
          <div className="absolute left-0 top-0 h-full w-1.5 cursor-ew-resize bg-emerald-500/50 hover:bg-emerald-500" />
          <div className="absolute right-0 top-0 h-full w-1.5 cursor-ew-resize bg-emerald-500/50 hover:bg-emerald-500" />
        </>
      )}
    </div>
  );
}
</file>

<file path="components/TimelineEditor/editor/TimelineControls.tsx">
"use client";

import type React from "react";
import {
  Play,
  Pause,
  Volume2,
  PlusCircle,
  Upload,
  Video,
  ImageIcon,
  FileText,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
  DropdownMenuLabel,
} from "@/components/ui/dropdown-menu";

interface TimelineControlsProps {
  isPlaying: boolean;
  onPlayPause: () => void;
  zoom: number;
  onZoomChange: (value: number) => void;
  volume: number;
  onVolumeChange: (value: number) => void;
  selectedClipId: string | null;
  onAddVoiceoverTrack: () => void;
  onAddSfxTrack: () => void;
  onAddSubtitleTrack: () => void;
  onOpenImportModal: () => void;
}

export function TimelineControls({
  isPlaying,
  onPlayPause,
  zoom,
  onZoomChange,
  volume,
  onVolumeChange,
  selectedClipId,
  onAddVoiceoverTrack,
  onAddSfxTrack,
  onAddSubtitleTrack,
  onOpenImportModal,
}: TimelineControlsProps) {
  return (
    <div className="flex items-center justify-between border-b border-border bg-card px-4 py-2">
      {/* Left controls */}
      <div className="flex items-center gap-2">
        <Button variant="ghost" size="icon" className="h-8 w-8">
          <Settings2Icon className="h-4 w-4" />
        </Button>
      </div>

      {/* Center - Play button and track actions */}
      <div className="flex flex-col items-center gap-2">
        <Button
          variant="ghost"
          size="icon"
          className="h-10 w-10"
          onClick={onPlayPause}
          aria-label={isPlaying ? "Pause" : "Play"}
        >
          {isPlaying ? (
            <Pause className="h-5 w-5" />
          ) : (
            <Play className="h-5 w-5" />
          )}
        </Button>

        {/* Track action buttons */}
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="sm"
            className="h-7 gap-1.5 text-xs bg-transparent"
            onClick={onAddVoiceoverTrack}
          >
            <PlusCircle className="h-3.5 w-3.5" />
            Add Voiceover Track
          </Button>
          <Button
            variant="outline"
            size="sm"
            className="h-7 gap-1.5 text-xs bg-transparent"
            onClick={onAddSfxTrack}
          >
            <PlusCircle className="h-3.5 w-3.5" />
            Add SFX Track
          </Button>
          <Button
            variant="outline"
            size="sm"
            className="h-7 gap-1.5 text-xs bg-transparent"
            onClick={onAddSubtitleTrack}
          >
            <FileText className="h-3.5 w-3.5" />
            Add Subtitle Track
          </Button>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="outline"
                size="sm"
                className="h-7 gap-1.5 text-xs bg-transparent"
              >
                <Upload className="h-3.5 w-3.5" />
                Import Media
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="center">
              <DropdownMenuLabel className="text-xs">
                Import Files
              </DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem onClick={onOpenImportModal} className="gap-2">
                <Video className="h-4 w-4" />
                Import Video
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onOpenImportModal} className="gap-2">
                <ImageIcon className="h-4 w-4" />
                Import Image
              </DropdownMenuItem>
              <DropdownMenuItem onClick={onOpenImportModal} className="gap-2">
                <FileText className="h-4 w-4" />
                Import Subtitles
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>

      {/* Right controls */}
      <div className="flex items-center gap-4">
        {/* Zoom control */}
        <div className="flex items-center gap-2">
          <span className="text-xs text-muted-foreground">Zoom</span>
          <Slider
            value={[zoom]}
            onValueChange={([value]) => onZoomChange(value ?? 10)}
            min={10}
            max={100}
            step={1}
            className="w-24"
            aria-label="Timeline zoom"
          />
        </div>

        {/* Selection info */}
        <div className="flex flex-col items-end gap-1">
          <span className="text-xs text-muted-foreground">
            {selectedClipId ? "1 Clip Selected" : "No Selection"}
          </span>

          {/* Volume control */}
          <div className="flex items-center gap-2">
            <Volume2 className="h-3.5 w-3.5 text-muted-foreground" />
            <Slider
              value={[volume]}
              onValueChange={([value]) => onVolumeChange(value ?? 100)}
              min={0}
              max={100}
              step={1}
              className="w-20"
              aria-label="Volume"
            />
          </div>
        </div>

        {/* Action buttons */}
        <div className="flex flex-col gap-1">
          <Button
            variant="outline"
            size="sm"
            className="h-7 text-xs bg-transparent"
            disabled={!selectedClipId}
          >
            Create Voice from Selection
          </Button>
          <Button
            variant="outline"
            size="sm"
            className="h-7 text-xs bg-transparent"
          >
            Generate Audio
          </Button>
        </div>
      </div>
    </div>
  );
}

function Settings2Icon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      {...props}
    >
      <path d="M20 7h-9" />
      <path d="M14 17H5" />
      <circle cx="17" cy="17" r="3" />
      <circle cx="7" cy="7" r="3" />
    </svg>
  );
}
</file>

<file path="components/TimelineEditor/editor/TimelinePanel.tsx">
"use client";

import type React from "react";

import { useRef, useCallback } from "react";
import { Settings, Lock, Type, Video, ImageIcon } from "lucide-react";
import { Button } from "@/components/ui/button";
import { WaveformClip } from "./WaveformClip";
import { SubtitleClip } from "./SubtitleClip";
import { VideoClipComponent } from "./VideoClipComponent";
import { ImageClipComponent } from "./ImageClipComponent";
import type {
  Track,
  AudioClip,
  SubtitleCue,
  VideoClip,
  ImageClip,
} from "@/types/audio-editor";

interface TimelinePanelProps {
  tracks: Track[];
  clips: AudioClip[];
  subtitles: SubtitleCue[];
  videoClips: VideoClip[];
  imageClips: ImageClip[];
  currentTime: number;
  zoom: number;
  selectedClipId: string | null;
  onSelectClip: (id: string | null) => void;
  onSeek: (time: number) => void;
}

export function TimelinePanel({
  tracks,
  clips,
  subtitles,
  videoClips,
  imageClips,
  currentTime,
  zoom,
  selectedClipId,
  onSelectClip,
  onSeek,
}: TimelinePanelProps) {
  const timelineRef = useRef<HTMLDivElement>(null);
  const duration = 60;
  const pixelsPerSecond = (zoom / 100) * 20 + 10;

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  };

  const handleTimelineClick = useCallback(
    (e: React.MouseEvent) => {
      if (!timelineRef.current) return;
      const rect = timelineRef.current.getBoundingClientRect();
      const x = e.clientX - rect.left - 140;
      const time = Math.max(0, Math.min(duration, x / pixelsPerSecond));
      onSeek(time);
    },
    [pixelsPerSecond, duration, onSeek]
  );

  const narratorTracks = tracks.filter((t) => t.type === "narrator");
  const sfxTracks = tracks.filter((t) => t.type === "sfx");

  const narratorClips = clips.filter((c) =>
    narratorTracks.some((t) => t.id === c.trackId)
  );
  const sfxClips = clips.filter((c) => sfxTracks.some((t) => t.id === c.trackId));

  const markers = [];
  for (let i = 0; i <= duration; i += 5) {
    markers.push(i);
  }

  return (
    <div
      ref={timelineRef}
      className="relative overflow-x-auto bg-timeline-bg"
      onClick={handleTimelineClick}
    >
      {/* Time ruler */}
      <div className="sticky top-0 z-10 flex h-8 border-b border-border bg-background/80 backdrop-blur-sm">
        <div className="w-[140px] shrink-0" />
        <div className="relative flex-1">
          {markers.map((time) => (
            <div
              key={time}
              className="absolute top-0 flex h-full flex-col items-center justify-end"
              style={{ left: time * pixelsPerSecond }}
            >
              <span className="mb-1 text-[10px] text-muted-foreground">
                {formatTime(time)}
              </span>
              <div className="h-2 w-px bg-border" />
            </div>
          ))}
        </div>
      </div>

      {/* Playhead */}
      <div
        className="absolute bottom-0 top-8 z-20 w-px bg-foreground"
        style={{ left: 140 + currentTime * pixelsPerSecond }}
      >
        <div className="absolute -left-1.5 -top-1 h-3 w-3 rounded-full bg-foreground" />
      </div>

      {/* Video Track */}
      <div className="flex min-h-[70px] border-b border-border">
        <div className="flex w-[140px] shrink-0 items-center gap-2 border-r border-border bg-card px-3">
          <div className="flex items-center gap-2">
            <Video className="h-4 w-4 text-violet-500" />
            <div className="flex flex-col">
              <span className="text-xs font-medium">Video Track</span>
              <span className="text-[10px] text-muted-foreground">
                {videoClips.length} clip{videoClips.length !== 1 ? "s" : ""}
              </span>
            </div>
          </div>
          <div className="ml-auto flex items-center gap-1">
            <Button variant="ghost" size="icon" className="h-6 w-6">
              <Lock className="h-3 w-3" />
            </Button>
          </div>
        </div>
        <div className="relative flex-1 py-1 bg-violet-500/5">
          {videoClips.map((clip) => (
            <VideoClipComponent
              key={clip.id}
              clip={clip}
              pixelsPerSecond={pixelsPerSecond}
              isSelected={clip.id === selectedClipId}
              onSelect={() => onSelectClip(clip.id)}
            />
          ))}
          {videoClips.length === 0 && (
            <div className="absolute inset-0 flex items-center justify-center text-xs text-muted-foreground/50">
              Import video to add clips
            </div>
          )}
        </div>
      </div>

      {/* Image Track */}
      <div className="flex min-h-[60px] border-b border-border">
        <div className="flex w-[140px] shrink-0 items-center gap-2 border-r border-border bg-card px-3">
          <div className="flex items-center gap-2">
            <ImageIcon className="h-4 w-4 text-amber-500" />
            <div className="flex flex-col">
              <span className="text-xs font-medium">Image Track</span>
              <span className="text-[10px] text-muted-foreground">
                {imageClips.length} image{imageClips.length !== 1 ? "s" : ""}
              </span>
            </div>
          </div>
          <div className="ml-auto flex items-center gap-1">
            <Button variant="ghost" size="icon" className="h-6 w-6">
              <Lock className="h-3 w-3" />
            </Button>
          </div>
        </div>
        <div className="relative flex-1 py-1 bg-amber-500/5">
          {imageClips.map((clip) => (
            <ImageClipComponent
              key={clip.id}
              clip={clip}
              pixelsPerSecond={pixelsPerSecond}
              isSelected={clip.id === selectedClipId}
              onSelect={() => onSelectClip(clip.id)}
            />
          ))}
          {imageClips.length === 0 && (
            <div className="absolute inset-0 flex items-center justify-center text-xs text-muted-foreground/50">
              Import images to add clips
            </div>
          )}
        </div>
      </div>

      {/* Narrator track row */}
      <div className="flex min-h-[60px] border-b border-border">
        <div className="flex w-[140px] shrink-0 items-center gap-2 border-r border-border bg-card px-3">
          <div className="flex flex-col">
            <span className="text-xs font-medium">Primary Narrator</span>
            <span className="text-[10px] text-muted-foreground">
              Narration Track - Original
            </span>
          </div>
          <div className="ml-auto flex items-center gap-1">
            <Button variant="ghost" size="icon" className="h-6 w-6">
              <Settings className="h-3 w-3" />
            </Button>
            <Button variant="ghost" size="icon" className="h-6 w-6">
              <Lock className="h-3 w-3" />
            </Button>
          </div>
        </div>
        <div className="relative flex-1 py-2">
          {narratorClips.map((clip) => (
            <WaveformClip
              key={clip.id}
              clip={clip}
              type="narrator"
              pixelsPerSecond={pixelsPerSecond}
              isSelected={clip.id === selectedClipId}
              onSelect={() => onSelectClip(clip.id)}
            />
          ))}
        </div>
      </div>

      {/* SFX track row */}
      <div className="flex min-h-[60px] border-b border-border">
        <div className="flex w-[140px] shrink-0 items-center gap-2 border-r border-border bg-card px-3">
          <div className="flex flex-col">
            <span className="text-xs font-medium">New SFX Track</span>
            <span className="text-[10px] text-muted-foreground">
              SFX Track - English
            </span>
          </div>
          <div className="ml-auto flex items-center gap-1">
            <Button variant="ghost" size="icon" className="h-6 w-6">
              <Lock className="h-3 w-3" />
            </Button>
          </div>
        </div>
        <div className="relative flex-1 py-2">
          {sfxClips.map((clip) => (
            <WaveformClip
              key={clip.id}
              clip={clip}
              type="sfx"
              pixelsPerSecond={pixelsPerSecond}
              isSelected={clip.id === selectedClipId}
              onSelect={() => onSelectClip(clip.id)}
            />
          ))}
        </div>
      </div>

      {/* Subtitle Track */}
      <div className="flex min-h-[50px]">
        <div className="flex w-[140px] shrink-0 items-center gap-2 border-r border-border bg-card px-3">
          <div className="flex items-center gap-2">
            <Type className="h-4 w-4 text-emerald-500" />
            <div className="flex flex-col">
              <span className="text-xs font-medium">Subtitles</span>
              <span className="text-[10px] text-muted-foreground">
                {subtitles.length} cue{subtitles.length !== 1 ? "s" : ""}
              </span>
            </div>
          </div>
          <div className="ml-auto flex items-center gap-1">
            <Button variant="ghost" size="icon" className="h-6 w-6">
              <Lock className="h-3 w-3" />
            </Button>
          </div>
        </div>
        <div className="relative flex-1 py-2 bg-emerald-500/5">
          {subtitles.map((cue) => (
            <SubtitleClip
              key={cue.id}
              cue={cue}
              pixelsPerSecond={pixelsPerSecond}
              isSelected={cue.id === selectedClipId}
              onSelect={() => onSelectClip(cue.id)}
            />
          ))}
          {subtitles.length === 0 && (
            <div className="absolute inset-0 flex items-center justify-center text-xs text-muted-foreground/50">
              Import subtitles or add manually
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/TimelineEditor/editor/TrackSidebar.tsx">
"use client";

import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { cn } from "@/lib/utils";
import type { Track } from "@/types/audio-editor";

interface TrackSidebarProps {
  tracks: Track[];
  selectedTrackId: string | null;
  onSelectTrack: (id: string) => void;
  onUpdateText: (id: string, text: string) => void;
  onGenerateAudio: (id: string) => void;
}

export function TrackSidebar({
  tracks,
  selectedTrackId,
  onSelectTrack,
  onUpdateText,
  onGenerateAudio,
}: TrackSidebarProps) {
  return (
    <ScrollArea className="w-[400px] border-r border-border bg-card lg:w-[480px]">
      <div className="flex flex-col gap-3 p-4">
        {tracks.map((track) => (
          <TrackCard
            key={track.id}
            track={track}
            isSelected={track.id === selectedTrackId}
            onSelect={() => onSelectTrack(track.id)}
            onUpdateText={(text) => onUpdateText(track.id, text)}
            onGenerateAudio={() => onGenerateAudio(track.id)}
          />
        ))}
      </div>
    </ScrollArea>
  );
}

interface TrackCardProps {
  track: Track;
  isSelected: boolean;
  onSelect: () => void;
  onUpdateText: (text: string) => void;
  onGenerateAudio: () => void;
}

function TrackCard({
  track,
  isSelected,
  onSelect,
  onUpdateText,
  onGenerateAudio,
}: TrackCardProps) {
  const isNarrator = track.type === "narrator";

  return (
    <div
      className={cn(
        "flex flex-col gap-2 rounded-lg border-2 bg-card p-3 transition-all",
        isSelected
          ? "border-primary shadow-sm"
          : "border-transparent hover:border-border"
      )}
      onClick={onSelect}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => e.key === "Enter" && onSelect()}
    >
      {/* Track header */}
      <div className="flex items-center gap-2">
        <div
          className={cn(
            "h-2.5 w-2.5 rounded-full",
            isNarrator ? "bg-narrator" : "bg-sfx"
          )}
          aria-hidden="true"
        />
        <span className="text-xs font-medium text-muted-foreground">
          {track.name}
        </span>
      </div>

      {/* Text input */}
      <Textarea
        value={track.text}
        onChange={(e) => onUpdateText(e.target.value)}
        placeholder={
          isNarrator
            ? "Enter narration text..."
            : "Enter sound effect description..."
        }
        className="min-h-[60px] resize-none border-0 bg-transparent p-0 text-sm focus-visible:ring-0 focus-visible:ring-offset-0"
        onClick={(e) => e.stopPropagation()}
      />

      {/* Generate button */}
      <Button
        variant="ghost"
        size="sm"
        className="self-end text-xs text-muted-foreground hover:text-foreground"
        onClick={(e) => {
          e.stopPropagation();
          onGenerateAudio();
        }}
      >
        Generate Audio
      </Button>
    </div>
  );
}
</file>

<file path="components/TimelineEditor/editor/VideoClipComponent.tsx">
"use client";

import { cn } from "@/lib/utils";
import type { VideoClip } from "@/types/audio-editor";

interface VideoClipProps {
  clip: VideoClip;
  pixelsPerSecond: number;
  isSelected: boolean;
  onSelect: () => void;
}

/**
 * Format duration in seconds to a human-readable string.
 */
function formatDuration(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  if (mins > 0) {
    return `${mins} minute${mins !== 1 ? "s" : ""} ${secs} second${secs !== 1 ? "s" : ""}`;
  }
  return `${secs} second${secs !== 1 ? "s" : ""}`;
}

export function VideoClipComponent({
  clip,
  pixelsPerSecond,
  isSelected,
  onSelect,
}: VideoClipProps) {
  const width = clip.duration * pixelsPerSecond;
  const left = clip.startTime * pixelsPerSecond;

  return (
    <div
      className={cn(
        "absolute top-1 bottom-1 cursor-pointer rounded-md overflow-hidden transition-all",
        "bg-violet-500/20 border-2",
        isSelected
          ? "border-violet-500 ring-2 ring-violet-500/30"
          : "border-violet-500/50 hover:border-violet-500/70"
      )}
      style={{ left, width, minWidth: 60 }}
      onClick={(e) => {
        e.stopPropagation();
        onSelect();
      }}
      role="button"
      tabIndex={0}
      aria-label={`Video clip: ${clip.name}, duration ${formatDuration(clip.duration)}`}
      aria-selected={isSelected}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          onSelect();
        }
      }}
    >
      {/* Thumbnail strip */}
      <div className="flex h-full">
        {Array.from({ length: Math.max(1, Math.floor(width / 50)) }).map(
          (_, i) => (
            <div
              key={i}
              className="h-full w-[50px] shrink-0 bg-cover bg-center border-r border-violet-500/30 last:border-r-0"
              style={{
                backgroundImage: `url(${clip.thumbnailUrl || "/video-frame.png"})`,
              }}
            />
          )
        )}
      </div>

      {/* Clip name overlay */}
      <div className="absolute inset-x-0 bottom-0 bg-gradient-to-t from-black/60 to-transparent px-2 py-1">
        <span className="text-[10px] font-medium text-white truncate block">
          {clip.name}
        </span>
      </div>

      {/* Resize handles when selected */}
      {isSelected && (
        <>
          <div className="absolute left-0 top-0 bottom-0 w-1.5 cursor-ew-resize bg-violet-500 hover:bg-violet-400" />
          <div className="absolute right-0 top-0 bottom-0 w-1.5 cursor-ew-resize bg-violet-500 hover:bg-violet-400" />
        </>
      )}
    </div>
  );
}
</file>

<file path="components/TimelineEditor/editor/VideoPreview.tsx">
"use client";

import { useState, useRef, useEffect } from "react";
import { Search, Play, Pause, Maximize2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import type { MediaFile, SubtitleCue } from "@/types/audio-editor";

interface VideoPreviewProps {
  video?: MediaFile | null;
  currentTime?: number;
  isPlaying?: boolean;
  subtitles?: SubtitleCue[];
  onTimeUpdate?: (time: number) => void;
  onPlayPause?: () => void;
}

export function VideoPreview({
  video,
  currentTime = 0,
  isPlaying = false,
  subtitles = [],
  onTimeUpdate,
  onPlayPause,
}: VideoPreviewProps) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const [currentSubtitle, setCurrentSubtitle] = useState<string>("");

  useEffect(() => {
    const el = videoRef.current;
    if (!el || !video) return;

    if (isPlaying) {
      const playVideoSafe = async () => {
        try {
          if (el.readyState >= 3) {
            await el.play();
          } else {
            el.oncanplay = async () => {
              try { await el.play(); } catch (err) {
                if (err instanceof Error && err.name !== 'AbortError') {
                  console.error("Playback failed on canplay", err);
                }
              }
            };
          }
        } catch (err) {
          if (err instanceof Error && err.name !== 'AbortError') {
            console.error("Playback failed", err);
          }
        }
      };
      playVideoSafe();
    } else {
      el.pause();
    }
  }, [isPlaying, video]);

  useEffect(() => {
    const activeCue = subtitles.find(
      (cue) => currentTime >= cue.startTime && currentTime <= cue.endTime
    );
    setCurrentSubtitle(activeCue?.text || "");
  }, [currentTime, subtitles]);

  const handleTimeUpdate = () => {
    if (videoRef.current && onTimeUpdate) {
      onTimeUpdate(videoRef.current.currentTime);
    }
  };

  return (
    <div className="relative flex flex-1 items-center justify-center bg-muted/30 p-4">
      {/* Zoom/Search button */}
      <Button
        variant="secondary"
        size="icon"
        className="absolute left-4 top-4 z-10 h-8 w-8 rounded-full bg-card/80 backdrop-blur-sm"
        aria-label="Zoom preview"
      >
        <Search className="h-4 w-4" />
      </Button>

      {/* Video preview container */}
      <div className="relative aspect-video w-full max-w-3xl overflow-hidden rounded-lg shadow-lg bg-black">
        {video ? (
          <>
            <video
              ref={videoRef}
              src={video.url}
              className="h-full w-full object-contain"
              onTimeUpdate={handleTimeUpdate}
              playsInline
            />
            {/* Play/Pause overlay button */}
            <Button
              variant="ghost"
              size="icon"
              className="absolute left-1/2 top-1/2 h-16 w-16 -translate-x-1/2 -translate-y-1/2 rounded-full bg-black/50 text-white opacity-0 transition-opacity hover:bg-black/70 hover:opacity-100 focus:opacity-100"
              onClick={onPlayPause}
              aria-label={isPlaying ? "Pause" : "Play"}
            >
              {isPlaying ? (
                <Pause className="h-8 w-8" />
              ) : (
                <Play className="h-8 w-8 ml-1" />
              )}
            </Button>
          </>
        ) : (
          // Default placeholder image
          <div className="h-full w-full flex items-center justify-center bg-muted/50">
            <span className="text-muted-foreground text-sm">
              No video loaded
            </span>
          </div>
        )}

        {/* Subtitle overlay */}
        {currentSubtitle && (
          <div className="absolute bottom-8 left-1/2 -translate-x-1/2 max-w-[80%]">
            <p className="rounded bg-black/75 px-4 py-2 text-center text-sm font-medium text-white md:text-base">
              {currentSubtitle}
            </p>
          </div>
        )}

        {/* Gradient overlay */}
        <div className="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent pointer-events-none" />

        {/* Fullscreen button */}
        <Button
          variant="ghost"
          size="icon"
          className="absolute bottom-4 right-4 h-8 w-8 rounded bg-black/50 text-white hover:bg-black/70"
          aria-label="Fullscreen"
        >
          <Maximize2 className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="components/TimelineEditor/editor/WaveformClip.tsx">
"use client";

import { Maximize2 } from "lucide-react";
import { cn } from "@/lib/utils";
import type { AudioClip } from "@/types/audio-editor";

interface WaveformClipProps {
  clip: AudioClip;
  type: "narrator" | "sfx";
  pixelsPerSecond: number;
  isSelected: boolean;
  onSelect: () => void;
}

export function WaveformClip({
  clip,
  type,
  pixelsPerSecond,
  isSelected,
  onSelect,
}: WaveformClipProps) {
  const width = clip.duration * pixelsPerSecond;
  const left = clip.startTime * pixelsPerSecond;

  return (
    <div
      className={cn(
        "absolute flex h-10 cursor-pointer items-center rounded-md transition-all",
        type === "narrator"
          ? "bg-narrator-waveform/20 hover:bg-narrator-waveform/30"
          : "bg-sfx-waveform/20 hover:bg-sfx-waveform/30",
        isSelected && "ring-2 ring-primary ring-offset-1"
      )}
      style={{ left, width }}
      onClick={(e) => {
        e.stopPropagation();
        onSelect();
      }}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          onSelect();
        }
      }}
      aria-label={`Audio clip, ${clip.duration.toFixed(1)} seconds`}
      aria-selected={isSelected}
    >
      {/* Waveform visualization */}
      <div className="flex h-full flex-1 items-center gap-px px-2">
        {clip.waveformData.map((amplitude, index) => (
          <div
            key={index}
            className={cn(
              "w-0.5 rounded-full",
              type === "narrator" ? "bg-narrator-waveform" : "bg-sfx-waveform"
            )}
            style={{ height: `${amplitude * 100}%` }}
          />
        ))}
      </div>

      {/* Resize handle */}
      <div className="absolute right-1 top-1">
        <Maximize2 className="h-3 w-3 rotate-90 text-muted-foreground/50" />
      </div>
    </div>
  );
}
</file>

<file path="components/TimelineEditor/FooterNav.tsx">
/**
 * FooterNav Component
 * 
 * Footer section of the Graphite Timeline containing:
 * - Zoom controls (zoom in/out buttons and slider)
 * - Project overview minimap
 * - Total duration display
 * 
 * Requirements: 8.1, 8.2, 9.1, 9.2, 9.3, 9.4
 */

import React, { useCallback, useRef } from "react";
import { formatTimecode, TimelineTrack } from "./graphite-timeline-utils";
import "./graphite-timeline.css";

// --- SVG Icons ---

const ZoomOutIcon = () => (
  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
    <circle cx="11" cy="11" r="8" />
    <line x1="21" y1="21" x2="16.65" y2="16.65" />
    <line x1="8" y1="11" x2="14" y2="11" />
  </svg>
);

const ZoomInIcon = () => (
  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
    <circle cx="11" cy="11" r="8" />
    <line x1="21" y1="21" x2="16.65" y2="16.65" />
    <line x1="11" y1="8" x2="11" y2="14" />
    <line x1="8" y1="11" x2="14" y2="11" />
  </svg>
);

// --- Types ---

export interface FooterNavProps {
  /** Current zoom level (pixels per second) */
  zoom: number;
  /** Minimum zoom level */
  minZoom: number;
  /** Maximum zoom level */
  maxZoom: number;
  /** Total project duration in seconds */
  duration: number;
  /** Start time of visible region in seconds */
  visibleStart: number;
  /** End time of visible region in seconds */
  visibleEnd: number;
  /** Callback when zoom level changes */
  onZoomChange: (zoom: number) => void;
  /** Timeline tracks for minimap display */
  tracks?: TimelineTrack[];
  /** Frames per second for duration display (default: 24) */
  fps?: number;
}

// --- Sub-Components ---

/**
 * ZoomControls - Zoom in/out buttons with slider
 * Requirements: 8.1, 8.2
 */
interface ZoomControlsProps {
  zoom: number;
  minZoom: number;
  maxZoom: number;
  onZoomChange: (zoom: number) => void;
}

function ZoomControls({ zoom, minZoom, maxZoom, onZoomChange }: ZoomControlsProps) {
  const sliderRef = useRef<HTMLDivElement>(null);
  
  // Calculate slider handle position (0-100%)
  const handlePosition = ((zoom - minZoom) / (maxZoom - minZoom)) * 100;
  
  const handleZoomOut = useCallback(() => {
    const newZoom = Math.max(minZoom, zoom - 10);
    onZoomChange(newZoom);
  }, [zoom, minZoom, onZoomChange]);
  
  const handleZoomIn = useCallback(() => {
    const newZoom = Math.min(maxZoom, zoom + 10);
    onZoomChange(newZoom);
  }, [zoom, maxZoom, onZoomChange]);
  
  const handleSliderClick = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    if (!sliderRef.current) return;
    
    const rect = sliderRef.current.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const percentage = Math.max(0, Math.min(1, clickX / rect.width));
    const newZoom = minZoom + percentage * (maxZoom - minZoom);
    onZoomChange(newZoom);
  }, [minZoom, maxZoom, onZoomChange]);
  
  const handleSliderDrag = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    if (e.buttons !== 1 || !sliderRef.current) return;
    
    const rect = sliderRef.current.getBoundingClientRect();
    const dragX = e.clientX - rect.left;
    const percentage = Math.max(0, Math.min(1, dragX / rect.width));
    const newZoom = minZoom + percentage * (maxZoom - minZoom);
    onZoomChange(newZoom);
  }, [minZoom, maxZoom, onZoomChange]);
  
  return (
    <div className="graphite-zoom-controls">
      <button
        className="graphite-btn graphite-btn-small"
        onClick={handleZoomOut}
        aria-label="Zoom out"
        title="Zoom out"
        disabled={zoom <= minZoom}
      >
        <ZoomOutIcon />
      </button>
      
      <div
        ref={sliderRef}
        className="graphite-zoom-slider"
        onClick={handleSliderClick}
        onMouseMove={handleSliderDrag}
        role="slider"
        aria-label="Zoom level"
        aria-valuemin={minZoom}
        aria-valuemax={maxZoom}
        aria-valuenow={zoom}
        tabIndex={0}
      >
        <div
          className="graphite-zoom-handle"
          style={{ left: `calc(${handlePosition}% - 7px)` }}
        />
      </div>
      
      <button
        className="graphite-btn graphite-btn-small"
        onClick={handleZoomIn}
        aria-label="Zoom in"
        title="Zoom in"
        disabled={zoom >= maxZoom}
      >
        <ZoomInIcon />
      </button>
    </div>
  );
}

/**
 * ProjectOverview - Minimap showing all clips and visible region
 * Requirements: 9.1, 9.2, 9.3, 9.4
 */
interface ProjectOverviewProps {
  tracks: TimelineTrack[];
  duration: number;
  visibleStart: number;
  visibleEnd: number;
}

function ProjectOverview({ tracks, duration, visibleStart, visibleEnd }: ProjectOverviewProps) {
  // Don't render if no duration
  if (duration <= 0) {
    return <div className="graphite-project-overview" />;
  }
  
  // Calculate visible region position and width as percentages
  const visibleLeft = (visibleStart / duration) * 100;
  const visibleWidth = ((visibleEnd - visibleStart) / duration) * 100;
  
  // Flatten all clips from all tracks for minimap display
  const allClips = tracks.flatMap(track => 
    track.clips.map(clip => ({
      ...clip,
      trackType: track.type,
    }))
  );
  
  return (
    <div className="graphite-project-overview" aria-label="Project overview minimap">
      {/* Render mini clips */}
      {allClips.map(clip => {
        const clipLeft = (clip.startTime / duration) * 100;
        const clipWidth = (clip.duration / duration) * 100;
        
        return (
          <div
            key={clip.id}
            className={`graphite-mini-clip graphite-mini-clip--${clip.trackType}`}
            style={{
              left: `${clipLeft}%`,
              width: `${Math.max(clipWidth, 0.5)}%`, // Minimum width for visibility
            }}
            title={clip.name}
          />
        );
      })}
      
      {/* Visible region indicator */}
      <div
        className="graphite-visible-region"
        style={{
          left: `${visibleLeft}%`,
          width: `${Math.max(visibleWidth, 1)}%`, // Minimum width for visibility
        }}
        aria-label={`Visible region: ${visibleStart.toFixed(1)}s to ${visibleEnd.toFixed(1)}s`}
      />
    </div>
  );
}

// --- Main Component ---

export function FooterNav({
  zoom,
  minZoom,
  maxZoom,
  duration,
  visibleStart,
  visibleEnd,
  onZoomChange,
  tracks = [],
  fps = 24,
}: FooterNavProps) {
  return (
    <footer className="graphite-footer-nav">
      {/* Zoom Controls - Requirements 8.1, 8.2 */}
      <ZoomControls
        zoom={zoom}
        minZoom={minZoom}
        maxZoom={maxZoom}
        onZoomChange={onZoomChange}
      />
      
      {/* Project Overview Minimap - Requirements 9.1, 9.2, 9.3, 9.4 */}
      <ProjectOverview
        tracks={tracks}
        duration={duration}
        visibleStart={visibleStart}
        visibleEnd={visibleEnd}
      />
      
      {/* Duration Display - Requirement 9.3 */}
      <div className="graphite-duration-display">
        DURATION: <span>{formatTimecode(duration, fps)}</span>
      </div>
    </footer>
  );
}

export default FooterNav;
</file>

<file path="components/TimelineEditor/graphite-timeline-utils.ts">
/**
 * Graphite Timeline Utility Functions
 * 
 * Core utility functions for the Graphite Timeline component including:
 * - Timecode formatting
 * - Tick interval calculation
 * - Track data transformation
 * - Selection state management
 */

import { Scene, NarrationSegment, VideoSFXPlan } from "@/types";

// --- Types ---

export interface TimelineClip {
  id: string;
  trackId: string;
  startTime: number;
  duration: number;
  name: string;
  thumbnail?: string;
  type: "video" | "audio" | "fx" | "music";
}

export interface TimelineTrack {
  id: string;
  name: string;
  type: "video" | "audio" | "fx" | "music";
  clips: TimelineClip[];
}

// ... existing interfaces ...

export interface TickInterval {
  major: number;
  minor: number;
}

// --- Timecode Formatting ---

/**
 * Formats a time value in seconds to HH:MM:SS:FF timecode format.
 * 
 * @param seconds - Time value in seconds (non-negative)
 * @param fps - Frames per second (default: 24)
 * @returns Zero-padded timecode string in HH:MM:SS:FF format
 * 
 * @example
 * formatTimecode(3661.5) // "01:01:01:12"
 * formatTimecode(0) // "00:00:00:00"
 * formatTimecode(59.99, 30) // "00:00:59:29"
 */
export function formatTimecode(seconds: number, fps: number = 24): string {
  // Ensure non-negative
  const time = Math.max(0, seconds);

  const hrs = Math.floor(time / 3600);
  const mins = Math.floor((time % 3600) / 60);
  const secs = Math.floor(time % 60);
  const frames = Math.floor((time % 1) * fps);

  return `${hrs.toString().padStart(2, "0")}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}:${frames.toString().padStart(2, "0")}`;
}


// --- Tick Interval Calculation ---

/**
 * Calculates major and minor tick intervals based on zoom level.
 * Higher zoom levels result in finer granularity (smaller intervals).
 * 
 * The relationship is monotonic: as zoom increases, intervals decrease or stay the same.
 * 
 * @param zoom - Current zoom level (pixels per second)
 * @returns Object with major and minor tick intervals in seconds
 * 
 * @example
 * getTickInterval(100) // { major: 1, minor: 0.2 }
 * getTickInterval(50)  // { major: 5, minor: 1 }
 * getTickInterval(20)  // { major: 10, minor: 2 }
 * getTickInterval(10)  // { major: 30, minor: 5 }
 */
export function getTickInterval(zoom: number): TickInterval {
  if (zoom >= 100) return { major: 1, minor: 0.2 };   // Every second
  if (zoom >= 50) return { major: 5, minor: 1 };     // Every 5 seconds
  if (zoom >= 20) return { major: 10, minor: 2 };    // Every 10 seconds
  return { major: 30, minor: 5 };                     // Every 30 seconds
}

// ... existing code ...

export function buildTracks(
  scenes: Scene[],
  visuals: Record<string, string>,
  narrationSegments: NarrationSegment[],
  sfxPlan: VideoSFXPlan | null = null
): TimelineTrack[] {
  // Video track from scenes - calculate cumulative start times
  let videoStartTime = 0;
  const videoClips: TimelineClip[] = scenes.map((scene) => {
    const clip: TimelineClip = {
      id: scene.id,
      trackId: "video",
      startTime: videoStartTime,
      duration: scene.duration,
      name: scene.name,
      thumbnail: visuals[scene.id],
      type: "video",
    };
    videoStartTime += scene.duration;
    return clip;
  });

  // Audio track from narration segments - calculate cumulative start times
  let audioStartTime = 0;
  const audioClips: TimelineClip[] = narrationSegments.map((segment, i) => {
    const scene = scenes.find((s) => s.id === segment.sceneId);
    const clip: TimelineClip = {
      id: `audio-${segment.sceneId}`,
      trackId: "audio",
      startTime: audioStartTime,
      duration: segment.audioDuration,
      name: scene?.name || `Narration ${i + 1}`,
      type: "audio",
    };
    audioStartTime += segment.audioDuration;
    return clip;
  });

  // FX / Ambient track from SFX plan
  let fxStartTime = 0;
  const fxClips: TimelineClip[] = [];

  if (sfxPlan) {
    sfxPlan.scenes.forEach((scenePlan) => {
      // Find the narration segment or scene duration for timing
      const narration = narrationSegments.find(n => n.sceneId === scenePlan.sceneId);
      const scene = scenes.find(s => s.id === scenePlan.sceneId);
      const duration = narration?.audioDuration || scene?.duration || 0;

      if (scenePlan.ambientTrack) {
        fxClips.push({
          id: `fx-${scenePlan.sceneId}`,
          trackId: "fx",
          startTime: fxStartTime,
          duration: duration,
          name: scenePlan.ambientTrack.name,
          type: "fx",
        });
      }
      fxStartTime += duration;
    });
  }

  // Music track from generated music (Suno AI)
  const musicClips: TimelineClip[] = [];

  if (sfxPlan?.generatedMusic) {
    // Calculate total video duration for the music track
    const totalDuration = scenes.reduce((sum, s) => sum + s.duration, 0);

    musicClips.push({
      id: `music-${sfxPlan.generatedMusic.trackId}`,
      trackId: "music",
      startTime: 0,
      // Use the shorter of music duration or video duration
      duration: Math.min(sfxPlan.generatedMusic.duration, totalDuration),
      name: sfxPlan.generatedMusic.title,
      type: "music",
    });
  }

  // Build tracks array - include music track only if there's generated music
  const tracks: TimelineTrack[] = [
    { id: "video", name: "Video 01", type: "video", clips: videoClips },
    { id: "audio", name: "Narration", type: "audio", clips: audioClips },
    { id: "fx", name: "FX / Ambient", type: "fx", clips: fxClips },
  ];

  // Add music track if there's generated music
  if (musicClips.length > 0) {
    tracks.push({ id: "music", name: "Music", type: "music", clips: musicClips });
  }

  return tracks;
}


// --- Selection State Management ---

/**
 * Selection state for the timeline.
 * Supports single-selection only (Requirement 10.4).
 */
export interface SelectionState {
  /** ID of the currently selected clip, or null if none selected */
  selectedClipId: string | null;
}

/**
 * Extracts the scene ID from a clip ID.
 * Audio clips use the pattern "audio-{sceneId}", video clips use the scene ID directly.
 * 
 * @param clipId - The clip ID to extract scene ID from
 * @returns The scene ID
 * 
 * @example
 * extractSceneId("scene-1") // "scene-1"
 * extractSceneId("audio-scene-1") // "scene-1"
 */
export function extractSceneId(clipId: string): string {
  if (clipId.startsWith("audio-")) {
    return clipId.replace("audio-", "");
  }
  return clipId;
}

/**
 * Creates the initial selection state.
 * 
 * @param initialSelectedId - Optional initial selected clip ID
 * @returns Initial selection state
 */
export function createInitialSelectionState(initialSelectedId?: string | null): SelectionState {
  return {
    selectedClipId: initialSelectedId ?? null,
  };
}

/**
 * Selects a clip by ID.
 * Implements single-selection: selecting a new clip deselects the previous one.
 * (Requirement 10.1, 10.4)
 * 
 * @param state - Current selection state
 * @param clipId - ID of the clip to select
 * @returns New selection state with the clip selected
 */
export function selectClip(state: SelectionState, clipId: string): SelectionState {
  return {
    selectedClipId: clipId,
  };
}

/**
 * Clears the current selection.
 * (Requirement 10.2)
 * 
 * @param state - Current selection state
 * @returns New selection state with no clip selected
 */
export function clearSelection(state: SelectionState): SelectionState {
  return {
    selectedClipId: null,
  };
}

/**
 * Checks if a specific clip is selected.
 * 
 * @param state - Current selection state
 * @param clipId - ID of the clip to check
 * @returns True if the clip is selected
 */
export function isClipSelected(state: SelectionState, clipId: string): boolean {
  return state.selectedClipId === clipId;
}

/**
 * Handles a clip click event.
 * Selects the clicked clip and returns the scene ID for the callback.
 * (Requirement 10.1, 10.3)
 * 
 * @param state - Current selection state
 * @param clipId - ID of the clicked clip
 * @returns Object with new state and scene ID for callback
 */
export function handleClipClick(
  state: SelectionState,
  clipId: string
): { newState: SelectionState; sceneId: string } {
  const newState = selectClip(state, clipId);
  const sceneId = extractSceneId(clipId);
  return { newState, sceneId };
}

/**
 * Handles a click outside of clips (on empty lane area).
 * Clears the selection.
 * (Requirement 10.2)
 * 
 * @param state - Current selection state
 * @returns New selection state with no clip selected
 */
export function handleOutsideClick(state: SelectionState): SelectionState {
  return clearSelection(state);
}
</file>

<file path="components/TimelineEditor/graphite-timeline.css">
/* =============================================================================
   Graphite Timeline - CSS Foundation
   A professional dark interface for video editing with graphite textures
   Requirements: 1.1, 1.2, 1.3, 12.1 + Accessibility
   ============================================================================= */

/* -----------------------------------------------------------------------------
   CSS Custom Properties - Graphite Theme
   ----------------------------------------------------------------------------- */
:root {
  /* Graphite Color Palette - Clean dark interface */
  --graphite-bg: rgba(10, 10, 12, 0.95);
  --graphite-deep: rgba(15, 15, 18, 0.9);
  --graphite-mid: rgba(35, 35, 40, 0.6);
  --graphite-light: rgba(50, 50, 55, 0.5);
  --graphite-edge: rgba(255, 255, 255, 0.12);

  /* Track Type Colors - Distinct for each track */
  --track-video: rgba(79, 70, 229, 0.15);
  /* Indigo tint */
  --track-audio: rgba(34, 197, 94, 0.12);
  /* Green tint */
  --track-fx: rgba(251, 146, 60, 0.12);
  /* Orange tint */
  --track-music: rgba(168, 85, 247, 0.12);
  /* Purple tint */

  /* Waveform Colors */
  --waveform-audio: #22c55e;
  /* Green for narration */
  --waveform-fx: #fb923c;
  /* Orange for FX */
  --waveform-music: #a855f7;
  /* Purple for music */

  /* Accent Colors */
  --plasma-cyan: #00f2ff;
  --plasma-glow: rgba(0, 242, 255, 0.4);
  --laser-red: #ff3e3e;

  /* Focus Colors (high contrast for accessibility) */
  --focus-ring: #00f2ff;
  --focus-ring-offset: #0a0a0a;

  /* Text Colors */
  --graphite-text-main: #e0e0e0;
  --graphite-text-dim: #888;

  /* Spacing & Sizing */
  --graphite-block-radius: 6px;
  --graphite-track-height: 110px;
  --graphite-clip-height: 85px;
  --graphite-ruler-height: 35px;
  --graphite-transport-height: 80px;
  --graphite-footer-height: 60px;
  --graphite-label-width: 140px;

  /* Transitions */
  --graphite-transition-fast: 0.2s cubic-bezier(0.23, 1, 0.32, 1);
  --graphite-transition-smooth: 0.3s ease;
}

/* -----------------------------------------------------------------------------
   Screen Reader Only Utility (Accessibility)
   ----------------------------------------------------------------------------- */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* Extend .sr-only when it's focusable */
.sr-only-focusable:focus,
.sr-only-focusable:active {
  position: static;
  width: auto;
  height: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  clip: auto;
  white-space: normal;
}

/* -----------------------------------------------------------------------------
   Base Container Styles
   ----------------------------------------------------------------------------- */
.graphite-timeline {
  background-color: var(--graphite-bg);
  color: var(--graphite-text-main);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  display: flex;
  flex-direction: column;
  position: relative;
  overflow: hidden;
  height: 100%;
  width: 100%;
}

/* Focus styles for timeline container (keyboard navigation) */
.graphite-timeline:focus {
  outline: none;
}

.graphite-timeline:focus-visible {
  outline: 2px solid var(--focus-ring);
  outline-offset: 2px;
}

.graphite-timeline--focused {
  box-shadow: 0 0 0 2px var(--focus-ring-offset), 0 0 0 4px var(--focus-ring);
}

.graphite-timeline-workspace {
  background: var(--graphite-deep);
  backdrop-filter: blur(10px);
  border: 1px solid var(--graphite-edge);
  display: flex;
  flex-direction: column;
  position: relative;
  overflow: hidden;
  flex: 1;
  border-radius: 12px;
  margin: 8px;
}

/* -----------------------------------------------------------------------------
   Noise Texture Overlay (Requirement 1.3)
   ----------------------------------------------------------------------------- */
.graphite-noise {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.01;
  /* Reduced from 0.03 - much subtler */
  pointer-events: none;
  z-index: 1;
  mix-blend-mode: overlay;
}

.graphite-noise rect {
  width: 100%;
  height: 100%;
}

/* -----------------------------------------------------------------------------
   Transport Bar Styles
   ----------------------------------------------------------------------------- */
.graphite-transport-bar {
  height: var(--graphite-transport-height);
  background: rgba(0, 0, 0, 0.3);
  border-bottom: 1px solid var(--graphite-edge);
  display: flex;
  align-items: center;
  padding: 0 30px;
  justify-content: space-between;
  z-index: 10;
  flex-shrink: 0;
}

.graphite-transport-btns {
  display: flex;
  gap: 15px;
}

.graphite-btn {
  background: var(--graphite-light);
  border: 1px solid var(--graphite-edge);
  width: 45px;
  height: 45px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--graphite-block-radius);
  transition: all var(--graphite-transition-fast);
  position: relative;
  color: var(--graphite-text-main);
  cursor: pointer;
}

.graphite-btn:hover {
  background: var(--graphite-edge);
  transform: translateY(-2px);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
}

.graphite-btn:active {
  transform: translateY(0);
}

/* Focus styles for buttons (keyboard navigation) */
.graphite-btn:focus {
  outline: none;
}

.graphite-btn:focus-visible {
  outline: 2px solid var(--focus-ring);
  outline-offset: 2px;
  box-shadow: 0 0 10px var(--plasma-glow);
}

.graphite-btn.primary {
  border-color: var(--plasma-cyan);
  color: var(--plasma-cyan);
}

.graphite-btn.primary:hover {
  box-shadow: 0 0 15px var(--plasma-glow), 0 4px 10px rgba(0, 0, 0, 0.4);
}

.graphite-btn.primary:focus-visible {
  box-shadow: 0 0 20px var(--plasma-glow);
}

/* Timecode Display */
.graphite-timecode-display {
  font-family: 'JetBrains Mono', monospace;
  font-size: 2rem;
  font-weight: 300;
  color: var(--plasma-cyan);
  letter-spacing: -1px;
  text-shadow: 0 0 15px var(--plasma-glow);
  background: #000;
  padding: 5px 20px;
  border-radius: var(--graphite-block-radius);
  box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
  border: 1px solid var(--graphite-light);
}

/* Project Info */
.graphite-project-info {
  display: flex;
  gap: 20px;
  align-items: center;
}

.graphite-project-name {
  font-size: 10px;
  font-weight: 800;
  color: var(--graphite-text-dim);
  letter-spacing: 1px;
  text-transform: uppercase;
}

/* -----------------------------------------------------------------------------
   Timeline Area Styles
   ----------------------------------------------------------------------------- */
.graphite-timeline-area {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  position: relative;
  overflow: hidden;
  background: transparent;
}

/* Time Ruler */
.graphite-ruler {
  height: var(--graphite-ruler-height);
  min-height: 35px;
  background: var(--graphite-deep);
  border-bottom: 1px solid var(--graphite-edge);
  position: relative;
  font-family: 'JetBrains Mono', monospace;
  font-size: 9px;
  color: var(--graphite-text-dim);
  flex-shrink: 0;
  overflow-x: auto;
  overflow-y: hidden;
}

/* Hide scrollbars on ruler but keep functionality (Requirement 11.5) */
.graphite-ruler::-webkit-scrollbar {
  display: none;
}

.graphite-ruler {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

/* Inner container for ruler content - enables scroll synchronization */
.graphite-ruler-inner {
  position: relative;
  height: 100%;
}

.graphite-ruler-mark {
  position: absolute;
  bottom: 0;
  width: 1px;
  height: 8px;
  background: var(--graphite-text-dim);
}

.graphite-ruler-mark.major {
  height: 15px;
  background: var(--graphite-text-main);
}

.graphite-ruler-label {
  position: absolute;
  top: 4px;
  font-size: 9px;
  color: var(--graphite-text-main);
  white-space: nowrap;
  pointer-events: none;
}

/* -----------------------------------------------------------------------------
   Tracks Container
   ----------------------------------------------------------------------------- */
.graphite-tracks-container {
  display: flex;
  flex: 1;
  position: relative;
  overflow: hidden;
}

/* Track Labels (Left Sidebar) */
.graphite-track-labels {
  width: var(--graphite-label-width);
  background: var(--graphite-deep);
  border-right: 2px solid #000;
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  z-index: 5;
}

/* Ruler spacer - empty area above track labels that aligns with the ruler */
.graphite-ruler-spacer {
  height: var(--graphite-ruler-height);
  background: var(--graphite-deep);
  border-bottom: 1px solid var(--graphite-edge);
  flex-shrink: 0;
}

.graphite-label-block {
  height: var(--graphite-track-height);
  padding: 15px;
  border-bottom: 1px solid var(--graphite-edge);
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
}

.graphite-label-block span {
  font-size: 10px;
  font-weight: 800;
  text-transform: uppercase;
  letter-spacing: 2px;
  color: var(--graphite-text-dim);
}

/* Track Lanes */
.graphite-track-lanes {
  flex-grow: 1;
  position: relative;
  background-image: linear-gradient(var(--graphite-deep) 1px, transparent 1px);
  background-size: 100% var(--graphite-track-height);
  overflow-x: auto;
  overflow-y: hidden;
}

/* Track lanes inner container - holds clips with full timeline width */
.graphite-track-lanes-inner {
  display: flex;
  flex-direction: column;
  min-width: 100%;
}

/* Timeline content area - contains ruler and track lanes, scrolls together */
.graphite-timeline-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  min-width: 0;
  /* Allow flex item to shrink below content size */
}

/* Hide scrollbars but keep functionality (Requirement 11.5) */
.graphite-track-lanes::-webkit-scrollbar {
  display: none;
}

.graphite-track-lanes {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

.graphite-lane {
  height: var(--graphite-track-height);
  position: relative;
  display: flex;
  align-items: center;
  padding: 0 20px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.02);
}

/* Track Type-Specific Background Colors (Requirement 4.5) */
.graphite-lane--video {
  background: var(--track-video);
  border-left: 3px solid rgba(79, 70, 229, 0.5);
}

.graphite-lane--audio {
  background: var(--track-audio);
  border-left: 3px solid rgba(34, 197, 94, 0.5);
}

.graphite-lane--fx {
  background: var(--track-fx);
  border-left: 3px solid rgba(251, 146, 60, 0.5);
}

.graphite-lane--music {
  background: var(--track-music);
  border-left: 3px solid rgba(168, 85, 247, 0.5);
}

/* -----------------------------------------------------------------------------
   Clip Styles (Requirement 1.4, 1.5) + Accessibility Focus Styles
   ----------------------------------------------------------------------------- */
.graphite-clip {
  position: absolute;
  height: var(--graphite-clip-height);
  background: linear-gradient(135deg, var(--graphite-light) 0%, var(--graphite-mid) 100%);
  border: 1px solid var(--graphite-edge);
  border-radius: var(--graphite-block-radius);
  box-shadow:
    4px 4px 15px rgba(0, 0, 0, 0.5),
    inset 1px 1px 0 rgba(255, 255, 255, 0.05);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transition: border-color var(--graphite-transition-smooth);
  cursor: pointer;
}

/* Hover state with cyan plasma glow (Requirement 1.4) */
.graphite-clip:hover {
  border-color: var(--plasma-cyan);
  z-index: 5;
}

/* Focus styles for clips (keyboard navigation) */
.graphite-clip:focus {
  outline: none;
}

.graphite-clip:focus-visible {
  outline: 2px solid var(--focus-ring);
  outline-offset: 2px;
  z-index: 10;
  box-shadow:
    0 0 15px var(--plasma-glow),
    4px 4px 15px rgba(0, 0, 0, 0.5);
}

/* Selected/Active state with enhanced glow (Requirement 1.5) */
.graphite-clip.active,
.graphite-clip.selected,
.graphite-clip[aria-selected="true"] {
  border-color: var(--plasma-cyan);
  box-shadow:
    0 0 20px var(--plasma-glow),
    4px 4px 15px rgba(0, 0, 0, 0.5);
}

/* Clip Thumbnail */
.graphite-clip-thumb {
  height: 55px;
  background: #000;
  width: 100%;
  opacity: 0.85;
  background-size: cover;
  background-position: center;
  transition: opacity var(--graphite-transition-smooth);
}

.graphite-clip:hover .graphite-clip-thumb,
.graphite-clip:focus-visible .graphite-clip-thumb {
  opacity: 1;
}

/* Clip Info */
.graphite-clip-info {
  padding: 6px 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex: 1;
}

.graphite-clip-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  color: var(--graphite-text-main);
}

.graphite-clip-duration {
  font-family: 'JetBrains Mono', monospace;
  font-size: 9px;
  opacity: 0.5;
  color: var(--graphite-text-main);
}

/* -----------------------------------------------------------------------------
   Audio Clip & Waveform Styles
   ----------------------------------------------------------------------------- */
.graphite-audio-clip {
  height: 65px;
  background: rgba(20, 22, 25, 0.9);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

/* Track-specific audio clip styling */
.graphite-lane--audio .graphite-audio-clip {
  background: rgba(34, 197, 94, 0.08);
  border-color: rgba(34, 197, 94, 0.25);
}

.graphite-lane--fx .graphite-audio-clip {
  background: rgba(251, 146, 60, 0.08);
  border-color: rgba(251, 146, 60, 0.25);
}

.graphite-lane--music .graphite-audio-clip {
  background: rgba(168, 85, 247, 0.1);
  border-color: rgba(168, 85, 247, 0.3);
}

/* Focus styles for audio clips */
.graphite-audio-clip:focus {
  outline: none;
}

.graphite-audio-clip:focus-visible {
  outline: 2px solid var(--focus-ring);
  outline-offset: 2px;
  z-index: 10;
}

.graphite-audio-clip[aria-selected="true"] {
  box-shadow: 0 0 15px var(--plasma-glow);
  border-color: var(--plasma-cyan);
}

.graphite-audio-wave {
  height: 42px;
  width: 100%;
  position: relative;
  display: flex;
  align-items: center;
  gap: 1px;
  padding: 0 8px;
}

/* Base waveform bar - defaults to cyan */
.graphite-wave-bar {
  width: 2px;
  background: var(--plasma-cyan);
  opacity: 0.6;
  border-radius: 1px;
}

/* Track-specific waveform colors */
.graphite-lane--audio .graphite-wave-bar {
  background: var(--waveform-audio);
  opacity: 0.7;
}

.graphite-lane--fx .graphite-wave-bar {
  background: var(--waveform-fx);
  opacity: 0.7;
}

.graphite-lane--music .graphite-wave-bar {
  background: var(--waveform-music);
  opacity: 0.7;
}

/* -----------------------------------------------------------------------------
   Playhead Styles
   ----------------------------------------------------------------------------- */
.graphite-playhead {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 2px;
  background: var(--laser-red);
  box-shadow: 0 0 10px var(--laser-red);
  z-index: 100;
  pointer-events: none;
}

.graphite-playhead-handle {
  position: absolute;
  top: 0;
  left: -8px;
  width: 18px;
  height: 35px;
  background: var(--laser-red);
  clip-path: polygon(0% 0%, 100% 0%, 100% 70%, 50% 100%, 0% 70%);
}

/* -----------------------------------------------------------------------------
   Footer Navigation Styles
   ----------------------------------------------------------------------------- */
.graphite-footer-nav {
  height: var(--graphite-footer-height);
  background: var(--graphite-mid);
  border-top: 1px solid #000;
  display: flex;
  align-items: center;
  padding: 0 30px;
  gap: 40px;
  flex-shrink: 0;
}

/* Zoom Controls */
.graphite-zoom-controls {
  display: flex;
  align-items: center;
  gap: 15px;
}

.graphite-zoom-slider {
  width: 150px;
  height: 4px;
  background: #000;
  border-radius: 2px;
  position: relative;
}

.graphite-zoom-handle {
  position: absolute;
  width: 14px;
  height: 14px;
  background: var(--graphite-text-main);
  border-radius: 50%;
  top: -5px;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
  cursor: pointer;
  transition: transform var(--graphite-transition-fast);
}

.graphite-zoom-handle:hover {
  transform: scale(1.2);
}

.graphite-zoom-handle:focus {
  outline: none;
}

.graphite-zoom-handle:focus-visible {
  outline: 2px solid var(--focus-ring);
  outline-offset: 2px;
}

/* Project Overview Minimap */
.graphite-project-overview {
  flex-grow: 1;
  height: 30px;
  background: #000;
  border-radius: var(--graphite-block-radius);
  position: relative;
  overflow: hidden;
  border: 1px solid var(--graphite-light);
}

.graphite-mini-clip {
  position: absolute;
  height: 100%;
  background: var(--graphite-edge);
  opacity: 0.5;
}

.graphite-visible-region {
  position: absolute;
  top: 0;
  height: 100%;
  border: 1px solid #fff;
  opacity: 0.3;
  background: rgba(255, 255, 255, 0.05);
}

/* Duration Display */
.graphite-duration-display {
  font-family: 'JetBrains Mono', monospace;
  font-size: 10px;
  color: var(--graphite-text-dim);
  white-space: nowrap;
}

.graphite-duration-display span {
  color: #fff;
}

/* Small Button Variant for Zoom Controls */
.graphite-btn-small {
  width: 28px;
  height: 28px;
  padding: 0;
}

.graphite-btn-small:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  transform: none;
}

.graphite-btn-small:disabled:hover {
  background: var(--graphite-light);
  transform: none;
  box-shadow: none;
}

/* Mini Clip Track Type Colors */
.graphite-mini-clip--video {
  background: var(--graphite-edge);
}

.graphite-mini-clip--audio {
  background: var(--plasma-cyan);
  opacity: 0.3;
}

.graphite-mini-clip--fx {
  background: var(--laser-red);
  opacity: 0.3;
}

.graphite-mini-clip--music {
  background: #8a2be2;
  opacity: 0.3;
}

/* -----------------------------------------------------------------------------
   Animation Keyframes (Requirement 12.1)
   ----------------------------------------------------------------------------- */
@keyframes graphite-reveal {
  from {
    opacity: 0;
    transform: translateY(10px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes graphite-fade-in {
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}

@keyframes graphite-glow-pulse {

  0%,
  100% {
    box-shadow: 0 0 10px var(--plasma-glow);
  }

  50% {
    box-shadow: 0 0 20px var(--plasma-glow);
  }
}

/* Focus indicator pulse animation */
@keyframes graphite-focus-pulse {

  0%,
  100% {
    box-shadow: 0 0 0 2px var(--focus-ring-offset), 0 0 0 4px var(--focus-ring);
  }

  50% {
    box-shadow: 0 0 0 2px var(--focus-ring-offset), 0 0 0 6px var(--focus-ring);
  }
}

/* Staggered reveal animation on mount */
.graphite-timeline-workspace>* {
  animation: graphite-reveal 0.8s cubic-bezier(0.16, 1, 0.3, 1) both;
}

.graphite-transport-bar {
  animation-delay: 0.1s;
}

.graphite-timeline-area {
  animation-delay: 0.2s;
}

.graphite-footer-nav {
  animation-delay: 0.3s;
}

/* Clip hover transition effects (Requirement 12.2) */
.graphite-clip {
  transition:
    border-color var(--graphite-transition-smooth),
    box-shadow var(--graphite-transition-smooth),
    transform var(--graphite-transition-fast);
}

/* Button hover lift effect (Requirement 12.4) */
.graphite-btn {
  transition:
    background var(--graphite-transition-fast),
    transform var(--graphite-transition-fast),
    box-shadow var(--graphite-transition-fast);
}

/* Playhead smooth transition for click-to-seek (Requirement 12.3) */
.graphite-playhead.animating {
  transition: left 0.2s cubic-bezier(0.23, 1, 0.32, 1);
}

/* -----------------------------------------------------------------------------
   High Contrast Mode Support (Accessibility)
   ----------------------------------------------------------------------------- */
@media (prefers-contrast: high) {
  :root {
    --graphite-edge: #555;
    --plasma-cyan: #00ffff;
    --focus-ring: #ffff00;
  }

  .graphite-clip:focus-visible {
    outline-width: 3px;
  }

  .graphite-btn:focus-visible {
    outline-width: 3px;
  }
}

/* -----------------------------------------------------------------------------
   Reduced Motion Support (Accessibility)
   ----------------------------------------------------------------------------- */
@media (prefers-reduced-motion: reduce) {

  .graphite-timeline-workspace>*,
  .graphite-clip,
  .graphite-btn,
  .graphite-playhead.animating {
    animation: none;
    transition: none;
  }

  .graphite-zoom-handle {
    transition: none;
  }
}

/* -----------------------------------------------------------------------------
   Utility Classes
   ----------------------------------------------------------------------------- */
.graphite-mono {
  font-family: 'JetBrains Mono', monospace;
}

.graphite-uppercase {
  text-transform: uppercase;
  letter-spacing: 2px;
}

.graphite-text-dim {
  color: var(--graphite-text-dim);
}

.graphite-text-cyan {
  color: var(--plasma-cyan);
}

.graphite-glow-cyan {
  text-shadow: 0 0 15px var(--plasma-glow);
}

/* -----------------------------------------------------------------------------
   Skip Link for Keyboard Navigation (Accessibility)
   ----------------------------------------------------------------------------- */
.graphite-skip-link {
  position: absolute;
  top: -40px;
  left: 0;
  background: var(--plasma-cyan);
  color: var(--graphite-bg);
  padding: 8px 16px;
  z-index: 1000;
  font-weight: bold;
  text-decoration: none;
}

.graphite-skip-link:focus {
  top: 0;
}
</file>

<file path="components/TimelineEditor/GraphiteClip.tsx">
/**
 * GraphiteClip Component
 * 
 * Renders a video clip in the Graphite Timeline with:
 * - Thumbnail with luminosity blend mode
 * - Clip title (uppercase, truncated)
 * - Duration badge
 * - Hover and selected states with plasma glow
 * 
 * Requirements: 5.1, 5.2, 5.3, 5.4, 5.6, 1.4, 1.5
 */

import { TimelineClip } from "./graphite-timeline-utils";
import "./graphite-timeline.css";

// --- Types ---

export interface GraphiteClipProps {
  /** Clip data containing id, name, duration, thumbnail, etc. */
  clip: TimelineClip;
  /** Current zoom level (pixels per second) */
  zoom: number;
  /** Whether this clip is currently selected */
  isSelected: boolean;
  /** Callback when clip is clicked */
  onClick: () => void;
  /** Optional left position override (otherwise calculated from startTime * zoom) */
  left?: number;
}

// --- Helper Functions ---

/**
 * Formats duration in seconds to a display string (e.g., "4.2s")
 */
function formatDuration(seconds: number): string {
  return `${seconds.toFixed(1)}s`;
}

// --- Component ---

export function GraphiteClip({
  clip,
  zoom,
  isSelected,
  onClick,
  left,
}: GraphiteClipProps) {
  // Calculate width based on duration and zoom level
  const width = clip.duration * zoom;
  
  // Calculate left position from startTime if not provided
  const leftPosition = left ?? clip.startTime * zoom;

  // Build class names for hover/selected states
  const classNames = [
    "graphite-clip",
    isSelected ? "selected" : "",
  ].filter(Boolean).join(" ");

  return (
    <div
      className={classNames}
      style={{
        left: `${leftPosition}px`,
        width: `${width}px`,
      }}
      onClick={(e) => {
        e.stopPropagation();
        onClick();
      }}
      role="button"
      tabIndex={0}
      aria-label={`Clip: ${clip.name}`}
      aria-selected={isSelected}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          onClick();
        }
      }}
    >
      {/* Thumbnail with luminosity blend mode - Requirements 5.1, 5.4, 5.6 */}
      <div
        className="graphite-clip-thumb"
        style={{
          backgroundImage: clip.thumbnail ? `url(${clip.thumbnail})` : undefined,
          backgroundColor: clip.thumbnail ? undefined : "var(--graphite-mid)",
        }}
        aria-hidden="true"
      />

      {/* Clip Info - Requirements 5.2, 5.3 */}
      <div className="graphite-clip-info">
        <span className="graphite-clip-title" title={clip.name}>
          {clip.name}
        </span>
        <span className="graphite-clip-duration">
          {formatDuration(clip.duration)}
        </span>
      </div>
    </div>
  );
}

export default GraphiteClip;
</file>

<file path="components/TimelineEditor/GraphiteTimeline.tsx">
/**
 * GraphiteTimeline Component
 * 
 * Main timeline component that assembles all sub-components:
 * - TransportBar: Playback controls and timecode display
 * - TimeRuler: Time scale with major/minor ticks
 * - TrackLabel: Track names in left sidebar
 * - TrackLane: Track lanes with clips
 * - Playhead: Current position indicator
 * - FooterNav: Zoom controls and project overview
 * 
 * Accessibility Features:
 * - Full keyboard navigation via useTimelineKeyboard hook
 * - ARIA roles and labels for screen readers
 * - Focus management and visual indicators
 * - Live regions for time announcements
 * 
 * Requirements: All (1.1-12.1) + Accessibility
 */

import { useState, useMemo, useCallback, useEffect, useRef } from "react";
import { Scene, NarrationSegment } from "@/types";
import { buildTracks, TimelineClip } from "./graphite-timeline-utils";
import { TransportBar } from "./TransportBar";
import { TimeRuler } from "./TimeRuler";
import { TrackLabel } from "./TrackLabel";
import { TrackLane } from "./TrackLane";
import { Playhead, usePlayheadSeek } from "./Playhead";
import { FooterNav } from "./FooterNav";
import { useTimelineScroll } from "./useTimelineScroll";
import { useTimelineSelection } from "@/hooks/useTimelineSelection";
import { useTimelineKeyboard } from "@/hooks/useTimelineKeyboard";
import "./graphite-timeline.css";

// --- Types ---

export interface GraphiteTimelineProps {
  /** Array of Scene objects from content plan */
  scenes: Scene[];
  /** Map of scene IDs to thumbnail URLs */
  visuals?: Record<string, string>;
  /** Array of NarrationSegment objects */
  narrationSegments?: NarrationSegment[];
  /** Current playback time in seconds */
  currentTime: number;
  /** Total duration in seconds */
  duration: number;
  /** Whether playback is currently active */
  isPlaying: boolean;
  /** Callback when play/pause is toggled */
  onPlayPause: () => void;
  /** Callback when user seeks to a new position */
  onSeek: (time: number) => void;
  /** Callback when a scene is selected */
  onSceneSelect?: (sceneId: string) => void;
  /** Currently selected scene ID */
  selectedSceneId?: string | null;
  /** Project name to display in transport bar */
  projectName?: string;
  /** Optional additional CSS class */
  className?: string;
  /** SFX plan for ambient tracks */
  sfxPlan?: import("@/types").VideoSFXPlan | null;
  /** Callback when a clip should be deleted */
  onDeleteClip?: (clipId: string) => void;
}

// --- Constants ---

const MIN_ZOOM = 10; // pixels per second
const MAX_ZOOM = 200;
const DEFAULT_ZOOM = 50;
const SKIP_INTERVAL = 5; // seconds

// --- Helper Functions ---

/**
 * Formats time in seconds to a human-readable string for screen readers
 * @param seconds - Time in seconds
 * @returns Formatted string like "1 minute 30 seconds"
 */
function formatTimeForScreenReader(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);

  if (mins === 0) {
    return `${secs} second${secs !== 1 ? 's' : ''}`;
  }
  return `${mins} minute${mins !== 1 ? 's' : ''} ${secs} second${secs !== 1 ? 's' : ''}`;
}


// --- Noise Texture SVG ---

const NoiseTexture = () => (
  <svg className="graphite-noise" aria-hidden="true">
    <filter id="graphite-noise-filter">
      <feTurbulence
        type="fractalNoise"
        baseFrequency="0.8"
        numOctaves="4"
        stitchTiles="stitch"
      />
    </filter>
    <rect filter="url(#graphite-noise-filter)" />
  </svg>
);

// --- Component ---

export function GraphiteTimeline({
  scenes,
  visuals = {},
  narrationSegments = [],
  currentTime,
  duration,
  isPlaying,
  onPlayPause,
  onSeek,
  onSceneSelect,
  selectedSceneId,
  projectName = "UNTITLED",
  className = "",
  sfxPlan = null,
  onDeleteClip,
}: GraphiteTimelineProps) {
  // --- State ---
  const [zoom, setZoom] = useState(DEFAULT_ZOOM);
  const [isFocused, setIsFocused] = useState(false);

  // --- Refs ---
  const timelineRef = useRef<HTMLDivElement>(null);
  const liveRegionRef = useRef<HTMLDivElement>(null);

  // --- Build Tracks ---
  // Memoize visuals to prevent unnecessary rebuilds when object reference changes but content is same
  const visualsJson = useMemo(() => JSON.stringify(visuals), [visuals]);

  const tracks = useMemo(() => {
    let parsedVisuals: Record<string, string> = {};
    try {
      parsedVisuals = JSON.parse(visualsJson);
    } catch (e) {
      console.error("[GraphiteTimeline] Failed to parse visualsJson:", e);
    }
    const t = buildTracks(scenes, parsedVisuals, narrationSegments, sfxPlan);
    // Only log in development and limit frequency
    if (process.env.NODE_ENV === 'development') {
      console.log("[GraphiteTimeline] Tracks built:", t.length, "tracks,", t.find(tr => tr.id === "fx")?.clips.length || 0, "FX clips");
    }
    return t;
  }, [scenes, visualsJson, narrationSegments, sfxPlan]);

  // --- Flatten all clips for index-based navigation ---
  const allClips = useMemo(() => {
    const clips: Array<TimelineClip & { trackId: string }> = [];
    tracks.forEach(track => {
      track.clips.forEach(clip => {
        clips.push({ ...clip, trackId: track.id });
      });
    });
    // Sort by start time for logical navigation order
    return clips.sort((a, b) => a.startTime - b.startTime);
  }, [tracks]);

  // --- Scroll Management ---
  const {
    scrollLeft,
    trackLanesRef,
    rulerRef,
    handleScroll,
    getVisibleRange,
  } = useTimelineScroll({
    currentTime,
    duration,
    zoom,
    isPlaying,
  });

  // --- Selection Management ---
  const {
    selectedClipId,
    handleSelectClip,
    handleClearSelection,
    setSelectedClipId,
  } = useTimelineSelection({
    initialSelectedId: selectedSceneId,
    onSceneSelect,
  });

  // --- Get selected clip index ---
  const selectedClipIndex = useMemo(() => {
    if (!selectedClipId) return null;
    const index = allClips.findIndex(clip => clip.id === selectedClipId);
    return index >= 0 ? index : null;
  }, [selectedClipId, allClips]);

  // Sync external selectedSceneId with internal state
  useEffect(() => {
    if (selectedSceneId !== undefined) {
      // The selectedSceneId could be a scene ID or null
      // We need to check if it matches any clip ID
    }
  }, [selectedSceneId]);

  // --- Playhead Seek ---
  const {
    isAnimating,
    handleMouseDown: handleSeekMouseDown,
    handleClick: handleSeekClick,
  } = usePlayheadSeek({
    zoom,
    scrollLeft,
    duration,
    onSeek,
  });

  // --- Transport Handlers ---
  const handleSkipBack = useCallback(() => {
    onSeek(Math.max(0, currentTime - SKIP_INTERVAL));
  }, [currentTime, onSeek]);

  const handleSkipForward = useCallback(() => {
    onSeek(Math.min(duration, currentTime + SKIP_INTERVAL));
  }, [currentTime, duration, onSeek]);

  // --- Zoom Handler ---
  const handleZoomChange = useCallback((newZoom: number) => {
    setZoom(Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom)));
  }, []);

  // --- Keyboard Navigation Handlers ---
  const handleNextClip = useCallback(() => {
    if (allClips.length === 0) return;
    const nextIndex = selectedClipIndex === null ? 0 : Math.min(selectedClipIndex + 1, allClips.length - 1);
    const clip = allClips[nextIndex];
    if (clip) {
      setSelectedClipId(clip.id);
      // Also seek to the clip start
      onSeek(clip.startTime);
    }
  }, [allClips, selectedClipIndex, setSelectedClipId, onSeek]);

  const handlePrevClip = useCallback(() => {
    if (allClips.length === 0) return;
    const prevIndex = selectedClipIndex === null ? allClips.length - 1 : Math.max(selectedClipIndex - 1, 0);
    const clip = allClips[prevIndex];
    if (clip) {
      setSelectedClipId(clip.id);
      // Also seek to the clip start
      onSeek(clip.startTime);
    }
  }, [allClips, selectedClipIndex, setSelectedClipId, onSeek]);

  const handleDeleteSelectedClip = useCallback((index: number) => {
    const clip = allClips[index];
    if (clip && onDeleteClip) {
      onDeleteClip(clip.id);
      // Clear selection after delete
      setSelectedClipId(null);
    }
  }, [allClips, onDeleteClip, setSelectedClipId]);

  const handleJumpToStart = useCallback(() => {
    onSeek(0);
  }, [onSeek]);

  const handleJumpToEnd = useCallback(() => {
    onSeek(duration);
  }, [onSeek, duration]);

  // --- Integrate Keyboard Navigation ---
  useTimelineKeyboard({
    isActive: isFocused,
    duration,
    currentTime,
    isPlaying,
    selectedClipIndex,
    clipCount: allClips.length,
    onTimeChange: onSeek,
    onPlayPause,
    onSelectClip: (index) => {
      if (index === null) {
        setSelectedClipId(null);
      } else {
        const clip = allClips[index];
        if (clip) {
          setSelectedClipId(clip.id);
        }
      }
    },
    onDeleteClip: onDeleteClip ? handleDeleteSelectedClip : undefined,
    onNextClip: handleNextClip,
    onPrevClip: handlePrevClip,
    onJumpToStart: handleJumpToStart,
    onJumpToEnd: handleJumpToEnd,
  });

  // --- Live Region Updates for Screen Readers ---
  const lastAnnouncedTimeRef = useRef<number>(currentTime);

  useEffect(() => {
    // Only announce significant time changes (more than 0.5 seconds)
    // to avoid flooding screen readers during playback
    if (Math.abs(currentTime - lastAnnouncedTimeRef.current) >= 0.5 && !isPlaying) {
      lastAnnouncedTimeRef.current = currentTime;
      // The live region will be read by screen readers
    }
  }, [currentTime, isPlaying]);

  // --- Focus Handler ---
  const handleFocus = useCallback(() => {
    setIsFocused(true);
  }, []);

  const handleBlur = useCallback((e: React.FocusEvent) => {
    // Only blur if focus moved outside the timeline container
    if (!timelineRef.current?.contains(e.relatedTarget as Node)) {
      setIsFocused(false);
    }
  }, []);

  // --- Visible Range for Minimap ---
  const visibleRange = getVisibleRange();

  // --- Calculate Timeline Width ---
  const timelineWidth = Math.max(duration * zoom, 800);

  // --- Calculate Track Container Height ---
  const trackContainerHeight = tracks.length * 120; // --graphite-track-height

  // --- Class Names ---
  const containerClassNames = [
    "graphite-timeline",
    isFocused && "graphite-timeline--focused",
    className,
  ].filter(Boolean).join(" ");

  return (
    <div
      ref={timelineRef}
      className={containerClassNames}
      tabIndex={0}
      role="application"
      aria-label={`Timeline editor for ${projectName}. Use arrow keys to navigate time, Tab to select clips, Space to play/pause.`}
      aria-describedby="timeline-instructions"
      aria-activedescendant={selectedClipId || undefined}
      onFocus={handleFocus}
      onBlur={handleBlur}
    >
      {/* Screen reader instructions (visually hidden) */}
      <div id="timeline-instructions" className="sr-only">
        Press Space or K to play/pause. Use left/right arrows to move 1 second, Shift+arrows for 5 seconds, Ctrl+arrows for frame-by-frame.
        Press Home to jump to start, End to jump to end. Tab to navigate clips, Delete to remove selected clip, Escape to deselect.
        Number keys 0-9 jump to that percentage of the timeline.
      </div>

      {/* Live region for time announcements (screen readers) */}
      <div
        ref={liveRegionRef}
        role="status"
        aria-live="polite"
        aria-atomic="true"
        className="sr-only"
      >
        {!isPlaying && `Current time: ${formatTimeForScreenReader(currentTime)} of ${formatTimeForScreenReader(duration)}`}
        {isPlaying && 'Playing'}
      </div>

      {/* Selected clip announcement for screen readers */}
      {selectedClipId && (
        <div
          role="status"
          aria-live="assertive"
          aria-atomic="true"
          className="sr-only"
        >
          {(() => {
            const clip = allClips.find(c => c.id === selectedClipId);
            if (clip) {
              return `Selected clip: ${clip.name}, duration ${formatTimeForScreenReader(clip.duration)}`;
            }
            return '';
          })()}
        </div>
      )}

      <div className="graphite-timeline-workspace">
        {/* Noise Texture Overlay - Requirement 1.3 */}
        <NoiseTexture />

        {/* Transport Bar - Requirements 2.1-2.6 */}
        <TransportBar
          currentTime={currentTime}
          isPlaying={isPlaying}
          projectName={projectName}
          onPlayPause={onPlayPause}
          onSkipBack={handleSkipBack}
          onSkipForward={handleSkipForward}
        />

        {/* Timeline Area */}
        <div
          className="graphite-timeline-area"
          role="region"
          aria-label="Timeline tracks"
        >
          {/* Tracks Container - holds labels and lanes side by side */}
          <div className="graphite-tracks-container">
            {/* Track Labels (Left Sidebar) - Requirement 4.2, 11.3 */}
            <div className="graphite-track-labels" role="group" aria-label="Track labels">
              {/* Ruler spacer to align with ruler */}
              <div className="graphite-ruler-spacer" aria-hidden="true" />
              {tracks.map((track) => (
                <TrackLabel key={track.id} name={track.name} />
              ))}
            </div>

            {/* Timeline Content (Ruler + Track Lanes) */}
            <div className="graphite-timeline-content">
              {/* Time Ruler - Requirements 3.1-3.5 */}
              <TimeRuler
                ref={rulerRef}
                duration={duration}
                zoom={zoom}
                scrollLeft={scrollLeft}
              />

              {/* Track Lanes Container */}
              <div
                ref={trackLanesRef}
                className="graphite-track-lanes"
                onScroll={handleScroll}
                role="list"
                aria-label="Track lanes with clips"
              >
                <div
                  className="graphite-track-lanes-inner"
                  style={{ width: `${timelineWidth}px` }}
                >
                  {tracks.map((track) => (
                    <TrackLane
                      key={track.id}
                      track={track}
                      zoom={zoom}
                      scrollLeft={0} // Clips position relative to inner container
                      selectedClipId={selectedClipId}
                      onClipSelect={handleSelectClip}
                      onLaneClick={handleClearSelection}
                      onSeekClick={handleSeekClick}
                      onSeekMouseDown={handleSeekMouseDown}
                    />
                  ))}
                </div>

                {/* Playhead - Requirements 7.1-7.6 */}
                <Playhead
                  currentTime={currentTime}
                  zoom={zoom}
                  scrollLeft={scrollLeft}
                  height={trackContainerHeight}
                  duration={duration}
                  isAnimating={isAnimating}
                />
              </div>
            </div>
          </div>
        </div>

        {/* Footer Navigation - Requirements 8.1-9.4 */}
        <FooterNav
          zoom={zoom}
          minZoom={MIN_ZOOM}
          maxZoom={MAX_ZOOM}
          duration={duration}
          visibleStart={visibleRange.start}
          visibleEnd={visibleRange.end}
          onZoomChange={handleZoomChange}
          tracks={tracks}
        />
      </div>
    </div>
  );
}

export default GraphiteTimeline;

// Backward compatibility alias - can be used as drop-in replacement for VideoTimeline
export { GraphiteTimeline as VideoTimeline };
</file>

<file path="components/TimelineEditor/index.ts">
/**
 * TimelineEditor - Barrel Export
 * 
 * Groups all timeline-related components for the video editing interface.
 * Provides a clean public API while hiding internal implementation details.
 * 
 * The AudioTimelineEditor is the new modernized timeline component that replaces
 * GraphiteTimeline while maintaining backward compatibility.
 */

// New AudioTimelineEditor component (recommended)
export { AudioTimelineEditor } from "./AudioTimelineEditor";
export type { AudioTimelineEditorProps } from "./AudioTimelineEditor";

// Backward-compatible aliases - AudioTimelineEditor exported as GraphiteTimeline and VideoTimeline
export { AudioTimelineEditor as GraphiteTimeline } from "./AudioTimelineEditor";
export { AudioTimelineEditor as VideoTimeline } from "./AudioTimelineEditor";
export type { AudioTimelineEditorProps as GraphiteTimelineProps } from "./AudioTimelineEditor";

// Adapter functions for data conversion
export {
  scenesToVideoTrack,
  narrationToAudioTrack,
  sfxPlanToTracks,
  clipIdToSceneId,
  sceneIdToClipId,
  convertToTimelineData,
  TRACK_IDS,
  CLIP_PREFIXES,
} from "./timelineAdapter";

// Accessibility helpers
export {
  formatDurationForAnnouncement,
  announceToScreenReader,
} from "./AudioTimelineEditor";

// Editor sub-components (exported for advanced customization)
export {
  TrackSidebar,
  VideoPreview,
  TimelinePanel,
  TimelineControls,
  ImportMediaModal,
  WaveformClip,
  SubtitleClip,
  VideoClipComponent,
  ImageClipComponent,
} from "./editor";

// Legacy components (deprecated - use AudioTimelineEditor instead)
// These are kept for backward compatibility with existing code
export { TransportBar } from "./TransportBar";
export { TimeRuler } from "./TimeRuler";
export { TrackLabel } from "./TrackLabel";
export { TrackLane } from "./TrackLane";
export { Playhead, usePlayheadSeek } from "./Playhead";
export { FooterNav } from "./FooterNav";
export { GraphiteClip } from "./GraphiteClip";
export { AudioClip } from "./AudioClip";

// Legacy utilities
export { buildTracks } from "./graphite-timeline-utils";
export { useTimelineScroll } from "./useTimelineScroll";
</file>

<file path="components/TimelineEditor/Playhead.tsx">
/**
 * Playhead Component
 * 
 * Renders the current playback position indicator in the Graphite Timeline.
 * Features:
 * - Red vertical line with glow shadow
 * - Triangular handle at the top
 * - Position based on currentTime, zoom, and scrollLeft
 * - Smooth animation when clicking to seek
 * 
 * Requirements: 7.1, 7.2, 7.3, 7.4, 7.6
 */

import React, { useRef, useCallback, useState, useEffect } from "react";
import "./graphite-timeline.css";

// --- Types ---

export interface PlayheadProps {
  /** Current playback time in seconds */
  currentTime: number;
  /** Zoom level (pixels per second) */
  zoom: number;
  /** Horizontal scroll offset in pixels */
  scrollLeft: number;
  /** Height of the playhead line (typically track container height) */
  height: number;
  /** Total duration of the timeline in seconds */
  duration: number;
  /** Whether to animate position changes (for click-to-seek) */
  isAnimating?: boolean;
}

// --- Component ---

export function Playhead({
  currentTime,
  zoom,
  scrollLeft,
  height,
  duration,
  isAnimating = false,
}: PlayheadProps) {
  // Calculate the left position based on currentTime and zoom
  // The playhead position is relative to the track lanes container
  const leftPosition = currentTime * zoom - scrollLeft;

  // Build class names for animation state
  const classNames = [
    "graphite-playhead",
    isAnimating ? "animating" : "",
  ].filter(Boolean).join(" ");

  return (
    <div
      className={classNames}
      style={{
        left: `${leftPosition}px`,
        height: `${height}px`,
      }}
      role="slider"
      aria-label="Playhead position"
      aria-valuenow={currentTime}
      aria-valuemin={0}
      aria-valuemax={duration}
    >
      {/* Triangular handle at the top - Requirement 7.1 */}
      <div className="graphite-playhead-handle" aria-hidden="true" />
    </div>
  );
}

// --- Seek Handler Hook ---

export interface UsePlayheadSeekOptions {
  /** Zoom level (pixels per second) */
  zoom: number;
  /** Horizontal scroll offset in pixels */
  scrollLeft: number;
  /** Total duration of the timeline in seconds */
  duration: number;
  /** Callback when user seeks to a new position */
  onSeek: (time: number) => void;
}

export interface UsePlayheadSeekResult {
  /** Whether the user is currently dragging */
  isDragging: boolean;
  /** Whether the playhead should animate (after click, not during drag) */
  isAnimating: boolean;
  /** Handler for mousedown events on the track lanes */
  handleMouseDown: (e: React.MouseEvent) => void;
  /** Handler for click events on the track lanes (click-to-seek) */
  handleClick: (e: React.MouseEvent) => void;
}

/**
 * Custom hook for handling playhead seek interactions.
 * Supports both click-to-seek and drag-to-scrub functionality.
 * 
 * Requirements: 7.3, 7.4, 7.6
 */
export function usePlayheadSeek({
  zoom,
  scrollLeft,
  duration,
  onSeek,
}: UsePlayheadSeekOptions): UsePlayheadSeekResult {
  const [isDragging, setIsDragging] = useState(false);
  const [isAnimating, setIsAnimating] = useState(false);
  const containerRef = useRef<HTMLElement | null>(null);

  /**
   * Calculates time from a mouse position relative to the track lanes.
   * Clamps the result to [0, duration] range.
   * Requirement 7.3: Clamp to valid range
   */
  const calculateTimeFromPosition = useCallback(
    (clientX: number, container: HTMLElement): number => {
      const rect = container.getBoundingClientRect();
      const x = clientX - rect.left + scrollLeft;
      const time = x / zoom;
      // Clamp to valid range [0, duration]
      return Math.max(0, Math.min(duration, time));
    },
    [zoom, scrollLeft, duration]
  );

  /**
   * Handle click-to-seek with animation.
   * Requirement 7.3: Click to jump playhead
   * Requirement 7.6: Animate smooth transitions on click
   */
  const handleClick = useCallback(
    (e: React.MouseEvent) => {
      // Don't handle if clicking on a clip
      if ((e.target as HTMLElement).closest(".graphite-clip")) {
        return;
      }

      const container = e.currentTarget as HTMLElement;
      const time = calculateTimeFromPosition(e.clientX, container);
      
      // Enable animation for click-to-seek
      setIsAnimating(true);
      onSeek(time);
      
      // Disable animation after transition completes
      setTimeout(() => setIsAnimating(false), 200);
    },
    [calculateTimeFromPosition, onSeek]
  );

  /**
   * Handle mousedown for drag-to-scrub.
   * Requirement 7.4: Drag to scrub
   */
  const handleMouseDown = useCallback(
    (e: React.MouseEvent) => {
      // Don't handle if clicking on a clip
      if ((e.target as HTMLElement).closest(".graphite-clip")) {
        return;
      }

      // Only handle left mouse button
      if (e.button !== 0) return;

      const container = e.currentTarget as HTMLElement;
      containerRef.current = container;
      setIsDragging(true);
      setIsAnimating(false); // No animation during drag

      // Initial seek on mousedown
      const time = calculateTimeFromPosition(e.clientX, container);
      onSeek(time);
    },
    [calculateTimeFromPosition, onSeek]
  );

  // Handle mousemove and mouseup for drag-to-scrub
  useEffect(() => {
    if (!isDragging) return;

    const handleMouseMove = (e: MouseEvent) => {
      if (!containerRef.current) return;
      const time = calculateTimeFromPosition(e.clientX, containerRef.current);
      onSeek(time);
    };

    const handleMouseUp = () => {
      setIsDragging(false);
      containerRef.current = null;
    };

    // Add listeners to document for drag outside container
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);

    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, [isDragging, calculateTimeFromPosition, onSeek]);

  return {
    isDragging,
    isAnimating,
    handleMouseDown,
    handleClick,
  };
}

export default Playhead;
</file>

<file path="components/TimelineEditor/timelineAdapter.ts">
/**
 * Timeline Adapter Functions
 *
 * Converts between the existing data model (Scene, NarrationSegment, VideoSFXPlan)
 * and the new AudioTimelineEditor's internal data model (Track, AudioClip, VideoClip).
 *
 * This adapter layer enables backward compatibility, allowing the new timeline component
 * to be used as a drop-in replacement without requiring changes to the rest of the application.
 *
 * @see .kiro/specs/timeline-editor-replacement/design.md for architecture details
 * @requirements 9.1, 9.2, 9.3, 9.4, 9.5
 */

import type { Scene, NarrationSegment, VideoSFXPlan } from "@/types";
import type { Track, AudioClip, VideoClip } from "@/types/audio-editor";

/** Track ID constants for consistent referencing */
export const TRACK_IDS = {
  VIDEO: "video-track",
  NARRATOR: "narrator-track",
  SFX: "sfx-track",
  AMBIENT: "ambient-track",
  MUSIC: "music-track",
} as const;

/** Clip ID prefixes for different track types */
export const CLIP_PREFIXES = {
  VIDEO: "video-",
  AUDIO: "audio-",
  SFX: "sfx-",
  AMBIENT: "ambient-",
  MUSIC: "music-",
} as const;

/**
 * Generates placeholder waveform data for audio clips.
 * In a real implementation, this would be extracted from the actual audio.
 *
 * @param duration - Duration in seconds
 * @param samplesPerSecond - Number of waveform samples per second
 * @returns Array of normalized waveform values (0-1)
 */
function generatePlaceholderWaveform(
  duration: number,
  samplesPerSecond: number = 10
): number[] {
  const sampleCount = Math.max(1, Math.floor(duration * samplesPerSecond));
  const waveform: number[] = [];

  for (let i = 0; i < sampleCount; i++) {
    // Generate a pseudo-random but deterministic waveform pattern
    const t = i / sampleCount;
    const value = 0.3 + 0.4 * Math.sin(t * Math.PI * 4) + 0.3 * Math.random();
    waveform.push(Math.min(1, Math.max(0, value)));
  }

  return waveform;
}

/**
 * Converts Scene[] to a video Track with VideoClip[].
 *
 * Conversion logic:
 * - Scene.id ‚Üí VideoClip.id (direct mapping)
 * - Scene.name ‚Üí VideoClip.name (direct mapping)
 * - Scene.duration ‚Üí VideoClip.duration (direct mapping)
 * - visuals[scene.id] ‚Üí VideoClip.thumbnailUrl (lookup from visuals map)
 * - Cumulative scene durations ‚Üí VideoClip.startTime (sum of previous scene durations)
 *
 * @param scenes - Array of Scene objects from ContentPlan
 * @param visuals - Map of scene IDs to thumbnail URLs
 * @returns Object containing the video track and array of video clips
 *
 * @requirements 9.1, 9.5
 * @validates Requirements 1.1, 1.2, 1.3, 1.4
 */
export function scenesToVideoTrack(
  scenes: Scene[],
  visuals: Record<string, string>
): { track: Track; clips: VideoClip[] } {
  const track: Track = {
    id: TRACK_IDS.VIDEO,
    type: "video",
    name: "Video",
    text: "",
    isGenerated: scenes.length > 0,
  };

  let cumulativeStartTime = 0;
  const clips: VideoClip[] = scenes.map((scene) => {
    const clip: VideoClip = {
      id: scene.id,
      trackId: TRACK_IDS.VIDEO,
      startTime: cumulativeStartTime,
      duration: scene.duration,
      thumbnailUrl: visuals[scene.id] || "",
      name: scene.name,
    };

    cumulativeStartTime += scene.duration;
    return clip;
  });

  return { track, clips };
}

/**
 * Converts NarrationSegment[] to a narrator Track with AudioClip[].
 *
 * Conversion logic:
 * - NarrationSegment.sceneId ‚Üí AudioClip.id (prefixed with "audio-")
 * - NarrationSegment.audioDuration ‚Üí AudioClip.duration (direct mapping)
 * - Cumulative narration durations ‚Üí AudioClip.startTime (sum of previous segment durations)
 *
 * @param segments - Array of NarrationSegment objects
 * @param scenes - Array of Scene objects (used for ordering and fallback durations)
 * @returns Object containing the narrator track and array of audio clips
 *
 * @requirements 9.2, 9.5
 * @validates Requirements 1.5
 */
export function narrationToAudioTrack(
  segments: NarrationSegment[],
  scenes: Scene[]
): { track: Track; clips: AudioClip[] } {
  const track: Track = {
    id: TRACK_IDS.NARRATOR,
    type: "narrator",
    name: "Narrator",
    text: segments.map((s) => s.transcript).join(" "),
    isGenerated: segments.length > 0,
  };

  // Order segments by scene order
  const orderedSegments = [...segments].sort((a, b) => {
    const aIndex = scenes.findIndex((s) => s.id === a.sceneId);
    const bIndex = scenes.findIndex((s) => s.id === b.sceneId);
    return aIndex - bIndex;
  });

  let cumulativeStartTime = 0;
  const clips: AudioClip[] = orderedSegments.map((segment) => {
    const clip: AudioClip = {
      id: `${CLIP_PREFIXES.AUDIO}${segment.sceneId}`,
      trackId: TRACK_IDS.NARRATOR,
      startTime: cumulativeStartTime,
      duration: segment.audioDuration,
      waveformData: generatePlaceholderWaveform(segment.audioDuration),
    };

    cumulativeStartTime += segment.audioDuration;
    return clip;
  });

  return { track, clips };
}

/**
 * Converts VideoSFXPlan to SFX Track(s) with AudioClip[].
 *
 * Creates clips for:
 * - Ambient tracks from each scene's SFX plan
 * - Background music if present
 * - Generated music if present
 *
 * @param sfxPlan - VideoSFXPlan object or null
 * @param scenes - Array of Scene objects (used for timing reference)
 * @param narrationSegments - Array of NarrationSegment objects (used for timing alignment)
 * @returns Object containing the SFX tracks and array of audio clips
 *
 * @requirements 9.3, 9.5
 * @validates Requirements 1.6
 */
export function sfxPlanToTracks(
  sfxPlan: VideoSFXPlan | null,
  scenes: Scene[],
  _narrationSegments: NarrationSegment[]
): { tracks: Track[]; clips: AudioClip[] } {
  const tracks: Track[] = [];
  const clips: AudioClip[] = [];

  // Create SFX track
  const sfxTrack: Track = {
    id: TRACK_IDS.SFX,
    type: "sfx",
    name: "Sound Effects",
    text: "",
    isGenerated: sfxPlan !== null && sfxPlan.scenes.length > 0,
  };
  tracks.push(sfxTrack);

  if (!sfxPlan) {
    return { tracks, clips };
  }

  // Calculate scene start times for positioning SFX clips
  const sceneStartTimes = new Map<string, number>();
  let cumulativeTime = 0;
  for (const scene of scenes) {
    sceneStartTimes.set(scene.id, cumulativeTime);
    cumulativeTime += scene.duration;
  }

  // Process ambient tracks from each scene
  for (const sceneSfx of sfxPlan.scenes) {
    const startTime = sceneStartTimes.get(sceneSfx.sceneId) ?? 0;
    const scene = scenes.find((s) => s.id === sceneSfx.sceneId);
    const sceneDuration = scene?.duration ?? 0;

    if (sceneSfx.ambientTrack) {
      const ambientClip: AudioClip = {
        id: `${CLIP_PREFIXES.AMBIENT}${sceneSfx.sceneId}`,
        trackId: TRACK_IDS.SFX,
        startTime,
        duration:
          sceneSfx.ambientTrack.duration > 0
            ? sceneSfx.ambientTrack.duration
            : sceneDuration,
        waveformData: generatePlaceholderWaveform(sceneDuration),
      };
      clips.push(ambientClip);
    }
  }

  // Add background music track if present
  if (sfxPlan.backgroundMusic || sfxPlan.generatedMusic) {
    const musicTrack: Track = {
      id: TRACK_IDS.MUSIC,
      type: "sfx",
      name: "Music",
      text: sfxPlan.generatedMusic?.title || sfxPlan.backgroundMusic?.name || "",
      isGenerated: true,
    };
    tracks.push(musicTrack);

    // Calculate total duration
    const totalDuration = scenes.reduce((sum, s) => sum + s.duration, 0);

    if (sfxPlan.generatedMusic) {
      const musicClip: AudioClip = {
        id: `${CLIP_PREFIXES.MUSIC}generated`,
        trackId: TRACK_IDS.MUSIC,
        startTime: 0,
        duration: sfxPlan.generatedMusic.duration || totalDuration,
        waveformData: generatePlaceholderWaveform(
          sfxPlan.generatedMusic.duration || totalDuration
        ),
      };
      clips.push(musicClip);
    } else if (sfxPlan.backgroundMusic) {
      const musicClip: AudioClip = {
        id: `${CLIP_PREFIXES.MUSIC}background`,
        trackId: TRACK_IDS.MUSIC,
        startTime: 0,
        duration:
          sfxPlan.backgroundMusic.duration > 0
            ? sfxPlan.backgroundMusic.duration
            : totalDuration,
        waveformData: generatePlaceholderWaveform(totalDuration),
      };
      clips.push(musicClip);
    }
  }

  return { tracks, clips };
}

/**
 * Extracts the scene ID from a clip ID.
 *
 * Handles various clip ID patterns:
 * - "audio-{sceneId}" ‚Üí sceneId
 * - "sfx-{sceneId}" ‚Üí sceneId
 * - "ambient-{sceneId}" ‚Üí sceneId
 * - "video-{sceneId}" ‚Üí sceneId
 * - "{sceneId}" (no prefix) ‚Üí sceneId
 *
 * @param clipId - The clip ID to extract scene ID from
 * @returns The extracted scene ID
 *
 * @requirements 9.4
 * @validates Requirements 3.2, 3.5, 10.4
 */
export function clipIdToSceneId(clipId: string): string {
  // Check for known prefixes and remove them
  for (const prefix of Object.values(CLIP_PREFIXES)) {
    if (clipId.startsWith(prefix)) {
      return clipId.slice(prefix.length);
    }
  }

  // No prefix found, return as-is (video clips use scene ID directly)
  return clipId;
}

/**
 * Converts a scene ID to a clip ID for a specific track type.
 *
 * @param sceneId - The scene ID to convert
 * @param trackType - The type of track ("video", "narrator", "sfx", "ambient", "music")
 * @returns The clip ID for the specified track type
 *
 * @requirements 9.4
 * @validates Requirements 3.2, 3.5, 10.4
 */
export function sceneIdToClipId(
  sceneId: string,
  trackType: "video" | "narrator" | "sfx" | "ambient" | "music"
): string {
  switch (trackType) {
    case "video":
      // Video clips use scene ID directly (no prefix)
      return sceneId;
    case "narrator":
      return `${CLIP_PREFIXES.AUDIO}${sceneId}`;
    case "sfx":
      return `${CLIP_PREFIXES.SFX}${sceneId}`;
    case "ambient":
      return `${CLIP_PREFIXES.AMBIENT}${sceneId}`;
    case "music":
      return `${CLIP_PREFIXES.MUSIC}${sceneId}`;
    default:
      return sceneId;
  }
}

/**
 * Converts all data sources to the timeline editor's internal format.
 * This is a convenience function that combines all adapter functions.
 *
 * @param scenes - Array of Scene objects from ContentPlan
 * @param visuals - Map of scene IDs to thumbnail URLs
 * @param narrationSegments - Array of NarrationSegment objects
 * @param sfxPlan - VideoSFXPlan object or null
 * @returns Object containing all tracks and clips
 */
export function convertToTimelineData(
  scenes: Scene[],
  visuals: Record<string, string>,
  narrationSegments: NarrationSegment[],
  sfxPlan: VideoSFXPlan | null
): {
  tracks: Track[];
  videoClips: VideoClip[];
  audioClips: AudioClip[];
} {
  const { track: videoTrack, clips: videoClips } = scenesToVideoTrack(
    scenes,
    visuals
  );
  const { track: narratorTrack, clips: narratorClips } = narrationToAudioTrack(
    narrationSegments,
    scenes
  );
  const { tracks: sfxTracks, clips: sfxClips } = sfxPlanToTracks(
    sfxPlan,
    scenes,
    narrationSegments
  );

  return {
    tracks: [videoTrack, narratorTrack, ...sfxTracks],
    videoClips,
    audioClips: [...narratorClips, ...sfxClips],
  };
}
</file>

<file path="components/TimelineEditor/TimeRuler.tsx">
/**
 * TimeRuler Component
 * 
 * Renders the time scale ruler at the top of the Graphite Timeline.
 * Features:
 * - Major and minor tick marks based on zoom level (Requirements 3.1, 3.2)
 * - Timecode labels at major ticks (Requirement 3.3)
 * - Zoom-responsive tick intervals (Requirement 3.4)
 * - Horizontal scroll synchronization with track lanes (Requirements 3.5, 11.2)
 * 
 * Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 11.2
 */

import React, { forwardRef, useMemo } from "react";
import { getTickInterval } from "./graphite-timeline-utils";
import "./graphite-timeline.css";

// --- Types ---

export interface TimeRulerProps {
  /** Total duration in seconds */
  duration: number;
  /** Current zoom level (pixels per second) */
  zoom: number;
  /** Horizontal scroll offset in pixels (for positioning) - used for sync tracking */
  scrollLeft?: number;
  /** Frames per second for timecode display (default: 24) */
  fps?: number;
  /** Optional additional CSS class */
  className?: string;
}

// --- Helper Functions ---

/**
 * Formats time for ruler labels (shorter format than full timecode).
 * Shows MM:SS for times under an hour, HH:MM:SS for longer.
 * 
 * @param seconds - Time value in seconds
 * @returns Formatted time string
 */
export function formatRulerLabel(seconds: number): string {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  
  if (hrs > 0) {
    return `${hrs}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  }
  return `${mins}:${secs.toString().padStart(2, "0")}`;
}

/**
 * Generates tick positions for the ruler based on duration and zoom level.
 * Uses getTickInterval to determine appropriate spacing based on zoom.
 * 
 * @param duration - Total duration in seconds
 * @param zoom - Current zoom level (pixels per second)
 * @returns Object containing arrays of major and minor tick positions
 */
export function generateTicks(
  duration: number,
  zoom: number
): { majorTicks: number[]; minorTicks: number[] } {
  const { major, minor } = getTickInterval(zoom);
  
  const majorTicks: number[] = [];
  const minorTicks: number[] = [];
  
  // Generate major ticks at configurable intervals (Requirement 3.1)
  for (let t = 0; t <= duration; t += major) {
    // Round to avoid floating point precision issues
    majorTicks.push(Math.round(t * 1000) / 1000);
  }
  
  // Generate minor ticks between major ticks for finer granularity (Requirement 3.2)
  for (let t = 0; t <= duration; t += minor) {
    const roundedT = Math.round(t * 1000) / 1000;
    // Check if this is not a major tick position (with small epsilon for floating point)
    const isMajorTick = majorTicks.some(mt => Math.abs(mt - roundedT) < 0.001);
    if (!isMajorTick) {
      minorTicks.push(roundedT);
    }
  }
  
  return { majorTicks, minorTicks };
}

// --- Component ---

/**
 * TimeRuler component with forwardRef for scroll synchronization.
 * 
 * The ref is used by useTimelineScroll to sync ruler scroll with track lanes.
 * When the track lanes scroll, the ruler's scrollLeft is updated to match,
 * ensuring the time scale stays aligned with the clips below.
 * 
 * Scroll synchronization (Requirements 3.5, 11.2):
 * - The ruler container has overflow-x: auto (hidden scrollbar via CSS)
 * - The inner container width matches the total timeline width
 * - The useTimelineScroll hook syncs scrollLeft between ruler and track lanes
 */
export const TimeRuler = forwardRef<HTMLDivElement, TimeRulerProps>(
  function TimeRuler(
    {
      duration,
      zoom,
      scrollLeft = 0,
      fps = 24,
      className = "",
    },
    ref
  ) {
    // Calculate total width based on duration and zoom
    const totalWidth = Math.max(duration * zoom, 800);
    
    // Generate tick positions - memoized for performance
    const { majorTicks, minorTicks } = useMemo(
      () => generateTicks(duration, zoom),
      [duration, zoom]
    );
    
    const classNames = [
      "graphite-ruler",
      className,
    ].filter(Boolean).join(" ");

    return (
      <div
        ref={ref}
        className={classNames}
        role="presentation"
        aria-label="Time ruler"
        style={{ minHeight: '35px' }}
      >
        {/* Inner container with full width for scrolling */}
        <div
          className="graphite-ruler-inner"
          style={{
            width: `${totalWidth}px`,
            minWidth: "100%",
            height: "100%",
            position: "relative",
          }}
        >
          {/* Minor ticks - smaller marks between major ticks (Requirement 3.2) */}
          {minorTicks.map((t) => (
            <div
              key={`minor-${t}`}
              className="graphite-ruler-mark"
              style={{ left: `${t * zoom}px` }}
              data-time={t}
            />
          ))}
          
          {/* Major ticks with timecode labels (Requirements 3.1, 3.3) */}
          {majorTicks.map((t) => (
            <React.Fragment key={`major-${t}`}>
              <div
                className="graphite-ruler-mark major"
                style={{ left: `${t * zoom}px` }}
                data-time={t}
              />
              <span
                className="graphite-ruler-label"
                style={{ left: `${t * zoom + 4}px` }}
              >
                {formatRulerLabel(t)}
              </span>
            </React.Fragment>
          ))}
        </div>
      </div>
    );
  }
);

export default TimeRuler;
</file>

<file path="components/TimelineEditor/TrackLabel.tsx">
/**
 * TrackLabel Component
 * 
 * Renders a track label in the left sidebar of the Graphite Timeline.
 * Displays the track name with uppercase styling and graphite background.
 * 
 * Requirements: 4.2
 */

import "./graphite-timeline.css";

// --- Types ---

export interface TrackLabelProps {
  /** Track name to display */
  name: string;
  /** Optional height override (default: uses CSS variable --graphite-track-height) */
  height?: number;
  /** Optional additional CSS class */
  className?: string;
}

// --- Component ---

export function TrackLabel({
  name,
  height,
  className = "",
}: TrackLabelProps) {
  const classNames = [
    "graphite-label-block",
    className,
  ].filter(Boolean).join(" ");

  return (
    <div
      className={classNames}
      style={height ? { height: `${height}px` } : undefined}
      role="rowheader"
      aria-label={`Track: ${name}`}
    >
      <span>{name}</span>
    </div>
  );
}

export default TrackLabel;
</file>

<file path="components/TimelineEditor/TrackLane.tsx">
/**
 * TrackLane Component
 * 
 * Renders a single track lane in the Graphite Timeline containing clips.
 * Supports different track types (video, audio, fx) with type-specific styling.
 * Handles clip selection via click events.
 * Supports click-to-seek and drag-to-scrub for playhead positioning.
 * 
 * Requirements: 4.5, 10.1, 7.3, 7.4
 */

import React from "react";
import { TimelineTrack, TimelineClip } from "./graphite-timeline-utils";
import { GraphiteClip } from "./GraphiteClip";
import { AudioClip } from "./AudioClip";
import "./graphite-timeline.css";

// --- Types ---

export interface TrackLaneProps {
  /** Track data containing clips and metadata */
  track: TimelineTrack;
  /** Current zoom level (pixels per second) */
  zoom: number;
  /** Horizontal scroll offset in pixels */
  scrollLeft: number;
  /** ID of the currently selected clip (null if none) */
  selectedClipId: string | null;
  /** Callback when a clip is clicked */
  onClipSelect: (clipId: string) => void;
  /** Callback when clicking on empty lane area (to deselect) */
  onLaneClick?: () => void;
  /** Callback for click-to-seek (Requirement 7.3) */
  onSeekClick?: (e: React.MouseEvent) => void;
  /** Callback for drag-to-scrub mousedown (Requirement 7.4) */
  onSeekMouseDown?: (e: React.MouseEvent) => void;
  /** Optional height override */
  height?: number;
  /** Optional additional CSS class */
  className?: string;
}

// --- Helper Functions ---

/**
 * Gets the CSS class modifier for track type-specific background colors.
 * Requirement 4.5: Visually distinguish track types using different background colors.
 */
function getTrackTypeClass(type: TimelineTrack["type"]): string {
  switch (type) {
    case "video":
      return "graphite-lane--video";
    case "audio":
      return "graphite-lane--audio";
    case "fx":
      return "graphite-lane--fx";
    case "music":
      return "graphite-lane--music";
    default:
      return "";
  }
}

/**
 * Renders the appropriate clip component based on track type.
 */
function renderClip(
  clip: TimelineClip,
  trackType: TimelineTrack["type"],
  zoom: number,
  isSelected: boolean,
  onSelect: () => void
) {
  if (trackType === "audio" || trackType === "fx" || trackType === "music") {
    return (
      <AudioClip
        key={clip.id}
        clip={clip}
        zoom={zoom}
        isSelected={isSelected}
        onClick={onSelect}
      />
    );
  }

  return (
    <GraphiteClip
      key={clip.id}
      clip={clip}
      zoom={zoom}
      isSelected={isSelected}
      onClick={onSelect}
    />
  );
}

// --- Component ---

export function TrackLane({
  track,
  zoom,
  scrollLeft,
  selectedClipId,
  onClipSelect,
  onLaneClick,
  onSeekClick,
  onSeekMouseDown,
  height,
  className = "",
}: TrackLaneProps) {
  const trackTypeClass = getTrackTypeClass(track.type);

  const classNames = [
    "graphite-lane",
    trackTypeClass,
    className,
  ].filter(Boolean).join(" ");

  // Handle click on lane area
  // Supports both deselection and click-to-seek (Requirement 7.3)
  const handleLaneClick = (e: React.MouseEvent) => {
    // Only trigger if clicking directly on the lane, not on a clip
    if ((e.target as HTMLElement).closest(".graphite-clip")) {
      return;
    }

    // Call deselect handler
    if (onLaneClick) {
      onLaneClick();
    }

    // Call seek handler for click-to-seek
    if (onSeekClick) {
      onSeekClick(e);
    }
  };

  // Handle mousedown for drag-to-scrub (Requirement 7.4)
  const handleMouseDown = (e: React.MouseEvent) => {
    // Only trigger if clicking directly on the lane, not on a clip
    if ((e.target as HTMLElement).closest(".graphite-clip")) {
      return;
    }

    if (onSeekMouseDown) {
      onSeekMouseDown(e);
    }
  };

  return (
    <div
      className={classNames}
      style={height ? { height: `${height}px` } : undefined}
      onClick={handleLaneClick}
      onMouseDown={handleMouseDown}
      role="row"
      aria-label={`${track.name} track lane`}
    >
      {track.clips.map((clip) =>
        renderClip(
          clip,
          track.type,
          zoom,
          clip.id === selectedClipId,
          () => onClipSelect(clip.id)
        )
      )}
    </div>
  );
}

export default TrackLane;
</file>

<file path="components/TimelineEditor/TransportBar.tsx">
/**
 * TransportBar Component
 * 
 * Header section of the Graphite Timeline containing:
 * - Playback controls (play/pause, skip back, skip forward)
 * - Timecode display with cyan glow styling
 * - Project name display
 * - Add button placeholder
 * 
 * Accessibility Features:
 * - Keyboard shortcut hints in tooltips
 * - ARIA labels for all interactive elements
 * - aria-pressed for toggle states
 * 
 * Requirements: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6 + Accessibility
 */

import React from "react";
import { formatTimecode } from "./graphite-timeline-utils";
import "./graphite-timeline.css";

// --- SVG Icons ---

const SkipBackIcon = () => (
  <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
    <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z" />
  </svg>
);

const PlayIcon = () => (
  <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
    <path d="M8 5v14l11-7z" />
  </svg>
);

const PauseIcon = () => (
  <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
  </svg>
);

const SkipForwardIcon = () => (
  <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
    <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" />
  </svg>
);

const AddIcon = () => (
  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" aria-hidden="true">
    <path d="M12 5v14M5 12h14" />
  </svg>
);

// --- Types ---

export interface TransportBarProps {
  /** Current playback time in seconds */
  currentTime: number;
  /** Whether playback is currently active */
  isPlaying: boolean;
  /** Project name to display in header */
  projectName?: string;
  /** Callback when play/pause button is clicked */
  onPlayPause: () => void;
  /** Callback when skip back button is clicked */
  onSkipBack: () => void;
  /** Callback when skip forward button is clicked */
  onSkipForward: () => void;
  /** Callback when add button is clicked (optional) */
  onAdd?: () => void;
  /** Frames per second for timecode display (default: 24) */
  fps?: number;
}

// --- Component ---

export function TransportBar({
  currentTime,
  isPlaying,
  projectName = "UNTITLED",
  onPlayPause,
  onSkipBack,
  onSkipForward,
  onAdd,
  fps = 24,
}: TransportBarProps) {
  return (
    <header className="graphite-transport-bar" role="toolbar" aria-label="Playback controls">
      {/* Playback Controls - Requirements 2.1, 2.4, 2.5 */}
      <div className="graphite-transport-btns" role="group" aria-label="Transport controls">
        <button
          className="graphite-btn"
          onClick={onSkipBack}
          aria-label="Skip backward 5 seconds (J or Left Arrow)"
          title="Skip backward 5 seconds (J or ‚Üê)"
          type="button"
        >
          <SkipBackIcon />
        </button>
        
        <button
          className="graphite-btn primary"
          onClick={onPlayPause}
          aria-label={isPlaying ? "Pause (Space or K)" : "Play (Space or K)"}
          aria-pressed={isPlaying}
          title={isPlaying ? "Pause (Space or K)" : "Play (Space or K)"}
          type="button"
        >
          {isPlaying ? <PauseIcon /> : <PlayIcon />}
        </button>
        
        <button
          className="graphite-btn"
          onClick={onSkipForward}
          aria-label="Skip forward 5 seconds (L or Right Arrow)"
          title="Skip forward 5 seconds (L or ‚Üí)"
          type="button"
        >
          <SkipForwardIcon />
        </button>
      </div>

      {/* Timecode Display - Requirement 2.2 */}
      <div 
        className="graphite-timecode-display"
        role="timer"
        aria-label={`Current time: ${formatTimecode(currentTime, fps)}`}
        aria-live="off"
      >
        {formatTimecode(currentTime, fps)}
      </div>

      {/* Project Info - Requirements 2.3, 2.6 */}
      <div className="graphite-project-info">
        <span className="graphite-project-name" aria-label={`Project name: ${projectName}`}>
          PROJECT: {projectName.toUpperCase()}
        </span>
        
        <button
          className="graphite-btn"
          onClick={onAdd}
          aria-label="Add new clip or media"
          title="Add new clip or media"
          type="button"
        >
          <AddIcon />
        </button>
      </div>
    </header>
  );
}

export default TransportBar;
</file>

<file path="components/TimelineEditor/useTimelineScroll.ts">
/**
 * useTimelineScroll Hook
 * 
 * Custom hook for managing horizontal scroll state in the Graphite Timeline.
 * Handles:
 * - Tracking scrollLeft state
 * - Syncing ruler and track lanes scroll positions
 * - Auto-scroll during playback to keep playhead visible
 * 
 * Requirements: 11.1, 11.2, 11.3, 11.4, 11.5
 */

import { useState, useCallback, useRef, useEffect } from "react";

// --- Types ---

export interface UseTimelineScrollOptions {
  /** Current playback time in seconds */
  currentTime: number;
  /** Total duration in seconds */
  duration: number;
  /** Current zoom level (pixels per second) */
  zoom: number;
  /** Whether playback is currently active */
  isPlaying: boolean;
  /** Width of the track labels sidebar in pixels */
  labelsWidth?: number;
  /** Margin from edge before auto-scroll triggers (in pixels) */
  autoScrollMargin?: number;
}

export interface UseTimelineScrollResult {
  /** Current horizontal scroll offset in pixels */
  scrollLeft: number;
  /** Ref to attach to the scrollable track lanes container */
  trackLanesRef: React.RefObject<HTMLDivElement | null>;
  /** Ref to attach to the ruler container (for sync) */
  rulerRef: React.RefObject<HTMLDivElement | null>;
  /** Handler for scroll events on track lanes */
  handleScroll: (e: React.UIEvent<HTMLDivElement>) => void;
  /** Programmatically set scroll position */
  setScrollLeft: (value: number) => void;
  /** Calculate visible time range based on current scroll and container width */
  getVisibleRange: () => { start: number; end: number };
  /** Scroll to make a specific time visible */
  scrollToTime: (time: number) => void;
}

// --- Constants ---

const DEFAULT_LABELS_WIDTH = 140;
const DEFAULT_AUTO_SCROLL_MARGIN = 100;

// --- Hook Implementation ---

/**
 * Custom hook for managing timeline horizontal scroll state.
 * 
 * Features:
 * - Tracks scrollLeft state for positioning playhead and clips
 * - Syncs ruler scroll with track lanes (Requirement 11.2)
 * - Auto-scrolls during playback to keep playhead visible (Requirement 11.4)
 * - Provides refs for attaching to scrollable containers
 * 
 * @param options - Configuration options
 * @returns Scroll state and handlers
 */
export function useTimelineScroll({
  currentTime,
  duration,
  zoom,
  isPlaying,
  labelsWidth = DEFAULT_LABELS_WIDTH,
  autoScrollMargin = DEFAULT_AUTO_SCROLL_MARGIN,
}: UseTimelineScrollOptions): UseTimelineScrollResult {
  // Scroll state
  const [scrollLeft, setScrollLeftState] = useState(0);
  
  // Refs for scrollable containers
  const trackLanesRef = useRef<HTMLDivElement>(null);
  const rulerRef = useRef<HTMLDivElement>(null);
  
  // Track if we're programmatically scrolling to avoid feedback loops
  const isProgrammaticScroll = useRef(false);

  /**
   * Handle scroll events from track lanes.
   * Syncs the ruler scroll position to match.
   * Requirement 11.2: Ruler scrolls in sync with track lanes
   */
  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    const newScrollLeft = e.currentTarget.scrollLeft;
    setScrollLeftState(newScrollLeft);
    
    // Sync ruler scroll position (Requirement 11.2)
    if (rulerRef.current && !isProgrammaticScroll.current) {
      rulerRef.current.scrollLeft = newScrollLeft;
    }
  }, []);

  /**
   * Programmatically set scroll position.
   * Updates both track lanes and ruler.
   */
  const setScrollLeft = useCallback((value: number) => {
    const clampedValue = Math.max(0, value);
    setScrollLeftState(clampedValue);
    
    isProgrammaticScroll.current = true;
    
    if (trackLanesRef.current) {
      trackLanesRef.current.scrollLeft = clampedValue;
    }
    if (rulerRef.current) {
      rulerRef.current.scrollLeft = clampedValue;
    }
    
    // Reset flag after a tick
    requestAnimationFrame(() => {
      isProgrammaticScroll.current = false;
    });
  }, []);

  /**
   * Calculate the visible time range based on current scroll and container width.
   * Used for the project overview minimap.
   */
  const getVisibleRange = useCallback((): { start: number; end: number } => {
    if (!trackLanesRef.current) {
      return { start: 0, end: duration };
    }
    
    const containerWidth = trackLanesRef.current.clientWidth;
    const visibleStart = scrollLeft / zoom;
    const visibleEnd = (scrollLeft + containerWidth) / zoom;
    
    return {
      start: Math.max(0, visibleStart),
      end: Math.min(duration, visibleEnd),
    };
  }, [scrollLeft, zoom, duration]);

  /**
   * Scroll to make a specific time visible.
   * Centers the time in the viewport if possible.
   */
  const scrollToTime = useCallback((time: number) => {
    if (!trackLanesRef.current) return;
    
    const containerWidth = trackLanesRef.current.clientWidth;
    const targetPosition = time * zoom;
    
    // Center the time in the viewport
    const newScrollLeft = Math.max(0, targetPosition - containerWidth / 2);
    setScrollLeft(newScrollLeft);
  }, [zoom, setScrollLeft]);

  /**
   * Auto-scroll during playback to keep playhead visible.
   * Requirement 11.4: Auto-scroll when playhead approaches edge
   */
  useEffect(() => {
    if (!isPlaying || !trackLanesRef.current) return;
    
    const containerWidth = trackLanesRef.current.clientWidth;
    const playheadPosition = currentTime * zoom;
    
    // Calculate visible bounds
    const visibleStart = scrollLeft;
    const visibleEnd = scrollLeft + containerWidth;
    
    // Check if playhead is approaching the right edge
    if (playheadPosition > visibleEnd - autoScrollMargin) {
      // Scroll to keep playhead visible with margin
      const newScrollLeft = playheadPosition - containerWidth + autoScrollMargin;
      setScrollLeft(Math.max(0, newScrollLeft));
    }
    // Check if playhead is before the visible area (e.g., after seeking)
    else if (playheadPosition < visibleStart + autoScrollMargin) {
      // Scroll to show playhead with margin from left
      const newScrollLeft = playheadPosition - autoScrollMargin;
      setScrollLeft(Math.max(0, newScrollLeft));
    }
  }, [currentTime, zoom, isPlaying, scrollLeft, autoScrollMargin, setScrollLeft]);

  return {
    scrollLeft,
    trackLanesRef,
    rulerRef,
    handleScroll,
    setScrollLeft,
    getVisibleRange,
    scrollToTime,
  };
}

export default useTimelineScroll;
</file>

<file path="components/TimelinePlayer.tsx">
import React, { useRef, useEffect, useState } from "react";
import {
  Play,
  Pause,
  RotateCcw,
  Activity,
  Circle,
  Waves,
  Sparkles,
} from "lucide-react";
import { SubtitleItem } from "@/types";
import { Button } from "@/components/ui/button";
import { cn, isRTL } from "@/lib/utils";
import { Card } from "@/components/ui/card";

interface TimelinePlayerProps {
  audioUrl: string;
  subtitles: SubtitleItem[];
  currentTime: number;
  duration: number;
  isPlaying: boolean;
  onPlayPause: () => void;
  onSeek: (time: number) => void;
  onTimeUpdate: (time: number) => void;
  onDurationChange: (duration: number) => void;
  onEnded: () => void;
  /** Content mode - "music" shows visualizer, "story" hides it */
  contentMode?: "music" | "story";
}

type VisualizerMode = "bars" | "circular" | "wave" | "particles";

class ParticleSystem {
  particles: {
    x: number;
    y: number;
    vx: number;
    vy: number;
    life: number;
    color: string;
    size: number;
  }[] = [];

  update(width: number, height: number, bassEnergy: number) {
    if (bassEnergy > 230) {
      const count = Math.floor(bassEnergy / 20);
      for (let i = 0; i < count; i++) {
        this.particles.push({
          x: width / 2,
          y: height / 2,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10,
          life: 1.0,
          color: `hsl(${Math.random() * 60 + 180}, 100%, 70%)`,
          size: Math.random() * 4 + 1,
        });
      }
    }

    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      if (!p) {
        this.particles.splice(i, 1);
        continue;
      }
      p.x += p.vx;
      p.y += p.vy;
      p.life -= 0.02;
      p.size *= 0.95;

      if (p.life <= 0 || p.x < 0 || p.x > width || p.y < 0 || p.y > height) {
        this.particles.splice(i, 1);
      }
    }
  }

  draw(ctx: CanvasRenderingContext2D) {
    ctx.globalCompositeOperation = "lighter";
    this.particles.forEach((p) => {
      if (!p) return;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.life;
      ctx.fill();
    });
    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 1.0;
  }
}

export const TimelinePlayer: React.FC<TimelinePlayerProps> = ({
  audioUrl,
  subtitles,
  currentTime,
  duration,
  isPlaying,
  onPlayPause,
  onSeek,
  onTimeUpdate,
  onDurationChange,
  onEnded,
  contentMode = "music",
}) => {
  const audioRef = useRef<HTMLAudioElement>(null);
  const progressBarRef = useRef<HTMLDivElement>(null);
  const waveformCanvasRef = useRef<HTMLCanvasElement>(null);
  const visualizerCanvasRef = useRef<HTMLCanvasElement>(null);

  const [waveformBuffer, setWaveformBuffer] = useState<AudioBuffer | null>(
    null,
  );
  const [visualizerMode, setVisualizerMode] = useState<VisualizerMode>("wave");

  const audioContextRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const sourceRef = useRef<MediaElementAudioSourceNode | null>(null);
  const animationFrameRef = useRef<number | null>(null);
  const particleSystemRef = useRef<ParticleSystem>(new ParticleSystem());

  // Only enable visualizer for music mode
  const showVisualizer = contentMode === "music";

  useEffect(() => {
    // Skip visualizer setup for story mode
    if (!showVisualizer) {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      return;
    }

    if (!isPlaying) {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      return;
    }

    // Defer AudioContext initialization to avoid blocking the click handler
    const timeoutId = setTimeout(() => {
      const initAudioContext = () => {
        if (!audioRef.current) return;

        if (!audioContextRef.current) {
          audioContextRef.current = new (
            window.AudioContext || (window as any).webkitAudioContext
          )();
        }

        const ctx = audioContextRef.current;

        if (!sourceRef.current) {
          try {
            const source = ctx.createMediaElementSource(audioRef.current);
            sourceRef.current = source;
            const analyser = ctx.createAnalyser();
            analyserRef.current = analyser;
            
            analyser.fftSize = visualizerMode === "wave" ? 2048 : 256;
            analyser.smoothingTimeConstant = 0.8;

            source.connect(analyser);
            analyser.connect(ctx.destination);
          } catch (e) {
            console.warn("AudioContext already connected");
          }
        }

        if (analyserRef.current) {
          analyserRef.current.fftSize =
            visualizerMode === "circular"
              ? 512
              : visualizerMode === "wave"
                ? 2048
                : 256;
        }

        if (ctx.state === "suspended") {
          ctx.resume();
        }

        startRenderLoop();
      };

      initAudioContext();
    }, 0);

    return () => {
      clearTimeout(timeoutId);
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [isPlaying, visualizerMode, showVisualizer]);

  const startRenderLoop = () => {
    const canvas = visualizerCanvasRef.current;
    const analyser = analyserRef.current;
    if (!canvas || !analyser) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);

    const width = rect.width;
    const height = rect.height;

    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    const render = () => {
      if (!analyser) return;
      analyser.getByteFrequencyData(dataArray);

      ctx.clearRect(0, 0, width, height);

      switch (visualizerMode) {
        case "circular":
          drawCircular(ctx, width, height, dataArray, bufferLength);
          break;
        case "wave":
          drawWave(ctx, width, height, dataArray, bufferLength);
          break;
        case "particles":
          drawParticles(ctx, width, height, dataArray, bufferLength);
          break;
        default:
          drawBars(ctx, width, height, dataArray, bufferLength);
      }

      animationFrameRef.current = requestAnimationFrame(render);
    };

    render();
  };

  const drawBars = (
    ctx: CanvasRenderingContext2D,
    w: number,
    h: number,
    data: Uint8Array,
    len: number,
  ) => {
    const barWidth = (w / len) * 2.5;
    let x = 0;

    const gradient = ctx.createLinearGradient(0, h, 0, 0);
    gradient.addColorStop(0, "rgba(34, 211, 238, 0.1)");
    gradient.addColorStop(0.5, "rgba(34, 211, 238, 0.8)");
    gradient.addColorStop(1, "rgba(167, 139, 250, 0.9)");

    ctx.fillStyle = gradient;

    for (let i = 0; i < len / 2; i++) {
      const val = data[i] ?? 0;
      const barHeight = (val / 255) * h;
      const centerX = w / 2;
      const offset = i * (barWidth + 1);

      ctx.fillRect(centerX + offset, h - barHeight, barWidth, barHeight);
      ctx.fillRect(
        centerX - offset - barWidth,
        h - barHeight,
        barWidth,
        barHeight,
      );

      x += barWidth + 1;
      if (x > w) break;
    }
  };

  const drawCircular = (
    ctx: CanvasRenderingContext2D,
    w: number,
    h: number,
    data: Uint8Array,
    len: number,
  ) => {
    const cx = w / 2;
    const cy = h / 2;
    const radius = Math.min(w, h) * 0.3;

    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.shadowBlur = 15;
    ctx.shadowColor = "#22d3ee";

    const angleStep = (Math.PI * 2) / len;

    ctx.strokeStyle = "rgba(34, 211, 238, 0.8)";
    ctx.beginPath();
    for (let i = 0; i < len; i += 2) {
      const value = data[i] ?? 0;
      const barHeight = (value / 255) * radius * 0.8;
      const angle = i * angleStep - Math.PI / 2;

      const xStart = cx + Math.cos(angle) * radius;
      const yStart = cy + Math.sin(angle) * radius;
      const xEnd = cx + Math.cos(angle) * (radius + barHeight);
      const yEnd = cy + Math.sin(angle) * (radius + barHeight);

      ctx.moveTo(xStart, yStart);
      ctx.lineTo(xEnd, yEnd);
    }
    ctx.stroke();

    ctx.shadowBlur = 5;
    ctx.shadowColor = "#a78bfa";
    ctx.beginPath();
    for (let i = 0; i < len; i += 4) {
      const value = data[len - i - 1] ?? 0;
      const barHeight = (value / 255) * radius * 0.5;

      const angle = i * angleStep - Math.PI / 2;

      const rOuter = radius * 0.6;
      const xStart = cx + Math.cos(angle) * (rOuter - barHeight);
      const yStart = cy + Math.sin(angle) * (rOuter - barHeight);
      const xEnd = cx + Math.cos(angle) * rOuter;
      const yEnd = cy + Math.sin(angle) * rOuter;

      ctx.moveTo(xStart, yStart);
      ctx.lineTo(xEnd, yEnd);
    }
    ctx.stroke();
    ctx.shadowBlur = 0;
  };

  const drawWave = (
    ctx: CanvasRenderingContext2D,
    w: number,
    h: number,
    data: Uint8Array,
    len: number,
  ) => {
    ctx.lineWidth = 3;
    const gradient = ctx.createLinearGradient(0, h, 0, h / 2);
    gradient.addColorStop(0, "rgba(34, 211, 238, 0.0)");
    gradient.addColorStop(0.5, "rgba(34, 211, 238, 0.2)");
    gradient.addColorStop(1, "rgba(167, 139, 250, 0.4)");

    const strokeGradient = ctx.createLinearGradient(0, 0, w, 0);
    strokeGradient.addColorStop(0, "#22d3ee");
    strokeGradient.addColorStop(0.5, "#a78bfa");
    strokeGradient.addColorStop(1, "#22d3ee");

    const sliceWidth = w / (len / 3);
    let x = 0;

    ctx.beginPath();
    ctx.moveTo(0, h);

    let lastX = 0;
    let lastY = h;

    const step = 2;
    for (let i = 0; i < len / 3; i += step) {
      const value = data[i] ?? 0;
      const percent = value / 255;
      const y = h - percent * h * 0.6 - 20;

      const nextX = i * sliceWidth * step;
      const xc = (lastX + (x + sliceWidth * step)) / 2;
      const yc = (lastY + y) / 2;

      ctx.quadraticCurveTo(lastX, lastY, xc, yc);

      lastX = x + sliceWidth * step;
      lastY = y;
      x += sliceWidth * step;
    }

    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fillStyle = gradient;
    ctx.fill();

    ctx.strokeStyle = strokeGradient;
    ctx.stroke();
  };

  const drawParticles = (
    ctx: CanvasRenderingContext2D,
    w: number,
    h: number,
    data: Uint8Array,
    _len: number,
  ) => {
    const bassEnergy = data.slice(0, 10).reduce((a, b) => a + b, 0) / 10;
    if (bassEnergy > 200) {
      ctx.fillStyle = `rgba(34, 211, 238, ${0.05 + (bassEnergy / 255) * 0.05})`;
      ctx.fillRect(0, 0, w, h);
    }
    const radius = 50 + (bassEnergy / 255) * 30;
    ctx.beginPath();
    ctx.arc(w / 2, h / 2, radius, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(167, 139, 250, 0.2)";
    ctx.fill();
    particleSystemRef.current.update(w, h, bassEnergy);
    particleSystemRef.current.draw(ctx);
  };

  useEffect(() => {
    if (audioRef.current) {
      if (isPlaying) {
        audioRef.current.play().catch((e) => console.error("Play error:", e));
      } else {
        audioRef.current.pause();
      }
    }
  }, [isPlaying]);

  // Sync audio element to currentTime prop when it changes externally (e.g., scene selection)
  // Using a smaller threshold (0.1s) to ensure accurate seeking when clicking thumbnails
  useEffect(() => {
    if (
      audioRef.current &&
      Math.abs(audioRef.current.currentTime - currentTime) > 0.1
    ) {
      audioRef.current.currentTime = currentTime;
    }
  }, [currentTime]);

  useEffect(() => {
    const loadAudioData = async () => {
      try {
        const response = await fetch(audioUrl);
        const arrayBuffer = await response.arrayBuffer();
        const audioContext = new (
          window.AudioContext || (window as any).webkitAudioContext
        )();
        const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer);
        setWaveformBuffer(decodedBuffer);
      } catch (error) {
        console.error("Failed to load audio waveform", error);
      }
    };
    loadAudioData();
  }, [audioUrl]);

  useEffect(() => {
    const canvas = waveformCanvasRef.current;
    if (!canvas || !waveformBuffer) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const parent = canvas.parentElement;
    if (parent) {
      canvas.width = parent.clientWidth;
      canvas.height = parent.clientHeight;
    }
    const width = canvas.width;
    const height = canvas.height;
    const data = waveformBuffer.getChannelData(0);
    const step = Math.ceil(data.length / width);
    const amp = height / 2;
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = "#334155";
    for (let i = 0; i < width; i++) {
      let min = 1.0;
      let max = -1.0;
      for (let j = 0; j < step; j++) {
        const datum = data[i * step + j] ?? 0;
        if (datum < min) min = datum;
        if (datum > max) max = datum;
      }
      const barHeight = (max - min) * amp;
      const y = (1 + min) * amp;
      ctx.fillRect(i, y, 1, Math.max(1, barHeight));
    }
  }, [waveformBuffer]);

  const handleSeek = (
    e: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>,
  ) => {
    if (progressBarRef.current && duration > 0) {
      const rect = progressBarRef.current.getBoundingClientRect();
      const clientX = "touches" in e ? (e.touches[0]?.clientX ?? 0) : e.clientX;
      const x = clientX - rect.left;
      const percentage = Math.min(Math.max(x / rect.width, 0), 1);
      const newTime = percentage * duration;
      onSeek(newTime);
    }
  };

  const formatTime = (time: number) => {
    const mins = Math.floor(time / 60);
    const secs = Math.floor(time % 60);
    const ms = Math.floor((time % 1) * 100);
    return `${mins}:${secs.toString().padStart(2, "0")}.${ms.toString().padStart(2, "0")}`;
  };

  const activeSubtitle = subtitles.find(
    (s) => currentTime >= s.startTime && currentTime <= s.endTime,
  );

  let karaokeStyle: React.CSSProperties = {};
  const isActiveSubtitleRTL = activeSubtitle
    ? isRTL(activeSubtitle.text)
    : false;
  const isActiveTranslationRTL = activeSubtitle?.translation
    ? isRTL(activeSubtitle.translation)
    : false;

  if (activeSubtitle) {
    const totalDuration = activeSubtitle.endTime - activeSubtitle.startTime;
    const progress = Math.max(
      0,
      Math.min(1, (currentTime - activeSubtitle.startTime) / totalDuration),
    );
    const percent = Math.floor(progress * 100);
    // For RTL languages, reverse the gradient direction (270deg instead of 90deg)
    const gradientDirection = isActiveSubtitleRTL ? "270deg" : "90deg";
    karaokeStyle = {
      backgroundImage: `linear-gradient(${gradientDirection}, #22d3ee ${percent}%, #94a3b8 ${percent}%)`,
      WebkitBackgroundClip: "text",
      WebkitTextFillColor: "transparent",
      backgroundClip: "text",
      color: "transparent",
      direction: isActiveSubtitleRTL ? "rtl" : "ltr",
      unicodeBidi: "isolate",
    };
  }

  const visuals = [
    { id: "wave", icon: Waves, label: "Fluid" },
    { id: "circular", icon: Circle, label: "Radial" },
    { id: "particles", icon: Sparkles, label: "Particles" },
    { id: "bars", icon: Activity, label: "Bars" },
  ];

  return (
    <Card className="flex flex-col gap-4 bg-card border-border p-6 shadow-xl backdrop-blur-sm">
      <audio
        ref={audioRef}
        src={audioUrl}
        crossOrigin="anonymous"
        onTimeUpdate={(e) => onTimeUpdate(e.currentTarget.currentTime)}
        onLoadedMetadata={(e) => onDurationChange(e.currentTarget.duration)}
        onEnded={onEnded}
      />

      <div className="aspect-video w-full flex items-center justify-center text-center p-8 bg-black rounded-xl border border-border relative overflow-hidden group">
        {/* Only render visualizer canvas in music mode */}
        {showVisualizer && (
          <canvas
            ref={visualizerCanvasRef}
            className="absolute inset-0 w-full h-full opacity-60 z-0 pointer-events-none"
          />
        )}
        <div className="absolute inset-0 bg-linear-to-t from-background/90 via-transparent to-background/40 z-1 pointer-events-none"></div>

        {/* Only show visualizer controls in music mode */}
        {showVisualizer && (
          <div className="absolute top-4 right-4 z-20 flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
            {visuals.map((v) => (
              <Button
                key={v.id}
                variant="outline"
                size="icon"
                onClick={() => setVisualizerMode(v.id as VisualizerMode)}
                className={cn(
                  "h-8 w-8 hover:bg-muted",
                  visualizerMode === v.id
                    ? "bg-primary/20 border-primary text-primary"
                    : "bg-black/40 border-border text-muted-foreground",
                )}
                title={v.label}
              >
                <v.icon size={16} />
              </Button>
            ))}
          </div>
        )}

        {/* Subtitles - positioned at bottom */}
        <div className="absolute bottom-6 left-4 right-4 z-10 flex flex-col items-center">
          {activeSubtitle ? (
            <div className="animate-in fade-in slide-in-from-bottom-2 duration-200 max-w-[90%]">
              {/* Slim background bar that fits the text */}
              <div
                className="inline-block px-4 py-2 rounded-lg"
                style={{
                  background: "rgba(0, 0, 0, 0.75)",
                  backdropFilter: "blur(4px)",
                }}
              >
                <p
                  className="text-lg md:text-xl lg:text-2xl font-semibold leading-snug"
                  style={{
                    direction: isActiveSubtitleRTL ? "rtl" : "ltr",
                    textAlign: "center",
                    color: "#ffffff",
                    textShadow: "1px 1px 2px rgba(0,0,0,0.8), -1px -1px 2px rgba(0,0,0,0.8)",
                  }}
                >
                  <span
                    style={karaokeStyle}
                    className="transition-all duration-75"
                  >
                    {activeSubtitle.text}
                  </span>
                </p>
              </div>
              {activeSubtitle.translation && (
                <div
                  className="inline-block px-3 py-1 rounded-md mt-1"
                  style={{
                    background: "rgba(0, 0, 0, 0.6)",
                  }}
                >
                  <p
                    className="text-sm md:text-base text-cyan-300 font-medium"
                    style={{
                      direction: isActiveTranslationRTL ? "rtl" : "ltr",
                      textAlign: "center",
                      unicodeBidi: "isolate",
                      textShadow: "1px 1px 2px rgba(0,0,0,0.8)",
                    }}
                  >
                    {activeSubtitle.translation}
                  </p>
                </div>
              )}
            </div>
          ) : (
            <div className="flex flex-col items-center gap-2 opacity-30">
              <div className="w-12 h-1 bg-muted-foreground rounded-full animate-pulse"></div>
              <div className="w-24 h-1 bg-muted-foreground rounded-full animate-pulse delay-75"></div>
            </div>
          )}
        </div>

        {/* Center content for music mode visualizer */}
        {showVisualizer && !activeSubtitle && (
          <div className="relative z-5 max-w-3xl flex flex-col gap-4">
            <div className="flex flex-col items-center gap-2 opacity-30">
              <div className="w-12 h-1 bg-muted-foreground rounded-full animate-pulse"></div>
              <div className="w-24 h-1 bg-muted-foreground rounded-full animate-pulse delay-75"></div>
            </div>
          </div>
        )}
      </div>

      <div className="flex flex-col gap-2 pt-2">
        <div
          ref={progressBarRef}
          className="relative h-16 bg-muted/20 rounded-lg cursor-pointer group overflow-hidden border border-border/50"
          onClick={handleSeek}
          onTouchStart={handleSeek}
          onTouchMove={handleSeek}
          style={{ touchAction: "none" }}
        >
          <canvas
            ref={waveformCanvasRef}
            className="absolute inset-0 w-full h-full opacity-60"
          />

          <div className="absolute inset-0 w-full h-full">
            {subtitles.map((sub) => {
              const left = (sub.startTime / duration) * 100;
              const width = ((sub.endTime - sub.startTime) / duration) * 100;
              const isActive =
                currentTime >= sub.startTime && currentTime <= sub.endTime;

              return (
                <div
                  key={sub.id}
                  className={`absolute bottom-0 h-3 rounded-t-sm transition-all duration-200 pointer-events-none border-x border-background/20
                    ${isActive
                      ? "bg-primary z-10 h-4 shadow-[0_0_15px_rgba(34,211,238,0.6)]"
                      : "bg-accent hover:bg-accent/80 h-3"
                    }
                  `}
                  style={{
                    left: `${left}%`,
                    width: `${Math.max(width, 0.2)}%`,
                  }}
                />
              );
            })}
          </div>

          <div
            className="absolute top-0 h-full bg-primary/20 pointer-events-none"
            style={{ width: `${(currentTime / duration) * 100}%` }}
          />

          <div
            className="absolute top-0 w-0.5 h-full bg-primary shadow-[0_0_10px_rgba(34,211,238,0.8)] z-20 pointer-events-none"
            style={{ left: `${(currentTime / duration) * 100}%` }}
          />
        </div>

        <div className="flex items-center justify-between gap-4">
          <span className="font-mono text-xs text-muted-foreground tabular-nums w-24">
            {formatTime(currentTime)}
          </span>

          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              onClick={() => onSeek(0)}
              className="h-9 w-9 text-muted-foreground hover:text-foreground"
              aria-label="Reset to beginning"
            >
              <RotateCcw size={16} />
            </Button>
            <Button
              variant="default"
              size="icon"
              onClick={onPlayPause}
              className="w-14 h-14 rounded-full bg-primary hover:bg-primary/90 text-primary-foreground flex items-center justify-center transition-all active:scale-95 shadow-lg shadow-primary/30 border border-primary/20 p-0"
              aria-label={isPlaying ? "Pause" : "Play"}
            >
              {isPlaying ? (
                <Pause size={24} fill="currentColor" />
              ) : (
                <Play size={24} fill="currentColor" className="ml-1" />
              )}
            </Button>
          </div>

          <span className="font-mono text-xs text-muted-foreground tabular-nums w-24 text-right">
            {formatTime(duration)}
          </span>
        </div>
      </div>
    </Card>
  );
};
</file>

<file path="components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        glass:
          "bg-white/5 backdrop-blur-md border border-white/10 hover:bg-white/10 hover:border-white/20 text-foreground",
        cinematic:
          "btn-cinematic font-editorial text-sm tracking-wide rounded-lg hover:shadow-[0_0_30px_var(--glow-spotlight)] hover:-translate-y-px",
        editorial:
          "font-editorial text-[var(--cinema-silver)] bg-transparent border border-transparent hover:bg-white/5 hover:border-white/10 transition-all",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      data-variant={variant}
      data-size={size}
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "glass-panel text-card-foreground flex flex-col gap-6 rounded-xl py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/60 backdrop-blur-xl",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "glass-panel data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg p-6 shadow-lg duration-200 outline-none sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            aria-label="Close dialog"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon aria-hidden="true" focusable="false" />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="components/ui/dropdown-menu.tsx">
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
</file>

<file path="components/ui/ErrorState.tsx">
/**
 * ErrorState - Consistent error display
 *
 * Provides various error state representations for different contexts.
 */

import React from 'react';
import { AlertCircle, RefreshCw, ChevronRight } from 'lucide-react';
import { motion } from 'framer-motion';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';

export interface ErrorStateProps {
  /** Error title */
  title?: string;
  /** Error message to display */
  message: string;
  /** Variant of error display */
  variant?: 'inline' | 'card' | 'fullArea';
  /** Callback for retry action */
  onRetry?: () => void;
  /** Custom retry button text */
  retryText?: string;
  /** Additional actions */
  actions?: React.ReactNode;
  /** Additional class names */
  className?: string;
}

/**
 * Error state display with optional retry
 */
export function ErrorState({
  title = 'Something went wrong',
  message,
  variant = 'card',
  onRetry,
  retryText = 'Try again',
  actions,
  className,
}: ErrorStateProps) {
  if (variant === 'inline') {
    return (
      <div
        className={cn(
          'flex items-center gap-2 text-red-400 text-sm',
          className
        )}
        role="alert"
      >
        <AlertCircle className="w-4 h-4 shrink-0" aria-hidden="true" />
        <span>{message}</span>
        {onRetry && (
          <button
            onClick={onRetry}
            className="text-red-300 hover:text-red-200 underline underline-offset-2"
          >
            {retryText}
          </button>
        )}
      </div>
    );
  }

  const content = (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      className={cn(
        'rounded-xl bg-red-500/10 border border-red-500/20 p-6',
        variant === 'fullArea' && 'max-w-md mx-auto',
        className
      )}
      role="alert"
    >
      <div className="flex items-start gap-4">
        <div className="w-10 h-10 rounded-full bg-red-500/20 flex items-center justify-center shrink-0">
          <AlertCircle className="w-5 h-5 text-red-400" aria-hidden="true" />
        </div>
        <div className="flex-1 min-w-0">
          <h3 className="text-red-200 font-medium mb-1">{title}</h3>
          <p className="text-red-200/70 text-sm">{message}</p>

          {(onRetry || actions) && (
            <div className="mt-4 flex items-center gap-3">
              {onRetry && (
                <Button
                  onClick={onRetry}
                  size="sm"
                  className="bg-red-500/20 hover:bg-red-500/30 text-red-200 border border-red-500/30"
                >
                  <RefreshCw className="w-3.5 h-3.5 me-2" aria-hidden="true" />
                  {retryText}
                </Button>
              )}
              {actions}
            </div>
          )}
        </div>
      </div>
    </motion.div>
  );

  if (variant === 'fullArea') {
    return (
      <div className="flex items-center justify-center w-full h-full min-h-[300px] p-6">
        {content}
      </div>
    );
  }

  return content;
}

/**
 * Error boundary fallback component
 */
export interface ErrorFallbackProps {
  error: Error;
  resetErrorBoundary?: () => void;
}

export function ErrorFallback({ error, resetErrorBoundary }: ErrorFallbackProps) {
  return (
    <ErrorState
      variant="fullArea"
      title="Application Error"
      message={error.message || 'An unexpected error occurred'}
      onRetry={resetErrorBoundary}
      retryText="Reload"
      actions={
        <Button
          variant="ghost"
          size="sm"
          onClick={() => window.location.reload()}
          className="text-red-200/70 hover:text-red-200"
        >
          Refresh page
          <ChevronRight className="w-3.5 h-3.5 ms-1" aria-hidden="true" />
        </Button>
      }
    />
  );
}

export default ErrorState;
</file>

<file path="components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="components/ui/label.tsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="components/ui/LoadingState.tsx">
/**
 * LoadingState - Consistent loading indicators
 *
 * Provides various loading state representations for different contexts.
 */

import React from 'react';
import { Loader2, Sparkles } from 'lucide-react';
import { motion } from 'framer-motion';
import { cn } from '@/lib/utils';

export interface LoadingStateProps {
  /** Loading message to display */
  message?: string;
  /** Variant of loading indicator */
  variant?: 'spinner' | 'dots' | 'pulse' | 'branded';
  /** Size of the loading indicator */
  size?: 'sm' | 'md' | 'lg';
  /** Additional class names */
  className?: string;
  /** Whether to show as full page/area overlay */
  fullArea?: boolean;
}

const sizeClasses = {
  sm: 'w-4 h-4',
  md: 'w-8 h-8',
  lg: 'w-12 h-12',
};

const textSizeClasses = {
  sm: 'text-xs',
  md: 'text-sm',
  lg: 'text-base',
};

/**
 * Loading indicator with multiple variants
 */
export function LoadingState({
  message,
  variant = 'spinner',
  size = 'md',
  className,
  fullArea = false,
}: LoadingStateProps) {
  const content = (
    <div className={cn('flex flex-col items-center gap-3', className)}>
      {variant === 'spinner' && (
        <Loader2
          className={cn(sizeClasses[size], 'text-violet-400 animate-spin')}
          aria-hidden="true"
        />
      )}

      {variant === 'dots' && (
        <div className="flex gap-1">
          {[0, 1, 2].map((i) => (
            <motion.div
              key={i}
              className={cn(
                'rounded-full bg-violet-400',
                size === 'sm' ? 'w-1.5 h-1.5' : size === 'md' ? 'w-2 h-2' : 'w-3 h-3'
              )}
              animate={{ scale: [1, 1.2, 1], opacity: [0.5, 1, 0.5] }}
              transition={{
                duration: 0.8,
                delay: i * 0.15,
                repeat: Infinity,
                ease: 'easeInOut',
              }}
            />
          ))}
        </div>
      )}

      {variant === 'pulse' && (
        <motion.div
          className={cn(
            'rounded-full bg-violet-500/20 border border-violet-500/30',
            sizeClasses[size]
          )}
          animate={{ scale: [1, 1.1, 1], opacity: [0.5, 1, 0.5] }}
          transition={{ duration: 1.5, repeat: Infinity, ease: 'easeInOut' }}
        />
      )}

      {variant === 'branded' && (
        <motion.div
          className={cn(
            'rounded-2xl bg-gradient-to-br from-violet-600/20 to-fuchsia-600/20 border border-white/10 flex items-center justify-center',
            size === 'sm' ? 'w-10 h-10' : size === 'md' ? 'w-16 h-16' : 'w-20 h-20'
          )}
          animate={{ scale: [1, 1.05, 1] }}
          transition={{ duration: 2, repeat: Infinity, ease: 'easeInOut' }}
        >
          <Sparkles
            className={cn(
              'text-violet-400',
              size === 'sm' ? 'w-5 h-5' : size === 'md' ? 'w-8 h-8' : 'w-10 h-10'
            )}
          />
        </motion.div>
      )}

      {message && (
        <span className={cn('text-white/60', textSizeClasses[size])}>{message}</span>
      )}
    </div>
  );

  if (fullArea) {
    return (
      <div className="flex items-center justify-center w-full h-full min-h-[200px]">
        {content}
      </div>
    );
  }

  return content;
}

/**
 * Inline loading spinner for buttons etc.
 */
export function InlineLoader({ className }: { className?: string }) {
  return (
    <Loader2
      className={cn('w-4 h-4 animate-spin', className)}
      aria-hidden="true"
    />
  );
}

/**
 * Skeleton loading placeholder
 */
export function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn('animate-pulse rounded-md bg-white/10', className)}
      {...props}
    />
  );
}

export default LoadingState;
</file>

<file path="components/ui/MarkdownContent.tsx">
import React, { useMemo } from 'react';
import { cn } from '@/lib/utils';

interface MarkdownContentProps {
  content: string;
  className?: string;
}

/**
 * Lightweight markdown renderer for scene content.
 * Handles bold, headings, italic, and line breaks without
 * requiring a heavy markdown library.
 */
export function MarkdownContent({ content, className }: MarkdownContentProps) {
  const rendered = useMemo(() => {
    if (!content) return '';

    let html = content
      // Escape HTML entities
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      // Headings (### -> h4, ## -> h3)
      .replace(
        /^###\s+(.+)$/gm,
        '<h4 class="heading-card mt-4 mb-2">$1</h4>'
      )
      .replace(
        /^##\s+(.+)$/gm,
        '<h3 class="heading-section mt-4 mb-2">$1</h3>'
      )
      // Bold (**text** or __text__)
      .replace(
        /\*\*(.+?)\*\*/g,
        '<strong class="font-editorial font-semibold text-[oklch(0.95_0.01_60)]">$1</strong>'
      )
      .replace(
        /__(.+?)__/g,
        '<strong class="font-editorial font-semibold text-[oklch(0.95_0.01_60)]">$1</strong>'
      )
      // Italic (*text* or _text_) - must come after bold
      .replace(
        /(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)/g,
        '<em class="font-script italic text-[oklch(0.80_0.02_60)]">$1</em>'
      )
      // Bullet lists (- item or * item)
      .replace(
        /^[\-\*]\s+(.+)$/gm,
        '<li class="text-body-editorial ps-2">$1</li>'
      )
      // Line breaks
      .replace(/\n\n/g, '</p><p class="mt-3">')
      .replace(/\n/g, '<br />');

    // Wrap standalone li elements in ul
    html = html.replace(
      /(<li[^>]*>.*?<\/li>(?:\s*<br\s*\/?>\s*)?)+/g,
      (match) => `<ul class="space-y-1 my-2 list-none">${match.replace(/<br\s*\/?>/g, '')}</ul>`
    );

    return html;
  }, [content]);

  return (
    <div
      dir="auto"
      className={cn('text-body-editorial', className)}
      dangerouslySetInnerHTML={{ __html: rendered }}
    />
  );
}

export default MarkdownContent;
</file>

<file path="components/ui/progress.tsx">
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}

export { Progress }
</file>

<file path="components/ui/scroll-area.tsx">
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }
</file>

<file path="components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.Trigger>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
    <SelectPrimitive.Trigger
        ref={ref}
        className={cn(
            "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
            className
        )}
        {...props}
    >
        {children}
        <SelectPrimitive.Icon asChild>
            <ChevronDown className="h-4 w-4 opacity-50" />
        </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
    <SelectPrimitive.ScrollUpButton
        ref={ref}
        className={cn(
            "flex cursor-default items-center justify-center py-1",
            className
        )}
        {...props}
    >
        <ChevronUp className="h-4 w-4" />
    </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
    <SelectPrimitive.ScrollDownButton
        ref={ref}
        className={cn(
            "flex cursor-default items-center justify-center py-1",
            className
        )}
        {...props}
    >
        <ChevronDown className="h-4 w-4" />
    </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
    SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.Content>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
    <SelectPrimitive.Portal>
        <SelectPrimitive.Content
            ref={ref}
            className={cn(
                "relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
                position === "popper" &&
                "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
                className
            )}
            position={position}
            {...props}
        >
            <SelectScrollUpButton />
            <SelectPrimitive.Viewport
                className={cn(
                    "p-1",
                    position === "popper" &&
                    "h-(--radix-select-trigger-height) w-full min-w-(--radix-select-trigger-width)"
                )}
            >
                {children}
            </SelectPrimitive.Viewport>
            <SelectScrollDownButton />
        </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.Label>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
    <SelectPrimitive.Label
        ref={ref}
        className={cn("px-2 py-1.5 text-sm font-semibold", className)}
        {...props}
    />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.Item>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
    <SelectPrimitive.Item
        ref={ref}
        className={cn(
            "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
            className
        )}
        {...props}
    >
        <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
            <SelectPrimitive.ItemIndicator>
                <Check className="h-4 w-4" />
            </SelectPrimitive.ItemIndicator>
        </span>
        <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.Separator>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
    <SelectPrimitive.Separator
        ref={ref}
        className={cn("-mx-1 my-1 h-px bg-muted", className)}
        {...props}
    />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
    Select,
    SelectGroup,
    SelectValue,
    SelectTrigger,
    SelectContent,
    SelectLabel,
    SelectItem,
    SelectSeparator,
    SelectScrollUpButton,
    SelectScrollDownButton,
}
</file>

<file path="components/ui/skeleton.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"

interface SkeletonProps extends React.HTMLAttributes<HTMLDivElement> {
    /**
     * The variant of the skeleton
     * - text: For text placeholders (default height, full width)
     * - circular: For avatar/icon placeholders (circle shape)
     * - rectangular: For image/card placeholders (larger height)
     */
    variant?: "text" | "circular" | "rectangular"
    /**
     * Width of the skeleton (CSS value)
     */
    width?: string | number
    /**
     * Height of the skeleton (CSS value)
     */
    height?: string | number
    /**
     * Whether to animate the skeleton
     */
    animate?: boolean
}

/**
 * Skeleton component for loading states.
 * Provides visual feedback while content is loading.
 * 
 * @example
 * // Text skeleton
 * <Skeleton className="h-4 w-full" />
 * 
 * // Circular skeleton (avatar)
 * <Skeleton variant="circular" className="w-10 h-10" />
 * 
 * // Rectangular skeleton (image)
 * <Skeleton variant="rectangular" className="w-full h-48" />
 */
function Skeleton({
    className,
    variant = "text",
    width,
    height,
    animate = true,
    ...props
}: SkeletonProps) {
    const variantStyles = {
        text: "h-4 rounded",
        circular: "rounded-full aspect-square",
        rectangular: "h-24 rounded-lg",
    }

    const style: React.CSSProperties = {
        width: typeof width === "number" ? `${width}px` : width,
        height: typeof height === "number" ? `${height}px` : height,
    }

    return (
        <div
            data-slot="skeleton"
            aria-hidden="true"
            role="presentation"
            className={cn(
                "bg-muted/50",
                animate && "animate-pulse",
                variantStyles[variant],
                className
            )}
            style={style}
            {...props}
        />
    )
}

/**
 * SkeletonText - Multiple skeleton lines for paragraph loading
 */
function SkeletonText({
    lines = 3,
    className,
    ...props
}: { lines?: number } & React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("space-y-2", className)} {...props}>
            {Array.from({ length: lines }).map((_, i) => (
                <Skeleton
                    key={i}
                    variant="text"
                    className={cn(
                        "h-4",
                        // Last line is shorter for natural look
                        i === lines - 1 && "w-3/4"
                    )}
                />
            ))}
        </div>
    )
}

/**
 * SkeletonCard - Card-shaped skeleton with header and content
 */
function SkeletonCard({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div
            className={cn(
                "rounded-lg border border-border/50 p-4 space-y-4",
                className
            )}
            {...props}
        >
            {/* Header with avatar and title */}
            <div className="flex items-center gap-3">
                <Skeleton variant="circular" className="w-10 h-10" />
                <div className="flex-1 space-y-2">
                    <Skeleton variant="text" className="h-4 w-1/2" />
                    <Skeleton variant="text" className="h-3 w-1/3" />
                </div>
            </div>
            {/* Content */}
            <Skeleton variant="rectangular" className="h-32 w-full" />
            {/* Footer */}
            <div className="flex gap-2">
                <Skeleton variant="text" className="h-8 w-20" />
                <Skeleton variant="text" className="h-8 w-20" />
            </div>
        </div>
    )
}

/**
 * SkeletonImage - Image placeholder with aspect ratio support
 */
function SkeletonImage({
    aspectRatio = "16/9",
    className,
    ...props
}: { aspectRatio?: string } & React.HTMLAttributes<HTMLDivElement>) {
    return (
        <Skeleton
            variant="rectangular"
            className={cn("w-full", className)}
            style={{ aspectRatio }}
            {...props}
        />
    )
}

/**
 * SkeletonStoryCard - Skeleton for story/shot cards in Story Mode
 */
function SkeletonStoryCard({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div
            className={cn(
                "rounded-xl border border-white/10 bg-black/20 p-4 space-y-3",
                className
            )}
            {...props}
        >
            <SkeletonImage aspectRatio="16/9" className="rounded-lg" />
            <div className="space-y-2">
                <Skeleton variant="text" className="h-5 w-3/4" />
                <Skeleton variant="text" className="h-4 w-full" />
                <Skeleton variant="text" className="h-4 w-2/3" />
            </div>
            <div className="flex items-center gap-2 pt-2">
                <Skeleton variant="text" className="h-8 w-24 rounded-full" />
                <Skeleton variant="text" className="h-8 w-24 rounded-full" />
            </div>
        </div>
    )
}

/**
 * SkeletonShotGrid - Grid of skeleton shot cards
 */
function SkeletonShotGrid({
    count = 6,
    className,
    ...props
}: { count?: number } & React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div
            className={cn(
                "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4",
                className
            )}
            {...props}
        >
            {Array.from({ length: count }).map((_, i) => (
                <SkeletonStoryCard key={i} />
            ))}
        </div>
    )
}

/**
 * SkeletonTimeline - Timeline/video editor skeleton
 */
function SkeletonTimeline({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div
            className={cn(
                "rounded-lg border border-white/10 bg-black/30 p-4 space-y-3",
                className
            )}
            {...props}
        >
            {/* Playback controls */}
            <div className="flex items-center gap-3">
                <Skeleton variant="circular" className="w-10 h-10" />
                <Skeleton variant="text" className="h-2 flex-1 rounded-full" />
                <Skeleton variant="text" className="h-4 w-16" />
            </div>
            {/* Timeline tracks */}
            <div className="space-y-2">
                {[1, 2, 3].map((i) => (
                    <div key={i} className="flex items-center gap-2">
                        <Skeleton variant="text" className="h-4 w-16" />
                        <div className="flex-1 flex gap-1">
                            {Array.from({ length: 4 + i }).map((_, j) => (
                                <Skeleton
                                    key={j}
                                    variant="rectangular"
                                    className="h-12 rounded"
                                    style={{ width: `${15 + Math.random() * 20}%` }}
                                />
                            ))}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    )
}

/**
 * SkeletonCharacterCard - Character profile skeleton
 */
function SkeletonCharacterCard({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div
            className={cn(
                "rounded-xl border border-white/10 bg-black/20 p-4 flex gap-4",
                className
            )}
            {...props}
        >
            <Skeleton variant="circular" className="w-20 h-20 flex-shrink-0" />
            <div className="flex-1 space-y-2">
                <Skeleton variant="text" className="h-5 w-1/2" />
                <Skeleton variant="text" className="h-4 w-3/4" />
                <Skeleton variant="text" className="h-4 w-full" />
                <div className="flex gap-2 pt-2">
                    <Skeleton variant="text" className="h-6 w-16 rounded-full" />
                    <Skeleton variant="text" className="h-6 w-16 rounded-full" />
                </div>
            </div>
        </div>
    )
}

/**
 * SkeletonSceneBreakdown - Scene breakdown list skeleton
 */
function SkeletonSceneBreakdown({
    sceneCount = 3,
    className,
    ...props
}: { sceneCount?: number } & React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div className={cn("space-y-4", className)} {...props}>
            {Array.from({ length: sceneCount }).map((_, i) => (
                <div
                    key={i}
                    className="rounded-lg border border-white/10 bg-black/20 p-4 space-y-3"
                >
                    <div className="flex items-center justify-between">
                        <Skeleton variant="text" className="h-6 w-32" />
                        <Skeleton variant="text" className="h-4 w-20" />
                    </div>
                    <SkeletonText lines={2} />
                    <div className="flex gap-2">
                        <Skeleton variant="text" className="h-6 w-20 rounded-full" />
                        <Skeleton variant="text" className="h-6 w-24 rounded-full" />
                    </div>
                </div>
            ))}
        </div>
    )
}

/**
 * SkeletonProjectCard - Project card skeleton for gallery
 */
function SkeletonProjectCard({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div
            className={cn(
                "rounded-xl border border-white/10 bg-black/20 overflow-hidden",
                className
            )}
            {...props}
        >
            <SkeletonImage aspectRatio="16/9" />
            <div className="p-4 space-y-2">
                <Skeleton variant="text" className="h-5 w-2/3" />
                <Skeleton variant="text" className="h-4 w-1/2" />
                <div className="flex items-center justify-between pt-2">
                    <Skeleton variant="text" className="h-4 w-20" />
                    <Skeleton variant="circular" className="w-8 h-8" />
                </div>
            </div>
        </div>
    )
}

export {
    Skeleton,
    SkeletonText,
    SkeletonCard,
    SkeletonImage,
    SkeletonStoryCard,
    SkeletonShotGrid,
    SkeletonTimeline,
    SkeletonCharacterCard,
    SkeletonSceneBreakdown,
    SkeletonProjectCard
}
</file>

<file path="components/ui/skip-link.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"

interface SkipLinkProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {
    /**
     * The ID of the element to skip to (without #)
     * @default "main-content"
     */
    targetId?: string
    /**
     * The text to display in the skip link
     */
    children?: React.ReactNode
}

/**
 * SkipLink component for keyboard accessibility.
 * 
 * Allows keyboard users to skip navigation and jump directly to main content.
 * The link is visually hidden until focused, then appears at the top of the viewport.
 * 
 * CSS classes are defined in index.css (.skip-to-content)
 * 
 * @example
 * // In your layout component:
 * <SkipLink />
 * <Header />
 * <main id="main-content">
 *   ...content
 * </main>
 */
function SkipLink({
    targetId = "main-content",
    children,
    className,
    ...props
}: SkipLinkProps) {
    const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
        e.preventDefault()
        const target = document.getElementById(targetId)
        if (target) {
            // Set focus to the target element
            target.setAttribute("tabindex", "-1")
            target.focus()
            // Scroll to the target
            target.scrollIntoView({ behavior: "smooth" })
            // Remove tabindex after focus to maintain normal tab order
            target.addEventListener(
                "blur",
                () => target.removeAttribute("tabindex"),
                { once: true }
            )
        }
    }

    return (
        <a
            href={`#${targetId}`}
            onClick={handleClick}
            className={cn("skip-to-content", className)}
            {...props}
        >
            {children || "Skip to main content"}
        </a>
    )
}

export { SkipLink }
</file>

<file path="components/ui/SlidePanel.tsx">
/**
 * SlidePanel - Slide-in side panel component
 *
 * A reusable slide-in panel for editing sidebars, scene editors, etc.
 * Includes focus trapping and RTL support.
 */

import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { useFocusTrap } from '@/hooks/useFocusTrap';

export interface SlidePanelProps {
  /** Whether the panel is open */
  isOpen: boolean;
  /** Callback when panel should close */
  onClose: () => void;
  /** Panel title */
  title: string;
  /** RTL layout */
  isRTL?: boolean;
  /** Panel width class */
  width?: string;
  /** Panel content */
  children: React.ReactNode;
  /** Additional class names for the panel */
  className?: string;
  /** Whether to show the close button */
  showCloseButton?: boolean;
  /** ID for the title element (for aria-labelledby) */
  titleId?: string;
}

/**
 * Slide-in panel with focus trapping
 *
 * @example
 * ```tsx
 * <SlidePanel
 *   isOpen={showEditor}
 *   onClose={() => setShowEditor(false)}
 *   title="Edit Scene"
 *   isRTL={isRTL}
 * >
 *   <SceneEditor ... />
 * </SlidePanel>
 * ```
 */
export function SlidePanel({
  isOpen,
  onClose,
  title,
  isRTL = false,
  width = 'max-w-md',
  children,
  className,
  showCloseButton = true,
  titleId,
}: SlidePanelProps) {
  const panelRef = useFocusTrap<HTMLDivElement>({
    isActive: isOpen,
    onEscape: onClose,
    returnFocusOnDeactivate: true,
  });

  const generatedTitleId = titleId || `slide-panel-title-${React.useId()}`;

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex"
          style={{ justifyContent: isRTL ? 'flex-start' : 'flex-end' }}
          onClick={onClose}
          role="dialog"
          aria-modal="true"
          aria-labelledby={generatedTitleId}
        >
          <motion.div
            ref={panelRef}
            initial={{ x: isRTL ? '-100%' : '100%' }}
            animate={{ x: 0 }}
            exit={{ x: isRTL ? '-100%' : '100%' }}
            transition={{ type: 'spring', damping: 25, stiffness: 200 }}
            className={cn(
              'w-full bg-[#12121a] h-full overflow-y-auto p-4',
              width,
              isRTL ? 'border-e border-white/10' : 'border-s border-white/10',
              className
            )}
            onClick={(e) => e.stopPropagation()}
          >
            {/* Header */}
            <div
              className={cn(
                'flex items-center justify-between mb-6',
                isRTL && 'flex-row-reverse'
              )}
            >
              <h2 id={generatedTitleId} className="text-lg font-semibold text-white">
                {title}
              </h2>
              {showCloseButton && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={onClose}
                  aria-label="Close panel"
                >
                  <X className="w-5 h-5" aria-hidden="true" />
                </Button>
              )}
            </div>

            {/* Content */}
            {children}
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}

export default SlidePanel;
</file>

<file path="components/ui/slider.tsx">
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary ring-ring/50 block size-4 shrink-0 rounded-full border bg-white shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }
</file>

<file path="components/ui/switch.tsx">
import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }
</file>

<file path="components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="components/ui/toast.tsx">
import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed bottom-0 right-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> & {
    variant?: "default" | "success" | "error" | "warning";
  }
>(({ className, variant = "default", ...props }, ref) => {
  const variantStyles = {
    default: "bg-[var(--cinema-celluloid)]/95 border-[var(--cinema-silver)]/20 text-[var(--cinema-silver)]",
    success: "bg-emerald-900/95 border-emerald-500/30 text-emerald-100",
    error: "bg-red-900/95 border-red-500/30 text-red-100",
    warning: "bg-amber-900/95 border-amber-500/30 text-amber-100",
  };

  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(
        "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-lg border p-4 pr-8 shadow-lg backdrop-blur-sm transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-bottom-full data-[state=open]:sm:slide-in-from-bottom-full",
        variantStyles[variant],
        className
      )}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border border-[var(--cinema-silver)]/30 bg-transparent px-3 text-xs font-medium transition-colors hover:bg-[var(--cinema-silver)]/10 focus:outline-none focus:ring-2 focus:ring-[var(--cinema-spotlight)] disabled:pointer-events-none disabled:opacity-50",
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-[var(--cinema-silver)]/50 opacity-0 transition-opacity hover:text-[var(--cinema-silver)] focus:opacity-100 focus:outline-none focus:ring-2 focus:ring-[var(--cinema-spotlight)] group-hover:opacity-100",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
    <span className="sr-only">Close</span>
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("font-editorial text-sm font-semibold", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-xs opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;
type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};
</file>

<file path="components/ui/toaster.tsx">
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "./toast";
import { useToast } from "./use-toast";

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}
</file>

<file path="components/ui/tooltip.tsx">
import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-lg bg-card border border-border/50 px-3 py-1.5 text-xs text-foreground shadow-xl shadow-black/20 animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };
</file>

<file path="components/ui/use-toast.tsx">
import * as React from "react";
import type { ToastActionElement, ToastProps } from "./toast";

const TOAST_LIMIT = 3;
const TOAST_REMOVE_DELAY = 5000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
  variant?: "default" | "success" | "error" | "warning";
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast };
</file>

<file path="components/VideoEditor/CanvasPreview.tsx">
/**
 * CanvasPreview
 *
 * Live canvas preview that composites visible clips at the current time.
 * Renders video frames, image overlays, and text elements onto a canvas.
 */

import { useRef, useEffect, useCallback, useMemo } from 'react';
import type { EditorClip, AspectRatio } from './types/video-editor-types';
import './video-editor.css';

const ASPECT_DIMENSIONS: Record<AspectRatio, { w: number; h: number }> = {
  '16:9': { w: 1280, h: 720 },
  '9:16': { w: 720, h: 1280 },
  '1:1': { w: 720, h: 720 },
  '4:3': { w: 960, h: 720 },
};

interface CanvasPreviewProps {
  clips: EditorClip[];
  currentTime: number;
  aspectRatio: AspectRatio;
  isPlaying: boolean;
  className?: string;
}

export function CanvasPreview({
  clips,
  currentTime,
  aspectRatio,
  isPlaying,
  className = '',
}: CanvasPreviewProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const imageCache = useRef<Map<string, HTMLImageElement>>(new Map());
  const rafRef = useRef<number>(0);

  const dims = ASPECT_DIMENSIONS[aspectRatio];

  // Get clips visible at the current time, sorted by track order
  const visibleClips = useMemo(() => {
    return clips.filter(c =>
      currentTime >= c.startTime && currentTime < c.startTime + c.duration
    );
  }, [clips, currentTime]);

  // Preload images for image/video clips
  const preloadImage = useCallback((url: string): HTMLImageElement | null => {
    const cached = imageCache.current.get(url);
    if (cached?.complete) return cached;
    if (!cached) {
      const img = new window.Image();
      img.crossOrigin = 'anonymous';
      img.src = url;
      imageCache.current.set(url, img);
      img.onload = () => renderFrame();
    }
    return null;
  }, []);

  const renderFrame = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Clear
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, dims.w, dims.h);

    // Render clips bottom-to-top (first = background)
    for (const clip of visibleClips) {
      if (clip.type === 'video' && clip.thumbnailUrl) {
        const img = preloadImage(clip.thumbnailUrl);
        if (img?.complete) {
          ctx.drawImage(img, 0, 0, dims.w, dims.h);
        }
      } else if (clip.type === 'image' && clip.imageUrl) {
        const img = preloadImage(clip.imageUrl);
        if (img?.complete) {
          // Center the image preserving aspect ratio
          const scale = Math.min(dims.w / img.width, dims.h / img.height) * 0.8;
          const drawW = img.width * scale;
          const drawH = img.height * scale;
          ctx.drawImage(img, (dims.w - drawW) / 2, (dims.h - drawH) / 2, drawW, drawH);
        }
      } else if (clip.type === 'text' && clip.text) {
        const style = clip.textStyle ?? {
          fontFamily: 'Inter',
          fontSize: 48,
          fontWeight: '700',
          color: '#ffffff',
          position: { x: 0.5, y: 0.5 },
          alignment: 'center' as const,
        };

        ctx.save();
        ctx.font = `${style.fontWeight} ${style.fontSize}px ${style.fontFamily}`;
        ctx.fillStyle = style.color;
        ctx.textAlign = style.alignment;
        ctx.textBaseline = 'middle';

        // Draw text shadow/outline
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.lineWidth = 3;
        const x = style.position.x * dims.w;
        const y = style.position.y * dims.h;
        ctx.strokeText(clip.text, x, y);
        ctx.fillText(clip.text, x, y);
        ctx.restore();
      }
      // Audio clips don't render on canvas
    }
  }, [dims, visibleClips, preloadImage]);

  // Render on time change or clip change
  useEffect(() => {
    renderFrame();
  }, [renderFrame]);

  // Animation loop when playing
  useEffect(() => {
    if (!isPlaying) return;
    const animate = () => {
      renderFrame();
      rafRef.current = requestAnimationFrame(animate);
    };
    rafRef.current = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(rafRef.current);
  }, [isPlaying, renderFrame]);

  return (
    <div className={`ve-preview ${className}`}>
      <canvas
        ref={canvasRef}
        width={dims.w}
        height={dims.h}
        className="ve-preview-canvas"
        aria-label="Video preview"
      />
      <div className="ve-aspect-badge">{aspectRatio}</div>
    </div>
  );
}
</file>

<file path="components/VideoEditor/clips/AudioTrackClip.tsx">
/**
 * AudioTrackClip ‚Äî Orange audio clip with waveform visualization.
 */

import { Music } from 'lucide-react';
import { useMemo } from 'react';
import type { EditorClip } from '../types/video-editor-types';
import { TRACK_COLORS } from '../types/video-editor-types';
import '../video-editor.css';

interface AudioTrackClipProps {
  clip: EditorClip;
  zoom: number;
  isSelected: boolean;
  onSelect: (clipId: string) => void;
  onResizeStart?: (clipId: string, edge: 'left' | 'right', e: React.PointerEvent) => void;
}

/**
 * Generate pseudo-random waveform bars if no waveformData is provided.
 * Uses a seed derived from the clip ID for consistent rendering.
 */
function generateWaveform(clipId: string, barCount: number): number[] {
  let hash = 0;
  for (let i = 0; i < clipId.length; i++) {
    hash = ((hash << 5) - hash + clipId.charCodeAt(i)) | 0;
  }
  const bars: number[] = [];
  for (let i = 0; i < barCount; i++) {
    hash = ((hash * 1103515245 + 12345) & 0x7fffffff);
    bars.push(0.2 + (hash % 100) / 125);
  }
  return bars;
}

export function AudioTrackClip({ clip, zoom, isSelected, onSelect, onResizeStart }: AudioTrackClipProps) {
  const left = clip.startTime * zoom;
  const width = Math.max(clip.duration * zoom, 20);
  const barCount = Math.max(8, Math.floor(width / 4));

  const waveform = useMemo(() => {
    return clip.waveformData ?? generateWaveform(clip.id, barCount);
  }, [clip.id, clip.waveformData, barCount]);

  const maxBarHeight = 36;
  const color = TRACK_COLORS.audio.waveform;

  return (
    <div
      className={`ve-clip ve-clip--audio ${isSelected ? 'selected' : ''}`}
      style={{ left: `${left}px`, width: `${width}px` }}
      onClick={(e) => { e.stopPropagation(); onSelect(clip.id); }}
      role="button"
      aria-label={`Audio: ${clip.name}`}
      aria-selected={isSelected}
      tabIndex={0}
    >
      {isSelected && (
        <>
          <div
            className="ve-resize-handle ve-resize-handle--left"
            onPointerDown={(e) => onResizeStart?.(clip.id, 'left', e)}
          />
          <div
            className="ve-resize-handle ve-resize-handle--right"
            onPointerDown={(e) => onResizeStart?.(clip.id, 'right', e)}
          />
        </>
      )}
      <Music size={12} className="ve-clip-icon" style={{ flexShrink: 0, marginRight: 2 }} />
      <div className="ve-waveform">
        {waveform.slice(0, barCount).map((amp, i) => (
          <div
            key={i}
            className="ve-wave-bar"
            style={{
              height: `${Math.max(4, amp * maxBarHeight)}px`,
              background: color,
            }}
          />
        ))}
      </div>
    </div>
  );
}
</file>

<file path="components/VideoEditor/clips/ImageTrackClip.tsx">
/**
 * ImageTrackClip ‚Äî Green image clip with thumbnail preview.
 */

import { ImageIcon } from 'lucide-react';
import type { EditorClip } from '../types/video-editor-types';
import '../video-editor.css';

interface ImageTrackClipProps {
  clip: EditorClip;
  zoom: number;
  isSelected: boolean;
  onSelect: (clipId: string) => void;
  onResizeStart?: (clipId: string, edge: 'left' | 'right', e: React.PointerEvent) => void;
}

export function ImageTrackClip({ clip, zoom, isSelected, onSelect, onResizeStart }: ImageTrackClipProps) {
  const left = clip.startTime * zoom;
  const width = Math.max(clip.duration * zoom, 20);

  return (
    <div
      className={`ve-clip ve-clip--image ${isSelected ? 'selected' : ''}`}
      style={{ left: `${left}px`, width: `${width}px` }}
      onClick={(e) => { e.stopPropagation(); onSelect(clip.id); }}
      role="button"
      aria-label={`Image: ${clip.name}`}
      aria-selected={isSelected}
      tabIndex={0}
    >
      {isSelected && (
        <>
          <div
            className="ve-resize-handle ve-resize-handle--left"
            onPointerDown={(e) => onResizeStart?.(clip.id, 'left', e)}
          />
          <div
            className="ve-resize-handle ve-resize-handle--right"
            onPointerDown={(e) => onResizeStart?.(clip.id, 'right', e)}
          />
        </>
      )}
      {clip.imageUrl ? (
        <img src={clip.imageUrl} alt={clip.name} className="ve-image-thumb" />
      ) : (
        <>
          <ImageIcon size={14} className="ve-clip-icon" />
          <span className="ve-clip-name">{clip.name}</span>
        </>
      )}
    </div>
  );
}
</file>

<file path="components/VideoEditor/clips/TextClip.tsx">
/**
 * TextClip ‚Äî Blue text clip renderer for the timeline.
 */

import { Type } from 'lucide-react';
import type { EditorClip } from '../types/video-editor-types';
import '../video-editor.css';

interface TextClipProps {
  clip: EditorClip;
  zoom: number;
  isSelected: boolean;
  onSelect: (clipId: string) => void;
  onResizeStart?: (clipId: string, edge: 'left' | 'right', e: React.PointerEvent) => void;
}

export function TextClip({ clip, zoom, isSelected, onSelect, onResizeStart }: TextClipProps) {
  const left = clip.startTime * zoom;
  const width = Math.max(clip.duration * zoom, 20);

  return (
    <div
      className={`ve-clip ve-clip--text ${isSelected ? 'selected' : ''}`}
      style={{ left: `${left}px`, width: `${width}px` }}
      onClick={(e) => { e.stopPropagation(); onSelect(clip.id); }}
      role="button"
      aria-label={`Text: ${clip.text ?? clip.name}`}
      aria-selected={isSelected}
      tabIndex={0}
    >
      {/* Resize handles */}
      {isSelected && (
        <>
          <div
            className="ve-resize-handle ve-resize-handle--left"
            onPointerDown={(e) => onResizeStart?.(clip.id, 'left', e)}
          />
          <div
            className="ve-resize-handle ve-resize-handle--right"
            onPointerDown={(e) => onResizeStart?.(clip.id, 'right', e)}
          />
        </>
      )}
      <Type size={14} className="ve-clip-icon" />
      <span className="ve-clip-name">{clip.text ?? clip.name}</span>
    </div>
  );
}
</file>

<file path="components/VideoEditor/clips/VideoTrackClip.tsx">
/**
 * VideoTrackClip ‚Äî Teal video clip with repeating thumbnail tiles.
 */

import { Film } from 'lucide-react';
import type { EditorClip } from '../types/video-editor-types';
import '../video-editor.css';

interface VideoTrackClipProps {
  clip: EditorClip;
  zoom: number;
  isSelected: boolean;
  onSelect: (clipId: string) => void;
  onResizeStart?: (clipId: string, edge: 'left' | 'right', e: React.PointerEvent) => void;
}

export function VideoTrackClip({ clip, zoom, isSelected, onSelect, onResizeStart }: VideoTrackClipProps) {
  const left = clip.startTime * zoom;
  const width = Math.max(clip.duration * zoom, 20);
  const tileCount = Math.max(1, Math.floor(width / 50));

  return (
    <div
      className={`ve-clip ve-clip--video ${isSelected ? 'selected' : ''}`}
      style={{ left: `${left}px`, width: `${width}px` }}
      onClick={(e) => { e.stopPropagation(); onSelect(clip.id); }}
      role="button"
      aria-label={`Video: ${clip.name}`}
      aria-selected={isSelected}
      tabIndex={0}
    >
      {isSelected && (
        <>
          <div
            className="ve-resize-handle ve-resize-handle--left"
            onPointerDown={(e) => onResizeStart?.(clip.id, 'left', e)}
          />
          <div
            className="ve-resize-handle ve-resize-handle--right"
            onPointerDown={(e) => onResizeStart?.(clip.id, 'right', e)}
          />
        </>
      )}
      {clip.thumbnailUrl ? (
        <div className="ve-thumb-strip">
          {Array.from({ length: tileCount }, (_, i) => (
            <div
              key={i}
              className="ve-thumb-tile"
              style={{ backgroundImage: `url(${clip.thumbnailUrl})` }}
            />
          ))}
        </div>
      ) : (
        <>
          <Film size={14} className="ve-clip-icon" />
          <span className="ve-clip-name">{clip.name}</span>
        </>
      )}
    </div>
  );
}
</file>

<file path="components/VideoEditor/EnhancedTransportBar.tsx">
/**
 * EnhancedTransportBar
 *
 * Full transport bar with undo/redo, split tool, playback controls,
 * timecode display, aspect ratio selector, zoom slider, and fullscreen toggle.
 */

import {
  Undo2, Redo2, Scissors,
  SkipBack, Play, Pause, SkipForward,
  Maximize2,
} from 'lucide-react';
import type { AspectRatio } from './types/video-editor-types';
import { MIN_ZOOM, MAX_ZOOM } from './types/video-editor-types';
import './video-editor.css';

function formatTimecodeCompact(seconds: number): string {
  const time = Math.max(0, seconds);
  const mins = Math.floor(time / 60);
  const secs = Math.floor(time % 60);
  const ms = Math.floor((time % 1) * 100);
  return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
}

interface EnhancedTransportBarProps {
  currentTime: number;
  duration: number;
  isPlaying: boolean;
  zoom: number;
  aspectRatio: AspectRatio;
  activeTool: string;
  canUndo: boolean;
  canRedo: boolean;
  onPlayPause: () => void;
  onSkipBack: () => void;
  onSkipForward: () => void;
  onUndo: () => void;
  onRedo: () => void;
  onSplit: () => void;
  onZoomChange: (zoom: number) => void;
  onAspectRatioChange: (ratio: AspectRatio) => void;
  onFullscreen: () => void;
}

export function EnhancedTransportBar({
  currentTime,
  duration,
  isPlaying,
  zoom,
  aspectRatio,
  activeTool,
  canUndo,
  canRedo,
  onPlayPause,
  onSkipBack,
  onSkipForward,
  onUndo,
  onRedo,
  onSplit,
  onZoomChange,
  onAspectRatioChange,
  onFullscreen,
}: EnhancedTransportBarProps) {
  return (
    <div className="ve-transport" role="toolbar" aria-label="Transport controls">
      {/* Left group: undo/redo/split */}
      <div className="ve-transport-group">
        <button
          className="ve-transport-btn"
          onClick={onUndo}
          disabled={!canUndo}
          title="Undo (Ctrl+Z)"
          aria-label="Undo"
        >
          <Undo2 size={16} />
        </button>
        <button
          className="ve-transport-btn"
          onClick={onRedo}
          disabled={!canRedo}
          title="Redo (Ctrl+Shift+Z)"
          aria-label="Redo"
        >
          <Redo2 size={16} />
        </button>
        <button
          className={`ve-transport-btn ${activeTool === 'split' ? 'active' : ''}`}
          onClick={onSplit}
          title="Split at playhead (S)"
          aria-label="Split clip"
        >
          <Scissors size={16} />
        </button>
      </div>

      <div className="ve-transport-divider" />

      {/* Center group: transport + timecode */}
      <div className="ve-transport-group">
        <button
          className="ve-transport-btn"
          onClick={onSkipBack}
          title="Skip back 5s (J)"
          aria-label="Skip back"
        >
          <SkipBack size={16} />
        </button>
        <button
          className="ve-transport-btn primary"
          onClick={onPlayPause}
          title={isPlaying ? 'Pause (Space)' : 'Play (Space)'}
          aria-label={isPlaying ? 'Pause' : 'Play'}
          aria-pressed={isPlaying}
        >
          {isPlaying ? <Pause size={16} /> : <Play size={16} />}
        </button>
        <button
          className="ve-transport-btn"
          onClick={onSkipForward}
          title="Skip forward 5s (L)"
          aria-label="Skip forward"
        >
          <SkipForward size={16} />
        </button>
      </div>

      {/* Timecode */}
      <div className="ve-timecode" role="timer" aria-label="Playback position">
        <span className="ve-timecode-current">{formatTimecodeCompact(currentTime)}</span>
        <span className="ve-timecode-separator">/</span>
        <span>{formatTimecodeCompact(duration)}</span>
      </div>

      <div className="ve-transport-spacer" />

      {/* Right group: aspect ratio, zoom, fullscreen */}
      <select
        className="ve-aspect-select"
        value={aspectRatio}
        onChange={(e) => onAspectRatioChange(e.target.value as AspectRatio)}
        title="Aspect ratio"
        aria-label="Aspect ratio"
      >
        <option value="16:9">16:9</option>
        <option value="9:16">9:16</option>
        <option value="1:1">1:1</option>
        <option value="4:3">4:3</option>
      </select>

      <div className="ve-zoom-container">
        <input
          type="range"
          className="ve-zoom-slider"
          min={MIN_ZOOM}
          max={MAX_ZOOM}
          value={zoom}
          onChange={(e) => onZoomChange(Number(e.target.value))}
          title={`Zoom: ${zoom}px/s`}
          aria-label="Timeline zoom"
        />
      </div>

      <button
        className="ve-transport-btn"
        onClick={onFullscreen}
        title="Fullscreen"
        aria-label="Toggle fullscreen"
      >
        <Maximize2 size={16} />
      </button>
    </div>
  );
}
</file>

<file path="components/VideoEditor/hooks/useVideoEditorStore.ts">
/**
 * Video Editor Store
 *
 * Zustand store managing all mutable state for the video editor:
 * tracks, clips, playback, selection, undo/redo, and view settings.
 */

import { create } from 'zustand';
import type {
  VideoEditorState,
  EditorTrack,
  EditorTrackType,
  EditorClip,
  EditorSnapshot,
  AspectRatio,
  ActiveTool,
  ToolPanel,
} from '../types/video-editor-types';
import { MAX_UNDO_STACK, DEFAULT_ZOOM } from '../types/video-editor-types';

let clipIdCounter = 0;
let trackIdCounter = 0;

function nextClipId(): string {
  return `clip_${Date.now()}_${++clipIdCounter}`;
}

function nextTrackId(): string {
  return `track_${Date.now()}_${++trackIdCounter}`;
}

function createSnapshot(state: { tracks: EditorTrack[]; clips: EditorClip[] }): EditorSnapshot {
  return {
    tracks: state.tracks.map(t => ({ ...t })),
    clips: state.clips.map(c => ({ ...c, textStyle: c.textStyle ? { ...c.textStyle, position: { ...c.textStyle.position } } : undefined })),
  };
}

function recalcDuration(clips: EditorClip[]): number {
  if (clips.length === 0) return 30;
  return Math.max(30, ...clips.map(c => c.startTime + c.duration));
}

export const useVideoEditorStore = create<VideoEditorState>((set, get) => ({
  // Initial state
  tracks: [],
  clips: [],
  currentTime: 0,
  duration: 30,
  isPlaying: false,
  selectedClipIds: [],
  selectedTrackId: null,
  zoom: DEFAULT_ZOOM,
  aspectRatio: '16:9' as AspectRatio,
  isFullscreen: false,
  undoStack: [],
  redoStack: [],
  activeTool: 'select' as ActiveTool,
  activeToolPanel: null as ToolPanel,

  // ---- Track Actions ----

  addTrack: (type: EditorTrackType, name?: string) => {
    const state = get();
    state.pushSnapshot();
    const track: EditorTrack = {
      id: nextTrackId(),
      type,
      name: name ?? `${type.charAt(0).toUpperCase() + type.slice(1)} ${state.tracks.filter(t => t.type === type).length + 1}`,
      isLocked: false,
      isMuted: false,
      isVisible: true,
      order: state.tracks.length,
    };
    set({ tracks: [...state.tracks, track], redoStack: [] });
  },

  removeTrack: (trackId: string) => {
    const state = get();
    state.pushSnapshot();
    set({
      tracks: state.tracks.filter(t => t.id !== trackId),
      clips: state.clips.filter(c => c.trackId !== trackId),
      selectedTrackId: state.selectedTrackId === trackId ? null : state.selectedTrackId,
      redoStack: [],
    });
  },

  reorderTrack: (trackId: string, newOrder: number) => {
    const state = get();
    state.pushSnapshot();
    const tracks = state.tracks.map(t => {
      if (t.id === trackId) return { ...t, order: newOrder };
      return t;
    }).sort((a, b) => a.order - b.order).map((t, i) => ({ ...t, order: i }));
    set({ tracks, redoStack: [] });
  },

  toggleTrackLock: (trackId: string) => {
    set(state => ({
      tracks: state.tracks.map(t => t.id === trackId ? { ...t, isLocked: !t.isLocked } : t),
    }));
  },

  toggleTrackMute: (trackId: string) => {
    set(state => ({
      tracks: state.tracks.map(t => t.id === trackId ? { ...t, isMuted: !t.isMuted } : t),
    }));
  },

  toggleTrackVisibility: (trackId: string) => {
    set(state => ({
      tracks: state.tracks.map(t => t.id === trackId ? { ...t, isVisible: !t.isVisible } : t),
    }));
  },

  // ---- Clip Actions ----

  addClip: (clipData) => {
    const state = get();
    state.pushSnapshot();
    const clip: EditorClip = { ...clipData, id: nextClipId() };
    const newClips = [...state.clips, clip];
    set({ clips: newClips, duration: recalcDuration(newClips), redoStack: [] });
  },

  removeClip: (clipId: string) => {
    const state = get();
    state.pushSnapshot();
    const newClips = state.clips.filter(c => c.id !== clipId);
    set({
      clips: newClips,
      duration: recalcDuration(newClips),
      selectedClipIds: state.selectedClipIds.filter(id => id !== clipId),
      redoStack: [],
    });
  },

  updateClip: (clipId: string, updates: Partial<EditorClip>) => {
    const state = get();
    state.pushSnapshot();
    const newClips = state.clips.map(c => c.id === clipId ? { ...c, ...updates } : c);
    set({ clips: newClips, duration: recalcDuration(newClips), redoStack: [] });
  },

  moveClip: (clipId: string, newStartTime: number, newTrackId?: string) => {
    const state = get();
    state.pushSnapshot();
    const clampedTime = Math.max(0, newStartTime);
    const newClips = state.clips.map(c => {
      if (c.id !== clipId) return c;
      return { ...c, startTime: clampedTime, ...(newTrackId ? { trackId: newTrackId } : {}) };
    });
    set({ clips: newClips, duration: recalcDuration(newClips), redoStack: [] });
  },

  resizeClip: (clipId: string, edge: 'left' | 'right', newTime: number) => {
    const state = get();
    state.pushSnapshot();
    const newClips = state.clips.map(c => {
      if (c.id !== clipId) return c;
      if (edge === 'left') {
        const clamped = Math.max(0, Math.min(newTime, c.startTime + c.duration - 0.1));
        const delta = clamped - c.startTime;
        return { ...c, startTime: clamped, duration: c.duration - delta, inPoint: c.inPoint + delta };
      } else {
        const newDuration = Math.max(0.1, newTime - c.startTime);
        return { ...c, duration: newDuration, outPoint: c.inPoint + newDuration };
      }
    });
    set({ clips: newClips, duration: recalcDuration(newClips), redoStack: [] });
  },

  splitClipAtPlayhead: (clipId: string) => {
    const state = get();
    const clip = state.clips.find(c => c.id === clipId);
    if (!clip) return;
    const splitTime = state.currentTime;
    if (splitTime <= clip.startTime || splitTime >= clip.startTime + clip.duration) return;

    state.pushSnapshot();
    const leftDuration = splitTime - clip.startTime;
    const rightDuration = clip.duration - leftDuration;

    const leftClip: EditorClip = { ...clip, duration: leftDuration, outPoint: clip.inPoint + leftDuration };
    const rightClip: EditorClip = {
      ...clip,
      id: nextClipId(),
      startTime: splitTime,
      duration: rightDuration,
      inPoint: clip.inPoint + leftDuration,
    };

    const newClips = state.clips.map(c => c.id === clipId ? leftClip : c);
    newClips.push(rightClip);
    set({ clips: newClips, duration: recalcDuration(newClips), redoStack: [] });
  },

  // ---- Playback Actions ----

  setCurrentTime: (time: number) => set({ currentTime: Math.max(0, time) }),
  setIsPlaying: (playing: boolean) => set({ isPlaying: playing }),
  togglePlayback: () => set(state => ({ isPlaying: !state.isPlaying })),

  // ---- View Actions ----

  setZoom: (zoom: number) => set({ zoom: Math.max(10, Math.min(200, zoom)) }),
  setAspectRatio: (ratio: AspectRatio) => set({ aspectRatio: ratio }),
  setFullscreen: (fullscreen: boolean) => set({ isFullscreen: fullscreen }),
  setActiveTool: (tool: ActiveTool) => set({ activeTool: tool }),
  setActiveToolPanel: (panel: ToolPanel) => set(state => ({
    activeToolPanel: state.activeToolPanel === panel ? null : panel,
  })),

  // ---- Selection Actions ----

  selectClip: (clipId: string, additive = false) => {
    set(state => ({
      selectedClipIds: additive
        ? (state.selectedClipIds.includes(clipId)
          ? state.selectedClipIds.filter(id => id !== clipId)
          : [...state.selectedClipIds, clipId])
        : [clipId],
    }));
  },

  selectTrack: (trackId: string | null) => set({ selectedTrackId: trackId }),

  deselectAll: () => set({ selectedClipIds: [], selectedTrackId: null }),

  // ---- Undo/Redo ----

  pushSnapshot: () => {
    set(state => {
      const snapshot = createSnapshot(state);
      const stack = [...state.undoStack, snapshot];
      if (stack.length > MAX_UNDO_STACK) stack.shift();
      return { undoStack: stack };
    });
  },

  undo: () => {
    const state = get();
    if (state.undoStack.length === 0) return;
    const currentSnapshot = createSnapshot(state);
    const prev = state.undoStack[state.undoStack.length - 1]!;
    set({
      tracks: prev.tracks,
      clips: prev.clips,
      duration: recalcDuration(prev.clips),
      undoStack: state.undoStack.slice(0, -1),
      redoStack: [...state.redoStack, currentSnapshot],
    });
  },

  redo: () => {
    const state = get();
    if (state.redoStack.length === 0) return;
    const currentSnapshot = createSnapshot(state);
    const next = state.redoStack[state.redoStack.length - 1]!;
    set({
      tracks: next.tracks,
      clips: next.clips,
      duration: recalcDuration(next.clips),
      redoStack: state.redoStack.slice(0, -1),
      undoStack: [...state.undoStack, currentSnapshot],
    });
  },

  // ---- Reset ----

  reset: () => {
    clipIdCounter = 0;
    trackIdCounter = 0;
    set({
      tracks: [],
      clips: [],
      currentTime: 0,
      duration: 30,
      isPlaying: false,
      selectedClipIds: [],
      selectedTrackId: null,
      zoom: DEFAULT_ZOOM,
      aspectRatio: '16:9',
      isFullscreen: false,
      undoStack: [],
      redoStack: [],
      activeTool: 'select',
      activeToolPanel: null,
    });
  },
}));
</file>

<file path="components/VideoEditor/index.ts">
/**
 * VideoEditor ‚Äî Barrel Export
 */

export { VideoEditor } from './VideoEditor';
export { useVideoEditorStore } from './hooks/useVideoEditorStore';
export type {
  EditorTrack,
  EditorClip,
  EditorTrackType,
  TextStyle,
  AspectRatio,
  ActiveTool,
  ToolPanel,
  VideoEditorState,
} from './types/video-editor-types';
</file>

<file path="components/VideoEditor/MultiTrackTimeline.tsx">
/**
 * MultiTrackTimeline
 *
 * The timeline panel containing the time ruler, track lanes, and playhead.
 * Reuses TimeRuler, Playhead, and usePlayheadSeek from the existing timeline.
 */

import { useRef, useCallback, useMemo } from 'react';
import { TimeRuler } from '@/components/TimelineEditor/TimeRuler';
import { Playhead, usePlayheadSeek } from '@/components/TimelineEditor/Playhead';
import { useTimelineScroll } from '@/components/TimelineEditor/useTimelineScroll';
import type { EditorTrack, EditorClip } from './types/video-editor-types';
import { TrackRow } from './TrackRow';
import './video-editor.css';

interface MultiTrackTimelineProps {
  tracks: EditorTrack[];
  clips: EditorClip[];
  currentTime: number;
  duration: number;
  isPlaying: boolean;
  zoom: number;
  selectedClipIds: string[];
  onSeek: (time: number) => void;
  onSelectClip: (clipId: string) => void;
  onDeselectAll: () => void;
  onSelectTrack: (trackId: string) => void;
  onResizeStart?: (clipId: string, edge: 'left' | 'right', e: React.PointerEvent) => void;
}

export function MultiTrackTimeline({
  tracks,
  clips,
  currentTime,
  duration,
  isPlaying,
  zoom,
  selectedClipIds,
  onSeek,
  onSelectClip,
  onDeselectAll,
  onSelectTrack,
  onResizeStart,
}: MultiTrackTimelineProps) {
  const trackLanesContainerRef = useRef<HTMLDivElement>(null);

  // Reuse scroll sync hook from existing timeline
  const {
    scrollLeft,
    trackLanesRef,
    rulerRef,
    handleScroll,
  } = useTimelineScroll({
    currentTime,
    zoom,
    isPlaying,
    duration,
    autoScrollMargin: 100,
  });

  // Reuse playhead seek hook
  const {
    isAnimating,
    handleMouseDown: seekMouseDown,
    handleClick: seekClick,
  } = usePlayheadSeek({
    zoom,
    scrollLeft,
    duration,
    onSeek,
  });

  // Sort tracks by order
  const sortedTracks = useMemo(
    () => [...tracks].sort((a, b) => a.order - b.order),
    [tracks],
  );

  // Group clips by track
  const clipsByTrack = useMemo(() => {
    const map = new Map<string, EditorClip[]>();
    for (const track of tracks) {
      map.set(track.id, []);
    }
    for (const clip of clips) {
      const arr = map.get(clip.trackId);
      if (arr) arr.push(clip);
    }
    return map;
  }, [tracks, clips]);

  const totalWidth = Math.max(duration * zoom, 800);
  const trackHeight = 64; // --ve-track-height
  const totalTrackHeight = sortedTracks.length * trackHeight;

  // Create a combined ref handler for track lanes
  const setTrackLanesRef = useCallback((node: HTMLDivElement | null) => {
    // Update the scroll hook's ref
    (trackLanesRef as React.MutableRefObject<HTMLDivElement | null>).current = node;
    trackLanesContainerRef.current = node;
  }, [trackLanesRef]);

  return (
    <div className="ve-timeline-content">
      {/* Time ruler ‚Äî syncs scroll with track lanes */}
      <TimeRuler
        ref={rulerRef}
        duration={duration}
        zoom={zoom}
        scrollLeft={scrollLeft}
      />

      {/* Track lanes with playhead */}
      <div
        ref={setTrackLanesRef}
        className="ve-track-lanes"
        onScroll={handleScroll}
        onClick={seekClick}
        onMouseDown={seekMouseDown}
      >
        <div
          className="ve-track-lanes-inner"
          style={{ width: `${totalWidth}px` }}
        >
          {sortedTracks.map(track => (
            <TrackRow
              key={track.id}
              track={track}
              clips={clipsByTrack.get(track.id) ?? []}
              zoom={zoom}
              selectedClipIds={selectedClipIds}
              onSelectClip={onSelectClip}
              onLaneClick={() => {
                onDeselectAll();
                onSelectTrack(track.id);
              }}
              onResizeStart={onResizeStart}
            />
          ))}

          {/* Empty state when no tracks */}
          {sortedTracks.length === 0 && (
            <div className="ve-empty-state" style={{ height: '120px' }}>
              <p>Add tracks using the toolbar to get started</p>
            </div>
          )}
        </div>

        {/* Playhead overlay */}
        <Playhead
          currentTime={currentTime}
          zoom={zoom}
          scrollLeft={scrollLeft}
          height={Math.max(totalTrackHeight, 120)}
          duration={duration}
          isAnimating={isAnimating}
        />
      </div>
    </div>
  );
}
</file>

<file path="components/VideoEditor/ToolPanels.tsx">
/**
 * ToolPanels
 *
 * Content panels that appear when toolbar icons are toggled.
 * Layers, Templates, Audio, Text, and Media panels.
 */

import { useState } from 'react';
import {
  Plus, Video, Image as ImageIcon, Type, Music, Trash2,
  Eye, EyeOff, GripVertical,
} from 'lucide-react';
import type { EditorTrack, EditorTrackType, ToolPanel } from './types/video-editor-types';
import { DEFAULT_TEXT_STYLE } from './types/video-editor-types';
import './video-editor.css';

// ============================================================================
// Layers Panel
// ============================================================================

interface LayersPanelProps {
  tracks: EditorTrack[];
  onToggleVisibility: (trackId: string) => void;
  onRemoveTrack: (trackId: string) => void;
  onAddTrack: (type: EditorTrackType) => void;
}

function LayersPanel({ tracks, onToggleVisibility, onRemoveTrack, onAddTrack }: LayersPanelProps) {
  const sorted = [...tracks].sort((a, b) => a.order - b.order);

  return (
    <div className="ve-tool-panel">
      <div className="ve-tool-panel-header">Layers</div>
      <div style={{ padding: '8px' }}>
        {sorted.map(track => (
          <div
            key={track.id}
            style={{
              display: 'flex', alignItems: 'center', gap: '6px',
              padding: '6px 8px', borderRadius: '6px',
              background: 'rgba(255,255,255,0.03)', marginBottom: '4px',
            }}
          >
            <GripVertical size={12} style={{ opacity: 0.3, cursor: 'grab' }} />
            <span style={{ flex: 1, fontSize: '12px' }}>{track.name}</span>
            <button
              onClick={() => onToggleVisibility(track.id)}
              style={{ background: 'none', border: 'none', cursor: 'pointer', color: 'inherit', padding: '2px' }}
              aria-label={track.isVisible ? 'Hide' : 'Show'}
            >
              {track.isVisible ? <Eye size={12} /> : <EyeOff size={12} />}
            </button>
            <button
              onClick={() => onRemoveTrack(track.id)}
              style={{ background: 'none', border: 'none', cursor: 'pointer', color: '#ef4444', padding: '2px' }}
              aria-label="Remove track"
            >
              <Trash2 size={12} />
            </button>
          </div>
        ))}
        <div style={{ display: 'flex', gap: '4px', marginTop: '8px', flexWrap: 'wrap' }}>
          {(['video', 'image', 'text', 'audio'] as const).map(type => (
            <button
              key={type}
              onClick={() => onAddTrack(type)}
              style={{
                display: 'flex', alignItems: 'center', gap: '4px',
                padding: '4px 8px', borderRadius: '4px', fontSize: '11px',
                background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)',
                color: 'inherit', cursor: 'pointer',
              }}
            >
              <Plus size={10} /> {type}
            </button>
          ))}
        </div>
      </div>
    </div>
  );
}

// ============================================================================
// Text Panel
// ============================================================================

interface TextPanelProps {
  onAddTextClip: (text: string) => void;
}

function TextPanel({ onAddTextClip }: TextPanelProps) {
  const [text, setText] = useState('');

  const presets = [
    'Title Text',
    'Subtitle',
    'Lower Third',
    'Call to Action',
  ];

  return (
    <div className="ve-tool-panel">
      <div className="ve-tool-panel-header">Text</div>
      <div style={{ padding: '12px' }}>
        <input
          type="text"
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="Enter text..."
          style={{
            width: '100%', padding: '8px', borderRadius: '6px',
            background: 'rgba(0,0,0,0.3)', border: '1px solid rgba(255,255,255,0.1)',
            color: '#fff', fontSize: '13px', marginBottom: '8px',
          }}
          onKeyDown={(e) => {
            if (e.key === 'Enter' && text.trim()) {
              onAddTextClip(text.trim());
              setText('');
            }
          }}
        />
        <button
          onClick={() => {
            if (text.trim()) {
              onAddTextClip(text.trim());
              setText('');
            }
          }}
          style={{
            width: '100%', padding: '8px', borderRadius: '6px',
            background: 'rgba(59, 130, 246, 0.3)', border: '1px solid rgba(59, 130, 246, 0.5)',
            color: '#fff', fontSize: '12px', cursor: 'pointer', marginBottom: '12px',
          }}
        >
          <Type size={12} style={{ marginRight: '4px', verticalAlign: 'middle' }} />
          Add Text
        </button>

        <div style={{ fontSize: '10px', color: '#888', marginBottom: '6px', textTransform: 'uppercase', letterSpacing: '1px' }}>
          Presets
        </div>
        {presets.map(preset => (
          <button
            key={preset}
            onClick={() => onAddTextClip(preset)}
            style={{
              display: 'block', width: '100%', padding: '8px',
              borderRadius: '6px', marginBottom: '4px', textAlign: 'left',
              background: 'rgba(255,255,255,0.03)', border: '1px solid rgba(255,255,255,0.06)',
              color: '#ccc', fontSize: '12px', cursor: 'pointer',
            }}
          >
            {preset}
          </button>
        ))}
      </div>
    </div>
  );
}

// ============================================================================
// Media Panel
// ============================================================================

interface MediaPanelProps {
  onAddTrack: (type: EditorTrackType) => void;
}

function MediaPanel({ onAddTrack }: MediaPanelProps) {
  return (
    <div className="ve-tool-panel">
      <div className="ve-tool-panel-header">Media</div>
      <div style={{ padding: '12px' }}>
        <div className="ve-empty-state" style={{ height: '120px', border: '2px dashed rgba(255,255,255,0.1)', borderRadius: '8px' }}>
          <p style={{ fontSize: '12px' }}>Drop files here or import</p>
        </div>
        <div style={{ marginTop: '12px', display: 'flex', gap: '6px', flexWrap: 'wrap' }}>
          <button
            onClick={() => onAddTrack('video')}
            style={{
              display: 'flex', alignItems: 'center', gap: '4px',
              padding: '6px 10px', borderRadius: '6px', fontSize: '11px',
              background: 'rgba(20, 184, 166, 0.15)', border: '1px solid rgba(20, 184, 166, 0.3)',
              color: '#14b8a6', cursor: 'pointer',
            }}
          >
            <Video size={12} /> Video
          </button>
          <button
            onClick={() => onAddTrack('image')}
            style={{
              display: 'flex', alignItems: 'center', gap: '4px',
              padding: '6px 10px', borderRadius: '6px', fontSize: '11px',
              background: 'rgba(34, 197, 94, 0.15)', border: '1px solid rgba(34, 197, 94, 0.3)',
              color: '#22c55e', cursor: 'pointer',
            }}
          >
            <ImageIcon size={12} /> Image
          </button>
          <button
            onClick={() => onAddTrack('audio')}
            style={{
              display: 'flex', alignItems: 'center', gap: '4px',
              padding: '6px 10px', borderRadius: '6px', fontSize: '11px',
              background: 'rgba(249, 115, 22, 0.15)', border: '1px solid rgba(249, 115, 22, 0.3)',
              color: '#f97316', cursor: 'pointer',
            }}
          >
            <Music size={12} /> Audio
          </button>
        </div>
      </div>
    </div>
  );
}

// ============================================================================
// Audio Panel
// ============================================================================

function AudioPanel() {
  return (
    <div className="ve-tool-panel">
      <div className="ve-tool-panel-header">Audio</div>
      <div style={{ padding: '12px' }}>
        <div className="ve-empty-state" style={{ height: '80px' }}>
          <Music size={24} style={{ opacity: 0.3 }} />
          <p style={{ fontSize: '12px' }}>No audio files imported</p>
        </div>
      </div>
    </div>
  );
}

// ============================================================================
// Templates Panel
// ============================================================================

function TemplatesPanel() {
  return (
    <div className="ve-tool-panel">
      <div className="ve-tool-panel-header">Templates</div>
      <div style={{ padding: '12px' }}>
        <div className="ve-empty-state" style={{ height: '80px' }}>
          <p style={{ fontSize: '12px' }}>Templates coming soon</p>
        </div>
      </div>
    </div>
  );
}

// ============================================================================
// Panel Router
// ============================================================================

interface ToolPanelRouterProps {
  activePanel: ToolPanel;
  tracks: EditorTrack[];
  onToggleVisibility: (trackId: string) => void;
  onRemoveTrack: (trackId: string) => void;
  onAddTrack: (type: EditorTrackType) => void;
  onAddTextClip: (text: string) => void;
}

export function ToolPanelRouter({
  activePanel,
  tracks,
  onToggleVisibility,
  onRemoveTrack,
  onAddTrack,
  onAddTextClip,
}: ToolPanelRouterProps) {
  if (!activePanel) return null;

  switch (activePanel) {
    case 'layers':
      return <LayersPanel tracks={tracks} onToggleVisibility={onToggleVisibility} onRemoveTrack={onRemoveTrack} onAddTrack={onAddTrack} />;
    case 'text':
      return <TextPanel onAddTextClip={onAddTextClip} />;
    case 'media':
      return <MediaPanel onAddTrack={onAddTrack} />;
    case 'audio':
      return <AudioPanel />;
    case 'templates':
      return <TemplatesPanel />;
    default:
      return null;
  }
}
</file>

<file path="components/VideoEditor/TrackLabelPanel.tsx">
/**
 * TrackLabelPanel
 *
 * Left sidebar of the timeline showing track names, type icons,
 * lock/mute toggle buttons for each track.
 */

import {
  Video, Image, Type, Music,
  Lock, Unlock, Eye, EyeOff,
} from 'lucide-react';
import type { EditorTrack, EditorTrackType } from './types/video-editor-types';
import './video-editor.css';

const TRACK_ICONS: Record<EditorTrackType, React.ElementType> = {
  video: Video,
  image: Image,
  text: Type,
  audio: Music,
};

interface TrackLabelPanelProps {
  tracks: EditorTrack[];
  selectedTrackId: string | null;
  onSelectTrack: (trackId: string) => void;
  onToggleLock: (trackId: string) => void;
  onToggleVisibility: (trackId: string) => void;
}

export function TrackLabelPanel({
  tracks,
  selectedTrackId,
  onSelectTrack,
  onToggleLock,
  onToggleVisibility,
}: TrackLabelPanelProps) {
  const sorted = [...tracks].sort((a, b) => a.order - b.order);

  return (
    <div className="ve-track-labels" role="list" aria-label="Track labels">
      <div className="ve-track-label-spacer" />
      {sorted.map(track => {
        const Icon = TRACK_ICONS[track.type];
        return (
          <div
            key={track.id}
            className={`ve-track-label ${selectedTrackId === track.id ? 'selected' : ''}`}
            onClick={() => onSelectTrack(track.id)}
            role="listitem"
            aria-label={`${track.name} track`}
          >
            <div className="ve-track-label-icon">
              <Icon size={14} />
            </div>
            <span className="ve-track-label-name">{track.name}</span>
            <div className="ve-track-label-actions">
              <button
                className={`ve-track-action-btn ${track.isLocked ? 'active' : ''}`}
                onClick={(e) => { e.stopPropagation(); onToggleLock(track.id); }}
                title={track.isLocked ? 'Unlock track' : 'Lock track'}
                aria-label={track.isLocked ? 'Unlock track' : 'Lock track'}
              >
                {track.isLocked ? <Lock size={12} /> : <Unlock size={12} />}
              </button>
              <button
                className={`ve-track-action-btn ${!track.isVisible ? 'muted' : ''}`}
                onClick={(e) => { e.stopPropagation(); onToggleVisibility(track.id); }}
                title={track.isVisible ? 'Hide track' : 'Show track'}
                aria-label={track.isVisible ? 'Hide track' : 'Show track'}
              >
                {track.isVisible ? <Eye size={12} /> : <EyeOff size={12} />}
              </button>
            </div>
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="components/VideoEditor/TrackRow.tsx">
/**
 * TrackRow
 *
 * A single track lane in the timeline. Renders clips of the appropriate type
 * and handles click-to-seek on empty areas.
 */

import type { EditorTrack, EditorClip } from './types/video-editor-types';
import { TextClip } from './clips/TextClip';
import { VideoTrackClip } from './clips/VideoTrackClip';
import { ImageTrackClip } from './clips/ImageTrackClip';
import { AudioTrackClip } from './clips/AudioTrackClip';
import './video-editor.css';

interface TrackRowProps {
  track: EditorTrack;
  clips: EditorClip[];
  zoom: number;
  selectedClipIds: string[];
  onSelectClip: (clipId: string) => void;
  onLaneClick?: () => void;
  onSeekClick?: (e: React.MouseEvent) => void;
  onResizeStart?: (clipId: string, edge: 'left' | 'right', e: React.PointerEvent) => void;
}

export function TrackRow({
  track,
  clips,
  zoom,
  selectedClipIds,
  onSelectClip,
  onLaneClick,
  onSeekClick,
  onResizeStart,
}: TrackRowProps) {
  const handleLaneClick = (e: React.MouseEvent) => {
    // Only fire if clicking on the lane background, not on a clip
    if ((e.target as HTMLElement).closest('.ve-clip')) return;
    onLaneClick?.();
    onSeekClick?.(e);
  };

  const renderClip = (clip: EditorClip) => {
    const isSelected = selectedClipIds.includes(clip.id);
    const props = { clip, zoom, isSelected, onSelect: onSelectClip, onResizeStart };

    switch (clip.type) {
      case 'text': return <TextClip key={clip.id} {...props} />;
      case 'video': return <VideoTrackClip key={clip.id} {...props} />;
      case 'image': return <ImageTrackClip key={clip.id} {...props} />;
      case 'audio': return <AudioTrackClip key={clip.id} {...props} />;
      default: return null;
    }
  };

  return (
    <div
      className={`ve-lane ve-lane--${track.type}`}
      onClick={handleLaneClick}
      role="row"
      aria-label={`${track.name} lane`}
    >
      {clips.map(renderClip)}
    </div>
  );
}
</file>

<file path="components/VideoEditor/types/video-editor-types.ts">
/**
 * Video Editor Types
 *
 * Type definitions for the professional video editor component.
 * Defines the mutable clip/track model used for interactive editing.
 */

// ============================================================================
// Track Types
// ============================================================================

export type EditorTrackType = 'text' | 'video' | 'image' | 'audio';

export interface EditorTrack {
  id: string;
  type: EditorTrackType;
  name: string;
  isLocked: boolean;
  isMuted: boolean;
  isVisible: boolean;
  order: number;
}

// ============================================================================
// Clip Types
// ============================================================================

export interface TextStyle {
  fontFamily: string;
  fontSize: number;
  fontWeight: string;
  color: string;
  backgroundColor?: string;
  /** Normalized position 0-1 on canvas */
  position: { x: number; y: number };
  alignment: 'left' | 'center' | 'right';
}

export interface EditorClip {
  id: string;
  trackId: string;
  type: EditorTrackType;
  startTime: number;
  duration: number;
  name: string;

  // Video-specific
  thumbnailUrl?: string;
  sourceUrl?: string;

  // Image-specific
  imageUrl?: string;

  // Text-specific
  text?: string;
  textStyle?: TextStyle;

  // Audio-specific
  waveformData?: number[];

  // Trimming (source-relative)
  inPoint: number;
  outPoint: number;
}

// ============================================================================
// Editor State
// ============================================================================

export type AspectRatio = '16:9' | '9:16' | '1:1' | '4:3';
export type ActiveTool = 'select' | 'split' | 'text' | 'hand';
export type ToolPanel = 'layers' | 'templates' | 'audio' | 'text' | 'media' | null;

export interface EditorSnapshot {
  tracks: EditorTrack[];
  clips: EditorClip[];
}

export interface VideoEditorState {
  // Tracks and clips
  tracks: EditorTrack[];
  clips: EditorClip[];

  // Playback
  currentTime: number;
  duration: number;
  isPlaying: boolean;

  // Selection
  selectedClipIds: string[];
  selectedTrackId: string | null;

  // View
  zoom: number;
  aspectRatio: AspectRatio;
  isFullscreen: boolean;

  // Undo
  undoStack: EditorSnapshot[];
  redoStack: EditorSnapshot[];

  // Tool state
  activeTool: ActiveTool;
  activeToolPanel: ToolPanel;

  // Actions ‚Äî Tracks
  addTrack: (type: EditorTrackType, name?: string) => void;
  removeTrack: (trackId: string) => void;
  reorderTrack: (trackId: string, newOrder: number) => void;
  toggleTrackLock: (trackId: string) => void;
  toggleTrackMute: (trackId: string) => void;
  toggleTrackVisibility: (trackId: string) => void;

  // Actions ‚Äî Clips
  addClip: (clip: Omit<EditorClip, 'id'>) => void;
  removeClip: (clipId: string) => void;
  updateClip: (clipId: string, updates: Partial<EditorClip>) => void;
  moveClip: (clipId: string, newStartTime: number, newTrackId?: string) => void;
  resizeClip: (clipId: string, edge: 'left' | 'right', newTime: number) => void;
  splitClipAtPlayhead: (clipId: string) => void;

  // Actions ‚Äî Playback
  setCurrentTime: (time: number) => void;
  setIsPlaying: (playing: boolean) => void;
  togglePlayback: () => void;

  // Actions ‚Äî View
  setZoom: (zoom: number) => void;
  setAspectRatio: (ratio: AspectRatio) => void;
  setFullscreen: (fullscreen: boolean) => void;
  setActiveTool: (tool: ActiveTool) => void;
  setActiveToolPanel: (panel: ToolPanel) => void;

  // Actions ‚Äî Selection
  selectClip: (clipId: string, additive?: boolean) => void;
  selectTrack: (trackId: string | null) => void;
  deselectAll: () => void;

  // Actions ‚Äî Undo/Redo
  undo: () => void;
  redo: () => void;
  pushSnapshot: () => void;

  // Actions ‚Äî Reset
  reset: () => void;
}

// ============================================================================
// Constants
// ============================================================================

export const MIN_ZOOM = 10;
export const MAX_ZOOM = 200;
export const DEFAULT_ZOOM = 50;
export const MAX_UNDO_STACK = 50;

export const TRACK_COLORS: Record<EditorTrackType, {
  bg: string;
  border: string;
  clip: string;
  clipBorder: string;
  waveform: string;
}> = {
  text: {
    bg: 'rgba(59, 130, 246, 0.12)',
    border: 'rgba(59, 130, 246, 0.5)',
    clip: 'rgba(59, 130, 246, 0.25)',
    clipBorder: 'rgba(59, 130, 246, 0.6)',
    waveform: '#3b82f6',
  },
  video: {
    bg: 'rgba(20, 184, 166, 0.12)',
    border: 'rgba(20, 184, 166, 0.5)',
    clip: 'rgba(20, 184, 166, 0.25)',
    clipBorder: 'rgba(20, 184, 166, 0.6)',
    waveform: '#14b8a6',
  },
  image: {
    bg: 'rgba(34, 197, 94, 0.12)',
    border: 'rgba(34, 197, 94, 0.5)',
    clip: 'rgba(34, 197, 94, 0.25)',
    clipBorder: 'rgba(34, 197, 94, 0.6)',
    waveform: '#22c55e',
  },
  audio: {
    bg: 'rgba(249, 115, 22, 0.12)',
    border: 'rgba(249, 115, 22, 0.5)',
    clip: 'rgba(249, 115, 22, 0.2)',
    clipBorder: 'rgba(249, 115, 22, 0.5)',
    waveform: '#f97316',
  },
};

export const DEFAULT_TEXT_STYLE: TextStyle = {
  fontFamily: 'Inter',
  fontSize: 48,
  fontWeight: '700',
  color: '#ffffff',
  position: { x: 0.5, y: 0.5 },
  alignment: 'center',
};
</file>

<file path="components/VideoEditor/video-editor.css">
/* =============================================================================
   Video Editor - CSS Foundation
   Extends the graphite design tokens for the professional video editor layout
   ============================================================================= */

/* Import graphite tokens (already loaded via graphite-timeline.css) */

/* -----------------------------------------------------------------------------
   Additional Track Colors for Video Editor
   ----------------------------------------------------------------------------- */
:root {
  /* Text track ‚Äî blue */
  --track-text: rgba(59, 130, 246, 0.12);
  --track-text-border: rgba(59, 130, 246, 0.5);
  --track-text-clip: rgba(59, 130, 246, 0.25);

  /* Video track ‚Äî teal */
  --track-video-ed: rgba(20, 184, 166, 0.12);
  --track-video-ed-border: rgba(20, 184, 166, 0.5);
  --track-video-ed-clip: rgba(20, 184, 166, 0.25);

  /* Image track ‚Äî green */
  --track-image: rgba(34, 197, 94, 0.12);
  --track-image-border: rgba(34, 197, 94, 0.5);
  --track-image-clip: rgba(34, 197, 94, 0.25);

  /* Audio track ‚Äî orange */
  --track-audio-ed: rgba(249, 115, 22, 0.12);
  --track-audio-ed-border: rgba(249, 115, 22, 0.5);
  --track-audio-ed-clip: rgba(249, 115, 22, 0.2);

  /* Editor sizing */
  --ve-toolbar-width: 48px;
  --ve-panel-width: 280px;
  --ve-transport-height: 48px;
  --ve-track-height: 64px;
  --ve-clip-height: 48px;
  --ve-label-width: 160px;
}

/* -----------------------------------------------------------------------------
   Editor Layout
   ----------------------------------------------------------------------------- */
.video-editor {
  display: grid;
  grid-template-columns: var(--ve-toolbar-width) 1fr;
  grid-template-rows: 1fr var(--ve-transport-height) minmax(180px, 40vh);
  height: 100%;
  width: 100%;
  background: var(--graphite-bg);
  color: var(--graphite-text-main);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  overflow: hidden;
  position: relative;
}

/* When tool panel is open, add panel column */
.video-editor--panel-open {
  grid-template-columns: var(--ve-toolbar-width) var(--ve-panel-width) 1fr;
}

/* -----------------------------------------------------------------------------
   Left Tool Sidebar
   ----------------------------------------------------------------------------- */
.ve-toolbar {
  grid-row: 1 / -1;
  grid-column: 1;
  background: var(--graphite-deep);
  border-right: 1px solid var(--graphite-edge);
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 8px 0;
  gap: 2px;
  z-index: 20;
}

.ve-toolbar-btn {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  cursor: pointer;
  transition: all var(--graphite-transition-fast);
  color: var(--graphite-text-dim);
  background: transparent;
  border: none;
}

.ve-toolbar-btn:hover {
  background: var(--graphite-mid);
  color: var(--graphite-text-main);
}

.ve-toolbar-btn.active {
  background: rgba(0, 242, 255, 0.1);
  color: var(--plasma-cyan);
  box-shadow: inset 0 0 10px rgba(0, 242, 255, 0.1);
}

.ve-toolbar-btn:focus-visible {
  outline: 2px solid var(--focus-ring);
  outline-offset: -2px;
}

/* -----------------------------------------------------------------------------
   Tool Panel (slides out from toolbar)
   ----------------------------------------------------------------------------- */
.ve-tool-panel {
  grid-row: 1;
  grid-column: 2;
  background: var(--graphite-deep);
  border-right: 1px solid var(--graphite-edge);
  overflow-y: auto;
  overflow-x: hidden;
}

.ve-tool-panel-header {
  padding: 16px;
  font-size: 12px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--graphite-text-dim);
  border-bottom: 1px solid var(--graphite-edge);
}

/* -----------------------------------------------------------------------------
   Canvas Preview
   ----------------------------------------------------------------------------- */
.ve-preview {
  background: #000;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
}

.ve-preview-canvas {
  background: #000;
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

/* Aspect ratio badges */
.ve-aspect-badge {
  position: absolute;
  bottom: 8px;
  right: 8px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 10px;
  color: var(--graphite-text-dim);
  background: rgba(0, 0, 0, 0.6);
  padding: 2px 6px;
  border-radius: 4px;
}

/* -----------------------------------------------------------------------------
   Transport Bar
   ----------------------------------------------------------------------------- */
.ve-transport {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 0 12px;
  background: var(--graphite-deep);
  border-top: 1px solid var(--graphite-edge);
  border-bottom: 1px solid var(--graphite-edge);
  height: var(--ve-transport-height);
}

.ve-transport-group {
  display: flex;
  align-items: center;
  gap: 2px;
}

.ve-transport-divider {
  width: 1px;
  height: 24px;
  background: var(--graphite-edge);
  margin: 0 8px;
}

.ve-transport-spacer {
  flex: 1;
}

.ve-transport-btn {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 6px;
  cursor: pointer;
  transition: all var(--graphite-transition-fast);
  color: var(--graphite-text-dim);
  background: transparent;
  border: none;
}

.ve-transport-btn:hover {
  background: var(--graphite-mid);
  color: var(--graphite-text-main);
}

.ve-transport-btn.active {
  color: var(--plasma-cyan);
}

.ve-transport-btn.primary {
  color: var(--graphite-text-main);
  background: var(--graphite-mid);
}

.ve-transport-btn.primary:hover {
  background: var(--graphite-light);
}

.ve-transport-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.ve-transport-btn:focus-visible {
  outline: 2px solid var(--focus-ring);
  outline-offset: -2px;
}

.ve-timecode {
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  font-weight: 500;
  color: var(--graphite-text-main);
  padding: 4px 10px;
  background: rgba(0, 0, 0, 0.4);
  border-radius: 4px;
  border: 1px solid var(--graphite-edge);
  white-space: nowrap;
  min-width: 140px;
  text-align: center;
}

.ve-timecode-current {
  color: var(--plasma-cyan);
}

.ve-timecode-separator {
  color: var(--graphite-text-dim);
  margin: 0 2px;
}

/* Aspect ratio select */
.ve-aspect-select {
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  color: var(--graphite-text-dim);
  background: transparent;
  border: 1px solid var(--graphite-edge);
  border-radius: 4px;
  padding: 4px 8px;
  cursor: pointer;
}

.ve-aspect-select:hover {
  border-color: var(--graphite-text-dim);
}

/* Zoom slider in transport */
.ve-zoom-container {
  display: flex;
  align-items: center;
  gap: 6px;
  min-width: 100px;
}

.ve-zoom-slider {
  width: 80px;
  height: 3px;
  appearance: none;
  background: var(--graphite-mid);
  border-radius: 2px;
  outline: none;
  cursor: pointer;
}

.ve-zoom-slider::-webkit-slider-thumb {
  appearance: none;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--graphite-text-main);
  cursor: pointer;
}

.ve-zoom-slider::-moz-range-thumb {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--graphite-text-main);
  cursor: pointer;
  border: none;
}

/* -----------------------------------------------------------------------------
   Timeline Area (bottom panel)
   ----------------------------------------------------------------------------- */
.ve-timeline-area {
  display: flex;
  flex-direction: row;
  overflow: hidden;
  background: var(--graphite-bg);
}

/* Track Labels (left of timeline) */
.ve-track-labels {
  width: var(--ve-label-width);
  min-width: var(--ve-label-width);
  background: var(--graphite-deep);
  border-right: 1px solid rgba(255, 255, 255, 0.06);
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  z-index: 5;
  overflow: hidden;
}

.ve-track-label-spacer {
  height: var(--graphite-ruler-height);
  border-bottom: 1px solid var(--graphite-edge);
  flex-shrink: 0;
}

.ve-track-label {
  height: var(--ve-track-height);
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 0 8px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.03);
  cursor: pointer;
  transition: background var(--graphite-transition-fast);
}

.ve-track-label:hover {
  background: rgba(255, 255, 255, 0.03);
}

.ve-track-label.selected {
  background: rgba(0, 242, 255, 0.05);
}

.ve-track-label-icon {
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--graphite-text-dim);
  flex-shrink: 0;
}

.ve-track-label-name {
  font-size: 11px;
  font-weight: 500;
  color: var(--graphite-text-main);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  min-width: 0;
}

.ve-track-label-actions {
  display: flex;
  gap: 2px;
  opacity: 0;
  transition: opacity var(--graphite-transition-fast);
}

.ve-track-label:hover .ve-track-label-actions {
  opacity: 1;
}

.ve-track-action-btn {
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  cursor: pointer;
  color: var(--graphite-text-dim);
  background: transparent;
  border: none;
  padding: 0;
}

.ve-track-action-btn:hover {
  background: var(--graphite-mid);
  color: var(--graphite-text-main);
}

.ve-track-action-btn.active {
  color: var(--plasma-cyan);
}

.ve-track-action-btn.muted {
  color: var(--laser-red);
}

/* Timeline content */
.ve-timeline-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  min-width: 0;
}

/* Track lanes scroll container */
.ve-track-lanes {
  flex: 1;
  overflow-x: auto;
  overflow-y: hidden;
  position: relative;
}

.ve-track-lanes-inner {
  display: flex;
  flex-direction: column;
  min-width: 100%;
  position: relative;
}

/* Individual track lane */
.ve-lane {
  height: var(--ve-track-height);
  position: relative;
  display: flex;
  align-items: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.03);
}

.ve-lane--text {
  background: var(--track-text);
  border-left: 3px solid var(--track-text-border);
}

.ve-lane--video {
  background: var(--track-video-ed);
  border-left: 3px solid var(--track-video-ed-border);
}

.ve-lane--image {
  background: var(--track-image);
  border-left: 3px solid var(--track-image-border);
}

.ve-lane--audio {
  background: var(--track-audio-ed);
  border-left: 3px solid var(--track-audio-ed-border);
}

/* -----------------------------------------------------------------------------
   Clip Styles
   ----------------------------------------------------------------------------- */
.ve-clip {
  position: absolute;
  height: var(--ve-clip-height);
  top: 50%;
  transform: translateY(-50%);
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  overflow: hidden;
  transition: box-shadow var(--graphite-transition-fast), border-color var(--graphite-transition-fast);
  user-select: none;
}

.ve-clip:hover {
  z-index: 5;
}

.ve-clip.selected {
  border-color: var(--plasma-cyan) !important;
  box-shadow: 0 0 12px var(--plasma-glow);
  z-index: 10;
}

.ve-clip--text {
  background: var(--track-text-clip);
  border: 1px solid rgba(59, 130, 246, 0.4);
}

.ve-clip--video {
  background: var(--track-video-ed-clip);
  border: 1px solid rgba(20, 184, 166, 0.4);
}

.ve-clip--image {
  background: var(--track-image-clip);
  border: 1px solid rgba(34, 197, 94, 0.4);
}

.ve-clip--audio {
  background: var(--track-audio-ed-clip);
  border: 1px solid rgba(249, 115, 22, 0.3);
}

.ve-clip-name {
  font-size: 11px;
  font-weight: 500;
  padding: 0 8px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  color: var(--graphite-text-main);
  pointer-events: none;
}

/* Clip icon badge */
.ve-clip-icon {
  width: 16px;
  height: 16px;
  margin-left: 6px;
  flex-shrink: 0;
  opacity: 0.6;
}

/* Resize handles */
.ve-resize-handle {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 6px;
  cursor: ew-resize;
  z-index: 15;
  transition: background var(--graphite-transition-fast);
}

.ve-resize-handle:hover {
  background: rgba(0, 242, 255, 0.3);
}

.ve-resize-handle--left {
  left: 0;
  border-radius: 6px 0 0 6px;
}

.ve-resize-handle--right {
  right: 0;
  border-radius: 0 6px 6px 0;
}

/* Waveform in audio clips */
.ve-waveform {
  display: flex;
  align-items: center;
  gap: 1px;
  height: 100%;
  padding: 0 8px;
  flex: 1;
  overflow: hidden;
}

.ve-wave-bar {
  width: 2px;
  border-radius: 1px;
  opacity: 0.7;
  flex-shrink: 0;
}

/* Thumbnail strip in video clips */
.ve-thumb-strip {
  display: flex;
  height: 100%;
  overflow: hidden;
  flex: 1;
}

.ve-thumb-tile {
  width: 50px;
  height: 100%;
  background-size: cover;
  background-position: center;
  flex-shrink: 0;
  opacity: 0.7;
}

/* Image clip thumbnail */
.ve-image-thumb {
  height: 100%;
  width: 100%;
  object-fit: cover;
  opacity: 0.75;
}

/* Drag ghost */
.ve-clip.dragging {
  opacity: 0.6;
  pointer-events: none;
}

/* Empty state */
.ve-empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 8px;
  color: var(--graphite-text-dim);
  font-size: 13px;
  height: 100%;
}

.ve-empty-state-icon {
  width: 48px;
  height: 48px;
  opacity: 0.3;
}

/* -----------------------------------------------------------------------------
   Reduced Motion & High Contrast
   ----------------------------------------------------------------------------- */
@media (prefers-reduced-motion: reduce) {
  .ve-clip,
  .ve-toolbar-btn,
  .ve-transport-btn,
  .ve-track-label-actions {
    transition: none;
  }
}

@media (prefers-contrast: high) {
  .ve-clip.selected {
    outline: 3px solid var(--focus-ring);
  }
}
</file>

<file path="components/VideoEditor/VideoEditor.tsx">
/**
 * VideoEditor
 *
 * Top-level layout component for the professional video editor.
 * Orchestrates toolbar, canvas preview, transport bar, and multi-track timeline.
 *
 * Layout:
 * ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 * ‚îÇ Toolbar  ‚îÇ [Tool Panel?] ‚îÇ Canvas Preview      ‚îÇ
 * ‚îÇ (48px)   ‚îÇ (280px)       ‚îÇ                     ‚îÇ
 * ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 * ‚îÇ Enhanced Transport Bar                         ‚îÇ
 * ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 * ‚îÇ Track Labels ‚îÇ MultiTrack Timeline             ‚îÇ
 * ‚îÇ (160px)      ‚îÇ (TimeRuler + Tracks + Playhead) ‚îÇ
 * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 */

import { useCallback, useEffect, useRef } from 'react';
import { useVideoEditorStore } from './hooks/useVideoEditorStore';
import { VideoEditorToolbar } from './VideoEditorToolbar';
import { ToolPanelRouter } from './ToolPanels';
import { CanvasPreview } from './CanvasPreview';
import { EnhancedTransportBar } from './EnhancedTransportBar';
import { TrackLabelPanel } from './TrackLabelPanel';
import { MultiTrackTimeline } from './MultiTrackTimeline';
import type { EditorTrackType, ToolPanel } from './types/video-editor-types';
import { DEFAULT_TEXT_STYLE } from './types/video-editor-types';
import './video-editor.css';

const SKIP_INTERVAL = 5;

interface VideoEditorProps {
  className?: string;
}

export function VideoEditor({ className = '' }: VideoEditorProps) {
  const store = useVideoEditorStore();
  const containerRef = useRef<HTMLDivElement>(null);
  const playbackRef = useRef<number>(0);
  const lastTimeRef = useRef<number>(0);

  // ---- Playback Loop ----
  useEffect(() => {
    if (!store.isPlaying) return;
    lastTimeRef.current = performance.now();

    const tick = (now: number) => {
      const delta = (now - lastTimeRef.current) / 1000;
      lastTimeRef.current = now;
      const newTime = store.currentTime + delta;
      if (newTime >= store.duration) {
        store.setIsPlaying(false);
        store.setCurrentTime(store.duration);
        return;
      }
      store.setCurrentTime(newTime);
      playbackRef.current = requestAnimationFrame(tick);
    };

    playbackRef.current = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(playbackRef.current);
  }, [store.isPlaying]);

  // ---- Transport Handlers ----
  const handlePlayPause = useCallback(() => store.togglePlayback(), [store]);
  const handleSkipBack = useCallback(() => {
    store.setCurrentTime(Math.max(0, store.currentTime - SKIP_INTERVAL));
  }, [store]);
  const handleSkipForward = useCallback(() => {
    store.setCurrentTime(Math.min(store.duration, store.currentTime + SKIP_INTERVAL));
  }, [store]);

  const handleSplit = useCallback(() => {
    if (store.selectedClipIds.length === 1) {
      store.splitClipAtPlayhead(store.selectedClipIds[0]!);
    }
  }, [store]);

  // ---- Tool Panel ----
  const handlePanelToggle = useCallback((panel: NonNullable<ToolPanel>) => {
    store.setActiveToolPanel(panel);
  }, [store]);

  // ---- Add Text Clip ----
  const handleAddTextClip = useCallback((text: string) => {
    // Find or create a text track
    let textTrack = store.tracks.find(t => t.type === 'text');
    if (!textTrack) {
      store.addTrack('text');
      textTrack = useVideoEditorStore.getState().tracks.find(t => t.type === 'text');
    }
    if (!textTrack) return;

    store.addClip({
      trackId: textTrack.id,
      type: 'text',
      startTime: store.currentTime,
      duration: 3,
      name: text,
      text,
      textStyle: { ...DEFAULT_TEXT_STYLE },
      inPoint: 0,
      outPoint: 3,
    });
  }, [store]);

  // ---- Add Track ----
  const handleAddTrack = useCallback((type: EditorTrackType) => {
    store.addTrack(type);
  }, [store]);

  // ---- Resize Handler ----
  const handleResizeStart = useCallback((clipId: string, edge: 'left' | 'right', e: React.PointerEvent) => {
    e.stopPropagation();
    e.preventDefault();
    const target = e.currentTarget as HTMLElement;
    const laneElement = target.closest('.ve-track-lanes');
    if (!laneElement) return;

    const zoom = store.zoom;

    const onPointerMove = (moveEvent: PointerEvent) => {
      const rect = laneElement.getBoundingClientRect();
      const scrollLeft = (laneElement as HTMLElement).scrollLeft;
      const x = moveEvent.clientX - rect.left + scrollLeft;
      const newTime = Math.max(0, x / zoom);
      store.resizeClip(clipId, edge, newTime);
    };

    const onPointerUp = () => {
      document.removeEventListener('pointermove', onPointerMove);
      document.removeEventListener('pointerup', onPointerUp);
    };

    document.addEventListener('pointermove', onPointerMove);
    document.addEventListener('pointerup', onPointerUp);
  }, [store]);

  // ---- Keyboard Shortcuts ----
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Don't handle if typing in an input
      if ((e.target as HTMLElement).tagName === 'INPUT' || (e.target as HTMLElement).tagName === 'TEXTAREA') return;

      switch (e.key) {
        case ' ':
        case 'k':
          e.preventDefault();
          store.togglePlayback();
          break;
        case 'j':
        case 'ArrowLeft':
          e.preventDefault();
          store.setCurrentTime(Math.max(0, store.currentTime - (e.shiftKey ? 5 : 1)));
          break;
        case 'l':
        case 'ArrowRight':
          e.preventDefault();
          store.setCurrentTime(Math.min(store.duration, store.currentTime + (e.shiftKey ? 5 : 1)));
          break;
        case 'Home':
          e.preventDefault();
          store.setCurrentTime(0);
          break;
        case 'End':
          e.preventDefault();
          store.setCurrentTime(store.duration);
          break;
        case 's':
          if (!e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            handleSplit();
          }
          break;
        case 'z':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (e.shiftKey) store.redo();
            else store.undo();
          }
          break;
        case 'y':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            store.redo();
          }
          break;
        case 'Delete':
        case 'Backspace':
          if (store.selectedClipIds.length > 0) {
            e.preventDefault();
            for (const id of store.selectedClipIds) {
              store.removeClip(id);
            }
          }
          break;
        case 'Escape':
          store.deselectAll();
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [store, handleSplit]);

  const isPanelOpen = store.activeToolPanel !== null;

  return (
    <div
      ref={containerRef}
      className={`video-editor ${isPanelOpen ? 'video-editor--panel-open' : ''} ${className}`}
      role="application"
      aria-label="Video Editor"
      tabIndex={0}
    >
      {/* Left toolbar ‚Äî spans all rows */}
      <VideoEditorToolbar
        activePanel={store.activeToolPanel}
        onPanelToggle={handlePanelToggle}
      />

      {/* Tool panel (conditionally rendered between toolbar and preview) */}
      {isPanelOpen && (
        <ToolPanelRouter
          activePanel={store.activeToolPanel}
          tracks={store.tracks}
          onToggleVisibility={store.toggleTrackVisibility}
          onRemoveTrack={store.removeTrack}
          onAddTrack={handleAddTrack}
          onAddTextClip={handleAddTextClip}
        />
      )}

      {/* Canvas preview */}
      <CanvasPreview
        clips={store.clips}
        currentTime={store.currentTime}
        aspectRatio={store.aspectRatio}
        isPlaying={store.isPlaying}
        className={isPanelOpen ? '' : ''}
      />

      {/* Transport bar ‚Äî spans full width below preview */}
      <EnhancedTransportBar
        currentTime={store.currentTime}
        duration={store.duration}
        isPlaying={store.isPlaying}
        zoom={store.zoom}
        aspectRatio={store.aspectRatio}
        activeTool={store.activeTool}
        canUndo={store.undoStack.length > 0}
        canRedo={store.redoStack.length > 0}
        onPlayPause={handlePlayPause}
        onSkipBack={handleSkipBack}
        onSkipForward={handleSkipForward}
        onUndo={store.undo}
        onRedo={store.redo}
        onSplit={handleSplit}
        onZoomChange={store.setZoom}
        onAspectRatioChange={store.setAspectRatio}
        onFullscreen={() => {
          if (containerRef.current) {
            if (document.fullscreenElement) {
              document.exitFullscreen();
            } else {
              containerRef.current.requestFullscreen();
            }
          }
        }}
      />

      {/* Timeline area: labels + tracks */}
      <div
        className="ve-timeline-area"
        style={{ gridColumn: isPanelOpen ? '2 / -1' : '2 / -1' }}
      >
        <TrackLabelPanel
          tracks={store.tracks}
          selectedTrackId={store.selectedTrackId}
          onSelectTrack={store.selectTrack}
          onToggleLock={store.toggleTrackLock}
          onToggleVisibility={store.toggleTrackVisibility}
        />
        <MultiTrackTimeline
          tracks={store.tracks}
          clips={store.clips}
          currentTime={store.currentTime}
          duration={store.duration}
          isPlaying={store.isPlaying}
          zoom={store.zoom}
          selectedClipIds={store.selectedClipIds}
          onSeek={store.setCurrentTime}
          onSelectClip={(id) => store.selectClip(id)}
          onDeselectAll={store.deselectAll}
          onSelectTrack={store.selectTrack}
          onResizeStart={handleResizeStart}
        />
      </div>
    </div>
  );
}
</file>

<file path="components/VideoEditor/VideoEditorToolbar.tsx">
/**
 * VideoEditorToolbar
 *
 * Left sidebar with tool icons that toggle media/property panels.
 */

import { Layers, LayoutTemplate, Music, Type, Image } from 'lucide-react';
import type { ToolPanel } from './types/video-editor-types';
import './video-editor.css';

interface ToolbarItem {
  panel: ToolPanel;
  icon: React.ElementType;
  label: string;
}

const TOOLS: ToolbarItem[] = [
  { panel: 'layers', icon: Layers, label: 'Layers' },
  { panel: 'templates', icon: LayoutTemplate, label: 'Templates' },
  { panel: 'audio', icon: Music, label: 'Audio' },
  { panel: 'text', icon: Type, label: 'Text' },
  { panel: 'media', icon: Image, label: 'Media' },
];

interface VideoEditorToolbarProps {
  activePanel: ToolPanel;
  onPanelToggle: (panel: NonNullable<ToolPanel>) => void;
}

export function VideoEditorToolbar({ activePanel, onPanelToggle }: VideoEditorToolbarProps) {
  return (
    <div className="ve-toolbar" role="toolbar" aria-label="Editor tools">
      {TOOLS.map(({ panel, icon: Icon, label }) => (
        <button
          key={panel}
          className={`ve-toolbar-btn ${activePanel === panel ? 'active' : ''}`}
          onClick={() => onPanelToggle(panel!)}
          title={label}
          aria-label={label}
          aria-pressed={activePanel === panel}
        >
          <Icon size={18} />
        </button>
      ))}
    </div>
  );
}
</file>

<file path="components/VideoExportModal.tsx">
import React, { useEffect, useState } from "react";
import { SongData, TransitionType } from "@/types";
import {
  Download,
  Film,
  AlertCircle,
  Settings,
  Smartphone,
  Monitor,
  Cloud,
  Laptop,
  Blend,
  ZoomIn,
  ArrowRightLeft,
  CircleSlash,
  Sparkles,
  Type,
  Activity,
  Volume2,
} from "lucide-react";
import {
  exportVideoWithFFmpeg,
  exportVideoClientSide,
  ExportProgress,
  ExportConfig,
} from "@/services/ffmpeg";
import { VideoSFXPlan } from "@/types";
import { SceneAudioInfo } from "@/services/audioMixerService";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Label } from "@/components/ui/label";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import { Card, CardContent } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { cn, isRTL } from "@/lib/utils";

interface VideoExportModalProps {
  songData: SongData;
  onClose: () => void;
  isOpen: boolean;
  /** Content mode - "music" includes visualizer, "story" skips it */
  contentMode?: "music" | "story";
  /** SFX plan with audio URLs for mixing */
  sfxPlan?: VideoSFXPlan | null;
  /** Scene timing information for SFX mixing */
  sceneTimings?: SceneAudioInfo[];
}

/**
 * Detect if the song's lyrics are primarily RTL (Arabic, Hebrew, etc.)
 */
function detectLyricsRTL(songData: SongData): boolean {
  if (!songData.parsedSubtitles || songData.parsedSubtitles.length === 0) {
    return false;
  }
  // Check first few subtitles to determine primary text direction
  const samplesToCheck = Math.min(5, songData.parsedSubtitles.length);
  let rtlCount = 0;
  for (let i = 0; i < samplesToCheck; i++) {
    const subtitle = songData.parsedSubtitles[i];
    if (subtitle && isRTL(subtitle.text)) {
      rtlCount++;
    }
  }
  // If majority of samples are RTL, consider the content RTL
  return rtlCount > samplesToCheck / 2;
}

export const VideoExportModal: React.FC<VideoExportModalProps> = ({
  songData,
  onClose,
  isOpen,
  contentMode = "music",
  sfxPlan,
  sceneTimings,
}) => {
  const [exportProgress, setExportProgress] = useState<ExportProgress>({
    stage: "loading",
    progress: 0,
    message: "Initializing...",
  });
  const [videoBlobUrl, setVideoBlobUrl] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Auto-detect RTL for text animation direction
  const isLyricsRTL = detectLyricsRTL(songData);

  // Check if SFX mixing is available
  const hasSFX = !!(sfxPlan && sceneTimings && sceneTimings.length > 0 &&
    sfxPlan.scenes.some(s => s.ambientTrack?.audioUrl));

  // Configuration State
  const [config, setConfig] = useState<ExportConfig>({
    orientation: "landscape",
    useModernEffects: true,
    syncOffsetMs: -50,
    fadeOutBeforeCut: true,
    wordLevelHighlight: true,
    contentMode: contentMode,
    transitionType: "dissolve",
    transitionDuration: 1.5,
    visualizerConfig: {
      enabled: true,
      opacity: 0.15,
      maxHeightRatio: 0.25,
      zIndex: 1,
      barWidth: 3,
      barGap: 2,
      colorScheme: "cyan-purple",
    },
    textAnimationConfig: {
      revealDirection: isLyricsRTL ? "rtl" : "ltr", // Auto-detect based on lyrics
      revealDuration: 0.3,
      wordReveal: true,
    },
    // SFX config
    sfxPlan: sfxPlan,
    sceneTimings: sceneTimings,
    sfxMasterVolume: 1.0,
    musicMasterVolume: 0.5,
  });
  const [isExporting, setIsExporting] = useState(false);
  const [useCloudRender, setUseCloudRender] = useState(true); // Default to server-side for faster encoding
  const [enableSFX, setEnableSFX] = useState(hasSFX);

  // Cleanup blob URL on unmount
  useEffect(() => {
    return () => {
      if (videoBlobUrl) URL.revokeObjectURL(videoBlobUrl);
    };
  }, [videoBlobUrl]);

  const startExport = async () => {
    // Validate audio URL before starting export
    if (!songData.audioUrl) {
      setError("No audio available for export. Please wait for audio generation to complete.");
      return;
    }

    setIsExporting(true);
    setError(null);
    setVideoBlobUrl(null);

    try {
      // Build export config with SFX if enabled
      const exportConfig: ExportConfig = {
        ...config,
        // Only include SFX data if enabled
        sfxPlan: enableSFX ? sfxPlan : null,
        sceneTimings: enableSFX ? sceneTimings : undefined,
      };

      const exportFn = useCloudRender
        ? exportVideoWithFFmpeg
        : exportVideoClientSide;
      const result = await exportFn(
        songData,
        (progress) => {
          setExportProgress(progress);
        },
        exportConfig,
      );

      const url = URL.createObjectURL(result.blob);
      setVideoBlobUrl(url);
    } catch (e: any) {
      console.error("Export failed:", e);
      setError(e.message || "Export failed. Please try again.");
      setIsExporting(false);
    }
  };

  const handleDownload = () => {
    if (videoBlobUrl) {
      const a = document.createElement("a");
      a.href = videoBlobUrl;
      a.download = `${songData.fileName.replace(/\.[^/.]+$/, "")}-lyriclens-${config.orientation}.mp4`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
  };

  const isComplete = exportProgress.stage === "complete" && videoBlobUrl;

  const getStageLabel = () => {
    switch (exportProgress.stage) {
      case "loading":
        return "Loading FFmpeg";
      case "preparing":
        return "Preparing Assets";
      case "rendering":
        return "Rendering Frames";
      case "encoding":
        return "Encoding Video";
      case "complete":
        return "Complete";
      default:
        return "Processing";
    }
  };

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => !open && !isExporting && onClose()}
    >
      <DialogContent className="sm:max-w-md md:max-w-lg glass-panel border-white/10 text-foreground">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2 text-xl">
            <Film className="w-5 h-5 text-primary" />
            {isComplete
              ? "Video Ready!"
              : isExporting
                ? "Exporting Video"
                : "Export Settings"}
          </DialogTitle>
          <DialogDescription className="text-muted-foreground">
            {!isExporting &&
              !isComplete &&
              "Customize your video export settings."}
            {isExporting &&
              !isComplete &&
              "Please wait while we render your video."}
            {isComplete && "Your video has been successfully generated."}
          </DialogDescription>
        </DialogHeader>

        <div className="py-4">
          {error ? (
            <div className="bg-destructive/10 border border-destructive/20 rounded-xl p-6 text-center mb-6">
              <AlertCircle className="w-12 h-12 text-destructive mx-auto mb-3" />
              <p className="text-destructive mb-4">{error}</p>
              <Button variant="destructive" onClick={() => setError(null)}>
                Try Again
              </Button>
            </div>
          ) : isExporting && !isComplete ? (
            <div className="space-y-6">
              <div className="flex justify-between text-xs uppercase tracking-wider">
                <span className="text-primary font-medium">
                  {getStageLabel()}
                </span>
                <span className="text-muted-foreground">
                  {Math.round(exportProgress.progress)}%
                </span>
              </div>

              <Progress value={exportProgress.progress} className="h-2" />

              <p className="text-sm text-muted-foreground text-center animate-pulse">
                {exportProgress.message}
              </p>

              <div className="grid grid-cols-5 gap-1 pt-2">
                {[
                  "loading",
                  "preparing",
                  "rendering",
                  "encoding",
                  "complete",
                ].map((stage, i) => {
                  const stages = [
                    "loading",
                    "preparing",
                    "rendering",
                    "encoding",
                    "complete",
                  ];
                  const currentIdx = stages.indexOf(exportProgress.stage);
                  const stageIdx = stages.indexOf(stage);
                  const isActive = stageIdx <= currentIdx;

                  return (
                    <div
                      key={stage}
                      className="flex flex-col items-center gap-1"
                    >
                      <div
                        className={cn(
                          "w-2 h-2 rounded-full transition-colors",
                          isActive ? "bg-primary" : "bg-muted",
                        )}
                      />
                      <span
                        className={cn(
                          "text-[9px] capitalize",
                          isActive ? "text-primary" : "text-muted-foreground",
                        )}
                      >
                        {stage}
                      </span>
                    </div>
                  );
                })}
              </div>
            </div>
          ) : isComplete ? (
            <div className="space-y-6">
              {videoBlobUrl && (
                <div className="relative aspect-video rounded-lg overflow-hidden bg-black border border-border">
                  <video
                    src={videoBlobUrl}
                    controls
                    className="w-full h-full"
                  />
                </div>
              )}

              <div className="flex flex-col gap-2">
                <Button
                  onClick={handleDownload}
                  className="w-full bg-primary hover:bg-primary/90 text-primary-foreground font-bold border-0"
                >
                  <Download className="mr-2 h-4 w-4" /> Download MP4
                </Button>
                <Button
                  variant="ghost"
                  className="text-muted-foreground hover:text-foreground"
                  onClick={() => {
                    setIsExporting(false);
                    setExportProgress({
                      stage: "loading",
                      progress: 0,
                      message: "Initializing...",
                    });
                    setVideoBlobUrl(null);
                  }}
                >
                  Export Another Version
                </Button>
              </div>
            </div>
          ) : (
            <div className="space-y-6">
              {/* Render Engine */}
              <div className="space-y-3">
                <Label className="text-muted-foreground">Render Engine</Label>
                <div className="grid grid-cols-2 gap-4">
                  <Card
                    className={cn(
                      "cursor-pointer transition-all border-white/10 hover:bg-white/5",
                      !useCloudRender && "border-primary bg-primary/10",
                    )}
                    onClick={() => setUseCloudRender(false)}
                  >
                    <CardContent className="flex flex-col items-center justify-center p-4 gap-2">
                      <Laptop
                        className={cn(
                          "h-6 w-6",
                          !useCloudRender
                            ? "text-primary"
                            : "text-muted-foreground",
                        )}
                      />
                      <div className="text-center">
                        <span className="text-sm font-medium">Browser</span>
                        <span className="text-[10px] text-muted-foreground block">
                          Private, No Upload
                        </span>
                      </div>
                    </CardContent>
                  </Card>
                  <Card
                    className={cn(
                      "cursor-pointer transition-all border-white/10 hover:bg-white/5",
                      useCloudRender && "border-primary bg-primary/10",
                    )}
                    onClick={() => setUseCloudRender(true)}
                  >
                    <CardContent className="flex flex-col items-center justify-center p-4 gap-2">
                      <Cloud
                        className={cn(
                          "h-6 w-6",
                          useCloudRender
                            ? "text-primary"
                            : "text-muted-foreground",
                        )}
                      />
                      <div className="text-center">
                        <span className="text-sm font-medium">Cloud</span>
                        <span className="text-[10px] text-muted-foreground block">
                          Faster for 4K
                        </span>
                      </div>
                    </CardContent>
                  </Card>
                </div>
              </div>

              {/* Orientation */}
              <div className="space-y-3">
                <Label className="text-muted-foreground">
                  Video Orientation
                </Label>
                <div className="grid grid-cols-2 gap-4">
                  <Card
                    className={cn(
                      "cursor-pointer transition-all border-white/10 hover:bg-white/5",
                      config.orientation === "landscape" &&
                      "border-primary bg-primary/10",
                    )}
                    onClick={() =>
                      setConfig({ ...config, orientation: "landscape" })
                    }
                  >
                    <CardContent className="flex flex-col items-center justify-center p-4 gap-2">
                      <Monitor
                        className={cn(
                          "h-6 w-6",
                          config.orientation === "landscape"
                            ? "text-primary"
                            : "text-muted-foreground",
                        )}
                      />
                      <span className="text-sm font-medium">
                        Landscape (16:9)
                      </span>
                    </CardContent>
                  </Card>
                  <Card
                    className={cn(
                      "cursor-pointer transition-all border-white/10 hover:bg-white/5",
                      config.orientation === "portrait" &&
                      "border-primary bg-primary/10",
                    )}
                    onClick={() =>
                      setConfig({ ...config, orientation: "portrait" })
                    }
                  >
                    <CardContent className="flex flex-col items-center justify-center p-4 gap-2">
                      <Smartphone
                        className={cn(
                          "h-6 w-6",
                          config.orientation === "portrait"
                            ? "text-primary"
                            : "text-muted-foreground",
                        )}
                      />
                      <span className="text-sm font-medium">
                        Portrait (9:16)
                      </span>
                    </CardContent>
                  </Card>
                </div>
              </div>

              {/* Visual Style */}
              <div className="flex items-center justify-between space-x-2 p-3 rounded-lg border border-white/10 bg-white/5">
                <div className="space-y-0.5">
                  <Label className="text-base text-foreground flex items-center gap-2">
                    <Settings className="w-4 h-4 text-primary" /> Cinematic
                    Effects
                  </Label>
                  <p className="text-xs text-muted-foreground">
                    Ken Burns zoom, smooth transitions, glow
                  </p>
                </div>
                <Switch
                  checked={config.useModernEffects}
                  onCheckedChange={(checked) =>
                    setConfig({ ...config, useModernEffects: checked })
                  }
                  className="data-[state=checked]:bg-primary"
                />
              </div>

              {/* Transition Type */}
              <div className="space-y-3">
                <Label className="text-muted-foreground">Scene Transitions</Label>
                <div className="grid grid-cols-5 gap-2">
                  {[
                    { value: "none", label: "Cut", icon: CircleSlash },
                    { value: "fade", label: "Fade", icon: Sparkles },
                    { value: "dissolve", label: "Dissolve", icon: Blend },
                    { value: "zoom", label: "Zoom", icon: ZoomIn },
                    { value: "slide", label: "Slide", icon: ArrowRightLeft },
                  ].map(({ value, label, icon: Icon }) => (
                    <button
                      key={value}
                      onClick={() => setConfig({ ...config, transitionType: value as TransitionType })}
                      className={cn(
                        "flex flex-col items-center gap-1 p-2 rounded-lg border transition-all text-xs",
                        config.transitionType === value
                          ? "border-primary bg-primary/10 text-primary"
                          : "border-border bg-card text-muted-foreground hover:border-primary/30"
                      )}
                    >
                      <Icon size={16} />
                      <span>{label}</span>
                    </button>
                  ))}
                </div>
              </div>

              <div className="space-y-4 pt-2 border-t border-border/50">
                <Label className="text-muted-foreground">Lyric Animation</Label>

                <div className="space-y-3">
                  <div className="flex justify-between">
                    <span className="text-xs text-muted-foreground">
                      Sync Offset
                    </span>
                    <span className="text-xs text-primary font-mono">
                      {config.syncOffsetMs}ms
                    </span>
                  </div>
                  <Slider
                    min={-200}
                    max={100}
                    step={10}
                    value={[config.syncOffsetMs]}
                    onValueChange={(vals) =>
                      setConfig({ ...config, syncOffsetMs: vals[0] ?? -50 })
                    }
                    className="py-2"
                  />
                  <p className="text-[10px] text-muted-foreground">
                    Negative values make lyrics appear earlier.
                  </p>
                </div>

                <div className="flex items-center justify-between space-x-2">
                  <div className="space-y-0.5">
                    <Label className="text-sm text-muted-foreground">
                      Word-by-Word Karaoke
                    </Label>
                    <p className="text-xs text-muted-foreground">
                      Highlight each word as it's sung
                    </p>
                  </div>
                  <Switch
                    checked={config.wordLevelHighlight}
                    onCheckedChange={(checked) =>
                      setConfig({ ...config, wordLevelHighlight: checked })
                    }
                  />
                </div>

                <div className="flex items-center justify-between space-x-2">
                  <div className="space-y-0.5">
                    <Label className="text-sm text-muted-foreground">
                      Fade Before Scene Change
                    </Label>
                    <p className="text-xs text-muted-foreground">
                      Lyrics fade out before transitions
                    </p>
                  </div>
                  <Switch
                    checked={config.fadeOutBeforeCut}
                    onCheckedChange={(checked) =>
                      setConfig({ ...config, fadeOutBeforeCut: checked })
                    }
                  />
                </div>

                {/* NEW: Visualizer Settings */}
                <div className="space-y-4 pt-4 border-t border-border/50">
                  <div className="flex items-center justify-between">
                    <Label className="text-muted-foreground flex items-center gap-2">
                      <Activity className="w-4 h-4" /> Audio Visualizer
                    </Label>
                    <Switch
                      checked={config.visualizerConfig?.enabled}
                      onCheckedChange={(checked) =>
                        setConfig({
                          ...config,
                          visualizerConfig: config.visualizerConfig ? {
                            ...config.visualizerConfig,
                            enabled: checked,
                          } : undefined,
                        })
                      }
                    />
                  </div>

                  {config.visualizerConfig?.enabled && (
                    <div className="space-y-4 pl-6">
                      <div className="space-y-2">
                        <div className="flex justify-between">
                          <span className="text-[10px] text-muted-foreground uppercase">Opacity</span>
                          <span className="text-[10px] font-mono">{Math.round((config.visualizerConfig?.opacity ?? 0.15) * 100)}%</span>
                        </div>
                        <Slider
                          min={0.05}
                          max={0.5}
                          step={0.01}
                          value={[config.visualizerConfig?.opacity ?? 0.15]}
                          onValueChange={([val]) =>
                            setConfig({
                              ...config,
                              visualizerConfig: config.visualizerConfig ? { ...config.visualizerConfig, opacity: val ?? 0.15 } : undefined,
                            })
                          }
                        />
                      </div>

                      <div className="space-y-2">
                        <div className="flex justify-between">
                          <span className="text-[10px] text-muted-foreground uppercase">Max Height</span>
                          <span className="text-[10px] font-mono">{Math.round((config.visualizerConfig?.maxHeightRatio ?? 0.25) * 100)}%</span>
                        </div>
                        <Slider
                          min={0.1}
                          max={0.5}
                          step={0.05}
                          value={[config.visualizerConfig?.maxHeightRatio ?? 0.25]}
                          onValueChange={([val]) =>
                            setConfig({
                              ...config,
                              visualizerConfig: config.visualizerConfig ? { ...config.visualizerConfig, maxHeightRatio: val ?? 0.25 } : undefined,
                            })
                          }
                        />
                      </div>

                      <div className="space-y-2">
                        <span className="text-[10px] text-muted-foreground uppercase block mb-1">Color Scheme</span>
                        <div className="grid grid-cols-3 gap-2">
                          {(["cyan-purple", "rainbow", "monochrome"] as const).map((scheme) => (
                            <Button
                              key={scheme}
                              variant="glass"
                              size="sm"
                              className={cn(
                                "text-[10px] h-7 px-2",
                                config.visualizerConfig?.colorScheme === scheme && "border-primary bg-primary/10"
                              )}
                              onClick={() =>
                                setConfig({
                                  ...config,
                                  visualizerConfig: config.visualizerConfig ? { ...config.visualizerConfig, colorScheme: scheme } : undefined,
                                })
                              }
                            >
                              {scheme.replace("-", " ")}
                            </Button>
                          ))}
                        </div>
                      </div>
                    </div>
                  )}
                </div>

                {/* NEW: Text Animation Settings */}
                <div className="space-y-4 pt-4 border-t border-border/50">
                  <Label className="text-muted-foreground flex items-center gap-2">
                    <Type className="w-4 h-4" /> Text Reveal Animation
                  </Label>

                  <div className="grid grid-cols-2 gap-4">
                    <div className="space-y-1.5">
                      <span className="text-[10px] text-muted-foreground uppercase">Direction</span>
                      <Select
                        value={config.textAnimationConfig?.revealDirection}
                        onValueChange={(val: "ltr" | "rtl" | "center-out" | "center-in") =>
                          setConfig({
                            ...config,
                            textAnimationConfig: config.textAnimationConfig ? { ...config.textAnimationConfig, revealDirection: val } : undefined,
                          })
                        }
                      >
                        <SelectTrigger className="h-8 text-xs">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="ltr">Left to Right</SelectItem>
                          <SelectItem value="rtl">Right to Left</SelectItem>
                          <SelectItem value="center-out">Center Out</SelectItem>
                          <SelectItem value="center-in">Center In</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>

                    <div className="space-y-1.5">
                      <span className="text-[10px] text-muted-foreground uppercase">Speed (s)</span>
                      <div className="flex items-center gap-2">
                        <Slider
                          min={0.1}
                          max={1.0}
                          step={0.1}
                          value={[config.textAnimationConfig?.revealDuration || 0.3]}
                          onValueChange={([val]) =>
                            setConfig({
                              ...config,
                              textAnimationConfig: config.textAnimationConfig ? { ...config.textAnimationConfig, revealDuration: val ?? 0.3 } : undefined,
                            })
                          }
                          className="flex-1"
                        />
                        <span className="text-[10px] font-mono w-6">
                          {config.textAnimationConfig?.revealDuration}s
                        </span>
                      </div>
                    </div>
                  </div>
                </div>

                {/* SFX Audio Mixing Settings */}
                {hasSFX && (
                  <div className="space-y-4 pt-4 border-t border-border/50">
                    <div className="flex items-center justify-between">
                      <Label className="text-muted-foreground flex items-center gap-2">
                        <Volume2 className="w-4 h-4" /> Ambient SFX
                      </Label>
                      <Switch
                        checked={enableSFX}
                        onCheckedChange={setEnableSFX}
                      />
                    </div>

                    {enableSFX && (
                      <div className="space-y-4 pl-6">
                        <div className="space-y-2">
                          <div className="flex justify-between">
                            <span className="text-[10px] text-muted-foreground uppercase">SFX Volume</span>
                            <span className="text-[10px] font-mono">{Math.round((config.sfxMasterVolume || 1.0) * 100)}%</span>
                          </div>
                          <Slider
                            min={0}
                            max={1}
                            step={0.05}
                            value={[config.sfxMasterVolume || 1.0]}
                            onValueChange={([val]) =>
                              setConfig({ ...config, sfxMasterVolume: val ?? 1.0 })
                            }
                          />
                        </div>

                        {sfxPlan?.backgroundMusic && (
                          <div className="space-y-2">
                            <div className="flex justify-between">
                              <span className="text-[10px] text-muted-foreground uppercase">Music Volume</span>
                              <span className="text-[10px] font-mono">{Math.round((config.musicMasterVolume || 0.5) * 100)}%</span>
                            </div>
                            <Slider
                              min={0}
                              max={1.0}
                              step={0.05}
                              value={[config.musicMasterVolume || 0.5]}
                              onValueChange={([val]) =>
                                setConfig({ ...config, musicMasterVolume: val ?? 0.5 })
                              }
                            />
                          </div>
                        )}

                        <p className="text-[10px] text-muted-foreground">
                          üéµ {sfxPlan?.scenes.filter(s => s.ambientTrack?.audioUrl).length || 0} scene sounds will be mixed
                          {sfxPlan?.backgroundMusic?.audioUrl && " + background music"}
                        </p>
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>

        <DialogFooter className="sm:justify-between">
          {!isExporting && !isComplete && (
            <Button
              className="w-full bg-primary hover:bg-primary/90 text-primary-foreground font-bold border-0 h-11"
              onClick={startExport}
            >
              <Film className="mr-2 h-4 w-4" /> Start Export
            </Button>
          )}
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};
</file>

<file path="components/VideoPreviewCard.tsx">
/**
 * VideoPreviewCard - Video preview with scene thumbnails
 *
 * Displays the current scene with playback controls and
 * a horizontal scrollable thumbnail strip for scene navigation.
 * Includes a full transport bar (seek, skip, volume, fullscreen)
 * and a "N / M Videos generated" counter badge.
 *
 * When `currentVisual` is a video, the internal <video> ref drives the
 * transport bar ‚Äî callers get `currentTime` / `onSeek` / `onPlayPause`
 * callbacks but can also leave them unset and the card self-manages.
 */

import React, { useRef, useState, useEffect, useCallback } from 'react';
import { motion } from 'framer-motion';
import {
  Video, Play, Pause, Loader2, CheckCircle2,
  SkipBack, SkipForward, ChevronFirst, Volume2, VolumeX, Maximize,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import type { Scene } from '@/types';

export interface VideoPreviewCardProps {
  /** List of scenes to display */
  scenes: Scene[];
  /** Map of scene ID to visual URL */
  visualsMap: Record<string, string | undefined>;
  /** Currently selected scene index */
  currentSceneIndex: number;
  /** Callback when scene is selected */
  onSceneSelect: (index: number) => void;
  /** Whether video is currently playing (controlled externally; ignored when self-managing) */
  isPlaying: boolean;
  /** Callback to toggle play/pause */
  onPlayPause: () => void;
  /** Whether video is ready for export */
  isReady?: boolean;
  /** Total duration in seconds */
  totalDuration?: number;
  /** Text for "scenes" label */
  scenesLabel?: string;
  /** Text for "done" status */
  doneLabel?: string;
  /** RTL layout */
  isRTL?: boolean;
  /** Additional class names */
  className?: string;

  // Transport bar ‚Äî caller-controlled (optional; if omitted the card self-manages via videoRef)
  currentTime?: number;
  onSeek?: (time: number) => void;
  onSkipToStart?: () => void;
  onSkipPrev?: () => void;
  onSkipNext?: () => void;
  volume?: number;
  onVolumeChange?: (v: number) => void;
  onFullscreen?: () => void;

  // Generation counter + Generate Video button
  videosGeneratedCount?: number;
  totalVideos?: number;
  onGenerateVideo?: () => void;
}

function formatTime(secs: number): string {
  const s = Math.floor(secs);
  const m = Math.floor(s / 60);
  return `${m}:${String(s % 60).padStart(2, '0')}`;
}

export function VideoPreviewCard({
  scenes,
  visualsMap,
  currentSceneIndex,
  onSceneSelect,
  isPlaying,
  onPlayPause,
  isReady = false,
  totalDuration = 0,
  scenesLabel = 'Scenes',
  doneLabel = 'Ready',
  isRTL = false,
  className,
  currentTime: externalCurrentTime,
  onSeek: externalOnSeek,
  onSkipToStart,
  onSkipPrev,
  onSkipNext,
  volume: externalVolume,
  onVolumeChange: externalOnVolumeChange,
  onFullscreen,
  videosGeneratedCount,
  totalVideos,
  onGenerateVideo,
}: VideoPreviewCardProps) {
  const currentScene = scenes[currentSceneIndex];
  const currentVisual = currentScene ? visualsMap[currentScene.id] : undefined;
  const isVideoSrc = !!(
    currentVisual &&
    (currentVisual.match(/\.(mp4|webm)$/i) ||
      currentVisual.includes('generativelanguage.googleapis.com'))
  );

  // Internal state for self-managed playback (only used when currentVisual is a <video>)
  const videoRef = useRef<HTMLVideoElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [internalTime, setInternalTime] = useState(0);
  const [internalDuration, setInternalDuration] = useState(0);
  const [internalVolume, setInternalVolume] = useState(1);
  const [internalPlaying, setInternalPlaying] = useState(false);

  // Whether we self-manage (no external seek wired)
  const selfManaged = isVideoSrc && !externalOnSeek;

  const currentTime = selfManaged ? internalTime : (externalCurrentTime ?? 0);
  const duration = selfManaged ? internalDuration : (totalDuration || 0);
  const volume = selfManaged ? internalVolume : (externalVolume ?? 1);
  const playing = selfManaged ? internalPlaying : isPlaying;

  // Sync video element play/pause with external isPlaying when not self-managed
  useEffect(() => {
    if (!videoRef.current || selfManaged) return;
    if (isPlaying) {
      videoRef.current.play().catch(() => {});
    } else {
      videoRef.current.pause();
    }
  }, [isPlaying, selfManaged]);

  // Sync volume to video element
  useEffect(() => {
    if (videoRef.current) {
      videoRef.current.volume = volume;
    }
  }, [volume]);

  // Reset internal state when scene changes
  useEffect(() => {
    setInternalTime(0);
    setInternalDuration(0);
    setInternalPlaying(false);
  }, [currentSceneIndex]);

  const handleVideoTimeUpdate = useCallback(() => {
    if (videoRef.current && selfManaged) {
      setInternalTime(videoRef.current.currentTime);
    }
  }, [selfManaged]);

  const handleVideoLoadedMetadata = useCallback(() => {
    if (videoRef.current) {
      setInternalDuration(videoRef.current.duration);
    }
  }, []);

  const handleVideoPlay = useCallback(() => setInternalPlaying(true), []);
  const handleVideoPause = useCallback(() => setInternalPlaying(false), []);
  const handleVideoEnded = useCallback(() => setInternalPlaying(false), []);

  const handlePlayPause = useCallback(() => {
    if (selfManaged && videoRef.current) {
      if (videoRef.current.paused) {
        videoRef.current.play().catch(() => {});
      } else {
        videoRef.current.pause();
      }
    } else {
      onPlayPause();
    }
  }, [selfManaged, onPlayPause]);

  const handleSeek = useCallback((time: number) => {
    if (selfManaged && videoRef.current) {
      videoRef.current.currentTime = time;
      setInternalTime(time);
    } else {
      externalOnSeek?.(time);
    }
  }, [selfManaged, externalOnSeek]);

  const handleSkipToStart = useCallback(() => {
    if (selfManaged && videoRef.current) {
      videoRef.current.currentTime = 0;
      setInternalTime(0);
    } else {
      onSkipToStart?.();
    }
  }, [selfManaged, onSkipToStart]);

  const handleVolumeChange = useCallback((v: number) => {
    if (selfManaged) {
      setInternalVolume(v);
      if (videoRef.current) videoRef.current.volume = v;
    } else {
      externalOnVolumeChange?.(v);
    }
  }, [selfManaged, externalOnVolumeChange]);

  const handleFullscreen = useCallback(() => {
    if (onFullscreen) {
      onFullscreen();
    } else if (containerRef.current) {
      if (!document.fullscreenElement) {
        containerRef.current.requestFullscreen?.();
      } else {
        document.exitFullscreen?.();
      }
    }
  }, [onFullscreen]);

  const hasTransportBar = isVideoSrc || !!(
    externalOnSeek || onSkipToStart || onSkipPrev || onSkipNext ||
    externalOnVolumeChange || onFullscreen
  );
  const hasGenerationCounter =
    videosGeneratedCount !== undefined && totalVideos !== undefined;

  if (scenes.length === 0) return null;

  return (
    <motion.div
      ref={containerRef}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className={cn('', className)}
    >
      <div className="bg-white/5 border border-white/10 rounded-2xl overflow-hidden backdrop-blur-sm">
        {/* Main Preview Area */}
        <div className="relative aspect-video bg-black/40">
          {/* Current Visual */}
          {currentVisual ? (
            isVideoSrc ? (
              <video
                ref={videoRef}
                src={currentVisual}
                className="w-full h-full object-cover"
                controls={false}
                loop
                muted={volume === 0}
                playsInline
                crossOrigin="anonymous"
                onTimeUpdate={handleVideoTimeUpdate}
                onLoadedMetadata={handleVideoLoadedMetadata}
                onPlay={handleVideoPlay}
                onPause={handleVideoPause}
                onEnded={handleVideoEnded}
              />
            ) : (
              <img
                src={currentVisual}
                alt={currentScene?.name || 'Scene preview'}
                className="w-full h-full object-cover"
                crossOrigin="anonymous"
              />
            )
          ) : (
            <div className="w-full h-full flex items-center justify-center">
              <Loader2 className="w-8 h-8 text-white/30 animate-spin" aria-hidden="true" />
            </div>
          )}

          {/* Gradient Overlay */}
          <div className="absolute inset-0 bg-linear-to-t from-black/80 via-transparent to-black/40 pointer-events-none" />

          {/* Scene Counter Badge (top-left) */}
          <div className={cn('absolute top-4', isRTL ? 'right-4' : 'left-4')}>
            <span className="px-3 py-1 rounded-full bg-black/50 backdrop-blur text-xs text-white/80 border border-white/10">
              {scenesLabel} {currentSceneIndex + 1} / {scenes.length}
            </span>
          </div>

          {/* Generation Counter Badge (top-right) */}
          {hasGenerationCounter && (
            <div className={cn('absolute top-4', isRTL ? 'left-4' : 'right-4')}>
              <span className="px-3 py-1 rounded-full bg-black/50 backdrop-blur text-xs text-white/80 border border-white/10">
                {videosGeneratedCount} / {totalVideos} Videos generated
              </span>
            </div>
          )}

          {/* Generate Video overlay (centered, when no visual yet) */}
          {onGenerateVideo && !currentVisual && (
            <div className="absolute inset-0 flex items-center justify-center z-10">
              <button
                onClick={onGenerateVideo}
                className="px-6 py-3 rounded-xl bg-yellow-400 hover:bg-yellow-300 text-black font-bold text-sm shadow-2xl transition-colors flex items-center gap-2"
              >
                <Video className="w-4 h-4" aria-hidden="true" />
                Generate Video ‚Üí
              </button>
            </div>
          )}

          {/* Play/Pause overlay button (center) */}
          {isReady && (
            <button
              onClick={handlePlayPause}
              className="absolute inset-0 flex items-center justify-center group"
              aria-label={playing ? 'Pause' : 'Play'}
            >
              <div
                className={cn(
                  'w-16 h-16 rounded-full bg-white/10 backdrop-blur-md border border-white/20 flex items-center justify-center transition-all',
                  'group-hover:scale-110 group-hover:bg-white/20',
                  playing ? 'opacity-0 group-hover:opacity-100' : 'opacity-100'
                )}
              >
                {playing ? (
                  <Pause className="w-6 h-6 text-white" aria-hidden="true" />
                ) : (
                  <Play className="w-6 h-6 text-white ms-1" aria-hidden="true" />
                )}
              </div>
            </button>
          )}

          {/* Scene Info Overlay */}
          <div
            className={cn(
              'absolute bottom-4 pointer-events-none',
              isRTL ? 'right-4 left-4 text-right' : 'left-4 right-4'
            )}
          >
            <h3 className="text-lg font-medium text-white mb-1">{currentScene?.name}</h3>
            <p className="text-sm text-white/60 line-clamp-2">{currentScene?.narrationScript}</p>
          </div>
        </div>

        {/* Transport Bar */}
        {hasTransportBar && (
          <div className="px-4 py-2 bg-black/30 border-t border-white/5 space-y-1.5">
            {/* Seek bar */}
            <input
              type="range"
              min={0}
              max={duration || 100}
              step={0.1}
              value={currentTime}
              onChange={e => handleSeek(parseFloat(e.target.value))}
              className="w-full h-1.5 rounded-full appearance-none cursor-pointer bg-white/10 accent-yellow-400"
              aria-label="Seek"
            />

            {/* Controls row */}
            <div className="flex items-center gap-1.5">
              {/* Skip to start */}
              <button
                onClick={handleSkipToStart}
                className="p-1 text-white/50 hover:text-white transition-colors"
                aria-label="Skip to start"
              >
                <ChevronFirst className="w-4 h-4" aria-hidden="true" />
              </button>

              {/* Previous scene */}
              <button
                onClick={() => {
                  if (onSkipPrev) onSkipPrev();
                  else if (currentSceneIndex > 0) onSceneSelect(currentSceneIndex - 1);
                }}
                disabled={currentSceneIndex === 0}
                className="p-1 text-white/50 hover:text-white disabled:text-white/20 transition-colors"
                aria-label="Previous scene"
              >
                <SkipBack className="w-4 h-4" aria-hidden="true" />
              </button>

              {/* Play / Pause */}
              <button
                onClick={handlePlayPause}
                className="p-1.5 rounded-full bg-white/10 hover:bg-white/20 text-white transition-colors"
                aria-label={playing ? 'Pause' : 'Play'}
              >
                {playing ? (
                  <Pause className="w-4 h-4" aria-hidden="true" />
                ) : (
                  <Play className="w-4 h-4 ms-0.5" aria-hidden="true" />
                )}
              </button>

              {/* Next scene */}
              <button
                onClick={() => {
                  if (onSkipNext) onSkipNext();
                  else if (currentSceneIndex < scenes.length - 1) onSceneSelect(currentSceneIndex + 1);
                }}
                disabled={currentSceneIndex >= scenes.length - 1}
                className="p-1 text-white/50 hover:text-white disabled:text-white/20 transition-colors"
                aria-label="Next scene"
              >
                <SkipForward className="w-4 h-4" aria-hidden="true" />
              </button>

              {/* Time display */}
              {duration > 0 && (
                <span className="text-xs text-white/40 font-mono tabular-nums ml-1">
                  {formatTime(currentTime)} / {formatTime(duration)}
                </span>
              )}

              <div className="flex-1" />

              {/* Volume */}
              <button
                onClick={() => handleVolumeChange(volume > 0 ? 0 : 1)}
                className="p-1 text-white/50 hover:text-white transition-colors"
                aria-label={volume > 0 ? 'Mute' : 'Unmute'}
              >
                {volume > 0 ? (
                  <Volume2 className="w-4 h-4" aria-hidden="true" />
                ) : (
                  <VolumeX className="w-4 h-4" aria-hidden="true" />
                )}
              </button>
              <input
                type="range"
                min={0}
                max={1}
                step={0.05}
                value={volume}
                onChange={e => handleVolumeChange(parseFloat(e.target.value))}
                className="w-16 h-1 rounded-full appearance-none cursor-pointer bg-white/10 accent-yellow-400"
                aria-label="Volume"
              />

              {/* Fullscreen */}
              <button
                onClick={handleFullscreen}
                className="p-1 text-white/50 hover:text-white transition-colors"
                aria-label="Fullscreen"
              >
                <Maximize className="w-4 h-4" aria-hidden="true" />
              </button>
            </div>
          </div>
        )}

        {/* Scene Thumbnails */}
        {scenes.length > 1 && (
          <div className="p-3 flex gap-2 overflow-x-auto bg-black/20" role="tablist">
            {scenes.map((scene, idx) => (
              <button
                key={scene.id}
                role="tab"
                aria-selected={idx === currentSceneIndex}
                aria-label={`Scene ${idx + 1}: ${scene.name}`}
                onClick={() => onSceneSelect(idx)}
                className={cn(
                  'shrink-0 w-20 h-12 rounded-lg overflow-hidden border-2 transition-all',
                  idx === currentSceneIndex
                    ? 'border-violet-500 ring-2 ring-violet-500/30'
                    : 'border-transparent opacity-60 hover:opacity-100'
                )}
              >
                {visualsMap[scene.id] ? (
                  (() => {
                    const url = visualsMap[scene.id]!;
                    const isVid = url.match(/\.(mp4|webm)$/i) ||
                      url.includes('generativelanguage.googleapis.com');
                    if (isVid) {
                      return (
                        <video
                          src={url}
                          className="w-full h-full object-cover"
                          muted
                          playsInline
                          crossOrigin="anonymous"
                          onMouseOver={e => e.currentTarget.play()}
                          onMouseOut={e => e.currentTarget.pause()}
                        />
                      );
                    }
                    return (
                      <img
                        src={url}
                        alt=""
                        className="w-full h-full object-cover"
                        crossOrigin="anonymous"
                      />
                    );
                  })()
                ) : (
                  <div className="w-full h-full bg-white/5 flex items-center justify-center text-xs text-white/30">
                    {idx + 1}
                  </div>
                )}
              </button>
            ))}
          </div>
        )}

        {/* Status Footer */}
        {isReady && (
          <div className="px-4 py-3 flex items-center justify-between border-t border-white/5 bg-black/20">
            <div className="flex items-center gap-4 text-xs text-white/40">
              <span className="flex items-center gap-1.5">
                <Video className="w-3.5 h-3.5" aria-hidden="true" />
                {scenes.length} {scenesLabel.toLowerCase()}
              </span>
              {totalDuration > 0 && <span>{Math.round(totalDuration)}s</span>}
            </div>
            <div className="flex items-center gap-1.5 text-emerald-400 text-xs">
              <CheckCircle2 className="w-3.5 h-3.5" aria-hidden="true" />
              {doneLabel}
            </div>
          </div>
        )}
      </div>
    </motion.div>
  );
}

export default VideoPreviewCard;
</file>

<file path="components/visualizer/AudioUploadForm.tsx">
/**
 * AudioUploadForm - Audio file upload with style/provider selection
 *
 * Extracted from VisualizerScreen for better maintainability.
 */

import React, { useCallback, useRef } from 'react';
import { Music, Sparkles, Loader2, CheckCircle2, X, Wand2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { useLanguage } from '@/i18n/useLanguage';
import { ART_STYLES } from '@/constants';
import { AppState } from '@/types';
import { LoadingState } from '@/components/ui/LoadingState';
import { ErrorState } from '@/components/ui/ErrorState';

export interface AudioUploadFormProps {
  /** Selected audio file */
  audioFile: File | null;
  /** Callback when audio file changes */
  onAudioFileChange: (file: File | null) => void;
  /** Selected visual style */
  selectedStyle: string;
  /** Callback when style changes */
  onStyleChange: (style: string) => void;
  /** Selected image provider */
  imageProvider: 'gemini' | 'deapi';
  /** Callback when provider changes */
  onProviderChange: (provider: 'gemini' | 'deapi') => void;
  /** Selected director mode (chain = faster, agent = smarter) */
  directorMode?: 'chain' | 'agent';
  /** Callback when director mode changes */
  onDirectorModeChange?: (mode: 'chain' | 'agent') => void;
  /** Global subject for visual consistency (e.g., "a bearded prophet in flowing robes") */
  globalSubject?: string;
  /** Callback when global subject changes */
  onGlobalSubjectChange?: (subject: string) => void;
  /** Current app state for processing status */
  appState: AppState;
  /** Error message to display */
  errorMsg?: string;
  /** Callback to start processing */
  onStartProcessing: () => void;
  /** Additional class names */
  className?: string;
}

/**
 * Audio upload form with drag & drop, style selection, and provider choice
 */
export function AudioUploadForm({
  audioFile,
  onAudioFileChange,
  selectedStyle,
  onStyleChange,
  imageProvider,
  onProviderChange,
  directorMode = 'chain',
  onDirectorModeChange,
  globalSubject = '',
  onGlobalSubjectChange,
  appState,
  errorMsg,
  onStartProcessing,
  className,
}: AudioUploadFormProps) {
  const { t, isRTL } = useLanguage();
  const audioInputRef = useRef<HTMLInputElement>(null);

  const isProcessing = appState === AppState.PROCESSING_AUDIO ||
    appState === AppState.TRANSCRIBING ||
    appState === AppState.ANALYZING_LYRICS ||
    appState === AppState.GENERATING_PROMPTS;

  const handleAudioSelect = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      onAudioFileChange(file);
    }
  }, [onAudioFileChange]);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file) {
      const isAudio = file.type.startsWith('audio/') ||
        file.name.endsWith('.mp3') ||
        file.name.endsWith('.wav');
      if (isAudio) {
        onAudioFileChange(file);
      }
    }
  }, [onAudioFileChange]);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
  }, []);

  const getProcessingMessage = () => {
    switch (appState) {
      case AppState.TRANSCRIBING:
        return 'Transcribing audio...';
      case AppState.ANALYZING_LYRICS:
        return 'Analyzing content...';
      case AppState.GENERATING_PROMPTS:
        return 'Generating visual prompts...';
      case AppState.PROCESSING_AUDIO:
        return t('common.loading');
      default:
        return t('common.loading');
    }
  };

  return (
    <div className={cn('max-w-2xl w-full', className)}>
      {/* Title */}
      <div className={cn('text-center mb-8', isRTL && 'rtl')}>
        <div className="w-16 h-16 mx-auto mb-6 rounded-2xl bg-gradient-to-br from-cyan-600/20 to-blue-600/20 border border-white/10 flex items-center justify-center">
          <Wand2 className="w-8 h-8 text-cyan-400" aria-hidden="true" />
        </div>
        <h1 className="text-3xl font-bold mb-3">{t('visualizer.title')}</h1>
        <p className="text-white/60">{t('visualizer.uploadAudio')}</p>
      </div>

      {/* Form Content */}
      <div className="space-y-4">
        {/* Audio Upload */}
        <div
          onClick={() => audioInputRef.current?.click()}
          onDrop={handleDrop}
          onDragOver={handleDragOver}
          className={cn(
            'relative p-8 rounded-2xl border-2 border-dashed transition-all cursor-pointer',
            audioFile
              ? 'border-cyan-500/50 bg-cyan-500/5'
              : 'border-white/20 hover:border-white/40 bg-white/5 hover:bg-white/10'
          )}
          role="button"
          tabIndex={0}
          aria-label={audioFile ? `Selected: ${audioFile.name}` : 'Click or drag to upload audio'}
          onKeyDown={(e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              audioInputRef.current?.click();
            }
          }}
        >
          <input
            ref={audioInputRef}
            type="file"
            accept="audio/*,.mp3,.wav,.m4a,.ogg"
            onChange={handleAudioSelect}
            className="hidden"
            aria-hidden="true"
          />
          <div className={cn('flex flex-col items-center gap-4', isRTL && 'rtl')}>
            <div className={cn(
              'w-14 h-14 rounded-xl flex items-center justify-center',
              audioFile ? 'bg-cyan-500/20' : 'bg-white/10'
            )}>
              {audioFile ? (
                <CheckCircle2 className="w-7 h-7 text-cyan-400" aria-hidden="true" />
              ) : (
                <Music className="w-7 h-7 text-white/60" aria-hidden="true" />
              )}
            </div>
            <div className="text-center">
              <p className="font-medium mb-1">
                {audioFile ? audioFile.name : t('visualizer.dropAudio')}
              </p>
              <p className="text-sm text-white/40">
                MP3, WAV, M4A, OGG
              </p>
            </div>
          </div>
          {audioFile && (
            <button
              onClick={(e) => {
                e.stopPropagation();
                onAudioFileChange(null);
              }}
              className="absolute top-4 end-4 p-1 rounded-full bg-white/10 hover:bg-white/20 transition-colors"
              aria-label="Remove selected file"
            >
              <X className="w-4 h-4" aria-hidden="true" />
            </button>
          )}
        </div>

        {/* Style Selection */}
        <div className="bg-white/5 rounded-2xl p-6 border border-white/10">
          <label className="block text-sm font-medium text-white/80 mb-3">
            Visual Style
          </label>
          <div className="grid grid-cols-3 md:grid-cols-5 gap-2" role="radiogroup" aria-label="Visual style selection">
            {ART_STYLES.slice(0, 10).map((style) => (
              <button
                key={style}
                role="radio"
                aria-checked={selectedStyle === style}
                onClick={() => onStyleChange(style)}
                className={cn(
                  'px-3 py-2 rounded-lg text-sm font-medium transition-all',
                  selectedStyle === style
                    ? 'bg-cyan-500/20 border-2 border-cyan-500 text-cyan-300'
                    : 'bg-white/5 border border-white/10 text-white/70 hover:bg-white/10'
                )}
              >
                {style}
              </button>
            ))}
          </div>
        </div>

        {/* Image Provider Selection */}
        <div className="bg-white/5 rounded-2xl p-6 border border-white/10">
          <label className="block text-sm font-medium text-white/80 mb-3">
            Image Provider
          </label>
          <div className="grid grid-cols-2 gap-2" role="radiogroup" aria-label="Image provider selection">
            <button
              role="radio"
              aria-checked={imageProvider === 'gemini'}
              onClick={() => onProviderChange('gemini')}
              className={cn(
                'px-4 py-3 rounded-lg text-sm font-medium transition-all text-start',
                imageProvider === 'gemini'
                  ? 'bg-cyan-500/20 border-2 border-cyan-500 text-cyan-300'
                  : 'bg-white/5 border border-white/10 text-white/70 hover:bg-white/10'
              )}
            >
              <div className="flex flex-col items-start gap-1">
                <span className="font-semibold">Gemini Imagen</span>
                <span className="text-xs text-white/50">Google AI (default)</span>
              </div>
            </button>
            <button
              role="radio"
              aria-checked={imageProvider === 'deapi'}
              onClick={() => onProviderChange('deapi')}
              className={cn(
                'px-4 py-3 rounded-lg text-sm font-medium transition-all text-start',
                imageProvider === 'deapi'
                  ? 'bg-purple-500/20 border-2 border-purple-500 text-purple-300'
                  : 'bg-white/5 border border-white/10 text-white/70 hover:bg-white/10'
              )}
            >
              <div className="flex flex-col items-start gap-1">
                <span className="font-semibold">DeAPI FLUX</span>
                <span className="text-xs text-white/50">Fast, high-quality</span>
              </div>
            </button>
          </div>
        </div>

        {/* Director Mode Selection */}
        {onDirectorModeChange && (
          <div className="bg-white/5 rounded-2xl p-6 border border-white/10">
            <label className="block text-sm font-medium text-white/80 mb-3">
              AI Director Mode
            </label>
            <div className="grid grid-cols-2 gap-2" role="radiogroup" aria-label="Director mode selection">
              <button
                role="radio"
                aria-checked={directorMode === 'chain'}
                onClick={() => onDirectorModeChange('chain')}
                className={cn(
                  'px-4 py-3 rounded-lg text-sm font-medium transition-all text-start',
                  directorMode === 'chain'
                    ? 'bg-cyan-500/20 border-2 border-cyan-500 text-cyan-300'
                    : 'bg-white/5 border border-white/10 text-white/70 hover:bg-white/10'
                )}
              >
                <div className="flex flex-col items-start gap-1">
                  <span className="font-semibold">Chain Mode</span>
                  <span className="text-xs text-white/50">Faster, predictable</span>
                </div>
              </button>
              <button
                role="radio"
                aria-checked={directorMode === 'agent'}
                onClick={() => onDirectorModeChange('agent')}
                className={cn(
                  'px-4 py-3 rounded-lg text-sm font-medium transition-all text-start',
                  directorMode === 'agent'
                    ? 'bg-amber-500/20 border-2 border-amber-500 text-amber-300'
                    : 'bg-white/5 border border-white/10 text-white/70 hover:bg-white/10'
                )}
              >
                <div className="flex flex-col items-start gap-1">
                  <span className="font-semibold">Agent Mode</span>
                  <span className="text-xs text-white/50">Smarter, self-correcting</span>
                </div>
              </button>
            </div>
          </div>
        )}

        {/* Global Subject Input */}
        {onGlobalSubjectChange && (
          <div className="bg-white/5 rounded-2xl p-6 border border-white/10">
            <label className="block text-sm font-medium text-white/80 mb-2">
              Global Subject (Optional)
            </label>
            <p className="text-xs text-white/50 mb-3">
              Describe a consistent character/subject to appear in all scenes (e.g., &quot;a bearded prophet in flowing white robes&quot;)
            </p>
            <input
              type="text"
              value={globalSubject}
              onChange={(e) => onGlobalSubjectChange(e.target.value)}
              placeholder="e.g., a young woman with dark curly hair in a crimson dress"
              className="w-full px-4 py-3 rounded-lg bg-white/5 border border-white/10 text-white placeholder-white/30 focus:outline-none focus:border-cyan-500/50 focus:ring-1 focus:ring-cyan-500/25"
            />
          </div>
        )}

        {/* Error Message */}
        {errorMsg && (
          <ErrorState variant="inline" message={errorMsg} />
        )}

        {/* Processing Status */}
        {isProcessing && (
          <div className="p-4 rounded-xl bg-cyan-500/10 border border-cyan-500/20">
            <div className={cn('flex items-center gap-3', isRTL && 'flex-row-reverse')}>
              <Loader2 className="w-5 h-5 text-cyan-400 animate-spin" aria-hidden="true" />
              <span className="text-cyan-200">{getProcessingMessage()}</span>
            </div>
          </div>
        )}

        {/* Start Button */}
        <Button
          onClick={onStartProcessing}
          disabled={!audioFile || isProcessing}
          size="lg"
          className={cn(
            'w-full h-14 text-lg font-semibold rounded-xl',
            'bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-600 hover:to-blue-700',
            'disabled:opacity-50 disabled:cursor-not-allowed'
          )}
        >
          {isProcessing ? (
            <>
              <Loader2 className="w-5 h-5 me-2 animate-spin" aria-hidden="true" />
              {t('studio.processing')}
            </>
          ) : (
            <>
              <Sparkles className="w-5 h-5 me-2" aria-hidden="true" />
              {t('visualizer.generate')}
            </>
          )}
        </Button>
      </div>
    </div>
  );
}

export default AudioUploadForm;
</file>

<file path="components/visualizer/index.ts">
/**
 * Visualizer Components Index
 *
 * Exports all visualizer-related components for easy importing.
 */

export { AudioUploadForm } from './AudioUploadForm';
export type { AudioUploadFormProps } from './AudioUploadForm';

export { VisualPreview } from './VisualPreview';
export type { VisualPreviewProps } from './VisualPreview';

export { SceneThumbnails } from './SceneThumbnails';
export type { SceneThumbnailsProps } from './SceneThumbnails';
</file>

<file path="components/visualizer/SceneThumbnails.tsx">
/**
 * SceneThumbnails - Horizontal scrollable scene thumbnail strip
 *
 * Extracted from VisualizerScreen for better maintainability.
 */

import React from 'react';
import { Video, Image as ImageIcon, Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';
import type { ImagePrompt, GeneratedImage } from '@/types';

export interface SceneThumbnailsProps {
  /** List of prompts/scenes */
  prompts: ImagePrompt[];
  /** Generated images for each prompt */
  generatedImages: GeneratedImage[];
  /** Currently active scene index */
  currentSceneIndex: number;
  /** Callback when scene is selected */
  onSceneSelect: (index: number, timestampSeconds?: number) => void;
  /** ID of prompt currently being animated */
  animatingPromptId: string | null;
  /** Additional class names */
  className?: string;
}

/**
 * Horizontal scrollable strip of scene thumbnails
 */
export function SceneThumbnails({
  prompts,
  generatedImages,
  currentSceneIndex,
  onSceneSelect,
  animatingPromptId,
  className,
}: SceneThumbnailsProps) {
  return (
    <div
      className={cn('flex gap-2 overflow-x-auto pb-2 scrollbar-thin scrollbar-thumb-white/20', className)}
      role="tablist"
      aria-label="Scene thumbnails"
    >
      {prompts.map((prompt, idx) => {
        const image = generatedImages.find(img => img.promptId === prompt.id);
        const isActive = idx === currentSceneIndex;
        const isAnimating = animatingPromptId === prompt.id;
        const isVideo = image?.type === 'video';

        return (
          <div key={prompt.id} className="relative shrink-0">
            <button
              role="tab"
              aria-selected={isActive}
              aria-label={`Scene ${idx + 1}${image ? (isVideo ? ' (video)' : ' (image)') : ''}`}
              onClick={() => onSceneSelect(idx, prompt.timestampSeconds)}
              className={cn(
                'w-24 h-14 rounded-lg overflow-hidden border-2 transition-all',
                isActive
                  ? 'border-cyan-500 ring-2 ring-cyan-500/30'
                  : 'border-transparent opacity-60 hover:opacity-100'
              )}
            >
              {image?.imageUrl ? (
                isVideo ? (
                  <video
                    src={image.imageUrl}
                    className="w-full h-full object-cover"
                    muted
                    playsInline
                  />
                ) : (
                  <img
                    src={image.imageUrl}
                    alt={`Scene ${idx + 1}`}
                    className="w-full h-full object-cover"
                  />
                )
              ) : (
                <div className="w-full h-full bg-white/5 flex items-center justify-center text-xs text-white/30">
                  {idx + 1}
                </div>
              )}

              {/* Video/Image indicator badge */}
              {image && (
                <div className="absolute top-0.5 end-0.5">
                  <span className={cn(
                    'flex items-center justify-center w-4 h-4 rounded-full text-[8px]',
                    isVideo ? 'bg-purple-500/80' : 'bg-cyan-500/80'
                  )}>
                    {isVideo ? (
                      <Video className="w-2.5 h-2.5" aria-hidden="true" />
                    ) : (
                      <ImageIcon className="w-2.5 h-2.5" aria-hidden="true" />
                    )}
                  </span>
                </div>
              )}

              {/* Animating overlay */}
              {isAnimating && (
                <div className="absolute inset-0 bg-black/60 flex items-center justify-center">
                  <Loader2 className="w-4 h-4 text-purple-400 animate-spin" aria-hidden="true" />
                </div>
              )}
            </button>
          </div>
        );
      })}
    </div>
  );
}

export default SceneThumbnails;
</file>

<file path="components/visualizer/VisualPreview.tsx">
/**
 * VisualPreview - Main visual preview with play/pause and animation controls
 *
 * Extracted from VisualizerScreen for better maintainability.
 */

import React from 'react';
import { Play, Pause, Video, Image as ImageIcon, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import type { GeneratedImage, SubtitleItem } from '@/types';

export interface VisualPreviewProps {
  /** Current visual being displayed */
  currentVisual: GeneratedImage | null;
  /** Current scene index */
  currentSceneIndex: number;
  /** Total number of scenes */
  totalScenes: number;
  /** Whether video is playing */
  isPlaying: boolean;
  /** Callback to toggle play/pause */
  onPlayPause: () => void;
  /** Current playback time in seconds */
  currentTime: number;
  /** Subtitles for overlay */
  subtitles: SubtitleItem[];
  /** ID of prompt currently being animated */
  animatingPromptId: string | null;
  /** Callback to animate current image */
  onAnimateImage: (promptId: string) => void;
  /** RTL layout */
  isRTL?: boolean;
  /** Additional class names */
  className?: string;
}

/**
 * Visual preview with play/pause, subtitle overlay, and animation controls
 */
export function VisualPreview({
  currentVisual,
  currentSceneIndex,
  totalScenes,
  isPlaying,
  onPlayPause,
  currentTime,
  subtitles,
  animatingPromptId,
  onAnimateImage,
  isRTL = false,
  className,
}: VisualPreviewProps) {
  // Find current subtitle
  const currentSubtitle = subtitles.find(
    s => currentTime >= s.startTime && currentTime <= s.endTime
  );

  const isVideo = currentVisual?.type === 'video';
  const canAnimate = !!(currentVisual && !isVideo);
  const isAnimating = !!(currentVisual && animatingPromptId === currentVisual.promptId);

  return (
    <div className={cn('relative aspect-video bg-black/40 rounded-2xl overflow-hidden border border-white/10', className)}>
      {/* Visual Content */}
      {currentVisual ? (
        isVideo ? (
          <video
            src={currentVisual.imageUrl}
            className="w-full h-full object-cover"
            autoPlay
            muted
            playsInline
            controls
          />
        ) : (
          <img
            src={currentVisual.imageUrl}
            alt={`Scene ${currentSceneIndex + 1}`}
            className="w-full h-full object-cover"
          />
        )
      ) : (
        <div className="w-full h-full flex items-center justify-center">
          <div className="text-center text-white/40">
            <ImageIcon className="w-12 h-12 mx-auto mb-2 opacity-50" aria-hidden="true" />
            <p>No visual for this scene</p>
          </div>
        </div>
      )}

      {/* Overlay gradient */}
      <div className="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-black/20 pointer-events-none" />

      {/* Scene indicator */}
      <div className={cn('absolute top-4 z-20', isRTL ? 'right-4' : 'left-4')}>
        <span className="px-3 py-1 rounded-full bg-black/50 backdrop-blur text-xs text-white/80 border border-white/10 flex items-center gap-1">
          {isVideo ? (
            <Video className="w-3 h-3" aria-hidden="true" />
          ) : (
            <ImageIcon className="w-3 h-3" aria-hidden="true" />
          )}
          Scene {currentSceneIndex + 1} / {totalScenes}
        </span>
      </div>

      {/* Animate button for current scene */}
      {canAnimate && (
        <div className={cn('absolute top-4 z-20', isRTL ? 'left-4' : 'right-4')}>
          <Button
            size="sm"
            onClick={(e) => {
              e.stopPropagation();
              onAnimateImage(currentVisual.promptId);
            }}
            disabled={isAnimating}
            className="bg-purple-600/80 hover:bg-purple-500 backdrop-blur text-xs"
          >
            {isAnimating ? (
              <>
                <Loader2 className="w-3 h-3 me-1 animate-spin" aria-hidden="true" />
                Animating...
              </>
            ) : (
              <>
                <Video className="w-3 h-3 me-1" aria-hidden="true" />
                Animate
              </>
            )}
          </Button>
        </div>
      )}

      {/* Play/Pause overlay */}
      <button
        onClick={onPlayPause}
        className="absolute inset-0 z-10 flex items-center justify-center group"
        aria-label={isPlaying ? 'Pause' : 'Play'}
      >
        <div className={cn(
          'w-16 h-16 rounded-full bg-white/10 backdrop-blur-md border border-white/20 flex items-center justify-center transition-all',
          'group-hover:scale-110 group-hover:bg-white/20',
          isPlaying ? 'opacity-0 group-hover:opacity-100' : 'opacity-100'
        )}>
          {isPlaying ? (
            <Pause className="w-6 h-6 text-white" aria-hidden="true" />
          ) : (
            <Play className="w-6 h-6 text-white ms-1" aria-hidden="true" />
          )}
        </div>
      </button>

      {/* Current subtitle */}
      {currentSubtitle && (
        <div className={cn('absolute bottom-4 z-20', isRTL ? 'right-4 left-4 text-right' : 'left-4 right-4')}>
          <p className="text-lg font-medium text-white text-center px-4 py-2 bg-black/60 rounded-lg backdrop-blur-sm">
            {currentSubtitle.text}
          </p>
        </div>
      )}
    </div>
  );
}

export default VisualPreview;
</file>

<file path="hooks/useAuth.ts">
/**
 * useAuth Hook
 *
 * React hook for Firebase authentication state.
 * Provides current user, loading state, and auth methods.
 * Syncs auth state with the global app store.
 */
import { useState, useEffect, useCallback } from 'react';
import {
  onAuthChange,
  signInWithGoogle,
  signInWithEmail,
  createAccount,
  signOut,
  getCurrentUser,
  isAuthAvailable,
  handleRedirectResult,
  type AuthUser,
} from '@/services/firebase';
import { useAppStore } from '@/stores/appStore';

interface UseAuthReturn {
  user: AuthUser | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  isAuthAvailable: boolean;
  error: string | null;
  signInWithGoogle: () => Promise<void>;
  signInWithEmail: (email: string, password: string) => Promise<void>;
  createAccount: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
  clearError: () => void;
}

export function useAuth(): UseAuthReturn {
  const [user, setUser] = useState<AuthUser | null>(() => getCurrentUser());
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Get app store actions for syncing auth state
  const setCurrentUser = useAppStore((state) => state.setCurrentUser);
  const clearCurrentUser = useAppStore((state) => state.clearCurrentUser);

  // Helper to sync auth user to app store
  const syncUserToStore = useCallback((authUser: AuthUser | null) => {
    if (authUser) {
      setCurrentUser({
        uid: authUser.uid,
        email: authUser.email,
        displayName: authUser.displayName,
        photoURL: authUser.photoURL,
        isAuthenticated: true,
      });
    } else {
      clearCurrentUser();
    }
  }, [setCurrentUser, clearCurrentUser]);

  // Subscribe to auth state changes and check for redirect result
  useEffect(() => {
    let mounted = true;

    console.log('[useAuth] Starting auth initialization...');

    // Subscribe to auth state changes immediately (don't gate behind redirect check)
    const unsubscribe = onAuthChange((authUser) => {
      if (!mounted) return;
      console.log('[useAuth] Auth state changed:', authUser?.email || 'signed out');
      setUser(authUser);
      syncUserToStore(authUser);
      setIsLoading(false);
    });

    // If Firebase not configured, stop loading immediately
    if (!unsubscribe) {
      setIsLoading(false);
    }

    // Check for redirect result separately (from Google sign-in redirect)
    handleRedirectResult()
      .then((redirectUser) => {
        if (!mounted) return;
        if (redirectUser) {
          console.log('[useAuth] Got redirect user:', redirectUser.email);
          setUser(redirectUser);
          syncUserToStore(redirectUser);
        }
      })
      .catch((error) => {
        console.error('[useAuth] Redirect result error:', error);
      });

    return () => {
      mounted = false;
      unsubscribe?.();
    };
  }, [syncUserToStore]);

  const handleSignInWithGoogle = useCallback(async () => {
    setError(null);
    setIsLoading(true);
    try {
      await signInWithGoogle();
    } catch (e) {
      const err = e as { message?: string; code?: string };
      setError(getAuthErrorMessage(err.code));
    } finally {
      setIsLoading(false);
    }
  }, []);

  const handleSignInWithEmail = useCallback(
    async (email: string, password: string) => {
      setError(null);
      setIsLoading(true);
      try {
        await signInWithEmail(email, password);
      } catch (e) {
        const err = e as { message?: string; code?: string };
        setError(getAuthErrorMessage(err.code));
      } finally {
        setIsLoading(false);
      }
    },
    []
  );

  const handleCreateAccount = useCallback(
    async (email: string, password: string) => {
      setError(null);
      setIsLoading(true);
      try {
        await createAccount(email, password);
      } catch (e) {
        const err = e as { message?: string; code?: string };
        setError(getAuthErrorMessage(err.code));
      } finally {
        setIsLoading(false);
      }
    },
    []
  );

  const handleSignOut = useCallback(async () => {
    setError(null);
    try {
      await signOut();
    } catch (e) {
      const err = e as { message?: string };
      setError(err.message || 'Sign out failed');
    }
  }, []);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return {
    user,
    isLoading,
    isAuthenticated: user !== null,
    isAuthAvailable: isAuthAvailable(),
    error,
    signInWithGoogle: handleSignInWithGoogle,
    signInWithEmail: handleSignInWithEmail,
    createAccount: handleCreateAccount,
    signOut: handleSignOut,
    clearError,
  };
}

/**
 * Convert Firebase auth error codes to user-friendly messages
 */
function getAuthErrorMessage(code?: string): string {
  switch (code) {
    case 'auth/email-already-in-use':
      return 'This email is already registered. Try signing in instead.';
    case 'auth/invalid-email':
      return 'Please enter a valid email address.';
    case 'auth/operation-not-allowed':
      return 'This sign-in method is not enabled.';
    case 'auth/weak-password':
      return 'Password should be at least 6 characters.';
    case 'auth/user-disabled':
      return 'This account has been disabled.';
    case 'auth/user-not-found':
    case 'auth/wrong-password':
    case 'auth/invalid-credential':
      return 'Invalid email or password.';
    case 'auth/too-many-requests':
      return 'Too many attempts. Please try again later.';
    case 'auth/network-request-failed':
      return 'Network error. Check your connection.';
    case 'auth/popup-closed-by-user':
      return ''; // User cancelled, no error message needed
    default:
      return code ? `Authentication error: ${code}` : 'An error occurred.';
  }
}

export default useAuth;
</file>

<file path="hooks/useFocusTrap.ts">
/**
 * useFocusTrap Hook
 * Requirements: 9.4 - Trap focus in modals
 * 
 * This hook provides focus trapping functionality for modals and dialogs.
 * It ensures that keyboard focus stays within the modal when it's open.
 */

import { useEffect, useRef, useCallback } from 'react';

interface UseFocusTrapOptions {
  /** Whether the focus trap is active */
  isActive: boolean;
  /** Element to return focus to when trap is deactivated */
  returnFocusOnDeactivate?: boolean;
  /** Initial element to focus when trap is activated */
  initialFocusRef?: React.RefObject<HTMLElement>;
  /** Callback when escape key is pressed */
  onEscape?: () => void;
}

/**
 * Get all focusable elements within a container
 */
function getFocusableElements(container: HTMLElement): HTMLElement[] {
  const focusableSelectors = [
    'a[href]',
    'button:not([disabled])',
    'textarea:not([disabled])',
    'input:not([disabled])',
    'select:not([disabled])',
    '[tabindex]:not([tabindex="-1"])',
    '[contenteditable="true"]',
  ].join(', ');

  const elements = Array.from(
    container.querySelectorAll<HTMLElement>(focusableSelectors)
  );

  // Filter out elements that are not visible
  return elements.filter((el) => {
    const style = window.getComputedStyle(el);
    return (
      style.display !== 'none' &&
      style.visibility !== 'hidden' &&
      el.offsetParent !== null
    );
  });
}

/**
 * Hook to trap focus within a container element
 * 
 * @example
 * ```tsx
 * function Modal({ isOpen, onClose }) {
 *   const containerRef = useFocusTrap({
 *     isActive: isOpen,
 *     onEscape: onClose,
 *   });
 * 
 *   return (
 *     <div ref={containerRef} role="dialog" aria-modal="true">
 *       <button>First focusable</button>
 *       <button>Last focusable</button>
 *     </div>
 *   );
 * }
 * ```
 */
export function useFocusTrap<T extends HTMLElement = HTMLDivElement>({
  isActive,
  returnFocusOnDeactivate = true,
  initialFocusRef,
  onEscape,
}: UseFocusTrapOptions) {
  const containerRef = useRef<T>(null);
  const previousActiveElement = useRef<HTMLElement | null>(null);

  // Handle keyboard events for focus trapping
  const handleKeyDown = useCallback(
    (event: KeyboardEvent) => {
      if (!containerRef.current || !isActive) return;

      // Handle Escape key
      if (event.key === 'Escape' && onEscape) {
        event.preventDefault();
        onEscape();
        return;
      }

      // Handle Tab key for focus trapping
      if (event.key === 'Tab') {
        const focusableElements = getFocusableElements(containerRef.current);
        
        if (focusableElements.length === 0) {
          event.preventDefault();
          return;
        }

        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];

        if (!firstElement || !lastElement) return;

        const activeElement = document.activeElement as HTMLElement;

        // Shift + Tab: Move focus backwards
        if (event.shiftKey) {
          if (activeElement === firstElement || !containerRef.current.contains(activeElement)) {
            event.preventDefault();
            lastElement.focus();
          }
        } 
        // Tab: Move focus forwards
        else {
          if (activeElement === lastElement || !containerRef.current.contains(activeElement)) {
            event.preventDefault();
            firstElement.focus();
          }
        }
      }
    },
    [isActive, onEscape]
  );

  // Set up focus trap when activated
  useEffect(() => {
    if (!isActive) return;

    // Store the currently focused element to restore later
    previousActiveElement.current = document.activeElement as HTMLElement;

    // Focus the initial element or the first focusable element
    const focusInitialElement = () => {
      if (initialFocusRef?.current) {
        initialFocusRef.current.focus();
      } else if (containerRef.current) {
        const focusableElements = getFocusableElements(containerRef.current);
        const firstFocusable = focusableElements[0];
        if (firstFocusable) {
          firstFocusable.focus();
        } else {
          // If no focusable elements, focus the container itself
          containerRef.current.setAttribute('tabindex', '-1');
          containerRef.current.focus();
        }
      }
    };

    // Small delay to ensure the modal is rendered
    const timeoutId = setTimeout(focusInitialElement, 10);

    // Add keyboard event listener
    document.addEventListener('keydown', handleKeyDown);

    return () => {
      clearTimeout(timeoutId);
      document.removeEventListener('keydown', handleKeyDown);

      // Return focus to the previously focused element
      if (returnFocusOnDeactivate && previousActiveElement.current) {
        previousActiveElement.current.focus();
      }
    };
  }, [isActive, handleKeyDown, initialFocusRef, returnFocusOnDeactivate]);

  return containerRef;
}

export default useFocusTrap;
</file>

<file path="hooks/useFormatPipeline.ts">
/**
 * useFormatPipeline Hook
 *
 * Orchestration hook bridging UI ‚Üî format-specific pipeline services.
 * Manages format selection, genre, idea, reference documents, pipeline execution,
 * checkpoint approval/rejection, and cancellation.
 *
 * movie-animation is excluded ‚Äî it delegates to the existing useStoryGeneration hook.
 */

import { useState, useCallback, useRef } from 'react';
import type { VideoFormat, CheckpointState } from '@/types';
import type { IndexedDocument } from '@/services/documentParser';
import type { PipelineCallbacks, PipelineResult } from '@/services/formatRouter';
import { formatRouter } from '@/services/formatRouter';
import { formatRegistry } from '@/services/formatRegistry';
import type { CheckpointSystem } from '@/services/checkpointSystem';
import type { ExecutionProgress } from '@/services/parallelExecutionEngine';
import type { PipelineTask } from '@/components/PipelineProgress';

// Pipeline class imports (lazy-registered before each execute)
import { YouTubeNarratorPipeline } from '@/services/pipelines/youtubeNarrator';
import { AdvertisementPipeline } from '@/services/pipelines/advertisement';
import { EducationalPipeline } from '@/services/pipelines/educational';
import { ShortsPipeline } from '@/services/pipelines/shorts';
import { DocumentaryPipeline } from '@/services/pipelines/documentary';
import { MusicVideoPipeline } from '@/services/pipelines/musicVideo';
import { NewsPoliticsPipeline } from '@/services/pipelines/newsPolitics';

/**
 * Build a static task list from format metadata for progress display.
 */
function buildTaskList(formatId: VideoFormat): PipelineTask[] {
  const meta = formatRegistry.getFormat(formatId);
  if (!meta) return [];

  const tasks: PipelineTask[] = [];

  if (meta.requiresResearch) {
    tasks.push({ id: 'research', name: 'Research & Sources', type: 'research', status: 'queued' });
  }

  tasks.push({ id: 'script', name: 'Script Generation', type: 'script', status: 'queued' });
  tasks.push({ id: 'visual', name: 'Visual Generation', type: 'visual', status: 'queued' });
  tasks.push({ id: 'audio', name: 'Audio / Narration', type: 'audio', status: 'queued' });
  tasks.push({ id: 'assembly', name: 'Final Assembly', type: 'assembly', status: 'queued' });

  return tasks;
}

export interface UseFormatPipelineReturn {
  // Selection state
  selectedFormat: VideoFormat | null;
  selectedGenre: string | null;
  idea: string;
  referenceDocuments: IndexedDocument[];
  setFormat: (format: VideoFormat) => void;
  setGenre: (genre: string) => void;
  setIdea: (idea: string) => void;
  setReferenceDocuments: (docs: IndexedDocument[]) => void;

  // Execution state
  isRunning: boolean;
  isCancelling: boolean;
  currentPhase: string;
  executionProgress: ExecutionProgress | null;
  tasks: PipelineTask[];
  result: PipelineResult | null;
  error: string | null;

  // Checkpoint state
  activeCheckpoint: CheckpointState | null;

  // Actions
  execute: (userId: string, projectId: string) => Promise<void>;
  cancel: () => void;
  approveCheckpoint: () => void;
  rejectCheckpoint: (changeRequest?: string) => void;
  reset: () => void;
}

export function useFormatPipeline(): UseFormatPipelineReturn {
  // Selection state
  const [selectedFormat, setSelectedFormat] = useState<VideoFormat | null>(null);
  const [selectedGenre, setSelectedGenre] = useState<string | null>(null);
  const [idea, setIdea] = useState('');
  const [referenceDocuments, setReferenceDocuments] = useState<IndexedDocument[]>([]);

  // Execution state
  const [isRunning, setIsRunning] = useState(false);
  const [isCancelling, setIsCancelling] = useState(false);
  const [currentPhase, setCurrentPhase] = useState('');
  const [executionProgress, setExecutionProgress] = useState<ExecutionProgress | null>(null);
  const [tasks, setTasks] = useState<PipelineTask[]>([]);
  const [result, setResult] = useState<PipelineResult | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Checkpoint state
  const [activeCheckpoint, setActiveCheckpoint] = useState<CheckpointState | null>(null);

  // Refs for bridging callbacks to React state
  const checkpointSystemRef = useRef<CheckpointSystem | null>(null);
  const cancelFnRef = useRef<(() => void) | null>(null);

  const setFormat = useCallback((format: VideoFormat) => {
    setSelectedFormat(format);
    setSelectedGenre(null); // Reset genre when format changes
    setResult(null);
    setError(null);
  }, []);

  const setGenre = useCallback((genre: string) => {
    setSelectedGenre(genre);
  }, []);

  /**
   * Register all 7 non-movie pipelines on the format router with fresh callback closures.
   * Called before each execute() to avoid stale React closures.
   */
  const registerPipelines = useCallback((callbacks: PipelineCallbacks) => {
    // We don't pass callbacks to constructors ‚Äî callbacks are passed via execute()
    formatRouter.registerPipeline('youtube-narrator', new YouTubeNarratorPipeline());
    formatRouter.registerPipeline('advertisement', new AdvertisementPipeline());
    formatRouter.registerPipeline('educational', new EducationalPipeline());
    formatRouter.registerPipeline('shorts', new ShortsPipeline());
    formatRouter.registerPipeline('documentary', new DocumentaryPipeline());
    formatRouter.registerPipeline('music-video', new MusicVideoPipeline());
    formatRouter.registerPipeline('news-politics', new NewsPoliticsPipeline());
  }, []);

  /**
   * Update task statuses based on checkpoint phase.
   */
  const updateTaskFromPhase = useCallback((phase: string) => {
    setTasks(prev => {
      const updated = [...prev];
      // Simple heuristic: map checkpoint phases to task types
      if (phase.includes('research')) {
        const task = updated.find(t => t.id === 'research');
        if (task) task.status = 'completed';
        const scriptTask = updated.find(t => t.id === 'script');
        if (scriptTask && scriptTask.status === 'queued') scriptTask.status = 'in-progress';
      } else if (phase.includes('script') || phase.includes('cta')) {
        const researchTask = updated.find(t => t.id === 'research');
        if (researchTask && researchTask.status === 'queued') researchTask.status = 'completed';
        const scriptTask = updated.find(t => t.id === 'script');
        if (scriptTask) scriptTask.status = 'completed';
        const visualTask = updated.find(t => t.id === 'visual');
        if (visualTask && visualTask.status === 'queued') visualTask.status = 'in-progress';
      } else if (phase.includes('visual') || phase.includes('preview')) {
        const researchTask = updated.find(t => t.id === 'research');
        if (researchTask) researchTask.status = 'completed';
        const scriptTask = updated.find(t => t.id === 'script');
        if (scriptTask) scriptTask.status = 'completed';
        const visualTask = updated.find(t => t.id === 'visual');
        if (visualTask) visualTask.status = 'completed';
        const audioTask = updated.find(t => t.id === 'audio');
        if (audioTask && audioTask.status === 'queued') audioTask.status = 'in-progress';
      } else if (phase.includes('assembly') || phase.includes('final')) {
        for (const t of updated) {
          if (t.id !== 'assembly') t.status = 'completed';
        }
        const assemblyTask = updated.find(t => t.id === 'assembly');
        if (assemblyTask) assemblyTask.status = 'in-progress';
      }
      return updated;
    });
  }, []);

  const execute = useCallback(async (userId: string, projectId: string) => {
    if (!selectedFormat || selectedFormat === 'movie-animation') return;
    if (isRunning) return;

    setIsRunning(true);
    setIsCancelling(false);
    setError(null);
    setResult(null);
    setActiveCheckpoint(null);
    setCurrentPhase('Initializing...');

    // Build static task list from format metadata
    const taskList = buildTaskList(selectedFormat);
    setTasks(taskList);

    // Set first task as in-progress
    if (taskList.length > 0) {
      taskList[0]!.status = 'in-progress';
      setTasks([...taskList]);
    }

    // Build callbacks with fresh closures
    const callbacks: PipelineCallbacks = {
      onCheckpointCreated: (checkpoint: CheckpointState) => {
        setActiveCheckpoint(checkpoint);
        setCurrentPhase(`Checkpoint: ${checkpoint.phase}`);
        updateTaskFromPhase(checkpoint.phase);
      },
      onCheckpointSystemCreated: (system: CheckpointSystem) => {
        checkpointSystemRef.current = system;
      },
      onProgress: (progress: ExecutionProgress) => {
        setExecutionProgress(progress);
      },
      onCancelRequested: (cancelFn: () => void) => {
        cancelFnRef.current = cancelFn;
      },
    };

    // Register fresh pipeline instances
    registerPipelines(callbacks);

    try {
      const pipelineResult = await formatRouter.dispatch(
        {
          formatId: selectedFormat,
          idea,
          genre: selectedGenre ?? undefined,
          language: 'en', // TODO: detect from idea
          referenceDocuments: referenceDocuments.length > 0 ? referenceDocuments : undefined,
          userId,
          projectId,
        },
        callbacks,
      );

      setResult(pipelineResult);

      if (pipelineResult.success) {
        // Mark all tasks as completed
        setTasks(prev => prev.map(t => ({ ...t, status: 'completed' as const })));
        setCurrentPhase('Complete');
      } else {
        setError(pipelineResult.error ?? 'Pipeline failed');
        setCurrentPhase('Failed');
      }
    } catch (err) {
      const msg = err instanceof Error ? err.message : String(err);
      setError(msg);
      setCurrentPhase('Failed');
    } finally {
      setIsRunning(false);
      checkpointSystemRef.current = null;
      cancelFnRef.current = null;
    }
  }, [selectedFormat, selectedGenre, idea, referenceDocuments, isRunning, registerPipelines, updateTaskFromPhase]);

  const cancel = useCallback(() => {
    if (!isRunning) return;
    setIsCancelling(true);
    cancelFnRef.current?.();
    // Mark remaining tasks as cancelled
    setTasks(prev => prev.map(t =>
      t.status === 'queued' || t.status === 'in-progress'
        ? { ...t, status: 'cancelled' as const }
        : t
    ));
  }, [isRunning]);

  const approveCheckpoint = useCallback(() => {
    if (!activeCheckpoint || !checkpointSystemRef.current) return;
    checkpointSystemRef.current.approveCheckpoint(activeCheckpoint.checkpointId);
    setActiveCheckpoint(null);
  }, [activeCheckpoint]);

  const rejectCheckpoint = useCallback((changeRequest?: string) => {
    if (!activeCheckpoint || !checkpointSystemRef.current) return;
    checkpointSystemRef.current.rejectCheckpoint(activeCheckpoint.checkpointId, changeRequest);
    setActiveCheckpoint(null);
  }, [activeCheckpoint]);

  const reset = useCallback(() => {
    setSelectedFormat(null);
    setSelectedGenre(null);
    setIdea('');
    setReferenceDocuments([]);
    setIsRunning(false);
    setIsCancelling(false);
    setCurrentPhase('');
    setExecutionProgress(null);
    setTasks([]);
    setResult(null);
    setError(null);
    setActiveCheckpoint(null);
    checkpointSystemRef.current = null;
    cancelFnRef.current = null;
  }, []);

  return {
    selectedFormat,
    selectedGenre,
    idea,
    referenceDocuments,
    setFormat,
    setGenre,
    setIdea,
    setReferenceDocuments,

    isRunning,
    isCancelling,
    currentPhase,
    executionProgress,
    tasks,
    result,
    error,

    activeCheckpoint,

    execute,
    cancel,
    approveCheckpoint,
    rejectCheckpoint,
    reset,
  };
}
</file>

<file path="hooks/useLyricLens.ts">
import { useState } from "react";
import { AppState, SongData, GeneratedImage, AssetType, ImagePrompt, SubtitleItem } from "@/types";
import {
  transcribeAudioWithWordTiming,
  fileToGenerativePart,
  inferAudioMimeType,
  generateImageFromPrompt,
  generateVideoFromPrompt,
  refineImagePrompt,
  translateSubtitles,
  generateMotionPrompt,
  VideoPurpose,
} from "@/services/geminiService";
import { generatePromptsWithLangChain } from "@/services/directorService";
import { generatePromptsWithAgent } from "@/services/agentDirectorService";
import {
  animateImageWithDeApi,
  generateImageWithAspectRatio,
  generateImageBatch,
  BatchGenerationItem,
} from "@/services/deapiService";
import { subtitlesToSRT } from "@/utils/srtParser";
import { calculateOptimalAssets } from "@/services/assetCalculatorService";

export function useLyricLens() {
  const [appState, setAppState] = useState<AppState>(AppState.IDLE);
  const [songData, setSongData] = useState<SongData | null>(null);
  const [errorMsg, setErrorMsg] = useState<string | null>(null);
  const [isBulkGenerating, setIsBulkGenerating] = useState(false);
  const [contentType, setContentType] = useState<"music" | "story">("music");
  const [globalSubject, setGlobalSubject] = useState("");
  const [aspectRatio, setAspectRatio] = useState("16:9");
  const [videoPurpose, setVideoPurpose] = useState<VideoPurpose>("music_video");
  const [generationMode, setGenerationMode] = useState<"image" | "video">(
    "image",
  );
  const [videoProvider, setVideoProvider] = useState<"veo" | "deapi">("veo");
  const [imageProvider, setImageProvider] = useState<"gemini" | "deapi">("gemini");
  const [directorMode, setDirectorMode] = useState<"chain" | "agent">("chain");
  const [pendingFile, setPendingFile] = useState<File | null>(null);

  // Translation State
  const [isTranslating, setIsTranslating] = useState(false);

  // Store file for processing (kept for backward compatibility)
  const handleFileSelect = (file: File) => {
    setErrorMsg(null);
    setPendingFile(file);
    // Don't change state - let caller decide when to process
  };

  /**
   * Process a file directly without relying on pendingFile state.
   * This eliminates the race condition where state may not be updated
   * before processing begins.
   * 
   * @param file - The audio file to process
   * @param selectedStyle - The style to use for prompt generation
   */
  const processFile = async (file: File, selectedStyle: string) => {
    // Also update pendingFile for backward compatibility
    setPendingFile(file);

    try {
      setErrorMsg(null);
      setAppState(AppState.PROCESSING_AUDIO);

      // 1. Setup local preview
      const audioUrl = URL.createObjectURL(file);
      const partialData: SongData = {
        fileName: file.name,
        audioUrl,
        srtContent: "",
        parsedSubtitles: [],
        prompts: [],
        generatedImages: [],
      };
      setSongData(partialData);

      // 2. Convert to Base64
      const base64Audio = await fileToGenerativePart(file);

      // 3. Transcribe with word-level timing
      setAppState(AppState.TRANSCRIBING);
      const parsedSubs = await transcribeAudioWithWordTiming(
        base64Audio,
        inferAudioMimeType(file.name, file.type),
      );
      // Generate SRT string for backward compat (downloads, prompts)
      const srt = subtitlesToSRT(parsedSubs);

      partialData.srtContent = srt;
      partialData.parsedSubtitles = parsedSubs;
      setSongData({ ...partialData });

      // 4. Calculate optimal number of assets
      // Note: Analysis is now done inside generatePromptsWithLangChain/Agent
      // to avoid duplicate API calls. calculateOptimalAssets only uses duration.
      setAppState(AppState.ANALYZING_LYRICS);

      // Get audio duration from the audio buffer
      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      const arrayBuffer = await file.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      const audioDuration = audioBuffer.duration;

      // Calculate optimal asset count based on duration
      // Note: analysisOutput is not used by the current implementation
      const assetCalc = await calculateOptimalAssets({
        audioDuration,
        analysisOutput: {
          sections: [],
          emotionalArc: { opening: "", peak: "", resolution: "" },
          themes: [],
          motifs: [],
          visualScenes: [],
        },
        videoPurpose,
        contentType: contentType === "story" ? "story" : "lyrics",
      });

      console.log(`[useLyricLens] Dynamic asset calculation: ${assetCalc.optimalAssetCount} assets recommended`);
      console.log(`[useLyricLens] Reasoning: ${assetCalc.reasoning}`);

      // 6. Generate Prompts using selected Director mode with calculated asset count
      setAppState(AppState.GENERATING_PROMPTS);
      // "chain" = LangChain LCEL pipeline (faster, deterministic)
      // "agent" = LangChain Agent with tools (smarter, self-improving)
      let prompts;
      if (directorMode === "agent") {
        console.log("[useLyricLens] Using Agent Director mode");
        prompts = await generatePromptsWithAgent(
          srt,
          selectedStyle,
          contentType === "story" ? "story" : "lyrics",
          videoPurpose,
          globalSubject,
          { targetAssetCount: assetCalc.optimalAssetCount }
        );
      } else {
        console.log("[useLyricLens] Using Chain Director mode");
        prompts = await generatePromptsWithLangChain(
          srt,
          selectedStyle,
          contentType === "story" ? "story" : "lyrics",
          videoPurpose,
          globalSubject,
          { targetAssetCount: assetCalc.optimalAssetCount }
        );
      }

      partialData.prompts = prompts;
      setSongData({ ...partialData });

      setAppState(AppState.READY);
    } catch (e: any) {
      console.error(e);
      setErrorMsg(e.message || "An unexpected error occurred.");
      setAppState(AppState.ERROR);
    }
  };

  /**
   * Legacy function that uses pendingFile state.
   * @deprecated Use processFile instead to avoid race conditions.
   */
  const startProcessing = async (selectedStyle: string) => {
    if (!pendingFile) return;
    await processFile(pendingFile, selectedStyle);
  };

  const handleImageGenerated = (newImg: GeneratedImage) => {
    if (!songData) return;
    setSongData((prev: SongData | null) => {
      if (!prev) return null;
      // Remove existing if replacing
      const filtered = prev.generatedImages.filter(
        (img: GeneratedImage) => img.promptId !== newImg.promptId,
      );

      return {
        ...prev,
        generatedImages: [...filtered, newImg],
      };
    });
  };

  const handleGenerateAll = async (
    selectedStyle: string,
    selectedAspectRatio: "16:9" | "9:16",
  ) => {
    if (!songData || isBulkGenerating) return;
    setIsBulkGenerating(true);

    const pendingPrompts = songData.prompts.filter(
      (p: ImagePrompt) => !songData.generatedImages.some((img: GeneratedImage) => img.promptId === p.id),
    );

    // Track refined prompts for cross-scene deduplication
    const refinedPromptTexts: string[] = [];

    // Collect all existing prompt texts (from already-generated scenes) as initial context
    const existingPromptTexts = songData.prompts
      .filter((p: ImagePrompt) =>
        songData.generatedImages.some((img: GeneratedImage) => img.promptId === p.id),
      )
      .map((p: ImagePrompt) => p.text);

    refinedPromptTexts.push(...existingPromptTexts);

    // Determine if we can use parallel batch generation (DeAPI image-only mode)
    const canUseBatchGeneration = imageProvider === "deapi" && generationMode === "image";

    if (canUseBatchGeneration) {
      // ============================================================
      // PARALLEL BATCH GENERATION (DeAPI)
      // Dramatically faster - runs multiple requests concurrently
      // ============================================================
      console.log(`[useLyricLens] Using parallel batch generation for ${pendingPrompts.length} assets`);

      // First, refine all prompts (this is fast and can be done serially)
      const refinedPrompts: Array<{ prompt: ImagePrompt; refinedText: string }> = [];
      for (const prompt of pendingPrompts) {
        try {
          const { refinedPrompt } = await refineImagePrompt({
            promptText: prompt.text,
            style: selectedStyle,
            globalSubject,
            aspectRatio: selectedAspectRatio,
            intent: "auto",
            previousPrompts: refinedPromptTexts,
          });
          refinedPromptTexts.push(refinedPrompt);
          refinedPrompts.push({ prompt, refinedText: refinedPrompt });
        } catch (e) {
          console.error(`Failed to refine prompt ${prompt.id}`, e);
          // Use original prompt if refinement fails
          refinedPrompts.push({ prompt, refinedText: prompt.text });
        }
      }

      // Prepare batch items for parallel generation
      const batchItems: BatchGenerationItem[] = refinedPrompts.map(({ prompt, refinedText }) => ({
        id: prompt.id,
        prompt: refinedText,
        aspectRatio: selectedAspectRatio as "16:9" | "9:16" | "1:1",
        model: "Flux1schnell" as const,
        negativePrompt: "blur, darkness, noise, low quality, text, watermark, logo",
      }));

      // Run parallel batch generation with concurrency limit of 5
      const batchResults = await generateImageBatch(
        batchItems,
        5, // Concurrency limit - adjust based on API rate limits
        (progress) => {
          console.log(`[useLyricLens] Batch progress: ${progress.completed}/${progress.total}`);
        }
      );

      // Process results and update state
      for (const result of batchResults) {
        if (result.success && result.imageUrl) {
          handleImageGenerated({
            promptId: result.id,
            imageUrl: result.imageUrl,
            type: "image",
          });
        } else {
          console.error(`Failed to generate image for prompt ${result.id}:`, result.error);
        }
      }
    } else {
      // ============================================================
      // SEQUENTIAL GENERATION (Gemini, Video, or mixed modes)
      // Used when parallel generation isn't suitable
      // ============================================================
      console.log(`[useLyricLens] Using sequential generation for ${pendingPrompts.length} assets`);

      for (const prompt of pendingPrompts) {
        try {
          // First, refine the prompt with cross-scene awareness
          const { refinedPrompt } = await refineImagePrompt({
            promptText: prompt.text,
            style: selectedStyle,
            globalSubject,
            aspectRatio: selectedAspectRatio,
            intent: "auto",
            previousPrompts: refinedPromptTexts,
          });

          // Track the refined prompt for subsequent scenes
          refinedPromptTexts.push(refinedPrompt);

          // Determine asset type: use per-card setting if available, otherwise fall back to global
          const getAssetTypeForPrompt = (): AssetType => {
            if (prompt.assetType) return prompt.assetType;
            if (generationMode === "video") {
              return videoProvider === "deapi" ? "video_with_image" : "video";
            }
            return "image";
          };

          const assetType = getAssetTypeForPrompt();
          let base64: string;
          let baseImageUrl: string | undefined;
          let resultType: "image" | "video" = "image";

          if (assetType === "video") {
            // Direct video generation (Veo)
            base64 = await generateVideoFromPrompt(
              refinedPrompt,
              selectedStyle,
              globalSubject,
              selectedAspectRatio,
            );
            resultType = "video";
          } else if (assetType === "video_with_image") {
            // Two-step: Image first, then animate (DeAPI)
            // 1. Generate Image (Gemini)
            const imgBase64 = await generateImageFromPrompt(
              refinedPrompt,
              selectedStyle,
              globalSubject,
              selectedAspectRatio,
              true,
            );
            baseImageUrl = imgBase64;

            // 2. Generate motion-optimized prompt for animation
            const motionResult = await generateMotionPrompt(
              refinedPrompt,
              prompt.mood || "cinematic",
              globalSubject,
            );

            // 3. Animate with motion-focused prompt (DeAPI)
            base64 = await animateImageWithDeApi(
              imgBase64,
              motionResult.combined,
              selectedAspectRatio as "16:9" | "9:16" | "1:1",
            );
            resultType = "video";
          } else {
            // Standard Image Generation
            // Choose provider: Gemini (default) or DeAPI
            if (imageProvider === "deapi") {
              // Use DeAPI for image generation (FLUX.1-schnell or Z-Image-Turbo)
              base64 = await generateImageWithAspectRatio(
                refinedPrompt,
                selectedAspectRatio as "16:9" | "9:16" | "1:1",
                "Flux1schnell", // Fast, high-quality model
              );
            } else {
              // Use Gemini Imagen (default)
              base64 = await generateImageFromPrompt(
                refinedPrompt,
                selectedStyle,
                globalSubject,
                selectedAspectRatio,
                true, // skipRefine - already refined above with previousPrompts
              );
            }
            resultType = "image";
          }

          handleImageGenerated({
            promptId: prompt.id,
            imageUrl: base64,
            type: resultType,
            baseImageUrl,
          });
        } catch (e) {
          console.error(`Failed to generate asset for prompt ${prompt.id}`, e);
        }
      }
    }

    setIsBulkGenerating(false);
  };

  const handleTranslate = async (targetLang: string) => {
    if (!songData || isTranslating) return;
    setIsTranslating(true);
    try {
      const translations = await translateSubtitles(
        songData.parsedSubtitles,
        targetLang,
      );

      // Merge translations
      const updatedSubs = songData.parsedSubtitles.map((sub: SubtitleItem) => {
        const trans = translations.find((t: { id: number; translation: string }) => t.id === sub.id);
        return trans ? { ...sub, translation: trans.translation } : sub;
      });

      setSongData((prev: SongData | null) =>
        prev ? { ...prev, parsedSubtitles: updatedSubs } : null,
      );
    } catch (e) {
      console.error("Translation failed", e);
      alert("Translation failed. Please try again.");
    } finally {
      setIsTranslating(false);
    }
  };

  const loadTestData = async () => {
    try {
      setErrorMsg(null);
      setAppState(AppState.PROCESSING_AUDIO);

      // Use browser-compatible test data
      const { createTestSongData } = await import("@/utils/testData");
      const testData = createTestSongData();

      setSongData(testData);
      setAppState(AppState.READY);

      console.log("‚úÖ Test data loaded successfully");
    } catch (e: any) {
      console.error("Failed to load test data:", e);
      setErrorMsg("Failed to load test data: " + e.message);
      setAppState(AppState.ERROR);
    }
  };

  const resetApp = () => {
    setAppState(AppState.IDLE);
    setSongData(null);
    setPendingFile(null);
    setErrorMsg(null);
    setIsBulkGenerating(false);
    setIsTranslating(false);
    setGlobalSubject("");
    setAspectRatio("16:9");
    setGenerationMode("image");
    setVideoProvider("veo");
    setVideoPurpose("music_video");
  };

  return {
    appState,
    songData,
    setSongData,
    errorMsg,
    isBulkGenerating,
    contentType,
    isTranslating,
    globalSubject,
    aspectRatio,
    generationMode,
    videoPurpose,
    setGenerationMode,
    videoProvider,
    setVideoProvider,
    imageProvider,
    setImageProvider,
    // Expose director mode for UI toggle (chain vs agent)
    directorMode,
    setDirectorMode,
    setAspectRatio,
    setGlobalSubject,
    setContentType,
    setVideoPurpose,
    handleFileSelect,
    startProcessing,
    processFile,
    // pendingFile removed from exports - use processFile instead
    handleImageGenerated,
    handleGenerateAll,
    handleTranslate,
    loadTestData,
    resetApp,
  };
}
</file>

<file path="hooks/useMediaPlayback.ts">
/**
 * useMediaPlayback - Shared media playback state and controls
 *
 * Provides unified playback controls for audio/video across components.
 * Used by StudioScreen, VisualizerScreen, and timeline components.
 */

import { useState, useCallback, useRef, useEffect, useMemo } from 'react';

export interface PlaybackState {
  isPlaying: boolean;
  currentTime: number;
  duration: number;
  volume: number;
  isMuted: boolean;
  playbackRate: number;
}

export interface UseMediaPlaybackOptions {
  /** Initial volume (0-1) */
  initialVolume?: number;
  /** Auto-play on load */
  autoPlay?: boolean;
  /** Loop playback */
  loop?: boolean;
  /** Callback when playback ends */
  onEnded?: () => void;
  /** Callback when time updates */
  onTimeUpdate?: (time: number) => void;
}

export interface UseMediaPlaybackReturn {
  // State
  isPlaying: boolean;
  currentTime: number;
  duration: number;
  volume: number;
  isMuted: boolean;
  playbackRate: number;

  // Ref to attach to audio/video element
  mediaRef: React.RefObject<HTMLAudioElement | HTMLVideoElement>;

  // Controls
  play: () => void;
  pause: () => void;
  togglePlayPause: () => void;
  seek: (time: number) => void;
  seekRelative: (delta: number) => void;
  setVolume: (volume: number) => void;
  toggleMute: () => void;
  setPlaybackRate: (rate: number) => void;
  reset: () => void;

  // Utilities
  formatTime: (seconds: number) => string;
  getProgress: () => number;
}

/**
 * Hook for managing audio/video playback state
 *
 * @example
 * ```tsx
 * const {
 *   mediaRef,
 *   isPlaying,
 *   togglePlayPause,
 *   seek,
 *   formatTime
 * } = useMediaPlayback({ onEnded: () => console.log('done') });
 *
 * return (
 *   <>
 *     <audio ref={mediaRef} src={audioUrl} />
 *     <button onClick={togglePlayPause}>
 *       {isPlaying ? 'Pause' : 'Play'}
 *     </button>
 *     <span>{formatTime(currentTime)} / {formatTime(duration)}</span>
 *   </>
 * );
 * ```
 */
export function useMediaPlayback(options: UseMediaPlaybackOptions = {}): UseMediaPlaybackReturn {
  const {
    initialVolume = 1,
    autoPlay = false,
    loop = false,
    onEnded,
    onTimeUpdate,
  } = options;

  const [state, setState] = useState<PlaybackState>({
    isPlaying: false,
    currentTime: 0,
    duration: 0,
    volume: initialVolume,
    isMuted: false,
    playbackRate: 1,
  });

  const mediaRef = useRef<HTMLAudioElement | HTMLVideoElement>(null);
  const onEndedRef = useRef(onEnded);
  const onTimeUpdateRef = useRef(onTimeUpdate);

  // Keep callbacks fresh
  useEffect(() => {
    onEndedRef.current = onEnded;
    onTimeUpdateRef.current = onTimeUpdate;
  }, [onEnded, onTimeUpdate]);

  // Set up media element event listeners
  useEffect(() => {
    const media = mediaRef.current;
    if (!media) return;

    const handleTimeUpdate = () => {
      const time = media.currentTime;
      setState((prev) => ({ ...prev, currentTime: time }));
      onTimeUpdateRef.current?.(time);
    };

    const handleDurationChange = () => {
      setState((prev) => ({ ...prev, duration: media.duration || 0 }));
    };

    const handlePlay = () => {
      setState((prev) => ({ ...prev, isPlaying: true }));
    };

    const handlePause = () => {
      setState((prev) => ({ ...prev, isPlaying: false }));
    };

    const handleEnded = () => {
      setState((prev) => ({ ...prev, isPlaying: false, currentTime: 0 }));
      onEndedRef.current?.();
    };

    const handleVolumeChange = () => {
      setState((prev) => ({
        ...prev,
        volume: media.volume,
        isMuted: media.muted,
      }));
    };

    const handleLoadedMetadata = () => {
      setState((prev) => ({ ...prev, duration: media.duration || 0 }));
      media.volume = initialVolume;
      media.loop = loop;
      if (autoPlay) {
        media.play().catch(() => {
          // Autoplay blocked by browser
        });
      }
    };

    media.addEventListener('timeupdate', handleTimeUpdate);
    media.addEventListener('durationchange', handleDurationChange);
    media.addEventListener('play', handlePlay);
    media.addEventListener('pause', handlePause);
    media.addEventListener('ended', handleEnded);
    media.addEventListener('volumechange', handleVolumeChange);
    media.addEventListener('loadedmetadata', handleLoadedMetadata);

    return () => {
      media.removeEventListener('timeupdate', handleTimeUpdate);
      media.removeEventListener('durationchange', handleDurationChange);
      media.removeEventListener('play', handlePlay);
      media.removeEventListener('pause', handlePause);
      media.removeEventListener('ended', handleEnded);
      media.removeEventListener('volumechange', handleVolumeChange);
      media.removeEventListener('loadedmetadata', handleLoadedMetadata);
    };
  }, [autoPlay, loop, initialVolume]);

  const play = useCallback(() => {
    mediaRef.current?.play().catch(() => {
      // Play was prevented
    });
  }, []);

  const pause = useCallback(() => {
    mediaRef.current?.pause();
  }, []);

  const togglePlayPause = useCallback(() => {
    const media = mediaRef.current;
    if (!media) return;

    if (media.paused) {
      media.play().catch(() => {});
    } else {
      media.pause();
    }
  }, []);

  const seek = useCallback((time: number) => {
    const media = mediaRef.current;
    if (!media) return;

    const clampedTime = Math.max(0, Math.min(time, media.duration || 0));
    media.currentTime = clampedTime;
    setState((prev) => ({ ...prev, currentTime: clampedTime }));
  }, []);

  const seekRelative = useCallback((delta: number) => {
    const media = mediaRef.current;
    if (!media) return;

    const newTime = media.currentTime + delta;
    seek(newTime);
  }, [seek]);

  const setVolume = useCallback((volume: number) => {
    const media = mediaRef.current;
    if (!media) return;

    const clampedVolume = Math.max(0, Math.min(1, volume));
    media.volume = clampedVolume;
    if (clampedVolume > 0 && media.muted) {
      media.muted = false;
    }
  }, []);

  const toggleMute = useCallback(() => {
    const media = mediaRef.current;
    if (!media) return;

    media.muted = !media.muted;
  }, []);

  const setPlaybackRate = useCallback((rate: number) => {
    const media = mediaRef.current;
    if (!media) return;

    const clampedRate = Math.max(0.25, Math.min(4, rate));
    media.playbackRate = clampedRate;
    setState((prev) => ({ ...prev, playbackRate: clampedRate }));
  }, []);

  const reset = useCallback(() => {
    const media = mediaRef.current;
    if (media) {
      media.pause();
      media.currentTime = 0;
    }
    setState((prev) => ({
      ...prev,
      isPlaying: false,
      currentTime: 0,
    }));
  }, []);

  const formatTime = useCallback((seconds: number): string => {
    if (!isFinite(seconds) || isNaN(seconds)) return '0:00';

    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }, []);

  const getProgress = useCallback((): number => {
    if (state.duration === 0) return 0;
    return (state.currentTime / state.duration) * 100;
  }, [state.currentTime, state.duration]);

  return useMemo(() => ({
    // State
    isPlaying: state.isPlaying,
    currentTime: state.currentTime,
    duration: state.duration,
    volume: state.volume,
    isMuted: state.isMuted,
    playbackRate: state.playbackRate,

    // Ref
    mediaRef: mediaRef as React.RefObject<HTMLAudioElement | HTMLVideoElement>,

    // Controls
    play,
    pause,
    togglePlayPause,
    seek,
    seekRelative,
    setVolume,
    toggleMute,
    setPlaybackRate,
    reset,

    // Utilities
    formatTime,
    getProgress,
  }), [
    state,
    play,
    pause,
    togglePlayPause,
    seek,
    seekRelative,
    setVolume,
    toggleMute,
    setPlaybackRate,
    reset,
    formatTime,
    getProgress,
  ]);
}

export default useMediaPlayback;
</file>

<file path="hooks/useModalState.ts">
/**
 * useModalState - Unified modal state management
 *
 * Replaces scattered boolean state flags with a single state machine
 * for managing modals and side panels.
 */

import { useState, useCallback, useMemo } from 'react';

export type ModalType =
  | 'export'
  | 'quality'
  | 'sceneEditor'
  | 'music'
  | 'settings'
  | 'timeline'
  | null;

export interface ModalOptions {
  /** Data to pass to the modal */
  data?: Record<string, unknown>;
  /** Callback when modal closes */
  onClose?: () => void;
}

export interface ModalState {
  activeModal: ModalType;
  modalData: Record<string, unknown>;
}

export interface UseModalStateReturn {
  /** Currently active modal (null if none) */
  activeModal: ModalType;
  /** Data passed to the active modal */
  modalData: Record<string, unknown>;
  /** Open a specific modal */
  openModal: (modal: ModalType, options?: ModalOptions) => void;
  /** Close the currently active modal */
  closeModal: () => void;
  /** Toggle a modal open/closed */
  toggleModal: (modal: ModalType, options?: ModalOptions) => void;
  /** Check if a specific modal is open */
  isOpen: (modal: ModalType) => boolean;
  /** Close all modals */
  closeAll: () => void;

  // Convenience boolean getters for common use cases
  showExport: boolean;
  showQuality: boolean;
  showSceneEditor: boolean;
  showMusic: boolean;
  showSettings: boolean;
  showTimeline: boolean;

  // Convenience setters for backwards compatibility
  setShowExport: (show: boolean) => void;
  setShowQuality: (show: boolean) => void;
  setShowSceneEditor: (show: boolean) => void;
  setShowMusic: (show: boolean) => void;
  setShowSettings: (show: boolean) => void;
  setShowTimeline: (show: boolean) => void;
}

/**
 * Hook for managing modal/panel visibility state
 *
 * @example
 * ```tsx
 * const { activeModal, openModal, closeModal, showExport } = useModalState();
 *
 * // Open with data
 * openModal('export', { data: { videoTitle: 'My Video' } });
 *
 * // Use convenience boolean
 * if (showExport) { ... }
 *
 * // Toggle
 * toggleModal('sceneEditor');
 * ```
 */
export function useModalState(initialModal: ModalType = null): UseModalStateReturn {
  const [state, setState] = useState<ModalState>({
    activeModal: initialModal,
    modalData: {},
  });

  const [closeCallback, setCloseCallback] = useState<(() => void) | null>(null);

  const openModal = useCallback((modal: ModalType, options?: ModalOptions) => {
    setState({
      activeModal: modal,
      modalData: options?.data || {},
    });
    if (options?.onClose) {
      setCloseCallback(() => options.onClose);
    }
  }, []);

  const closeModal = useCallback(() => {
    if (closeCallback) {
      closeCallback();
      setCloseCallback(null);
    }
    setState({
      activeModal: null,
      modalData: {},
    });
  }, [closeCallback]);

  const toggleModal = useCallback((modal: ModalType, options?: ModalOptions) => {
    setState((prev) => {
      if (prev.activeModal === modal) {
        if (closeCallback) {
          closeCallback();
          setCloseCallback(null);
        }
        return { activeModal: null, modalData: {} };
      }
      if (options?.onClose) {
        setCloseCallback(() => options.onClose);
      }
      return {
        activeModal: modal,
        modalData: options?.data || {},
      };
    });
  }, [closeCallback]);

  const isOpen = useCallback((modal: ModalType): boolean => {
    return state.activeModal === modal;
  }, [state.activeModal]);

  const closeAll = useCallback(() => {
    if (closeCallback) {
      closeCallback();
      setCloseCallback(null);
    }
    setState({ activeModal: null, modalData: {} });
  }, [closeCallback]);

  // Convenience booleans
  const showExport = state.activeModal === 'export';
  const showQuality = state.activeModal === 'quality';
  const showSceneEditor = state.activeModal === 'sceneEditor';
  const showMusic = state.activeModal === 'music';
  const showSettings = state.activeModal === 'settings';
  const showTimeline = state.activeModal === 'timeline';

  // Convenience setters for backwards compatibility
  const setShowExport = useCallback((show: boolean) => {
    if (show) openModal('export');
    else if (state.activeModal === 'export') closeModal();
  }, [openModal, closeModal, state.activeModal]);

  const setShowQuality = useCallback((show: boolean) => {
    if (show) openModal('quality');
    else if (state.activeModal === 'quality') closeModal();
  }, [openModal, closeModal, state.activeModal]);

  const setShowSceneEditor = useCallback((show: boolean) => {
    if (show) openModal('sceneEditor');
    else if (state.activeModal === 'sceneEditor') closeModal();
  }, [openModal, closeModal, state.activeModal]);

  const setShowMusic = useCallback((show: boolean) => {
    if (show) openModal('music');
    else if (state.activeModal === 'music') closeModal();
  }, [openModal, closeModal, state.activeModal]);

  const setShowSettings = useCallback((show: boolean) => {
    if (show) openModal('settings');
    else if (state.activeModal === 'settings') closeModal();
  }, [openModal, closeModal, state.activeModal]);

  const setShowTimeline = useCallback((show: boolean) => {
    if (show) openModal('timeline');
    else if (state.activeModal === 'timeline') closeModal();
  }, [openModal, closeModal, state.activeModal]);

  return useMemo(() => ({
    activeModal: state.activeModal,
    modalData: state.modalData,
    openModal,
    closeModal,
    toggleModal,
    isOpen,
    closeAll,
    showExport,
    showQuality,
    showSceneEditor,
    showMusic,
    showSettings,
    showTimeline,
    setShowExport,
    setShowQuality,
    setShowSceneEditor,
    setShowMusic,
    setShowSettings,
    setShowTimeline,
  }), [
    state,
    openModal,
    closeModal,
    toggleModal,
    isOpen,
    closeAll,
    showExport,
    showQuality,
    showSceneEditor,
    showMusic,
    showSettings,
    showTimeline,
    setShowExport,
    setShowQuality,
    setShowSceneEditor,
    setShowMusic,
    setShowSettings,
    setShowTimeline,
  ]);
}

export default useModalState;
</file>

<file path="hooks/useProjectSession.ts">
/**
 * useProjectSession Hook
 *
 * Manages the connection between Project (Firestore) and Production Session (IndexedDB).
 * Handles loading, restoring, and syncing project state.
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import { useAppStore } from '@/stores';
import {
  getProject,
  updateProject,
  markProjectAccessed,
  type Project,
  type UpdateProjectInput,
} from '@/services/projectService';
import {
  restoreProductionSession,
  initializeProductionSession,
  flushPendingPersistence,
} from '@/services/ai/production/store';
import { cloudAutosave } from '@/services/cloudStorageService';
import type { ProductionState } from '@/services/ai/production/types';

export interface UseProjectSessionResult {
  project: Project | null;
  sessionId: string | null;
  isLoading: boolean;
  error: string | null;
  restoredState: ProductionState | null;
  syncProjectMetadata: (updates: Partial<UpdateProjectInput>) => void;
  flushSession: () => Promise<void>;
}

const SYNC_DEBOUNCE_MS = 2000;

export function useProjectSession(projectId: string | undefined): UseProjectSessionResult {
  const [project, setProject] = useState<Project | null>(null);
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [restoredState, setRestoredState] = useState<ProductionState | null>(null);

  const setCurrentProjectId = useAppStore((s) => s.setCurrentProjectId);
  const syncTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const pendingUpdatesRef = useRef<Partial<UpdateProjectInput>>({});

  // Load project and restore session on mount or projectId change
  useEffect(() => {
    if (!projectId) {
      // No project - clear state
      setProject(null);
      setSessionId(null);
      setRestoredState(null);
      setCurrentProjectId(null);
      setError(null);
      return;
    }

    // Capture projectId to help TypeScript narrow the type
    const currentProjectId = projectId;
    let cancelled = false;

    async function loadAndRestore() {
      setIsLoading(true);
      setError(null);

      try {
        // 1. Load project from Firestore
        const loadedProject = await getProject(currentProjectId);

        if (cancelled) return;

        if (!loadedProject) {
          throw new Error(`Project "${currentProjectId}" not found or access denied`);
        }

        setProject(loadedProject);
        setCurrentProjectId(currentProjectId);

        // Mark as accessed (fire-and-forget)
        markProjectAccessed(currentProjectId);

        // 2. Get session ID from project
        const cloudSessionId = loadedProject.cloudSessionId;
        setSessionId(cloudSessionId);

        // 3. Try to restore production state from IndexedDB
        const restored = await restoreProductionSession(cloudSessionId);

        if (cancelled) return;

        if (restored) {
          console.log(
            `[useProjectSession] Restored session ${cloudSessionId} with ${restored.contentPlan?.scenes?.length || 0} scenes`
          );
          setRestoredState(restored);
        } else {
          // No existing session - initialize new one
          console.log(
            `[useProjectSession] No existing session, initializing ${cloudSessionId}`
          );
          await initializeProductionSession(cloudSessionId, {});

          // Initialize cloud autosave (fire-and-forget)
          cloudAutosave.initSession(cloudSessionId).catch((err) => {
            console.warn('[useProjectSession] Cloud autosave init failed:', err);
          });
        }
      } catch (err) {
        if (cancelled) return;
        console.error('[useProjectSession] Failed to load project:', err);
        setError(err instanceof Error ? err.message : 'Failed to load project');
      } finally {
        if (!cancelled) {
          setIsLoading(false);
        }
      }
    }

    loadAndRestore();

    // Cleanup on unmount or projectId change
    return () => {
      cancelled = true;
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
        // Flush any pending updates before unmount
        if (Object.keys(pendingUpdatesRef.current).length > 0) {
          updateProject(currentProjectId, pendingUpdatesRef.current).catch(() => {});
          pendingUpdatesRef.current = {};
        }
      }
    };
  }, [projectId, setCurrentProjectId]);

  // Sync project metadata to Firestore (debounced)
  const syncProjectMetadata = useCallback(
    (updates: Partial<UpdateProjectInput>) => {
      if (!projectId || !project) return;

      // Merge updates with pending
      pendingUpdatesRef.current = {
        ...pendingUpdatesRef.current,
        ...updates,
      };

      // Debounce sync calls
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
      }

      syncTimeoutRef.current = setTimeout(async () => {
        const toSync = { ...pendingUpdatesRef.current };
        pendingUpdatesRef.current = {};

        try {
          await updateProject(projectId, toSync);
          console.log('[useProjectSession] Synced project metadata:', Object.keys(toSync));
        } catch (err) {
          console.warn('[useProjectSession] Failed to sync project metadata:', err);
        }
      }, SYNC_DEBOUNCE_MS);
    },
    [projectId, project]
  );

  // Flush session to IndexedDB
  const flushSession = useCallback(async () => {
    if (!sessionId) return;

    // Flush IndexedDB persistence
    await flushPendingPersistence(sessionId);

    // Also flush any pending Firestore updates
    if (syncTimeoutRef.current) {
      clearTimeout(syncTimeoutRef.current);
      syncTimeoutRef.current = null;
    }

    if (projectId && Object.keys(pendingUpdatesRef.current).length > 0) {
      const toSync = { ...pendingUpdatesRef.current };
      pendingUpdatesRef.current = {};
      await updateProject(projectId, toSync);
    }
  }, [sessionId, projectId]);

  return {
    project,
    sessionId,
    isLoading,
    error,
    restoredState,
    syncProjectMetadata,
    flushSession,
  };
}
</file>

<file path="hooks/useStoryGeneration.ts">
/**
 * useStoryGeneration Hook
 *
 * Manages the state and transition logic for the Story Mode workflow.
 * Workflow: Idea (Topic) ‚Üí Breakdown ‚Üí Screenplay ‚Üí Characters ‚Üí Shotlist ‚Üí Narration ‚Üí Animation ‚Üí Export
 */

import { useState, useCallback, useEffect } from 'react';
import type {
    StoryStep,
    StoryState,
    ScreenplayScene,
    CharacterProfile,
    ShotlistEntry,
    ConsistencyReport,
    StoryShot,
    Scene
} from '@/types';
import { runProductionAgent } from '@/services/ai/productionAgent';
import { breakAllScenesIntoShots } from '@/services/ai/shotBreakdownAgent';
import { storyModeStore } from '@/services/ai/production/store';
import type { StoryModeState } from '@/services/ai/production/types';
import { narrateScene, narrateAllShots, createAudioUrl, type NarratorConfig } from '@/services/narratorService';
import { generateVideoFromPrompt } from '@/services/videoService';
import { animateImageWithDeApi, generateVideoWithDeApi, isDeApiConfigured, generateImageWithAspectRatio, generateImageBatch } from '@/services/deapiService';
import { exportVideoWithFFmpeg } from '@/services/ffmpeg/exporters';
import { generateCharacterReference, enrichCharactersWithCoreAnchors } from '@/services/characterService';
import { cloudAutosave } from '@/services/cloudStorageService';
import { createCombinedNarrationAudio } from '@/services/audioConcatService';
import {
    debouncedSaveToCloud,
    loadStoryFromCloud,
    isSyncAvailable,
    flushPendingSave,
    getCurrentUser,
    onAuthChange,
} from '@/services/firebase';
import {
    fromShotBreakdown,
    serializeStyleGuideAsText,
    type ExtractedStyleOverride,
} from '@/services/prompt/imageStyleGuide';
import { getSystemPersona } from '@/services/prompt/personaData';
import type { VideoPurpose } from '@/constants';
import {
    extractVisualStyle,
    type VisualStyle,
} from '@/services/visualConsistencyService';
import { getCharacterSeed } from '@/services/imageService';
import { cleanForTTS, cleanForSubtitles } from '@/services/textSanitizer';
import { generateVoiceoverScripts } from '@/services/ai/storyPipeline';
import { detectLanguage } from '@/services/languageDetector';

/**
 * Generate anti-style negative prompts based on chosen visual style.
 * Prevents style contamination (e.g., cinematic shots appearing as 3D renders).
 */
function generateNegativePromptsForStyle(style: string): string[] {
    const lower = style.toLowerCase();
    const base = ["watermark", "text overlay", "UI elements", "blurry", "low resolution"];

    const styleNegatives: Record<string, string[]> = {
        cinematic: ["3D render", "stock photo", "cartoon", "flat lighting", "anime", "pixel art"],
        "anime / manga": ["photorealistic", "3D render", "stock photo", "film grain"],
        cyberpunk: ["pastoral", "bright daylight", "cartoon", "watercolor"],
        watercolor: ["photorealistic", "3D render", "sharp edges", "neon"],
        "oil painting": ["photorealistic", "digital art", "flat colors", "anime"],
        "pixel art": ["photorealistic", "smooth gradients", "film grain"],
        photorealistic: ["cartoon", "anime", "pixel art", "painting", "illustration"],
        "dark fantasy": ["bright colors", "cartoon", "modern setting", "clean"],
        "comic book": ["photorealistic", "film grain", "watercolor", "muted colors"],
    };

    return [...base, ...(styleNegatives[lower] || styleNegatives["cinematic"]!)];
}

/** Motion strength configuration for DeAPI animation (Issue 4) */
type MotionStrength = 'subtle' | 'moderate' | 'dynamic';

const MOTION_CONFIGS: Record<MotionStrength, { frames: number; promptPrefix: string }> = {
    subtle: { frames: 60, promptPrefix: "Slow gentle camera movement. Minimal subject motion." },
    moderate: { frames: 90, promptPrefix: "Smooth camera movement. Subtle subject motion." },
    dynamic: { frames: 120, promptPrefix: "Dynamic camera movement." },
};

/** Auto-select motion strength based on shot type and camera movement (Issue 4) */
function selectMotionStrength(shotType: string, movement: string): MotionStrength {
    const type = shotType.toLowerCase();
    const mov = movement.toLowerCase();

    // Close-ups use subtle to prevent face distortion
    if (type.includes('close-up') || type.includes('extreme close')) return 'subtle';
    // Static shots use subtle
    if (mov === 'static') return 'subtle';
    // Tracking/handheld use dynamic
    if (mov === 'tracking' || mov === 'handheld') return 'dynamic';
    // Pan/tilt/dolly/zoom use moderate
    return 'moderate';
}

/** Build camera-focused animation prompt instead of raw narrative description (Issue 4) */
function buildAnimationPrompt(movement: string, description: string): string {
    const movLower = movement.toLowerCase();
    let cameraDirection = '';
    if (movLower === 'pan') cameraDirection = 'slow horizontal pan';
    else if (movLower === 'tilt') cameraDirection = 'gentle vertical tilt';
    else if (movLower === 'zoom') cameraDirection = 'slow zoom in';
    else if (movLower === 'dolly') cameraDirection = 'smooth dolly forward';
    else if (movLower === 'tracking') cameraDirection = 'tracking camera movement';
    else if (movLower === 'handheld') cameraDirection = 'subtle handheld sway';
    else cameraDirection = 'slow gentle camera drift';

    // Truncate description to 200 chars to leave room for camera instruction
    const shortDesc = description.length > 200 ? description.substring(0, 197) + '...' : description;
    return `${cameraDirection}. ${shortDesc}. Atmospheric, minimal character motion.`;
}

const STORAGE_KEY = 'ai_soul_studio_story_state';
const SESSION_KEY = 'ai_soul_studio_story_session';
const USER_ID_KEY = 'ai_soul_studio_story_user_id';
const PROJECT_ID_KEY = 'ai_soul_studio_story_project_id';

/**
 * Strip markdown and metadata artifacts from narration text.
 * Delegates to the extracted textSanitizer service for comprehensive cleaning.
 */
function cleanNarrationText(text: string): string {
    return cleanForTTS(text);
}

/**
 * Infer emotional tone and instruction triplet for a scene based on its content
 * and position in the narrative arc. Replaces hardcoded 'dramatic' for all scenes.
 */
function inferSceneEmotion(scene: ScreenplayScene, index: number, total: number): {
    emotionalTone: 'professional' | 'dramatic' | 'friendly' | 'urgent' | 'calm';
    instructionTriplet: { primaryEmotion: string; cinematicDirection: string; environmentalAtmosphere: string };
} {
    const text = `${scene.heading} ${scene.action}`.toLowerCase();

    // Keyword-based emotion detection (English + Arabic)
    const urgentWords = /\b(run|escape|chase|hurry|danger|attack|fight|scream|crash|explode|fire|flood|storm)\b|Ÿäÿ±ŸÉÿ∂|ŸäŸáÿ±ÿ®|ÿÆÿ∑ÿ±|Ÿáÿ¨ŸàŸÖ|ŸäŸáÿßÿ¨ŸÖ|Ÿäÿµÿ±ÿÆ|ÿµÿ±ÿßÿÆ|ŸäŸÜŸÅÿ¨ÿ±|ÿ≠ÿ±ŸäŸÇ|ŸÅŸäÿ∂ÿßŸÜ|ÿπÿßÿµŸÅÿ©|ÿÆŸÜŸÇ|ŸäÿÆŸÜŸÇ|ÿ±ÿπÿ®|ŸÅÿ≤ÿπ|ŸáŸÑÿπ|Ÿäÿ∑ÿßÿ±ÿØ/;
    const calmWords = /\b(peace|serene|quiet|gentle|soft|still|dawn|morning|garden|rest|sleep|dream)\b|ÿ≥ŸÑÿßŸÖ|ŸáÿØŸàÿ°|ÿ≥ŸÉŸàŸÜ|ÿµÿ®ÿßÿ≠|ÿ≠ÿØŸäŸÇÿ©|ÿ±ÿßÿ≠ÿ©|ŸÜŸàŸÖ|ÿ≠ŸÑŸÖ|ŸÅÿ¨ÿ±|ÿ∑ŸÖÿ£ŸÜŸäŸÜÿ©|ÿ£ŸÖÿßŸÜ/;
    const friendlyWords = /\b(smile|laugh|friend|welcome|warm|celebrate|joy|happy|festival|feast|gift)\b|ÿßÿ®ÿ™ÿ≥ÿßŸÖÿ©|ÿ∂ÿ≠ŸÉ|ÿµÿØŸäŸÇ|ÿ™ÿ±ÿ≠Ÿäÿ®|ŸÅÿ±ÿ≠|ÿßÿ≠ÿ™ŸÅÿßŸÑ|ÿ≥ÿπÿßÿØÿ©|ÿπŸäÿØ|ŸáÿØŸäÿ©/;
    const dramaticWords = /\b(reveal|secret|truth|betray|lost|dark|shadow|death|ancient|fate|destiny|mystery)\b|ÿ≥ÿ±|ÿ≠ŸÇŸäŸÇÿ©|ÿÆŸäÿßŸÜÿ©|ÿ∏ŸÑÿßŸÖ|ÿ∏ŸÑ|ŸÖŸàÿ™|ŸÇÿØŸäŸÖ|ŸÖÿµŸäÿ±|ŸÇÿØÿ±|ÿ∫ŸÖŸàÿ∂|ŸÑÿ∫ÿ≤|ÿ¥ÿ®ÿ≠|ÿ¨ŸÜ|ŸÑÿπŸÜÿ©|ŸÖŸáÿ¨Ÿàÿ±|ŸÖÿÆŸäŸÅ|ÿ∫ÿßŸÖÿ∂/;

    // Narrative arc position
    const position = total > 1 ? index / (total - 1) : 0.5;
    const isOpening = index === 0;
    const isClimax = position >= 0.6 && position <= 0.8;
    const isEnding = index === total - 1;

    let tone: 'professional' | 'dramatic' | 'friendly' | 'urgent' | 'calm' = 'dramatic';
    let emotion = 'cinematic-wonder';
    let cinematic = 'slow-push-in';
    let atmosphere = 'golden-hour-decay';

    if (urgentWords.test(text)) {
        tone = 'urgent';
        emotion = 'visceral-dread';
        cinematic = 'handheld-float';
        atmosphere = 'tension-drone';
    } else if (calmWords.test(text)) {
        tone = 'calm';
        emotion = 'nostalgic-warmth';
        cinematic = 'slow-pull-back';
        atmosphere = 'golden-hour-decay';
    } else if (friendlyWords.test(text)) {
        tone = 'friendly';
        emotion = 'bittersweet-longing';
        cinematic = 'tracking-shot';
        atmosphere = 'hopeful-pad';
    } else if (dramaticWords.test(text)) {
        tone = 'dramatic';
        emotion = 'visceral-dread';
        cinematic = 'dutch-angle';
        atmosphere = 'foggy-ruins';
    }

    // Narrative arc overrides
    if (isOpening) {
        cinematic = 'slow-push-in';
        if (tone === 'dramatic') atmosphere = 'foggy-ruins';
    }
    if (isClimax) {
        tone = urgentWords.test(text) ? 'urgent' : 'dramatic';
        cinematic = 'dutch-angle';
        emotion = 'visceral-dread';
    }
    if (isEnding) {
        cinematic = 'slow-pull-back';
        if (!urgentWords.test(text)) {
            tone = 'calm';
            emotion = 'nostalgic-warmth';
            atmosphere = 'golden-hour-decay';
        }
    }

    return {
        emotionalTone: tone,
        instructionTriplet: {
            primaryEmotion: emotion,
            cinematicDirection: cinematic,
            environmentalAtmosphere: atmosphere,
        },
    };
}

/**
 * Strip base64 image/audio/video data from state before saving to localStorage.
 * Media is saved to cloud storage separately, so we only need metadata for recovery.
 * This prevents QuotaExceededError when state contains many generated assets.
 */
function stripImageDataForStorage(state: StoryState): StoryState {
    const isBase64 = (url?: string) => url?.startsWith('data:');
    const isBlobUrl = (url?: string) => url?.startsWith('blob:');
    const shouldStrip = (url?: string) => isBase64(url) || isBlobUrl(url);

    return {
        ...state,
        characters: state.characters.map(char => ({
            ...char,
            // Keep URL if it's a cloud/remote URL, remove if base64/blob
            referenceImageUrl: shouldStrip(char.referenceImageUrl) ? undefined : char.referenceImageUrl,
        })),
        shotlist: state.shotlist.map(shot => ({
            ...shot,
            imageUrl: shouldStrip(shot.imageUrl) ? undefined : shot.imageUrl,
        })),
        shots: state.shots?.map(shot => ({
            ...shot,
            imageUrl: shouldStrip(shot.imageUrl) ? undefined : shot.imageUrl,
        })),
        // Strip blob URLs from narration (audio)
        narrationSegments: state.narrationSegments?.map(seg => ({
            ...seg,
            audioUrl: shouldStrip(seg.audioUrl) ? '' : seg.audioUrl,
        })),
        // Strip blob URLs from per-shot narration segments
        shotNarrationSegments: state.shotNarrationSegments?.map(seg => ({
            ...seg,
            audioUrl: shouldStrip(seg.audioUrl) ? '' : seg.audioUrl,
        })),
        // Strip blob URLs from animated shots (video)
        animatedShots: state.animatedShots?.map(shot => ({
            ...shot,
            videoUrl: shouldStrip(shot.videoUrl) ? '' : shot.videoUrl,
            thumbnailUrl: shouldStrip(shot.thumbnailUrl) ? undefined : shot.thumbnailUrl,
        })),
        // Don't save final video URL (too large)
        finalVideoUrl: undefined,
    };
}

/** Matches ASCII digits (0-9), Arabic-Indic (Ÿ†-Ÿ©), and Extended Arabic-Indic (€∞-€π) */
const DIGITS = '(?:[0-9\u0660-\u0669\u06F0-\u06F9])';

/**
 * Strip LLM preamble text that appears before the first scene/act/chapter marker.
 * LLMs often prepend conversational text like "Here is a narrative breakdown..."
 * or Arabic equivalents like "ÿ•ŸÑŸäŸÉ ÿ™ŸÅÿµŸäŸÑ ÿ≥ÿ±ÿØŸä..." which pollutes scene data.
 */
function stripLLMPreamble(text: string): string {
    // Find the first occurrence of a scene/act/chapter marker
    const markerPattern = new RegExp(`(?:Act|Chapter|Scene|Part|ŸÅÿµŸÑ|ŸÖÿ¥ŸáÿØ)\\s*${DIGITS}+`, 'i');
    const match = text.match(markerPattern);

    if (match && match.index !== undefined && match.index > 0) {
        const preamble = text.substring(0, match.index).trim();
        // Only strip if the preamble looks like conversational text (not actual content)
        // Heuristic: preamble is short-ish (< 300 chars) and doesn't contain multiple newlines
        // (which would suggest it's actual structured content)
        const newlineCount = (preamble.match(/\n/g) || []).length;
        if (preamble.length < 300 || newlineCount < 3) {
            console.log(`[parseBreakdown] Stripped LLM preamble (${preamble.length} chars): "${preamble.substring(0, 80)}..."`);
            return text.substring(match.index);
        }
    }

    // Also try numbered list markers (e.g., "1." or "1)" or "Ÿ°.")
    const numberedMatch = text.match(new RegExp(`^\\s*${DIGITS}[.)]\\s`, 'm'));
    if (numberedMatch && numberedMatch.index !== undefined && numberedMatch.index > 0) {
        const preamble = text.substring(0, numberedMatch.index).trim();
        const newlineCount = (preamble.match(/\n/g) || []).length;
        if (preamble.length < 300 || newlineCount < 3) {
            console.log(`[parseBreakdown] Stripped LLM preamble before numbered list (${preamble.length} chars)`);
            return text.substring(numberedMatch.index);
        }
    }

    return text;
}

/**
 * Parse AI-generated breakdown text into structured ScreenplayScene objects.
 * Handles various formats: "Act 1:", "Chapter 1:", "Scene 1:", numbered lists, etc.
 */
function parseBreakdownToScenes(breakdownText: string, topic: string): ScreenplayScene[] {
    const scenes: ScreenplayScene[] = [];

    // Strip LLM preamble before parsing to prevent it from becoming scene_0
    const cleanedText = stripLLMPreamble(breakdownText);

    // Try to split by common patterns: Act, Chapter, Scene, or numbered sections
    // Supports ASCII digits (0-9), Arabic-Indic (Ÿ†-Ÿ©), and Extended Arabic-Indic (€∞-€π)
    const patterns = [
        new RegExp(`(?:Act|Chapter|Scene|Part|ŸÅÿµŸÑ|ŸÖÿ¥ŸáÿØ|ÿßŸÑŸÖÿ¥ŸáÿØ)\\s*${DIGITS}+[:.]?\\s*`, 'gi'),
        new RegExp(`(?:^${DIGITS}+[.)]\\s*)`, 'gm'),
        /(?:\n\n+)/g, // Double newlines as fallback
    ];

    let sections: string[] = [];

    // Try each pattern until we get reasonable sections
    for (const pattern of patterns) {
        sections = cleanedText.split(pattern).filter(s => s.trim().length > 20);
        if (sections.length >= 2 && sections.length <= 10) break;
    }

    // If no good split found, treat whole text as one section
    if (sections.length < 2) {
        sections = [cleanedText];
    }

    sections.forEach((section, index) => {
        const lines = section.trim().split('\n').filter(l => l.trim());
        if (lines.length === 0) return;

        // Extract title from first line or generate one
        let title = lines[0]?.replace(/^[*\-#\d.)]+\s*/, '').trim() || `Scene ${index + 1}`;
        // Clean up title - remove markdown, limit length
        title = title.replace(/[*_#]/g, '').substring(0, 100);

        // Rest of lines become the action/description
        // Strip trailing scene number artifacts (e.g., "Ÿ¢. **" or "3. **") that leak
        // from the next section's numbering during split, and clean leftover markdown.
        const actionLines = lines.slice(1).join(' ').trim()
            .replace(/\s*[0-9\u0660-\u0669\u06F0-\u06F9]+\.\s*\*{0,2}\s*$/, '')
            .replace(/\*{2,}/g, '')
            .trim();

        scenes.push({
            id: `scene_${index}`,
            sceneNumber: index + 1,
            heading: title,
            action: actionLines || `Scene from: ${topic}`,
            dialogue: [],
            charactersPresent: [],
        });
    });

    // Ensure we have at least one scene
    if (scenes.length === 0) {
        scenes.push({
            id: 'scene_0',
            sceneNumber: 1,
            heading: 'Opening',
            action: breakdownText.substring(0, 500),
            dialogue: [],
            charactersPresent: [],
        });
    }

    return scenes;
}

interface StoryAgentResult {
    sessionId?: string;
    scenes?: ScreenplayScene[];
    screenplay?: { title: string; scenes: ScreenplayScene[] };
    characters?: CharacterProfile[];
    shots?: ShotlistEntry[];
    report?: ConsistencyReport;
    [key: string]: unknown;
}

export function useStoryGeneration(projectId?: string | null) {
    const initialState: StoryState = {
        currentStep: 'idea',
        breakdown: [],
        script: null,
        characters: [],
        shotlist: [],
    };

    const [state, setState] = useState<StoryState>(initialState);

    const [sessionId, setSessionId] = useState<string | null>(null);
    const [topic, setTopic] = useState<string | null>(null);
    const [isProcessing, setIsProcessing] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [progress, setProgress] = useState<{ message: string; percent: number }>({
        message: '',
        percent: 0
    });

    // History for Undo/Redo
    const [past, setPast] = useState<StoryState[]>([]);
    const [future, setFuture] = useState<StoryState[]>([]);

    /**
     * Helper to push a new state to history
     */
    const pushState = useCallback((newState: StoryState) => {
        setPast(prev => {
            // Limit history size to 50
            const nextPast = [...prev, state];
            if (nextPast.length > 50) return nextPast.slice(nextPast.length - 50);
            return nextPast;
        });
        setFuture([]); // Clear redo stack on new action
        setState(newState);
    }, [state]);

    const undo = useCallback(() => {
        if (past.length === 0) return;

        const previous = past[past.length - 1];
        if (!previous) return;

        const newPast = past.slice(0, past.length - 1);

        setPast(newPast);
        setFuture(prev => [state, ...prev]);
        setState(previous);
    }, [past, state]);

    const redo = useCallback(() => {
        if (future.length === 0) return;

        const next = future[0];
        if (!next) return;

        const newFuture = future.slice(1);

        setFuture(newFuture);
        setPast(prev => [...prev, state]);
        setState(next);
    }, [future, state]);

    // Load state from localStorage on mount / project change (with ownership validation)
    useEffect(() => {
        const savedState = localStorage.getItem(STORAGE_KEY);
        const savedSession = localStorage.getItem(SESSION_KEY);
        const savedUserId = localStorage.getItem(USER_ID_KEY);
        const savedProjectId = localStorage.getItem(PROJECT_ID_KEY);

        // Get current user to validate ownership
        const currentUser = getCurrentUser();

        // Clear stale session if user mismatch (prevents Firebase permission errors)
        if (savedUserId && currentUser && savedUserId !== currentUser.uid) {
            console.log('[useStoryGeneration] Session belongs to different user, clearing');
            localStorage.removeItem(STORAGE_KEY);
            localStorage.removeItem(SESSION_KEY);
            localStorage.removeItem(USER_ID_KEY);
            localStorage.removeItem(PROJECT_ID_KEY);
            return;
        }

        // If a projectId is provided and it differs from the saved one,
        // this is a different/new project ‚Äî start fresh instead of loading old state
        if (projectId && savedProjectId && projectId !== savedProjectId) {
            console.log('[useStoryGeneration] Different project detected, resetting state', {
                current: projectId,
                saved: savedProjectId,
            });
            setState(initialState);
            setSessionId(null);
            setTopic(null);
            setPast([]);
            setFuture([]);
            localStorage.removeItem(STORAGE_KEY);
            localStorage.removeItem(SESSION_KEY);
            // Update the stored projectId to the new one
            localStorage.setItem(PROJECT_ID_KEY, projectId);
            return;
        }

        // If projectId is provided but nothing was saved yet, store it
        if (projectId && !savedProjectId) {
            localStorage.setItem(PROJECT_ID_KEY, projectId);
        }

        if (savedState) {
            try {
                const parsed = JSON.parse(savedState);
                setState(parsed);
                console.log('[useStoryGeneration] Recovered story state');
            } catch (e) {
                console.error('Failed to parse saved story state', e);
            }
        }

        if (savedSession) {
            setSessionId(savedSession);
            // Re-initialize cloud storage for the restored session
            cloudAutosave.initSession(savedSession).then(success => {
                if (success) {
                    console.log('[useStoryGeneration] Cloud storage re-initialized for restored session');
                }
            });

            // Re-populate storyModeStore with restored state so tools can find the session
            if (savedState) {
                try {
                    const parsed = JSON.parse(savedState);
                    // Convert React state format to StoryModeState format
                    const storyModeState = {
                        id: savedSession,
                        topic: parsed.breakdown?.[0]?.heading || 'Restored Story',
                        breakdown: parsed.breakdown?.map((s: ScreenplayScene) =>
                            `${s.heading}: ${s.action}`
                        ).join('\n') || '',
                        screenplay: parsed.script?.scenes || [],
                        characters: parsed.characters || [],
                        shotlist: parsed.shotlist || [],
                        currentStep: parsed.currentStep === 'script' ? 'screenplay' : parsed.currentStep,
                        updatedAt: Date.now(),
                    };
                    storyModeStore.set(savedSession, storyModeState);
                    console.log('[useStoryGeneration] Restored storyModeStore for session:', savedSession);
                } catch (e) {
                    console.error('[useStoryGeneration] Failed to restore storyModeStore:', e);
                }
            }
        }
    }, [projectId]);

    // Save state to localStorage and Firestore on change
    useEffect(() => {
        if (state.currentStep !== 'idea') {
            try {
                const stateForStorage = stripImageDataForStorage(state);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(stateForStorage));

                // Also sync to Firestore if user is authenticated
                if (sessionId && isSyncAvailable()) {
                    debouncedSaveToCloud(sessionId, state, topic || undefined);
                }
            } catch (err) {
                // QuotaExceededError - log but don't crash
                console.warn('[useStoryGeneration] Failed to save state to localStorage:', err);
            }
        }
        if (sessionId) {
            localStorage.setItem(SESSION_KEY, sessionId);
        }
        // Keep projectId in sync
        if (projectId) {
            localStorage.setItem(PROJECT_ID_KEY, projectId);
        }
    }, [state, sessionId, topic, projectId]);

    // Clear stale sessions on auth state change (sign-out or user switch)
    useEffect(() => {
        const unsubscribe = onAuthChange((user) => {
            const savedUserId = localStorage.getItem(USER_ID_KEY);

            if (!user) {
                // User signed out - clear session data
                console.log('[useStoryGeneration] User signed out, clearing session');
                localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem(SESSION_KEY);
                localStorage.removeItem(USER_ID_KEY);
                localStorage.removeItem(PROJECT_ID_KEY);
            } else if (savedUserId && savedUserId !== user.uid) {
                // Different user signed in - clear stale session
                console.log('[useStoryGeneration] Different user signed in, clearing stale session');
                localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem(SESSION_KEY);
                localStorage.removeItem(USER_ID_KEY);
                localStorage.removeItem(PROJECT_ID_KEY);
            }
        });

        return () => {
            if (unsubscribe) unsubscribe();
        };
    }, []);

    /**
     * Step 1: Generate Breakdown
     */
    const generateBreakdown = useCallback(async (inputTopic: string, genre: string) => {
        setIsProcessing(true);
        setError(null);
        setTopic(inputTopic);
        setProgress({ message: 'Generating story breakdown...', percent: 20 });

        try {
            const prompt = `Use the generate_breakdown tool to create a ${genre} story about ${inputTopic}. Return 3-5 scenes.`;
            let capturedSessionId: string | null = null;
            
            await runProductionAgent(prompt, (progress) => {
                setProgress({ message: progress.message, percent: progress.isComplete ? 100 : 50 });
                // Capture sessionId from the progress callback
                if (progress.sessionId) {
                    capturedSessionId = progress.sessionId;
                }
            });

            // Use the captured sessionId, or fall back to searching storyModeStore
            let foundSessionId: string | null = capturedSessionId;
            let foundState = null;

            if (!foundSessionId) {
                // Fallback: Find the best matching story session
                // Priority: exact topic match > most recent story session
                let bestMatch: { sid: string; state: StoryModeState; updatedAt: number } | null = null;
                for (const [sid, storyState] of storyModeStore.entries()) {
                    if (storyState.topic === inputTopic) {
                        // Exact topic match ‚Äî use immediately
                        foundSessionId = sid;
                        foundState = storyState;
                        break;
                    }
                    if (sid.startsWith('story_')) {
                        const ts = storyState.updatedAt || 0;
                        if (!bestMatch || ts > bestMatch.updatedAt) {
                            bestMatch = { sid, state: storyState, updatedAt: ts };
                        }
                    }
                }
                if (!foundSessionId && bestMatch) {
                    foundSessionId = bestMatch.sid;
                    foundState = bestMatch.state;
                }
            } else {
                // Get the state from storyModeStore using the captured sessionId
                foundState = storyModeStore.get(foundSessionId);
            }

            if (foundSessionId && foundState && foundState.breakdown) {
                setSessionId(foundSessionId);

                // Save userId with session to prevent cross-user sync issues
                const user = getCurrentUser();
                if (user) {
                    localStorage.setItem(USER_ID_KEY, user.uid);
                }

                // Initialize cloud storage session for media persistence
                cloudAutosave.initSession(foundSessionId).then(success => {
                    if (success) {
                        console.log('[useStoryGeneration] Cloud storage initialized for session');
                    } else {
                        console.warn('[useStoryGeneration] Cloud storage unavailable, using local storage only');
                    }
                });

                // Parse the breakdown text into scenes
                const breakdownText = foundState.breakdown;
                const scenes: ScreenplayScene[] = parseBreakdownToScenes(breakdownText, inputTopic);

                console.log('[useStoryGeneration] Breakdown parsed into scenes:', scenes.length);

                setState(prev => ({
                    ...prev,
                    currentStep: 'breakdown',
                    breakdown: scenes,
                    genre,
                }));
            } else {
                setError('Story breakdown was generated but could not be retrieved. Please try again.');
            }
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        } finally {
            setIsProcessing(false);
        }
    }, []);

    /**
     * Step 1.5: Regenerate Specific Scene
     */
    const regenerateScene = useCallback(async (sceneNumber: number, feedback: string) => {
        if (!sessionId) return;
        setIsProcessing(true);
        setError(null);
        setProgress({ message: `Regenerating scene ${sceneNumber}...`, percent: 30 });

        try {
            const prompt = `Using sessionId ${sessionId}, call regenerate_scene_breakdown for scene ${sceneNumber} with feedback: ${feedback}`;
            const result = await runProductionAgent(prompt, (p) => {
                setProgress({ message: p.message, percent: p.isComplete ? 100 : 50 });
            });

            if (result && (result as unknown as StoryAgentResult).scenes) {
                setState(prev => ({
                    ...prev,
                    breakdown: (result as unknown as StoryAgentResult).scenes || prev.breakdown
                }));
            }
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        } finally {
            setIsProcessing(false);
        }
    }, [sessionId]);

    /**
     * Step 2: Create Screenplay
     */
    const generateScreenplay = useCallback(async () => {
        if (!sessionId) return;
        setIsProcessing(true);
        setError(null);
        setProgress({ message: 'Expanding breakdown into full screenplay...', percent: 40 });

        try {
            const prompt = `Using sessionId ${sessionId}, call create_screenplay with the current breakdown.`;
            await runProductionAgent(prompt, (progress) => {
                setProgress({ message: progress.message, percent: progress.isComplete ? 100 : 60 });
            });

            // Fetch the screenplay from storyModeStore
            const storyState = storyModeStore.get(sessionId);
            if (storyState && storyState.screenplay && storyState.screenplay.length > 0) {
                console.log('[useStoryGeneration] Screenplay retrieved:', storyState.screenplay.length, 'scenes');

                // Reconcile scene count: if screenplay has fewer scenes than breakdown,
                // align breakdown to match screenplay to prevent downstream misalignment
                // (e.g., narration iterating over more scenes than the screenplay covers).
                const screenplayScenes = storyState.screenplay;
                let reconciledBreakdown = state.breakdown;

                if (screenplayScenes.length !== state.breakdown.length) {
                    console.warn(
                        `[useStoryGeneration] Scene count mismatch: breakdown=${state.breakdown.length}, screenplay=${screenplayScenes.length}. Reconciling...`
                    );
                    // Use screenplay as source of truth ‚Äî trim or pad breakdown to match
                    reconciledBreakdown = screenplayScenes.map((sp, idx) => {
                        // Try to match with existing breakdown scene by index
                        const existing = state.breakdown[idx];
                        return {
                            ...sp,
                            // Preserve breakdown's id scheme for consistency
                            id: existing?.id || `scene_${idx}`,
                            sceneNumber: idx + 1,
                            // Use screenplay's richer action text if available
                            action: sp.action || existing?.action || '',
                            heading: sp.heading || existing?.heading || `Scene ${idx + 1}`,
                        };
                    });
                    console.log(`[useStoryGeneration] Reconciled to ${reconciledBreakdown.length} scenes`);
                }

                // Build script object from screenplay scenes
                const script = {
                    title: reconciledBreakdown[0]?.heading || 'Untitled Story',
                    scenes: screenplayScenes,
                };

                setState(prev => ({
                    ...prev,
                    currentStep: 'script',
                    script,
                    breakdown: reconciledBreakdown,
                }));
            } else {
                setError('Screenplay was generated but could not be retrieved. Please try again.');
            }
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        } finally {
            setIsProcessing(false);
        }
    }, [sessionId, state.breakdown]);

    /**
     * Step 3: Extract Characters
     */
    const generateCharacters = useCallback(async () => {
        if (!sessionId) return;
        setIsProcessing(true);
        setError(null);
        setProgress({ message: 'Extracting and visualizing characters...', percent: 60 });

        try {
            const prompt = `Using sessionId ${sessionId}, call generate_characters for the current script.`;
            await runProductionAgent(prompt, (progress) => {
                setProgress({ message: progress.message, percent: progress.isComplete ? 100 : 75 });
            });

            // Fetch the characters from storyModeStore
            const storyState = storyModeStore.get(sessionId);
            if (storyState && storyState.characters && storyState.characters.length > 0) {
                console.log('[useStoryGeneration] Characters retrieved:', storyState.characters.length);

                // Enrich with coreAnchors for stronger prompt anchoring in image generation
                const enrichedCharacters = enrichCharactersWithCoreAnchors(
                    storyState.characters,
                    state.visualStyle || 'Cinematic'
                );

                setState(prev => ({
                    ...prev,
                    currentStep: 'characters',
                    characters: enrichedCharacters,
                }));
            } else {
                setError('Characters were generated but could not be retrieved. Please try again.');
            }
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        } finally {
            setIsProcessing(false);
        }
    }, [sessionId]);

    /**
     * Generate (or regenerate) a single character's reference image via DeAPI.
     */
    const generateCharacterImage = useCallback(async (characterId: string) => {
        if (!sessionId) return;

        const char = state.characters.find(c => c.id === characterId);
        if (!char) {
            setError(`Character not found: ${characterId}`);
            return;
        }

        setIsProcessing(true);
        setError(null);
        setProgress({ message: `Generating portrait for ${char.name}...`, percent: 50 });

        try {
            const referenceUrl = await generateCharacterReference(
                char.name,
                char.visualDescription,
                sessionId,
                state.visualStyle || 'Cinematic',
            );

            setState(prev => ({
                ...prev,
                characters: prev.characters.map(c =>
                    c.id === characterId
                        ? { ...c, referenceImageUrl: referenceUrl }
                        : c
                ),
            }));

            setProgress({ message: `Portrait for ${char.name} ready!`, percent: 100 });
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        } finally {
            setIsProcessing(false);
        }
    }, [sessionId, state.characters]);

    /**
     * Step 4: Generate Shotlist
     */
    const generateShotlist = useCallback(async () => {
        if (!sessionId) return;
        setIsProcessing(true);
        setError(null);
        setProgress({ message: 'Creating technical shotlist/storyboard...', percent: 80 });

        try {
            const prompt = `Using sessionId ${sessionId}, call generate_shotlist for the current screenplay.`;
            await runProductionAgent(prompt, (progress) => {
                setProgress({ message: progress.message, percent: progress.isComplete ? 100 : 90 });
            });

            // Fetch the shotlist from storyModeStore
            const storyState = storyModeStore.get(sessionId);
            if (storyState && storyState.shotlist && storyState.shotlist.length > 0) {
                console.log('[useStoryGeneration] Shotlist retrieved:', storyState.shotlist.length, 'shots');

                setState(prev => ({
                    ...prev,
                    currentStep: 'storyboard',
                    shotlist: storyState.shotlist,
                }));
            } else {
                setError('Shotlist was generated but could not be retrieved. Please try again.');
            }
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        } finally {
            setIsProcessing(false);
        }
    }, [sessionId]);

    /**
     * Navigation actions
     */
    const setStep = (step: StoryStep) => {
        setState(prev => ({ ...prev, currentStep: step }));
    };

    const updateBreakdown = (scenes: ScreenplayScene[]) => {
        pushState({ ...state, breakdown: scenes });
    };

    const updateScript = (script: { title: string; scenes: ScreenplayScene[] }) => {
        pushState({ ...state, script });
    };

    /**
     * Update a single shot's metadata (from Shot Editor Modal saves).
     * Merges `updates` into the matching ShotlistEntry without regenerating visuals.
     */
    const updateShot = useCallback((shotId: string, updates: Partial<ShotlistEntry>) => {
        const updatedShotlist = state.shotlist.map(s =>
            s.id === shotId ? { ...s, ...updates } : s
        );
        pushState({ ...state, shotlist: updatedShotlist });
    }, [state, pushState]);

    const resetStory = useCallback(() => {
        setState(initialState);
        setSessionId(null);
        setTopic(null);
        setPast([]);
        setFuture([]);
        localStorage.removeItem(STORAGE_KEY);
        localStorage.removeItem(SESSION_KEY);
        localStorage.removeItem(PROJECT_ID_KEY);
    }, []);

    const exportScreenplay = useCallback((format: 'txt' | 'pdf' = 'txt') => {
        if (!state.script) return;

        if (format === 'pdf') {
            // PDF export using browser print API (industry-standard screenplay format)
            const printWindow = window.open('', '_blank');
            if (!printWindow) {
                setError('Please allow popups to export PDF');
                return;
            }

            // Build HTML with proper screenplay formatting (Courier 12pt, specific margins)
            let html = `<!DOCTYPE html>
<html>
<head>
    <title>${state.script.title} - Screenplay</title>
    <style>
        @page { size: letter; margin: 1in 1.5in 1in 1.5in; }
        body { font-family: 'Courier New', Courier, monospace; font-size: 12pt; line-height: 1; }
        .title { text-align: center; margin-bottom: 3in; margin-top: 2in; }
        .title h1 { font-size: 12pt; text-transform: uppercase; }
        .scene-heading { text-transform: uppercase; margin-top: 24pt; margin-bottom: 12pt; }
        .action { margin-bottom: 12pt; }
        .character { text-transform: uppercase; margin-left: 2.2in; margin-bottom: 0; }
        .dialogue { margin-left: 1in; margin-right: 1.5in; margin-bottom: 12pt; }
        .parenthetical { margin-left: 1.6in; margin-right: 2in; font-style: italic; }
        .transition { text-align: right; text-transform: uppercase; margin-top: 12pt; }
        .page-break { page-break-after: always; }
    </style>
</head>
<body>
    <div class="title">
        <h1>${state.script.title}</h1>
        <p>Written by AI Soul Studio</p>
    </div>
    <div class="page-break"></div>
`;

            state.script.scenes.forEach((scene: ScreenplayScene) => {
                html += `<div class="scene-heading">${scene.heading}</div>\n`;
                html += `<div class="action">${scene.action}</div>\n`;

                scene.dialogue.forEach((line) => {
                    html += `<div class="character">${line.speaker}</div>\n`;
                    html += `<div class="dialogue">${line.text}</div>\n`;
                });
            });

            html += `</body></html>`;

            printWindow.document.write(html);
            printWindow.document.close();
            printWindow.onload = () => {
                printWindow.print();
            };
            return;
        }

        // Text export (original behavior)
        let content = `${state.script.title.toUpperCase()}\n\n`;

        state.script.scenes.forEach((scene: ScreenplayScene) => {
            content += `SCENE ${scene.sceneNumber}: ${scene.heading.toUpperCase()}\n\n`;
            content += `${scene.action.toUpperCase()}\n\n`;

            scene.dialogue.forEach((line) => {
                content += `\t\t${line.speaker.toUpperCase()}\n`;
                content += `\t${line.text}\n\n`;
            });

            content += `\n${'-'.repeat(40)}\n\n`;
        });

        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${state.script.title.replace(/\s+/g, '_')}_Screenplay.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }, [state.script]);

    /**
     * Step 5: Verify Character Consistency
     */
    const verifyConsistency = useCallback(async (characterName: string) => {
        if (!sessionId) return;
        setIsProcessing(true);
        setError(null);
        setProgress({ message: `Verifying consistency for ${characterName}...`, percent: 90 });

        try {
            const prompt = `Using sessionId ${sessionId}, verify consistency for character ${characterName}`;
            const result = await runProductionAgent(prompt, (p) => {
                setProgress({ message: p.message, percent: p.isComplete ? 100 : 95 });
            });

            if (result && (result as any).report) {
                const report = (result as any).report as ConsistencyReport;
                setState(prev => ({
                    ...prev,
                    consistencyReports: {
                        ...(prev.consistencyReports || {}),
                        [characterName]: report
                    }
                }));
            }
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        } finally {
            setIsProcessing(false);
        }
    }, [sessionId]);

    /**
     * Lock Story - Only locks the screenplay for editing, does NOT auto-generate shots.
     * Shot generation is now a separate step triggered by generateShots().
     */
    const lockStory = useCallback(() => {
        if (state.isLocked) return;

        // Only lock the story - no async generation here
        const lockedState: StoryState = {
            ...state,
            isLocked: true,
            lockedAt: new Date().toISOString(),
            version: 'locked_v1' as const,
        };

        pushState(lockedState);
    }, [state, pushState]);

    /**
     * Generate shot breakdown for all scenes (or a specific scene).
     * This is now a separate step from locking.
     *
     * @param sceneIndex - Optional specific scene to generate shots for (for per-scene control)
     */
    const generateShots = useCallback(async (sceneIndex?: number) => {
        if (!state.isLocked) {
            setError('Story must be locked before generating shots');
            return;
        }

        setIsProcessing(true);
        setError(null);

        try {
            // Get scenes to process, filtering out undefined
            const scenesToProcess: ScreenplayScene[] = sceneIndex !== undefined
                ? [state.breakdown[sceneIndex]].filter((s): s is ScreenplayScene => s !== undefined)
                : state.breakdown;

            if (scenesToProcess.length === 0) {
                setError('No scenes to process');
                setIsProcessing(false);
                return;
            }

            const genre = state.genre || 'Drama';
            const isPerScene = sceneIndex !== undefined;

            setProgress({
                message: isPerScene
                    ? `Generating shots for scene ${sceneIndex + 1}...`
                    : 'Generating shot breakdown...',
                percent: 10
            });

            const newShots = await breakAllScenesIntoShots(
                scenesToProcess,
                genre,
                (sceneIdx, totalScenes) => {
                    const percent = 10 + ((sceneIdx + 1) / totalScenes) * 80;
                    setProgress({
                        message: `Processing scene ${sceneIdx + 1} of ${totalScenes}...`,
                        percent
                    });
                },
                sessionId || undefined,
            );

            // Convert Shot[] to StoryShot[]
            const storyShots: StoryShot[] = newShots.map(shot => ({
                ...shot,
            }));

            setProgress({ message: 'Finalizing...', percent: 95 });

            // If generating for a specific scene, merge with existing shots
            if (isPerScene && state.shots) {
                const existingShotsFromOtherScenes = state.shots.filter(
                    s => s.sceneId !== state.breakdown[sceneIndex]?.id
                );
                const sceneId = state.breakdown[sceneIndex]?.id;
                pushState({
                    ...state,
                    shots: [...existingShotsFromOtherScenes, ...storyShots],
                    currentStep: 'shots',
                    // Track which scenes have shots generated
                    scenesWithShots: [
                        ...(state.scenesWithShots || []),
                        ...(sceneId ? [sceneId] : [])
                    ].filter((v, i, a) => a.indexOf(v) === i), // dedupe
                });
            } else {
                // Generating all shots
                pushState({
                    ...state,
                    shots: storyShots,
                    currentStep: 'shots',
                    scenesWithShots: state.breakdown.map(s => s.id),
                });
            }

            setProgress({ message: 'Complete!', percent: 100 });
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        } finally {
            setIsProcessing(false);
        }
    }, [state, pushState]);

    /**
     * Update Visual Style
     */
    const updateVisualStyle = useCallback((style: string) => {
        setState(prev => ({
            ...prev,
            visualStyle: style,
        }));
    }, []);

    /**
     * Update Aspect Ratio
     */
    const updateAspectRatio = useCallback((ratio: string) => {
        setState(prev => ({
            ...prev,
            aspectRatio: ratio,
        }));
    }, []);

    /**
     * Update Genre
     */
    const updateGenre = useCallback((genre: string) => {
        setState(prev => ({
            ...prev,
            genre,
        }));
    }, []);

    /**
     * Update Image Provider (gemini or deapi)
     */
    const updateImageProvider = useCallback((provider: 'gemini' | 'deapi') => {
        setState(prev => ({
            ...prev,
            imageProvider: provider,
        }));
    }, []);

    /**
     * Generate storyboard visuals for all scenes or a specific scene.
     * This enables per-scene control over visual generation.
     *
     * @param sceneIndex - Optional specific scene to generate visuals for
     */
    const generateVisuals = useCallback(async (sceneIndex?: number) => {
        if (!state.shots || state.shots.length === 0) {
            setError('Shots must be generated before creating visuals');
            return;
        }

        setIsProcessing(true);
        setError(null);

        const isPerScene = sceneIndex !== undefined;
        const targetSceneId = isPerScene ? state.breakdown[sceneIndex]?.id : null;

        // Filter shots for the target scene(s)
        const shotsToProcess = isPerScene
            ? state.shots.filter(s => s.sceneId === targetSceneId)
            : state.shots;

        if (shotsToProcess.length === 0) {
            setError('No shots to process for this scene');
            setIsProcessing(false);
            return;
        }

        setProgress({
            message: isPerScene
                ? `Generating visuals for scene ${sceneIndex + 1}...`
                : 'Generating storyboard visuals...',
            percent: 10
        });

        try {
            // Import the image generation service dynamically
            const { generateImageFromPrompt } = await import('@/services/imageService');

            const updatedShotlist: ShotlistEntry[] = [...state.shotlist];
            const style = state.visualStyle || 'Cinematic';

            // Build character input list for structured prompt builder
            const characterInputs = state.characters
                .filter(c => c.visualDescription)
                .map(c => ({ name: c.name, visualDescription: c.visualDescription, facialTags: c.facialTags }));

            // Extract visual style from first generated shot for consistency (Issue 3)
            let extractedStyleOverride: ExtractedStyleOverride | undefined;

            // Resolve persona from story genre for persona-aware negative injection
            const genreToPurpose: Record<string, VideoPurpose> = {
                'Drama': 'story_drama',
                'Comedy': 'story_comedy',
                'Thriller': 'story_thriller',
                'Sci-Fi': 'story_scifi',
                'Action': 'story_action',
                'Fantasy': 'story_fantasy',
                'Romance': 'story_romance',
                'Historical': 'story_historical',
                'Animation': 'story_animation',
            };
            const storyPurpose: VideoPurpose = genreToPurpose[state.genre || ''] ?? 'storytelling';
            const storyPersona = getSystemPersona(storyPurpose);

            // Helper: build structured prompt for a shot (Issues 1, 2, 3)
            const buildShotPrompt = (shot: NonNullable<typeof shotsToProcess[0]>) => {
                const guide = fromShotBreakdown(
                    {
                        description: shot.description,
                        shotType: shot.shotType,
                        cameraAngle: shot.cameraAngle,
                        movement: shot.movement,
                        lighting: shot.lighting,
                        emotion: shot.emotion,
                    },
                    characterInputs,
                    style,
                    extractedStyleOverride,
                    storyPersona,
                );
                const serialized = serializeStyleGuideAsText(guide);

                // Inject CHARACTERS IN FRAME section from coreAnchors for stronger consistency
                const shotDescLower = shot.description.toLowerCase();
                const presentChars = state.characters.filter(c =>
                    shotDescLower.includes(c.name.toLowerCase()) && c.coreAnchors
                );
                if (presentChars.length > 0) {
                    const charSection = "CHARACTERS IN FRAME:\n" +
                        presentChars.map(c => `- ${c.coreAnchors}`).join('\n');
                    return `${charSection}\n\nSCENE:\n${serialized}`;
                }
                return serialized;
            };

            // Helper: get seed for the primary character in a shot (Issue 1)
            const getShotSeed = (shot: NonNullable<typeof shotsToProcess[0]>): number | undefined => {
                const shotDescLower = shot.description.toLowerCase();
                const primaryChar = characterInputs.find(c =>
                    shotDescLower.includes(c.name.toLowerCase())
                );
                if (primaryChar) {
                    return getCharacterSeed(primaryChar.visualDescription);
                }
                return undefined;
            };

            // Helper: upload to cloud and create shotlist entry
            const processShotResult = async (shot: NonNullable<typeof shotsToProcess[0]>, imageUrl: string) => {
                let finalUrl = imageUrl;
                if (sessionId && finalUrl && (finalUrl.startsWith('data:') || finalUrl.startsWith('blob:'))) {
                    const cloudUrl = await cloudAutosave.saveImageWithUrl(sessionId, finalUrl, shot.id);
                    if (cloudUrl) {
                        console.log(`[useStoryGeneration] Image uploaded to cloud: ${shot.id}`);
                        finalUrl = cloudUrl;
                    }
                }
                const existingIdx = updatedShotlist.findIndex(s => s.id === shot.id);
                const shotlistEntry: ShotlistEntry = {
                    id: shot.id,
                    sceneId: shot.sceneId,
                    shotNumber: shot.shotNumber,
                    description: shot.description,
                    cameraAngle: shot.cameraAngle,
                    movement: shot.movement,
                    lighting: shot.lighting,
                    dialogue: '',
                    imageUrl: finalUrl,
                };
                if (existingIdx >= 0) {
                    updatedShotlist[existingIdx] = shotlistEntry;
                } else {
                    updatedShotlist.push(shotlistEntry);
                }
            };

            // --- Resume logic: build storyboard status and filter already-done shots ---
            const alreadyDoneShots = state.shotlist.filter(s => s.imageUrl);
            const alreadyDoneStatus: Record<string, 'pending' | 'success' | 'failed'> = {};
            alreadyDoneShots.forEach(s => { alreadyDoneStatus[s.id] = 'success'; });
            const storyboardStatus: Record<string, 'pending' | 'success' | 'failed'> = {
                ...(state.storyboardStatus || {}),
                ...alreadyDoneStatus,
            };
            // Only process shots that don't already have an imageUrl
            const shotsNeedingVisuals = shotsToProcess.filter(s => !s?.imageUrl);

            if (state.imageProvider === 'deapi') {
                // Sequential-first for shot #1 (extract style), then parallel for rest
                const validShots = shotsNeedingVisuals.filter((s): s is NonNullable<typeof s> => s != null);

                // Generate shot #1 first to extract visual style (Issue 3)
                if (validShots.length > 0) {
                    const firstShot = validShots[0]!;
                    setProgress({ message: 'Generating reference image (shot 1)...', percent: 12 });
                    const firstSeed = getShotSeed(firstShot);
                    const firstResult = await generateImageWithAspectRatio(
                        buildShotPrompt(firstShot),
                        (state.aspectRatio || '16:9') as '16:9' | '9:16' | '1:1',
                        'Flux_2_Klein_4B_BF16',
                        undefined, // negativePrompt ‚Äî style guide handles avoid
                    );
                    await processShotResult(firstShot, firstResult);

                    // Extract visual DNA from first image for consistency
                    try {
                        const visualStyle = await extractVisualStyle(firstResult, sessionId || undefined);
                        extractedStyleOverride = {
                            colorPalette: visualStyle.colorPalette,
                            lighting: visualStyle.lighting,
                            texture: visualStyle.texture,
                            moodKeywords: visualStyle.moodKeywords,
                            negativePrompts: generateNegativePromptsForStyle(style),
                        };
                        // Store master style on state for persistence
                        console.log('[useStoryGeneration] Extracted master style:', extractedStyleOverride.colorPalette?.join(', '));
                    } catch (styleErr) {
                        console.warn('[useStoryGeneration] Style extraction failed, continuing without:', styleErr);
                    }
                }

                // Generate remaining shots in parallel with extracted style
                const remainingShots = validShots.slice(1);
                if (remainingShots.length > 0) {
                    const batchItems = remainingShots.map((shot) => ({
                        id: shot.id,
                        prompt: buildShotPrompt(shot), // Now includes extractedStyleOverride
                        aspectRatio: (state.aspectRatio || '16:9') as '16:9' | '9:16' | '1:1',
                        model: 'Flux_2_Klein_4B_BF16' as const,
                        seed: getShotSeed(shot),
                    }));

                    const batchResults = await generateImageBatch(
                        batchItems,
                        5, // concurrency
                        (prog) => {
                            const percent = 20 + (prog.completed / prog.total) * 70;
                            setProgress({
                                message: `Generating visuals ${prog.completed + 1}/${validShots.length} (parallel)...`,
                                percent,
                            });
                        },
                    );

                    for (const result of batchResults) {
                        const shot = remainingShots.find(s => s.id === result.id);
                        if (!shot) continue;
                        if (result.success && result.imageUrl) {
                            await processShotResult(shot, result.imageUrl);
                        } else {
                            console.error(`Failed to generate visual for shot ${shot.shotNumber}:`, result.error);
                        }
                    }
                }
            } else {
                // Parallel generation via Gemini Imagen using ParallelExecutionEngine
                const { ParallelExecutionEngine } = await import('@/services/parallelExecutionEngine');
                const engine = new ParallelExecutionEngine();

                // If we have existing images, extract style from the first one for consistency
                const firstExistingImage = state.shotlist.find(s => s.imageUrl)?.imageUrl;
                if (firstExistingImage && !extractedStyleOverride) {
                    try {
                        const visualStyleData = await extractVisualStyle(firstExistingImage, sessionId || undefined);
                        extractedStyleOverride = {
                            colorPalette: visualStyleData.colorPalette,
                            lighting: visualStyleData.lighting,
                            texture: visualStyleData.texture,
                            moodKeywords: visualStyleData.moodKeywords,
                            negativePrompts: generateNegativePromptsForStyle(style),
                        };
                    } catch (e) { /* non-fatal */ }
                }

                // Style extraction guard ‚Äî only the first completed task triggers it
                let styleExtractionDone = !!extractedStyleOverride;

                const tasks = shotsNeedingVisuals
                    .filter((s): s is NonNullable<typeof s> => s != null)
                    .map((shot, idx) => ({
                        id: shot.id,
                        type: 'visual' as const,
                        priority: shot.shotNumber,
                        retryable: true,
                        timeout: 90_000,
                        execute: async () => {
                            const prompt = buildShotPrompt(shot);
                            const imageUrl = await generateImageFromPrompt(
                                prompt,
                                style,
                                '',
                                state.aspectRatio || '16:9',
                                false,
                                undefined,
                                sessionId || undefined,
                                idx
                            );
                            return { shotId: shot.id, imageUrl };
                        },
                    }));

                let completedCount = alreadyDoneShots.length;
                const geminiResults = await engine.execute(tasks, {
                    concurrencyLimit: 4,
                    retryAttempts: 2,
                    retryDelay: 3000,
                    exponentialBackoff: true,
                    onProgress: (p) => {
                        completedCount = alreadyDoneShots.length + p.completedTasks;
                        setProgress({
                            message: `Generating visual ${completedCount + 1}/${shotsToProcess.length}...`,
                            percent: 10 + (completedCount / shotsToProcess.length) * 80,
                        });
                    },
                    onTaskFail: (taskId, error) => {
                        console.error(`[generateVisuals] Shot ${taskId} failed:`, error.message);
                        storyboardStatus[taskId] = 'failed';
                    },
                    onTaskComplete: (taskId) => {
                        storyboardStatus[taskId] = 'success';
                    },
                });

                // Process results in post-execution loop (cloud upload + shotlist mutation NOT inside execute())
                for (const result of geminiResults) {
                    if (!result.success || !result.data) continue;
                    const shot = shotsNeedingVisuals.find(s => s?.id === result.taskId);
                    if (!shot) continue;
                    await processShotResult(shot, result.data.imageUrl);
                    storyboardStatus[result.taskId] = 'success';

                    // Extract visual style from first successfully generated image
                    if (!styleExtractionDone) {
                        styleExtractionDone = true;
                        try {
                            const vs = await extractVisualStyle(result.data.imageUrl, sessionId || undefined);
                            extractedStyleOverride = {
                                colorPalette: vs.colorPalette,
                                lighting: vs.lighting,
                                texture: vs.texture,
                                moodKeywords: vs.moodKeywords,
                                negativePrompts: generateNegativePromptsForStyle(style),
                            };
                        } catch (styleErr) {
                            console.warn('[useStoryGeneration] Style extraction failed:', styleErr);
                        }
                    }
                }
            }

            setProgress({ message: 'Finalizing...', percent: 95 });

            // Update scenes with visuals tracking
            const newScenesWithVisuals = isPerScene && targetSceneId
                ? [...(state.scenesWithVisuals || []), targetSceneId].filter((v, i, a) => a.indexOf(v) === i)
                : state.breakdown.map(s => s.id);

            pushState({
                ...state,
                shotlist: updatedShotlist,
                currentStep: 'storyboard',
                scenesWithVisuals: newScenesWithVisuals,
                storyboardStatus,
            });

            setProgress({ message: 'Complete!', percent: 100 });
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        } finally {
            setIsProcessing(false);
        }
    }, [state, sessionId, pushState]);

    /**
     * Regenerate visual for a single shot (Storyboarder.ai-style per-shot refresh)
     * Allows users to regenerate any individual shot without affecting others.
     * 
     * @param shotId - The ID of the shot to regenerate
     * @param customPrompt - Optional custom prompt override (for user edits)
     */
    const regenerateShotVisual = useCallback(async (shotId: string, customPrompt?: string) => {
        const shot = state.shots?.find(s => s.id === shotId);
        const existingEntry = state.shotlist.find(s => s.id === shotId);

        if (!shot && !existingEntry) {
            setError(`Shot ${shotId} not found`);
            return;
        }

        setIsProcessing(true);
        setError(null);
        setProgress({ message: `Regenerating shot...`, percent: 20 });

        try {
            const { generateImageFromPrompt } = await import('@/services/imageService');
            const style = state.visualStyle || 'Cinematic';

            // Build prompt from shot details or use custom prompt
            const baseDescription = customPrompt || shot?.description || existingEntry?.description || '';
            const shotType = shot?.shotType || existingEntry?.cameraAngle || 'Medium';
            const cameraAngle = shot?.cameraAngle || 'Eye-level';
            const lighting = shot?.lighting || existingEntry?.lighting || 'Natural';
            const emotion = shot?.emotion || 'neutral';

            setProgress({ message: 'Generating new image...', percent: 50 });

            // Build a structured style guide for consistent prompts across providers
            const { buildImageStyleGuide, serializeStyleGuideAsText } = await import('@/services/prompt/imageStyleGuide');
            const regenGenreToPurpose: Record<string, VideoPurpose> = {
                'Drama': 'story_drama',
                'Comedy': 'story_comedy',
                'Thriller': 'story_thriller',
                'Sci-Fi': 'story_scifi',
                'Action': 'story_action',
                'Fantasy': 'story_fantasy',
                'Romance': 'story_romance',
                'Historical': 'story_historical',
                'Animation': 'story_animation',
            };
            const regenPurpose: VideoPurpose = regenGenreToPurpose[state.genre || ''] ?? 'storytelling';
            const regenPersona = getSystemPersona(regenPurpose);
            const guide = buildImageStyleGuide({
                scene: customPrompt || baseDescription,
                style,
                mood: emotion,
                composition: { shot_type: shotType, camera_angle: cameraAngle, framing: 'rule of thirds' },
                lighting: { source: lighting, quality: 'natural' },
                personaNegatives: regenPersona.negative_constraints,
            });

            let imageUrl: string;
            if (state.imageProvider === 'deapi') {
                const guidePrompt = serializeStyleGuideAsText(guide);
                const negativePrompt = guide.avoid.map(item => `no ${item}`).join(', ');
                imageUrl = await generateImageWithAspectRatio(
                    guidePrompt,
                    (state.aspectRatio || '16:9') as '16:9' | '9:16' | '1:1',
                    'Flux_2_Klein_4B_BF16',
                    negativePrompt,
                );
            } else {
                imageUrl = await generateImageFromPrompt(
                    baseDescription,
                    style,
                    '',
                    state.aspectRatio || '16:9',
                    true,            // skipRefine ‚Äî guide is already complete
                    undefined,       // New seed for variation
                    sessionId || undefined,
                    undefined,
                    guide,           // prebuiltGuide
                );
            }

            // Upload to cloud storage for persistence
            if (sessionId && imageUrl && (imageUrl.startsWith('data:') || imageUrl.startsWith('blob:'))) {
                const cloudUrl = await cloudAutosave.saveImageWithUrl(sessionId, imageUrl, shotId);
                if (cloudUrl) {
                    console.log(`[useStoryGeneration] Regenerated image uploaded to cloud: ${shotId}`);
                    imageUrl = cloudUrl;
                }
            }

            setProgress({ message: 'Updating storyboard...', percent: 90 });

            // Update the shotlist with new image
            const updatedShotlist = state.shotlist.map(entry =>
                entry.id === shotId
                    ? { ...entry, imageUrl, description: customPrompt || entry.description }
                    : entry
            );

            // If shot wasn't in shotlist yet, add it
            if (!state.shotlist.find(s => s.id === shotId) && shot) {
                updatedShotlist.push({
                    id: shot.id,
                    sceneId: shot.sceneId,
                    shotNumber: shot.shotNumber,
                    description: customPrompt || shot.description,
                    cameraAngle: shot.cameraAngle,
                    movement: shot.movement,
                    lighting: shot.lighting,
                    dialogue: '',
                    imageUrl,
                });
            }

            pushState({
                ...state,
                shotlist: updatedShotlist,
            });

            setProgress({ message: 'Shot regenerated!', percent: 100 });
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        } finally {
            setIsProcessing(false);
        }
    }, [state, sessionId, pushState]);

    /**
     * Check if all scenes have shots generated
     */
    const allScenesHaveShots = useCallback(() => {
        if (!state.scenesWithShots) return false;
        return state.breakdown.every(s => state.scenesWithShots?.includes(s.id));
    }, [state.breakdown, state.scenesWithShots]);

    /**
     * Check if all scenes have visuals generated
     */
    const allScenesHaveVisuals = useCallback(() => {
        if (!state.scenesWithVisuals) return false;
        return state.breakdown.every(s => state.scenesWithVisuals?.includes(s.id));
    }, [state.breakdown, state.scenesWithVisuals]);

    /**
     * Get progress info for current stage
     */
    const getStageProgress = useCallback(() => {
        const totalScenes = state.breakdown.length;
        const scenesWithShots = state.scenesWithShots?.length || 0;
        const scenesWithVisuals = state.scenesWithVisuals?.length || 0;

        return {
            totalScenes,
            scenesWithShots,
            scenesWithVisuals,
            shotsComplete: scenesWithShots >= totalScenes,
            visualsComplete: scenesWithVisuals >= totalScenes,
        };
    }, [state.breakdown, state.scenesWithShots, state.scenesWithVisuals]);

    /**
     * Clear any error state
     */
    const clearError = useCallback(() => {
        setError(null);
    }, []);

    /**
     * Check if we have a recovered session (from page refresh)
     */
    const hasRecoveredSession = useCallback(() => {
        return state.currentStep !== 'idea' && state.breakdown.length > 0;
    }, [state.currentStep, state.breakdown.length]);

    /**
     * Retry the last failed operation based on current step
     */
    const retryLastOperation = useCallback(async () => {
        clearError();
        switch (state.currentStep) {
            case 'breakdown':
                // Cannot retry breakdown without topic
                break;
            case 'script':
                await generateScreenplay();
                break;
            case 'characters':
                await generateCharacters();
                break;
            case 'shots':
                await generateShots();
                break;
            case 'storyboard':
                await generateVisuals();
                break;
            default:
                break;
        }
    }, [state.currentStep, clearError, generateScreenplay, generateCharacters, generateShots, generateVisuals]);

    /**
     * Step 6: Generate per-shot narration (TTS).
     * Uses narrateAllShots() for per-shot audio segments, with resume logic to skip
     * already-narrated shots. Falls back to voiceover scripts ‚Üí scene action ‚Üí description.
     */
    const generateNarration = useCallback(async () => {
        if (!state.shotlist || state.shotlist.length === 0) {
            setError('Visuals must be generated before creating narration');
            return;
        }

        setIsProcessing(true);
        setError(null);
        setProgress({ message: 'Rewriting scripts for voiceover...', percent: 5 });

        try {
            const screenplayScenes = state.script?.scenes || [];

            // Step A: Generate voiceover scripts from screenplay action text (delivery markers)
            const breakdownHooks = state.breakdown.map(s => {
                const action = s.action || '';
                return action.length > 100 ? action.slice(0, 100) : action;
            });
            const voiceoverMap = await generateVoiceoverScripts(screenplayScenes, breakdownHooks);

            // Detect language for voice selection
            const sampleSources = [
                state.breakdown[0]?.action || '',
                state.breakdown[0]?.heading || '',
                screenplayScenes[0]?.action || '',
                screenplayScenes[0]?.heading || '',
            ].join(' ');
            const detectedLang = detectLanguage(sampleSources);
            const narratorConfig: NarratorConfig = {
                videoPurpose: 'storytelling',
                ...(detectedLang === 'ar' ? { language: 'ar' as const } : {}),
            };

            // Resume logic: identify shots already narrated
            const existingNarrations = state.shotNarrationSegments || [];
            const narrationStatus: Record<string, 'pending' | 'success' | 'failed'> = {
                ...(state.narrationStatus || {}),
            };
            const successfulIds = new Set(
                existingNarrations.filter(s => s.audioUrl).map(s => s.shotId)
            );
            const shotsToNarrate = state.shotlist.filter(s => !successfulIds.has(s.id));

            setProgress({ message: 'Generating narration...', percent: 15 });

            // Call narrateAllShots for parallel per-shot TTS (serialized via acquireTtsSlot mutex)
            const newSegments = await narrateAllShots(
                shotsToNarrate,
                screenplayScenes,
                narratorConfig,
                (completed, total) => {
                    setProgress({
                        message: `Narrating shot ${completed}/${total}...`,
                        percent: 15 + (total > 0 ? (completed / total) * 70 : 0),
                    });
                },
                sessionId || undefined,
                state.narrationStatus,
                existingNarrations,
            );

            setProgress({ message: 'Uploading audio...', percent: 88 });

            // Process results: create object URLs, optionally upload to cloud
            const updatedShotNarrations: NonNullable<StoryState['shotNarrationSegments']> = [];
            for (const seg of newSegments) {
                let audioUrl = URL.createObjectURL(seg.audioBlob);
                if (sessionId) {
                    const cloudUrl = await cloudAutosave.saveNarrationWithUrl(
                        sessionId,
                        seg.audioBlob,
                        seg.shotId
                    );
                    if (cloudUrl) {
                        console.log(`[useStoryGeneration] Shot narration uploaded to cloud: ${seg.shotId}`);
                        audioUrl = cloudUrl;
                    }
                }
                narrationStatus[seg.shotId] = 'success';
                updatedShotNarrations.push({
                    shotId: seg.shotId,
                    sceneId: seg.sceneId,
                    audioUrl,
                    duration: seg.duration,
                    text: seg.text,
                });
            }

            // Mark failed shots
            const newShotIds = new Set(updatedShotNarrations.map(s => s.shotId));
            for (const shot of shotsToNarrate) {
                if (!newShotIds.has(shot.id)) {
                    narrationStatus[shot.id] = 'failed';
                }
            }

            // Merge with existing (keep previously narrated, replace updated ones)
            const allShotNarrations: NonNullable<StoryState['shotNarrationSegments']> = [
                ...existingNarrations.filter(n => !newShotIds.has(n.shotId)),
                ...updatedShotNarrations,
            ];

            // Build legacy scene-level narrationSegments for backward compat with animateShots()
            const sceneNarrationMap = new Map<string, { audioUrl: string; duration: number; text: string }>();
            for (const seg of allShotNarrations) {
                const existing = sceneNarrationMap.get(seg.sceneId);
                if (existing) {
                    existing.duration += seg.duration;
                    existing.text += ' ' + seg.text;
                } else {
                    sceneNarrationMap.set(seg.sceneId, {
                        audioUrl: seg.audioUrl, // Use first shot's audio for legacy compat
                        duration: seg.duration,
                        text: seg.text,
                    });
                }
            }
            const narrationSegments: NonNullable<StoryState['narrationSegments']> = Array.from(
                sceneNarrationMap.entries()
            ).map(([sceneId, data]) => ({ sceneId, ...data }));

            setProgress({ message: 'Finalizing narration...', percent: 95 });

            pushState({
                ...state,
                shotNarrationSegments: allShotNarrations,
                narrationStatus,
                narrationSegments, // Legacy: for animateShots() fallback
                scenesWithNarration: [...new Set(allShotNarrations.map(n => n.sceneId))],
                currentStep: 'narration',
            });

            setProgress({ message: 'Narration complete!', percent: 100 });
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        } finally {
            setIsProcessing(false);
        }
    }, [state, sessionId, pushState]);

    /**
     * Step 7: Animate shots using Veo or DeAPI
     * Converts static storyboard images into animated video clips
     */
    const animateShots = useCallback(async (shotIndex?: number) => {
        if (!state.shotlist || state.shotlist.length === 0) {
            setError('Visuals must be generated before animation');
            return;
        }

        setIsProcessing(true);
        setError(null);

        const isPerShot = shotIndex !== undefined;
        const shotsToAnimate = isPerShot
            ? [state.shotlist[shotIndex]].filter(Boolean)
            : state.shotlist.filter(s => s.imageUrl);

        if (shotsToAnimate.length === 0) {
            setError('No shots with images to animate');
            setIsProcessing(false);
            return;
        }

        setProgress({
            message: isPerShot
                ? `Animating shot ${shotIndex + 1}...`
                : 'Animating storyboard shots...',
            percent: 10
        });

        try {
            const animatedShots: StoryState['animatedShots'] = [
                ...(state.animatedShots || [])
            ];

            const useDeApi = isDeApiConfigured();

            // Pre-compute per-shot target durations from narration
            const shotTargetDurations = new Map<string, number>();
            if (state.shotNarrationSegments && state.shotNarrationSegments.length > 0) {
                // Exact per-shot durations from per-shot narration (new system)
                state.shotNarrationSegments.forEach(seg => {
                    shotTargetDurations.set(seg.shotId, seg.duration);
                });
            } else if (state.narrationSegments && state.narrationSegments.length > 0) {
                // Legacy fallback: divide scene duration evenly across shots in that scene
                const sceneIds = [...new Set(state.shotlist.map(s => s.sceneId))];
                for (const sceneId of sceneIds) {
                    const sceneShotIds = state.shotlist.filter(s => s.sceneId === sceneId).map(s => s.id);
                    const sceneNarration = state.narrationSegments.find(n => n.sceneId === sceneId);
                    const sceneDur = sceneNarration?.duration || 5;
                    const perShot = sceneDur / Math.max(sceneShotIds.length, 1);
                    for (const sid of sceneShotIds) {
                        shotTargetDurations.set(sid, perShot);
                    }
                }
            }

            for (let i = 0; i < shotsToAnimate.length; i++) {
                const shot = shotsToAnimate[i];
                if (!shot || !shot.imageUrl) continue;

                const percent = 10 + ((i + 1) / shotsToAnimate.length) * 80;
                setProgress({
                    message: `Animating shot ${i + 1}/${shotsToAnimate.length}...`,
                    percent
                });

                try {
                    let videoUrl: string;

                    // Normalize aspect ratio to valid values
                    const aspectRatio = (state.aspectRatio === '9:16' ? '9:16' : '16:9') as '16:9' | '9:16';
                    const deapiAspectRatio = (state.aspectRatio === '9:16' ? '9:16' : state.aspectRatio === '1:1' ? '1:1' : '16:9') as '16:9' | '9:16' | '1:1';

                    // Get the StoryShot data for motion strength selection (Issue 4)
                    const storyShot = state.shots?.find(s => s.id === shot.id);
                    const shotType = storyShot?.shotType || '';
                    const movement = storyShot?.movement || shot.movement || 'Static';

                    // Auto-select motion strength based on shot type (Issue 4)
                    const motionStrength = selectMotionStrength(shotType, movement);
                    const motionConfig = MOTION_CONFIGS[motionStrength];

                    // Build camera-focused animation prompt (Issue 4)
                    const animationPrompt = buildAnimationPrompt(movement, shot.description);

                    if (useDeApi && shot.imageUrl) {
                        // img2video requires a data: URL ‚Äî convert remote URLs
                        let imageDataUrl = shot.imageUrl;
                        if (!imageDataUrl.startsWith('data:')) {
                            try {
                                const resp = await fetch(imageDataUrl);
                                const blob = await resp.blob();
                                imageDataUrl = await new Promise<string>((resolve, reject) => {
                                    const reader = new FileReader();
                                    reader.onloadend = () => resolve(reader.result as string);
                                    reader.onerror = reject;
                                    reader.readAsDataURL(blob);
                                });
                            } catch (fetchErr) {
                                console.warn(`[useStoryGeneration] Failed to fetch image for img2video, falling back to txt2video:`, fetchErr);
                                imageDataUrl = '';
                            }
                        }

                        if (imageDataUrl.startsWith('data:')) {
                            videoUrl = await animateImageWithDeApi(
                                imageDataUrl,
                                animationPrompt,
                                deapiAspectRatio,
                                sessionId || undefined,
                                i,
                                { motionStrength },
                            );
                        } else {
                            // Fallback to txt2video only if image conversion failed
                            videoUrl = await generateVideoWithDeApi(
                                {
                                    prompt: animationPrompt,
                                    frames: motionConfig.frames,
                                },
                                deapiAspectRatio,
                                sessionId || undefined,
                                i
                            );
                        }
                    } else {
                        videoUrl = await generateVideoFromPrompt(
                            animationPrompt,
                            state.visualStyle || 'Cinematic',
                            '',
                            aspectRatio,
                            6,
                            true,
                            undefined,
                            sessionId || undefined,
                            i
                        );
                    }

                    // Upload to cloud storage for persistence
                    if (sessionId && videoUrl && (videoUrl.startsWith('data:') || videoUrl.startsWith('blob:'))) {
                        const cloudUrl = await cloudAutosave.saveAnimatedVideoWithUrl(sessionId, videoUrl, shot.id);
                        if (cloudUrl) {
                            console.log(`[useStoryGeneration] Animated video uploaded to cloud: ${shot.id}`);
                            videoUrl = cloudUrl;
                        }
                    }

                    // Store with target duration from narration (Issue 6)
                    const targetDuration = shotTargetDurations.get(shot.id) || motionConfig.frames / 30;
                    const existingIdx = animatedShots.findIndex(a => a.shotId === shot.id);
                    const animatedShot = {
                        shotId: shot.id,
                        videoUrl,
                        duration: targetDuration,
                    };

                    if (existingIdx >= 0) {
                        animatedShots[existingIdx] = animatedShot;
                    } else {
                        animatedShots.push(animatedShot);
                    }
                } catch (err) {
                    console.error(`Failed to animate shot ${shot.id}:`, err);
                }
            }

            setProgress({ message: 'Finalizing animations...', percent: 95 });

            pushState({
                ...state,
                animatedShots,
                shotsWithAnimation: animatedShots.map(s => s.shotId),
                currentStep: 'animation',
            });

            setProgress({ message: 'Animation complete!', percent: 100 });
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
        } finally {
            setIsProcessing(false);
        }
    }, [state, sessionId, pushState]);

    /**
     * Step 8: Export final video using FFmpeg
     * Combines narration audio, animated shots, and renders final MP4
     */
    const exportFinalVideo = useCallback(async () => {
        if (!state.narrationSegments || state.narrationSegments.length === 0) {
            setError('Narration must be generated before export');
            return;
        }

        if (!state.animatedShots || state.animatedShots.length === 0) {
            // Fall back to static images if no animations
            console.warn('[useStoryGeneration] No animations, will use static images for export');
        }

        setIsProcessing(true);
        setError(null);
        setProgress({ message: 'Preparing video export...', percent: 5 });

        try {
            // Build SongData structure for FFmpeg exporter
            // Safely get narration segments (already validated above)
            const narrationSegs = state.narrationSegments || [];

            // Calculate total duration with fallback for undefined/NaN values
            const totalDuration = narrationSegs.reduce((sum, s) => sum + (s.duration || 0), 0);

            console.log('[useStoryGeneration] Export stats:', {
                narrationSegments: narrationSegs.length,
                totalDuration,
                shotlistLength: state.shotlist.length,
                segmentDurations: narrationSegs.map(s => s.duration),
            });

            // Combine all narration audio segments into a single audio track
            let combinedAudioUrl: string;

            try {
                combinedAudioUrl = await createCombinedNarrationAudio(
                    narrationSegs,
                    (message, percent) => setProgress({ message, percent })
                );
                console.log('[useStoryGeneration] Combined', narrationSegs.length, 'narration segments');
            } catch (audioErr) {
                console.warn('[useStoryGeneration] Failed to combine audio, using first segment:', audioErr);
                combinedAudioUrl = narrationSegs[0]?.audioUrl || '';
            }

            // Narration-aware timestamps: distribute shots proportionally across scenes
            // Each scene's narration duration determines its shots' time slots
            const effectiveDuration = totalDuration > 0 ? totalDuration : state.shotlist.length * 5;

            // Build scene ‚Üí shots mapping and scene ‚Üí narration duration mapping
            const sceneIds = [...new Set(state.shotlist.map(s => s.sceneId))];
            const prompts: Array<{
                id: string;
                text: string;
                mood: string;
                timestamp: string;
                timestampSeconds: number;
            }> = [];
            let accumulatedTime = 0;

            for (const sceneId of sceneIds) {
                const sceneShotlist = state.shotlist.filter(s => s.sceneId === sceneId);
                // Find narration segment for this scene
                const sceneNarration = narrationSegs.find(n => n.sceneId === sceneId);
                const sceneDuration = sceneNarration?.duration || (effectiveDuration / sceneIds.length);
                const perShotDuration = sceneDuration / Math.max(sceneShotlist.length, 1);

                for (let i = 0; i < sceneShotlist.length; i++) {
                    const shot = sceneShotlist[i]!;
                    const shotTimestamp = accumulatedTime + i * perShotDuration;
                    prompts.push({
                        id: shot.id,
                        text: shot.description,
                        mood: 'cinematic',
                        timestamp: `${Math.floor(shotTimestamp / 60)}:${Math.floor(shotTimestamp % 60).toString().padStart(2, '0')}`,
                        timestampSeconds: shotTimestamp,
                    });
                }
                accumulatedTime += sceneDuration;
            }

            console.log('[useStoryGeneration] Narration-aware shot timing:', {
                effectiveDuration,
                sceneCount: sceneIds.length,
                totalShots: state.shotlist.length,
                firstTs: prompts[0]?.timestampSeconds,
                lastTs: prompts[prompts.length - 1]?.timestampSeconds,
            });

            // Build generatedImages array
            const generatedImages = state.shotlist.map((shot) => {
                const animated = state.animatedShots?.find(a => a.shotId === shot.id);
                return {
                    promptId: shot.id,
                    imageUrl: animated?.videoUrl || shot.imageUrl || '',
                    type: (animated ? 'video' : 'image') as 'video' | 'image',
                };
            });

            // Validate generatedImages have URLs
            const validImages = generatedImages.filter(g => g.imageUrl);
            console.log('[useStoryGeneration] Generated images:', {
                total: generatedImages.length,
                withUrl: validImages.length,
                sample: generatedImages.slice(0, 3).map(g => ({ id: g.promptId, hasUrl: !!g.imageUrl, type: g.type })),
            });

            // Build subtitle items from narration using textSanitizer service
            const parsedSubtitles: { id: string; text: string; startTime: number; endTime: number }[] = [];

            for (let idx = 0; idx < narrationSegs.length; idx++) {
                const seg = narrationSegs[idx]!;
                const segStart = narrationSegs.slice(0, idx).reduce((sum, s) => sum + (s.duration || 0), 0);
                const segDuration = seg.duration || 0;

                const { chunks, minDisplayTime } = cleanForSubtitles(seg.text || '', 80);
                if (chunks.length === 0) continue;

                // Distribute segment duration across chunks, respecting minimum display time
                const rawChunkDuration = chunks.length > 0 ? segDuration / chunks.length : segDuration;
                const chunkDuration = Math.max(rawChunkDuration, minDisplayTime);

                for (let c = 0; c < chunks.length; c++) {
                    parsedSubtitles.push({
                        id: `sub_${idx}_${c}`,
                        text: chunks[c]!,
                        startTime: segStart + c * chunkDuration,
                        endTime: segStart + (c + 1) * chunkDuration,
                    });
                }
            }

            setProgress({ message: 'Building video timeline...', percent: 20 });

            // Build SongData structure matching the expected interface
            const songData = {
                fileName: `${state.script?.title || 'story'}.mp4`,
                audioUrl: combinedAudioUrl,
                srtContent: '', // Not used for story mode
                parsedSubtitles,
                prompts,
                generatedImages,
                durationSeconds: effectiveDuration,
            };

            console.log('[useStoryGeneration] SongData built:', {
                promptCount: prompts.length,
                generatedImagesCount: generatedImages.length,
                durationSeconds: effectiveDuration,
                firstPromptTs: prompts[0]?.timestampSeconds,
                lastPromptTs: prompts[prompts.length - 1]?.timestampSeconds,
            });

            const exportConfig = {
                orientation: (state.aspectRatio === '9:16' ? 'portrait' : 'landscape') as 'portrait' | 'landscape',
                subtitlePosition: 'bottom' as const,
                subtitleSize: 'medium' as const,
                contentMode: 'story' as const,
            };

            const exportResult = await exportVideoWithFFmpeg(
                songData as any,
                (progress) => {
                    setProgress({
                        message: progress.message || 'Rendering video...',
                        percent: progress.progress || 50
                    });
                },
                exportConfig,
                { cloudSessionId: sessionId || undefined }
            );

            // Create URL for the final video (use cloud URL if available, otherwise create blob URL)
            const finalVideoUrl = exportResult.cloudUrl || URL.createObjectURL(exportResult.blob);

            pushState({
                ...state,
                finalVideoUrl,
                currentStep: 'export',
            });

            setProgress({ message: 'Export complete!', percent: 100 });

            // Return the blob for download
            return exportResult.blob;
        } catch (err) {
            setError(err instanceof Error ? err.message : String(err));
            return null;
        } finally {
            setIsProcessing(false);
        }
    }, [state, sessionId, pushState]);

    /**
     * Download the final exported video
     */
    const downloadVideo = useCallback(() => {
        if (!state.finalVideoUrl) {
            setError('No video to download. Please export first.');
            return;
        }

        const a = document.createElement('a');
        a.href = state.finalVideoUrl;
        a.download = `${state.script?.title || 'story'}_video.mp4`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }, [state.finalVideoUrl, state.script?.title]);

    /**
     * Check if all scenes have narration
     */
    const allScenesHaveNarration = useCallback(() => {
        if (!state.scenesWithNarration) return false;
        return state.breakdown.every(s => state.scenesWithNarration?.includes(s.id));
    }, [state.breakdown, state.scenesWithNarration]);

    /**
     * Check if all shots have animation
     */
    const allShotsHaveAnimation = useCallback(() => {
        if (!state.shotsWithAnimation || !state.shotlist) return false;
        return state.shotlist.every(s => state.shotsWithAnimation?.includes(s.id));
    }, [state.shotlist, state.shotsWithAnimation]);

    /**
     * Load a story from Firestore by session ID
     */
    const loadFromCloud = useCallback(async (cloudSessionId: string): Promise<boolean> => {
        setIsProcessing(true);
        setProgress({ message: 'Loading story from cloud...', percent: 50 });

        try {
            const cloudState = await loadStoryFromCloud(cloudSessionId);
            if (!cloudState) {
                setError('Story not found in cloud');
                return false;
            }

            // Initialize cloud storage for media
            setSessionId(cloudSessionId);
            await cloudAutosave.initSession(cloudSessionId);

            // Apply the loaded state
            pushState(cloudState);
            setProgress({ message: 'Story loaded', percent: 100 });
            console.log(`[useStoryGeneration] Loaded story ${cloudSessionId} from cloud`);
            return true;
        } catch (err) {
            console.error('[useStoryGeneration] Failed to load from cloud:', err);
            setError('Failed to load story from cloud');
            return false;
        } finally {
            setIsProcessing(false);
        }
    }, [pushState]);

    /**
     * Save current state to cloud immediately (flush pending debounced saves)
     */
    const saveToCloud = useCallback(async (): Promise<boolean> => {
        if (!sessionId || !isSyncAvailable()) {
            return false;
        }
        await flushPendingSave(sessionId, state, topic || undefined);
        return true;
    }, [sessionId, state, topic]);

    /**
     * Apply a template to the current story state
     */
    const applyTemplate = useCallback((templateState: Partial<StoryState>) => {
        console.log('[useStoryGeneration] Applying template:', templateState);
        pushState({
            ...state,
            ...templateState,
        });
    }, [state, pushState]);

    /**
     * Import a complete project state (e.g., from JSON file or version history)
     */
    const importProject = useCallback((importedState: StoryState) => {
        console.log('[useStoryGeneration] Importing project state');
        pushState(importedState);
    }, [pushState]);

    return {
        state,
        sessionId,
        isProcessing,
        error,
        progress,
        generateBreakdown,
        generateScreenplay,
        generateCharacters,
        generateCharacterImage,
        generateShotlist,
        verifyConsistency,
        regenerateScene,
        setStep,
        updateBreakdown,
        updateScript,
        resetStory,
        exportScreenplay,
        undo,
        redo,
        canUndo: past.length > 0,
        canRedo: future.length > 0,
        // Storyboarder.ai-style workflow functions
        lockStory,
        updateVisualStyle,
        updateAspectRatio,
        updateGenre,
        updateImageProvider,
        // New step-by-step generation methods
        generateShots,
        generateVisuals,
        regenerateShotVisual, // Storyboarder.ai-style per-shot refresh
        updateShot,           // Merge metadata edits from Shot Editor Modal
        // Narration, Animation, and Export methods
        generateNarration,
        animateShots,
        exportFinalVideo,
        downloadVideo,
        // Progress tracking helpers
        allScenesHaveShots,
        allScenesHaveVisuals,
        allScenesHaveNarration,
        allShotsHaveAnimation,
        getStageProgress,
        // Error handling
        clearError,
        retryLastOperation,
        hasRecoveredSession,
        // Cloud sync
        loadFromCloud,
        saveToCloud,
        isSyncAvailable: isSyncAvailable(),
        // Template and project management
        applyTemplate,
        importProject,
    };
}
</file>

<file path="hooks/useStoryProject.ts">
/**
 * useStoryProject Hook
 *
 * Manages UI state for the Story Workspace: tab navigation, step completion,
 * keyboard shortcuts, and auto-save. Decouples UI orchestration from the
 * StoryWorkspace component so it receives data via props/context.
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import type { StoryState, StoryStep } from '@/types';

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export type MainStep = 'idea' | 'breakdown' | 'storyboard';
export type StepStatus = 'completed' | 'active' | 'pending' | 'processing';

export interface UseStoryProjectOptions {
  storyState: StoryState;
  isProcessing: boolean;
  onUndo?: () => void;
  onRedo?: () => void;
  canUndo?: boolean;
  canRedo?: boolean;
  onGenerateScreenplay?: () => void;
  onGenerateCharacters?: () => void;
  onAutoSave?: (state: StoryState) => void;
}

export interface UseStoryProjectReturn {
  // Tab state
  activeMainTab: MainStep;
  setActiveMainTab: (tab: MainStep) => void;
  subTab: StoryStep;
  setSubTab: (tab: StoryStep) => void;

  // Dialog state
  showLockDialog: boolean;
  setShowLockDialog: (show: boolean) => void;
  showVersionHistory: boolean;
  setShowVersionHistory: (show: boolean) => void;

  // Helpers
  getHighLevelStep: (step: StoryStep) => MainStep;
  getStepCompletionStatus: (stepId: StoryStep) => StepStatus;
  handleTabNavigation: (tabId: StoryStep) => void;
  handleMainTabClick: (tabId: MainStep) => void;

  // Derived state
  isBreakdownProcessing: boolean;
  isStoryboardProcessing: boolean;
  currentStepIndex: number;
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

export function getHighLevelStep(step: StoryStep): MainStep {
  if (step === 'idea') return 'idea';
  if (['breakdown', 'script', 'characters'].includes(step)) return 'breakdown';
  return 'storyboard';
}

const AUTOSAVE_DELAY = 2000;

// ---------------------------------------------------------------------------
// Hook
// ---------------------------------------------------------------------------

export function useStoryProject({
  storyState,
  isProcessing,
  onUndo,
  onRedo,
  canUndo,
  canRedo,
  onGenerateScreenplay,
  onGenerateCharacters,
  onAutoSave,
}: UseStoryProjectOptions): UseStoryProjectReturn {
  // --- Tab state ---
  const [activeMainTab, setActiveMainTab] = useState<MainStep>(
    getHighLevelStep(storyState.currentStep),
  );
  const [subTab, setSubTab] = useState<StoryStep>(storyState.currentStep);

  // --- Dialog state ---
  const [showLockDialog, setShowLockDialog] = useState(false);
  const [showVersionHistory, setShowVersionHistory] = useState(false);

  // Sync tabs when storyState.currentStep changes externally
  useEffect(() => {
    const newMain = getHighLevelStep(storyState.currentStep);
    setActiveMainTab(newMain);
    setSubTab(storyState.currentStep);
  }, [storyState.currentStep]);

  // --- Keyboard shortcuts (Ctrl+Z / Ctrl+Y) ---
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!(e.ctrlKey || e.metaKey)) return;
      if (e.key === 'z') {
        if (e.shiftKey) {
          if (canRedo && onRedo) { e.preventDefault(); onRedo(); }
        } else {
          if (canUndo && onUndo) { e.preventDefault(); onUndo(); }
        }
      } else if (e.key === 'y') {
        if (canRedo && onRedo) { e.preventDefault(); onRedo(); }
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [onUndo, onRedo, canUndo, canRedo]);

  // --- Auto-save (debounced 2 s) ---
  const autoSaveTimer = useRef<ReturnType<typeof setTimeout> | null>(null);
  const prevStateRef = useRef(storyState);

  useEffect(() => {
    if (!onAutoSave) return;
    // Don't auto-save the initial "idea" step
    if (storyState.currentStep === 'idea') return;
    // Don't auto-save if nothing changed
    if (prevStateRef.current === storyState) return;
    prevStateRef.current = storyState;

    if (autoSaveTimer.current) clearTimeout(autoSaveTimer.current);
    autoSaveTimer.current = setTimeout(() => {
      onAutoSave(storyState);
    }, AUTOSAVE_DELAY);

    return () => {
      if (autoSaveTimer.current) clearTimeout(autoSaveTimer.current);
    };
  }, [storyState, onAutoSave]);

  // --- Tab navigation with auto-generation ---
  const handleTabNavigation = useCallback(
    (tabId: StoryStep) => {
      if (tabId === 'script' && !storyState.script && !isProcessing) {
        onGenerateScreenplay?.();
      } else if (
        tabId === 'characters' &&
        storyState.characters.length === 0 &&
        !isProcessing
      ) {
        onGenerateCharacters?.();
      }
      setSubTab(tabId);
    },
    [storyState.script, storyState.characters.length, isProcessing, onGenerateScreenplay, onGenerateCharacters],
  );

  const handleMainTabClick = useCallback(
    (tabId: MainStep) => {
      const stepOrder: MainStep[] = ['idea', 'breakdown', 'storyboard'];
      const currentIdx = stepOrder.indexOf(getHighLevelStep(storyState.currentStep));
      const tabIdx = stepOrder.indexOf(tabId);
      if (tabIdx > currentIdx) return; // not accessible

      setActiveMainTab(tabId);
      if (tabId === 'idea') setSubTab('idea');
      if (tabId === 'breakdown') setSubTab('breakdown');
      if (tabId === 'storyboard') setSubTab('shots');
    },
    [storyState.currentStep],
  );

  // --- Step completion status ---
  const getStepCompletionStatus = useCallback(
    (stepId: StoryStep): StepStatus => {
      const storyboardOrder: StoryStep[] = ['shots', 'style', 'storyboard', 'narration', 'animation', 'export'];
      const breakdownOrder: StoryStep[] = ['breakdown', 'script', 'characters'];
      const currentOrder = activeMainTab === 'storyboard' ? storyboardOrder : breakdownOrder;
      const currentIndex = currentOrder.indexOf(subTab);
      const stepIndex = currentOrder.indexOf(stepId);

      if (stepId === subTab) return isProcessing ? 'processing' : 'active';

      if (activeMainTab === 'storyboard') {
        switch (stepId) {
          case 'shots': return (storyState.shots?.length ?? 0) > 0 ? 'completed' : stepIndex < currentIndex ? 'completed' : 'pending';
          case 'style': return storyState.visualStyle ? 'completed' : stepIndex < currentIndex ? 'completed' : 'pending';
          case 'storyboard': return (storyState.scenesWithVisuals?.length ?? 0) > 0 ? 'completed' : stepIndex < currentIndex ? 'completed' : 'pending';
          case 'narration': return (storyState.narrationSegments?.length ?? 0) > 0 ? 'completed' : stepIndex < currentIndex ? 'completed' : 'pending';
          case 'animation': return (storyState.animatedShots?.length ?? 0) > 0 ? 'completed' : stepIndex < currentIndex ? 'completed' : 'pending';
          case 'export': return storyState.finalVideoUrl ? 'completed' : 'pending';
        }
      } else {
        switch (stepId) {
          case 'breakdown': return storyState.breakdown.length > 0 ? 'completed' : 'pending';
          case 'script': return storyState.script ? 'completed' : stepIndex < currentIndex ? 'completed' : 'pending';
          case 'characters': return storyState.characters.length > 0 ? 'completed' : 'pending';
        }
      }

      return stepIndex < currentIndex ? 'completed' : 'pending';
    },
    [activeMainTab, subTab, isProcessing, storyState],
  );

  // --- Derived state ---
  const isBreakdownProcessing =
    isProcessing && activeMainTab === 'breakdown' && storyState.breakdown.length === 0;
  const isStoryboardProcessing =
    isProcessing && activeMainTab === 'storyboard' && (!storyState.shots || storyState.shots.length === 0);

  const stepOrder: MainStep[] = ['idea', 'breakdown', 'storyboard'];
  const currentStepIndex = stepOrder.indexOf(getHighLevelStep(storyState.currentStep));

  return {
    activeMainTab,
    setActiveMainTab,
    subTab,
    setSubTab,
    showLockDialog,
    setShowLockDialog,
    showVersionHistory,
    setShowVersionHistory,
    getHighLevelStep,
    getStepCompletionStatus,
    handleTabNavigation,
    handleMainTabClick,
    isBreakdownProcessing,
    isStoryboardProcessing,
    currentStepIndex,
  };
}
</file>

<file path="hooks/useSunoMusic.ts">
/**
 * useSunoMusic Hook
 *
 * Manages AI music generation using the Suno API.
 * Extracted from useVideoProduction to adhere to Single Responsibility Principle.
 *
 * ROBUST PATTERNS IMPLEMENTED:
 * - Timeout protection for all polling loops
 * - AbortController support for cancellation
 * - Safe state updates that check mount status
 * - Comprehensive error handling
 */

import { useState, useCallback, useRef, useEffect } from "react";
import {
    SunoTaskStatus,
    SunoGeneratedTrack,
    SunoGenerationConfig,
    SunoExtendConfig,
    SunoUploadConfig,
    SunoPersonaConfig,
    SunoStemSeparationResult,
    isSunoConfigured,
    generateMusic as sunoGenerateMusic,
    waitForCompletion,
    generateLyrics as sunoGenerateLyrics,
    getLyricsStatus,
    getCredits,
    extendMusic as sunoExtendMusic,
    uploadAndExtend as sunoUploadAndExtend,
    generatePersona as sunoGeneratePersona,
    convertToWav as sunoConvertToWav,
    separateVocals as sunoSeparateVocals,
    waitForStemSeparation,
    createMusicVideo,
    generateCover,
    addVocals,
    addInstrumental,
    uploadAndCover,
    uploadAudioFile
} from "@/services/sunoService";

/**
 * Music generation state for Suno API integration.
 * Tracks the status of AI music generation requests.
 */
export interface MusicGenerationState {
    /** Whether a generation is currently in progress */
    isGenerating: boolean;
    /** Whether an extend operation is in progress */
    isExtending: boolean;
    /** Whether a stem separation is in progress */
    isSeparating: boolean;
    /** Whether a WAV conversion is in progress */
    isConverting: boolean;
    /** Whether a persona generation is in progress */
    isGeneratingPersona: boolean;
    /** Current task ID from Suno API */
    taskId: string | null;
    /** Current generation status */
    status: SunoTaskStatus | null;
    /** Progress percentage (0-100) */
    progress: number;
    /** Generated tracks (Suno returns 2 variations) */
    generatedTracks: SunoGeneratedTrack[];
    /** ID of the selected track */
    selectedTrackId: string | null;
    /** Generated or custom lyrics */
    lyrics: string | null;
    /** Lyrics generation task ID */
    lyricsTaskId: string | null;
    /** Remaining API credits */
    credits: number | null;
    /** Error message if generation failed */
    error: string | null;
    /** Result of stem separation (vocals and instrumental URLs) */
    stemSeparationResult: SunoStemSeparationResult | null;
    /** URL of converted WAV file */
    convertedWavUrl: string | null;
    /** Generated persona ID */
    personaId: string | null;
}

const initialMusicState: MusicGenerationState = {
    isGenerating: false,
    isExtending: false,
    isSeparating: false,
    isConverting: false,
    isGeneratingPersona: false,
    taskId: null,
    status: null,
    progress: 0,
    generatedTracks: [],
    selectedTrackId: null,
    lyrics: null,
    lyricsTaskId: null,
    credits: null,
    error: null,
    stemSeparationResult: null,
    convertedWavUrl: null,
    personaId: null,
};

// Default timeout for long-running operations (5 minutes)
const DEFAULT_TIMEOUT_MS = 5 * 60 * 1000;
// Poll interval for status checks
const POLL_INTERVAL_MS = 5000;

export function useSunoMusic() {
    const [musicState, setMusicState] = useState<MusicGenerationState>(initialMusicState);

    // Track if component is mounted
    const isMountedRef = useRef(true);

    // AbortController for cancelling operations
    const abortControllerRef = useRef<AbortController | null>(null);

    // Cleanup on unmount
    useEffect(() => {
        isMountedRef.current = true;
        return () => {
            isMountedRef.current = false;
            // Cancel any in-progress operations
            if (abortControllerRef.current) {
                abortControllerRef.current.abort();
                abortControllerRef.current = null;
            }
        };
    }, []);

    // Safe state updater
    const safeSetState = useCallback((
        updater: React.SetStateAction<MusicGenerationState>
    ) => {
        if (isMountedRef.current) {
            setMusicState(updater);
        }
    }, []);

    /**
     * Cancel any in-progress music generation operations.
     */
    const cancelGeneration = useCallback(() => {
        if (abortControllerRef.current) {
            console.log("[useSunoMusic] Cancelling in-progress operation");
            abortControllerRef.current.abort();
            abortControllerRef.current = null;
            safeSetState(prev => ({
                ...prev,
                isGenerating: false,
                isExtending: false,
                isSeparating: false,
                isConverting: false,
                isGeneratingPersona: false,
                status: null,
                progress: 0,
                error: "Operation was cancelled",
            }));
            return true;
        }
        return false;
    }, [safeSetState]);

    /**
     * Generate AI music using Suno API.
     * Includes timeout protection and cancellation support.
     */
    const generateMusic = useCallback(async (config: Partial<SunoGenerationConfig> & { prompt: string }) => {
        if (!isSunoConfigured()) {
            safeSetState(prev => ({
                ...prev,
                error: "Suno API key not configured. Add VITE_SUNO_API_KEY to .env.local",
            }));
            return;
        }

        // Cancel any existing operation
        if (abortControllerRef.current) {
            abortControllerRef.current.abort();
        }
        abortControllerRef.current = new AbortController();
        const signal = abortControllerRef.current.signal;

        safeSetState(prev => ({
            ...prev,
            isGenerating: true,
            taskId: null,
            status: "PENDING",
            progress: 0,
            generatedTracks: [],
            error: null,
        }));

        try {
            // Check for abort
            if (signal.aborted) throw new Error("Operation was cancelled");

            console.log("[useSunoMusic] Starting music generation...");
            const taskId = await sunoGenerateMusic(config);

            if (signal.aborted) throw new Error("Operation was cancelled");

            safeSetState(prev => ({
                ...prev,
                taskId,
                status: "PROCESSING",
                progress: 25,
            }));

            // Wait with timeout protection
            const startTime = Date.now();
            const tracks = await Promise.race([
                waitForCompletion(taskId),
                new Promise<never>((_, reject) => {
                    const checkAbort = setInterval(() => {
                        if (signal.aborted) {
                            clearInterval(checkAbort);
                            reject(new Error("Operation was cancelled"));
                        }
                        if (Date.now() - startTime > DEFAULT_TIMEOUT_MS) {
                            clearInterval(checkAbort);
                            reject(new Error(`Music generation timed out after ${DEFAULT_TIMEOUT_MS / 1000}s`));
                        }
                    }, 1000);
                }),
            ]);

            if (signal.aborted) throw new Error("Operation was cancelled");

            console.log(`[useSunoMusic] Music generation complete: ${tracks.length} tracks`);

            safeSetState(prev => ({
                ...prev,
                isGenerating: false,
                status: "SUCCESS",
                progress: 100,
                generatedTracks: tracks,
                selectedTrackId: tracks[0]?.id || null,
            }));

            abortControllerRef.current = null;
        } catch (err) {
            if (signal.aborted) {
                console.log("[useSunoMusic] Music generation was cancelled");
                return;
            }
            console.error("[useSunoMusic] Music generation failed:", err);
            safeSetState(prev => ({
                ...prev,
                isGenerating: false,
                status: "FAILED",
                progress: 0,
                error: err instanceof Error ? err.message : String(err),
            }));
            abortControllerRef.current = null;
        }
    }, [safeSetState]);

    /**
     * Generate lyrics using Suno API.
     * Includes timeout protection and cancellation support.
     */
    const generateLyrics = useCallback(async (prompt: string) => {
        if (!isSunoConfigured()) {
            safeSetState(prev => ({
                ...prev,
                error: "Suno API key not configured. Add VITE_SUNO_API_KEY to .env.local",
            }));
            return;
        }

        // Cancel any existing operation
        if (abortControllerRef.current) {
            abortControllerRef.current.abort();
        }
        abortControllerRef.current = new AbortController();
        const signal = abortControllerRef.current.signal;

        safeSetState(prev => ({
            ...prev,
            lyricsTaskId: null,
            lyrics: null,
            error: null,
        }));

        try {
            if (signal.aborted) throw new Error("Operation was cancelled");

            console.log("[useSunoMusic] Starting lyrics generation...");
            const taskId = await sunoGenerateLyrics(prompt);

            if (signal.aborted) throw new Error("Operation was cancelled");

            safeSetState(prev => ({
                ...prev,
                lyricsTaskId: taskId,
            }));

            const maxWaitMs = 2 * 60 * 1000;
            const startTime = Date.now();

            while (Date.now() - startTime < maxWaitMs) {
                // Check for cancellation at each iteration
                if (signal.aborted) throw new Error("Operation was cancelled");

                const result = await getLyricsStatus(taskId);

                if (result.status === "SUCCESS" && result.text) {
                    console.log("[useSunoMusic] Lyrics generation complete");
                    safeSetState(prev => ({
                        ...prev,
                        lyrics: result.text || null,
                    }));
                    abortControllerRef.current = null;
                    return;
                }

                if (result.status === "FAILED") {
                    throw new Error(result.errorMessage || "Lyrics generation failed");
                }

                // Wait with abort check
                await new Promise<void>((resolve, reject) => {
                    const timeoutId = setTimeout(resolve, POLL_INTERVAL_MS);
                    signal.addEventListener('abort', () => {
                        clearTimeout(timeoutId);
                        reject(new Error("Operation was cancelled"));
                    }, { once: true });
                });
            }

            throw new Error("Lyrics generation timed out. Please try again.");
        } catch (err) {
            if (signal.aborted) {
                console.log("[useSunoMusic] Lyrics generation was cancelled");
                return;
            }
            console.error("[useSunoMusic] Lyrics generation failed:", err);
            safeSetState(prev => ({
                ...prev,
                error: err instanceof Error ? err.message : String(err),
            }));
            abortControllerRef.current = null;
        }
    }, [safeSetState]);

    /**
     * Select a generated track for use.
     */
    const selectTrack = useCallback((trackId: string) => {
        setMusicState(prev => ({
            ...prev,
            selectedTrackId: trackId,
        }));
    }, []);

    /**
     * Refresh the Suno API credits balance.
     */
    const refreshCredits = useCallback(async () => {
        if (!isSunoConfigured()) {
            setMusicState(prev => ({
                ...prev,
                credits: null,
                error: "Suno API key not configured",
            }));
            return;
        }

        try {
            console.log("[useSunoMusic] Fetching Suno credits...");
            const result = await getCredits();

            setMusicState(prev => ({
                ...prev,
                credits: result.credits,
            }));

            console.log(`[useSunoMusic] Suno credits: ${result.credits}`);
        } catch (err) {
            console.error("[useSunoMusic] Failed to fetch credits:", err);
            setMusicState(prev => ({
                ...prev,
                credits: null,
            }));
        }
    }, []);

    /**
     * Reset music generation state.
     */
    const resetMusicState = useCallback(() => {
        setMusicState(initialMusicState);
    }, []);

    /**
     * Get the currently selected track.
     */
    const getSelectedTrack = useCallback((): SunoGeneratedTrack | null => {
        const { selectedTrackId, generatedTracks } = musicState;
        if (!selectedTrackId) return null;
        return generatedTracks.find(t => t.id === selectedTrackId) || null;
    }, [musicState]);

    /**
     * Extend an existing music track.
     * Wraps the service function with state management.
     */
    const extendMusic = useCallback(async (config: SunoExtendConfig) => {
        if (!isSunoConfigured()) {
            setMusicState(prev => ({
                ...prev,
                error: "Suno API key not configured. Add VITE_SUNO_API_KEY to .env.local",
            }));
            return;
        }

        setMusicState(prev => ({
            ...prev,
            isExtending: true,
            taskId: null,
            status: "PENDING",
            progress: 0,
            error: null,
        }));

        try {
            console.log("[useSunoMusic] Starting music extension...");
            const taskId = await sunoExtendMusic(config);

            setMusicState(prev => ({
                ...prev,
                taskId,
                status: "PROCESSING",
                progress: 25,
            }));

            const tracks = await waitForCompletion(taskId);

            console.log(`[useSunoMusic] Music extension complete: ${tracks.length} tracks`);

            setMusicState(prev => ({
                ...prev,
                isExtending: false,
                status: "SUCCESS",
                progress: 100,
                generatedTracks: [...prev.generatedTracks, ...tracks],
                selectedTrackId: tracks[0]?.id || prev.selectedTrackId,
            }));

            return tracks;
        } catch (err) {
            console.error("[useSunoMusic] Music extension failed:", err);
            setMusicState(prev => ({
                ...prev,
                isExtending: false,
                status: "FAILED",
                progress: 0,
                error: err instanceof Error ? err.message : String(err),
            }));
            return null;
        }
    }, []);

    /**
     * Upload and extend audio with new content.
     * Wraps the service function with state management.
     */
    const uploadAndExtend = useCallback(async (config: SunoUploadConfig) => {
        if (!isSunoConfigured()) {
            setMusicState(prev => ({
                ...prev,
                error: "Suno API key not configured. Add VITE_SUNO_API_KEY to .env.local",
            }));
            return null;
        }

        setMusicState(prev => ({
            ...prev,
            isExtending: true,
            taskId: null,
            status: "PENDING",
            progress: 0,
            error: null,
        }));

        try {
            console.log("[useSunoMusic] Starting upload and extend...");
            const taskId = await sunoUploadAndExtend(config);

            setMusicState(prev => ({
                ...prev,
                taskId,
                status: "PROCESSING",
                progress: 25,
            }));

            const tracks = await waitForCompletion(taskId);

            console.log(`[useSunoMusic] Upload and extend complete: ${tracks.length} tracks`);

            setMusicState(prev => ({
                ...prev,
                isExtending: false,
                status: "SUCCESS",
                progress: 100,
                generatedTracks: [...prev.generatedTracks, ...tracks],
                selectedTrackId: tracks[0]?.id || prev.selectedTrackId,
            }));

            return tracks;
        } catch (err) {
            console.error("[useSunoMusic] Upload and extend failed:", err);
            setMusicState(prev => ({
                ...prev,
                isExtending: false,
                status: "FAILED",
                progress: 0,
                error: err instanceof Error ? err.message : String(err),
            }));
            return null;
        }
    }, []);

    /**
     * Convert a generated track to WAV format.
     * Wraps the service function with state management.
     */
    const convertToWav = useCallback(async (taskId: string, audioId: string) => {
        if (!isSunoConfigured()) {
            setMusicState(prev => ({
                ...prev,
                error: "Suno API key not configured. Add VITE_SUNO_API_KEY to .env.local",
            }));
            return null;
        }

        setMusicState(prev => ({
            ...prev,
            isConverting: true,
            convertedWavUrl: null,
            error: null,
        }));

        try {
            console.log("[useSunoMusic] Starting WAV conversion...");
            const conversionTaskId = await sunoConvertToWav(taskId, audioId);

            // Poll for completion - WAV conversion uses the same task status endpoint
            const tracks = await waitForCompletion(conversionTaskId);

            // The converted WAV URL should be in the first track's audio_url
            const wavUrl = tracks.length > 0 ? tracks[0]?.audio_url || null : null;

            console.log(`[useSunoMusic] WAV conversion complete: ${wavUrl}`);

            setMusicState(prev => ({
                ...prev,
                isConverting: false,
                convertedWavUrl: wavUrl,
            }));

            return wavUrl;
        } catch (err) {
            console.error("[useSunoMusic] WAV conversion failed:", err);
            setMusicState(prev => ({
                ...prev,
                isConverting: false,
                error: err instanceof Error ? err.message : String(err),
            }));
            return null;
        }
    }, []);

    /**
     * Separate vocals from instrumental in a track.
     * Wraps the service function with state management.
     */
    const separateVocals = useCallback(async (taskId: string, audioId: string) => {
        if (!isSunoConfigured()) {
            setMusicState(prev => ({
                ...prev,
                error: "Suno API key not configured. Add VITE_SUNO_API_KEY to .env.local",
            }));
            return null;
        }

        setMusicState(prev => ({
            ...prev,
            isSeparating: true,
            stemSeparationResult: null,
            error: null,
        }));

        try {
            console.log("[useSunoMusic] Starting vocal separation...");
            const separationTaskId = await sunoSeparateVocals(taskId, audioId);

            // Wait for stem separation to complete
            const result = await waitForStemSeparation(separationTaskId);

            console.log(`[useSunoMusic] Vocal separation complete:`, result);

            setMusicState(prev => ({
                ...prev,
                isSeparating: false,
                stemSeparationResult: result,
            }));

            return result;
        } catch (err) {
            console.error("[useSunoMusic] Vocal separation failed:", err);
            setMusicState(prev => ({
                ...prev,
                isSeparating: false,
                error: err instanceof Error ? err.message : String(err),
            }));
            return null;
        }
    }, []);

    /**
     * Generate a personalized music style/persona.
     * Wraps the service function with state management.
     */
    const generatePersona = useCallback(async (config: SunoPersonaConfig) => {
        if (!isSunoConfigured()) {
            setMusicState(prev => ({
                ...prev,
                error: "Suno API key not configured. Add VITE_SUNO_API_KEY to .env.local",
            }));
            return null;
        }

        setMusicState(prev => ({
            ...prev,
            isGeneratingPersona: true,
            personaId: null,
            error: null,
        }));

        try {
            console.log("[useSunoMusic] Starting persona generation...");
            const personaTaskId = await sunoGeneratePersona(config);

            // Poll for completion - persona generation uses the same task status endpoint
            await waitForCompletion(personaTaskId);

            // The persona ID should be returned in the response
            // For now, we use the task ID as the persona ID
            const personaId = personaTaskId;

            console.log(`[useSunoMusic] Persona generation complete: ${personaId}`);

            setMusicState(prev => ({
                ...prev,
                isGeneratingPersona: false,
                personaId,
            }));

            return personaId;
        } catch (err) {
            console.error("[useSunoMusic] Persona generation failed:", err);
            setMusicState(prev => ({
                ...prev,
                isGeneratingPersona: false,
                error: err instanceof Error ? err.message : String(err),
            }));
            return null;
        }
    }, []);

    return {
        // State
        musicState,

        // Actions
        generateMusic,
        generateLyrics,
        selectTrack,
        refreshCredits,
        resetMusicState,
        cancelGeneration,

        // New Actions with State Management
        extendMusic,
        uploadAndExtend,
        convertToWav,
        separateVocals,
        generatePersona,

        // Helpers
        getSelectedTrack,

        // Advanced Actions (Static imports - no dynamic loading)
        createMusicVideo: async (taskId: string, audioId: string) => {
            return createMusicVideo(taskId, audioId);
        },
        generateCover: async (taskId: string) => {
            return generateCover(taskId);
        },
        addVocals: async (config: any) => {
            setMusicState(prev => ({
                ...prev,
                isGenerating: true,
                taskId: null,
                status: "PENDING",
                progress: 0,
                generatedTracks: [],
                error: null,
            }));

            try {
                console.log("[useSunoMusic] Starting add vocals...");
                const taskId = await addVocals(config);

                setMusicState(prev => ({
                    ...prev,
                    taskId,
                    status: "PROCESSING",
                    progress: 25,
                }));

                const tracks = await waitForCompletion(taskId);

                console.log(`[useSunoMusic] Add vocals complete: ${tracks.length} tracks`);

                setMusicState(prev => ({
                    ...prev,
                    isGenerating: false,
                    status: "SUCCESS",
                    progress: 100,
                    generatedTracks: tracks,
                    selectedTrackId: tracks[0]?.id || null,
                }));

                return taskId;
            } catch (err) {
                console.error("[useSunoMusic] Add vocals failed:", err);
                setMusicState(prev => ({
                    ...prev,
                    isGenerating: false,
                    status: "FAILED",
                    progress: 0,
                    error: err instanceof Error ? err.message : String(err),
                }));
                throw err;
            }
        },
        addInstrumental: async (config: any) => {
            setMusicState(prev => ({
                ...prev,
                isGenerating: true,
                taskId: null,
                status: "PENDING",
                progress: 0,
                generatedTracks: [],
                error: null,
            }));

            try {
                console.log("[useSunoMusic] Starting add instrumental...");
                const taskId = await addInstrumental(config);

                setMusicState(prev => ({
                    ...prev,
                    taskId,
                    status: "PROCESSING",
                    progress: 25,
                }));

                const tracks = await waitForCompletion(taskId);

                console.log(`[useSunoMusic] Add instrumental complete: ${tracks.length} tracks`);

                setMusicState(prev => ({
                    ...prev,
                    isGenerating: false,
                    status: "SUCCESS",
                    progress: 100,
                    generatedTracks: tracks,
                    selectedTrackId: tracks[0]?.id || null,
                }));

                return taskId;
            } catch (err) {
                console.error("[useSunoMusic] Add instrumental failed:", err);
                setMusicState(prev => ({
                    ...prev,
                    isGenerating: false,
                    status: "FAILED",
                    progress: 0,
                    error: err instanceof Error ? err.message : String(err),
                }));
                throw err;
            }
        },
        uploadAndCover: async (config: any) => {
            setMusicState(prev => ({
                ...prev,
                isGenerating: true,
                taskId: null,
                status: "PENDING",
                progress: 0,
                generatedTracks: [],
                error: null,
            }));

            try {
                console.log("[useSunoMusic] Starting upload and cover...");
                const taskId = await uploadAndCover(config);

                setMusicState(prev => ({
                    ...prev,
                    taskId,
                    status: "PROCESSING",
                    progress: 25,
                }));

                const tracks = await waitForCompletion(taskId);

                console.log(`[useSunoMusic] Upload and cover complete: ${tracks.length} tracks`);

                setMusicState(prev => ({
                    ...prev,
                    isGenerating: false,
                    status: "SUCCESS",
                    progress: 100,
                    generatedTracks: tracks,
                    selectedTrackId: tracks[0]?.id || null,
                }));

                return taskId;
            } catch (err) {
                console.error("[useSunoMusic] Upload and cover failed:", err);
                setMusicState(prev => ({
                    ...prev,
                    isGenerating: false,
                    status: "FAILED",
                    progress: 0,
                    error: err instanceof Error ? err.message : String(err),
                }));
                throw err;
            }
        },
        uploadAudio: async (file: File) => {
            return uploadAudioFile(file);
        }
    };
}
</file>

<file path="hooks/useTimelineAdapter.ts">
/**
 * useTimelineAdapter Hook
 *
 * Custom React hook that converts external props (Scene, NarrationSegment, VideoSFXPlan)
 * to the internal data model (Track, AudioClip, VideoClip) used by AudioTimelineEditor.
 *
 * This adapter layer enables backward compatibility, allowing the new timeline component
 * to be used as a drop-in replacement without requiring changes to the rest of the application.
 *
 * Key responsibilities:
 * 1. Convert scenes ‚Üí videoClips using scenesToVideoTrack
 * 2. Convert narrationSegments ‚Üí audioClips using narrationToAudioTrack
 * 3. Convert sfxPlan ‚Üí tracks/clips using sfxPlanToTracks
 * 4. Sync selectedSceneId ‚Üî selectedClipId using clipIdToSceneId/sceneIdToClipId
 * 5. Wrap onSceneSelect to convert clip IDs back to scene IDs
 * 6. Wrap onDeleteClip similarly
 *
 * @see .kiro/specs/timeline-editor-replacement/design.md for architecture details
 * @requirements 9.1-9.6, 10.1, 10.3, 10.4
 */

import { useMemo, useCallback } from "react";
import type { Scene, NarrationSegment, VideoSFXPlan } from "@/types";
import type {
  Track,
  AudioClip,
  VideoClip,
  ImageClip,
  SubtitleCue,
} from "@/types/audio-editor";
import {
  scenesToVideoTrack,
  narrationToAudioTrack,
  sfxPlanToTracks,
  clipIdToSceneId,
  sceneIdToClipId,
} from "@/components/TimelineEditor/timelineAdapter";

/**
 * Props interface matching AudioTimelineEditorProps from design.md
 * These are the external props that the adapter converts from.
 */
export interface UseTimelineAdapterProps {
  /** Array of Scene objects from ContentPlan */
  scenes: Scene[];
  /** Map of scene IDs to thumbnail URLs */
  visuals?: Record<string, string>;
  /** Array of NarrationSegment objects */
  narrationSegments?: NarrationSegment[];
  /** Sound effects plan */
  sfxPlan?: VideoSFXPlan | null;
  /** Currently selected scene ID (external state) */
  selectedSceneId?: string | null;
  /** Callback when a scene is selected */
  onSceneSelect?: (sceneId: string) => void;
  /** Callback when a clip is deleted */
  onDeleteClip?: (clipId: string) => void;
}

/**
 * Return type for the useTimelineAdapter hook.
 * Contains the converted internal data model and wrapped callbacks.
 */
export interface UseTimelineAdapterReturn {
  /** All tracks (video, narrator, sfx, etc.) */
  tracks: Track[];
  /** Audio clips (narrator and sfx) */
  audioClips: AudioClip[];
  /** Video clips (from scenes) */
  videoClips: VideoClip[];
  /** Image clips (currently empty, for future use) */
  imageClips: ImageClip[];
  /** Subtitle cues (currently empty, for future use) */
  subtitles: SubtitleCue[];
  /** Currently selected clip ID (converted from selectedSceneId) */
  selectedClipId: string | null;
  /** Handler for clip selection - converts clip ID to scene ID and calls onSceneSelect */
  handleClipSelect: (clipId: string | null) => void;
  /** Handler for clip deletion - converts clip ID to scene ID and calls onDeleteClip */
  handleDeleteClip: (clipId: string) => void;
}

/**
 * Hook for adapting external timeline props to internal data model.
 *
 * @param props - External props from AudioTimelineEditor
 * @returns Converted internal data model and wrapped callbacks
 *
 * @example
 * ```tsx
 * const {
 *   tracks,
 *   audioClips,
 *   videoClips,
 *   selectedClipId,
 *   handleClipSelect,
 *   handleDeleteClip,
 * } = useTimelineAdapter({
 *   scenes,
 *   visuals,
 *   narrationSegments,
 *   sfxPlan,
 *   selectedSceneId,
 *   onSceneSelect,
 *   onDeleteClip,
 * });
 * ```
 *
 * @requirements 9.1-9.6, 10.1, 10.3, 10.4
 */
export function useTimelineAdapter(
  props: UseTimelineAdapterProps
): UseTimelineAdapterReturn {
  const {
    scenes,
    visuals = {},
    narrationSegments = [],
    sfxPlan = null,
    selectedSceneId = null,
    onSceneSelect,
    onDeleteClip,
  } = props;

  /**
   * Convert scenes to video track and clips.
   * Memoized to prevent unnecessary recalculations.
   *
   * @requirements 9.1, 9.5
   * @validates Requirements 1.1, 1.2, 1.3, 1.4
   */
  const { track: videoTrack, clips: videoClips } = useMemo(
    () => scenesToVideoTrack(scenes, visuals),
    [scenes, visuals]
  );

  /**
   * Convert narration segments to narrator track and audio clips.
   * Memoized to prevent unnecessary recalculations.
   *
   * @requirements 9.2, 9.5
   * @validates Requirements 1.5
   */
  const { track: narratorTrack, clips: narratorClips } = useMemo(
    () => narrationToAudioTrack(narrationSegments, scenes),
    [narrationSegments, scenes]
  );

  /**
   * Convert SFX plan to SFX tracks and audio clips.
   * Memoized to prevent unnecessary recalculations.
   *
   * @requirements 9.3, 9.5
   * @validates Requirements 1.6
   */
  const { tracks: sfxTracks, clips: sfxClips } = useMemo(
    () => sfxPlanToTracks(sfxPlan, scenes, narrationSegments),
    [sfxPlan, scenes, narrationSegments]
  );

  /**
   * Combine all tracks into a single array.
   * Order: video, narrator, sfx tracks
   */
  const tracks = useMemo<Track[]>(
    () => [videoTrack, narratorTrack, ...sfxTracks],
    [videoTrack, narratorTrack, sfxTracks]
  );

  /**
   * Combine all audio clips (narrator + sfx).
   */
  const audioClips = useMemo<AudioClip[]>(
    () => [...narratorClips, ...sfxClips],
    [narratorClips, sfxClips]
  );

  /**
   * Image clips - currently empty, for future media import functionality.
   * @requirements 9.1
   */
  const imageClips = useMemo<ImageClip[]>(() => [], []);

  /**
   * Subtitle cues - currently empty, for future subtitle import functionality.
   * @requirements 9.3
   */
  const subtitles = useMemo<SubtitleCue[]>(() => [], []);

  /**
   * Convert selectedSceneId to selectedClipId.
   * Video clips use scene ID directly, so we can use it as-is.
   *
   * @requirements 9.4, 10.4
   * @validates Requirements 3.5
   */
  const selectedClipId = useMemo<string | null>(() => {
    if (!selectedSceneId) {
      return null;
    }
    // Video clips use scene ID directly (no prefix)
    // This allows selection to work with video track clips
    return sceneIdToClipId(selectedSceneId, "video");
  }, [selectedSceneId]);

  /**
   * Handle clip selection - converts clip ID back to scene ID and calls onSceneSelect.
   * This wraps the external callback to maintain backward compatibility.
   *
   * @requirements 9.4, 10.3, 10.4
   * @validates Requirements 3.2
   */
  const handleClipSelect = useCallback(
    (clipId: string | null) => {
      if (!onSceneSelect) {
        return;
      }

      if (clipId === null) {
        // Selection cleared - some implementations may want to handle this
        // For now, we don't call onSceneSelect with null since the original
        // GraphiteTimeline didn't support clearing selection via callback
        return;
      }

      // Convert clip ID back to scene ID
      const sceneId = clipIdToSceneId(clipId);
      onSceneSelect(sceneId);
    },
    [onSceneSelect]
  );

  /**
   * Handle clip deletion - converts clip ID back to scene ID and calls onDeleteClip.
   * This wraps the external callback to maintain backward compatibility.
   *
   * @requirements 9.4, 10.3
   * @validates Requirements 3.4
   */
  const handleDeleteClip = useCallback(
    (clipId: string) => {
      if (!onDeleteClip) {
        return;
      }

      // Convert clip ID back to scene ID
      const sceneId = clipIdToSceneId(clipId);
      onDeleteClip(sceneId);
    },
    [onDeleteClip]
  );

  // Return memoized result to prevent unnecessary re-renders
  return useMemo(
    () => ({
      tracks,
      audioClips,
      videoClips,
      imageClips,
      subtitles,
      selectedClipId,
      handleClipSelect,
      handleDeleteClip,
    }),
    [
      tracks,
      audioClips,
      videoClips,
      imageClips,
      subtitles,
      selectedClipId,
      handleClipSelect,
      handleDeleteClip,
    ]
  );
}

export default useTimelineAdapter;
</file>

<file path="hooks/useTimelineKeyboard.ts">
/**
 * useTimelineKeyboard Hook
 * 
 * Custom React hook for comprehensive keyboard navigation in the Graphite Timeline.
 * Implements professional video editor-style keyboard shortcuts for:
 * - Playback control (Space/K for play/pause)
 * - Time navigation (Arrow keys, J/K/L, Home/End)
 * - Clip navigation and selection (Tab, Enter, Escape, Delete)
 * - Frame-by-frame navigation (Ctrl+Arrow)
 * 
 * Requirements: Accessibility - keyboard-only navigation support
 */

import { useCallback, useEffect, useRef } from 'react';

// --- Types ---

export interface UseTimelineKeyboardOptions {
  /** Whether the timeline component is currently focused/active */
  isActive: boolean;
  /** Total duration of the timeline in seconds */
  duration: number;
  /** Current playhead time in seconds */
  currentTime: number;
  /** Whether playback is currently active */
  isPlaying: boolean;
  /** Index of the currently selected clip, or null if none selected */
  selectedClipIndex: number | null;
  /** Total number of clips in the timeline */
  clipCount: number;
  /** Callback when time should change */
  onTimeChange: (time: number) => void;
  /** Callback for play/pause toggle */
  onPlayPause: () => void;
  /** Callback for selecting a clip by index */
  onSelectClip: (index: number | null) => void;
  /** Callback for deleting the selected clip */
  onDeleteClip?: (index: number) => void;
  /** Callback to navigate to next clip */
  onNextClip: () => void;
  /** Callback to navigate to previous clip */
  onPrevClip: () => void;
  /** Callback to jump to start of timeline */
  onJumpToStart: () => void;
  /** Callback to jump to end of timeline */
  onJumpToEnd: () => void;
  /** Frames per second for frame-by-frame navigation (default: 30) */
  fps?: number;
  /** Amount to skip for small time jumps in seconds (default: 1) */
  smallSkip?: number;
  /** Amount to skip for large time jumps in seconds (default: 5) */
  largeSkip?: number;
}

export interface UseTimelineKeyboardReturn {
  /** Map of keyboard shortcut descriptions for displaying help */
  shortcuts: Record<string, string>;
}

// --- Constants ---

const DEFAULT_FPS = 30;
const DEFAULT_SMALL_SKIP = 1; // 1 second
const DEFAULT_LARGE_SKIP = 5; // 5 seconds

/**
 * Keyboard shortcut reference map for UI display
 */
const SHORTCUTS: Record<string, string> = {
  'Space / K': 'Play/Pause',
  '‚Üê / J': 'Rewind 1 second',
  '‚Üí / L': 'Forward 1 second',
  'Shift + ‚Üê/‚Üí': 'Move 5 seconds',
  'Ctrl + ‚Üê/‚Üí': 'Move 1 frame',
  'Home': 'Jump to start',
  'End': 'Jump to end',
  'Tab': 'Next clip',
  'Shift + Tab': 'Previous clip',
  'Delete / Backspace': 'Remove selected clip',
  'Escape': 'Deselect clip',
};

// --- Hook Implementation ---

/**
 * Custom hook for keyboard navigation in the timeline editor.
 * 
 * Implements industry-standard keyboard shortcuts similar to professional
 * video editing software (Premiere Pro, Final Cut, DaVinci Resolve).
 * 
 * @param options - Configuration options and callbacks
 * @returns Object with keyboard shortcut map for UI display
 * 
 * @example
 * ```tsx
 * const { shortcuts } = useTimelineKeyboard({
 *   isActive: isFocused,
 *   duration: 120,
 *   currentTime,
 *   isPlaying,
 *   selectedClipIndex,
 *   clipCount: clips.length,
 *   onTimeChange: setCurrentTime,
 *   onPlayPause: togglePlay,
 *   onSelectClip: setSelectedClipIndex,
 *   onNextClip: () => selectNext(),
 *   onPrevClip: () => selectPrev(),
 *   onJumpToStart: () => setCurrentTime(0),
 *   onJumpToEnd: () => setCurrentTime(duration),
 * });
 * ```
 */
export function useTimelineKeyboard({
  isActive,
  duration,
  currentTime,
  isPlaying,
  selectedClipIndex,
  clipCount,
  onTimeChange,
  onPlayPause,
  onSelectClip,
  onDeleteClip,
  onNextClip,
  onPrevClip,
  onJumpToStart,
  onJumpToEnd,
  fps = DEFAULT_FPS,
  smallSkip = DEFAULT_SMALL_SKIP,
  largeSkip = DEFAULT_LARGE_SKIP,
}: UseTimelineKeyboardOptions): UseTimelineKeyboardReturn {
  
  // Track last announced time for screen readers to avoid excessive announcements
  const lastAnnouncedTimeRef = useRef<number>(currentTime);
  
  /**
   * Main keyboard event handler.
   * Processes keyboard events when the timeline has focus.
   */
  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    // Only handle events when the timeline is active/focused
    if (!isActive) return;
    
    // Don't interfere with input elements
    const target = e.target as HTMLElement;
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
      return;
    }
    
    // Calculate frame duration for frame-by-frame navigation
    const frameDuration = 1 / fps;
    
    switch (e.code) {
      // ==================== PLAYBACK CONTROLS ====================
      
      // Play/Pause - Space or K (standard video editor shortcut)
      case 'Space':
      case 'KeyK':
        e.preventDefault();
        onPlayPause();
        break;
        
      // ==================== TIME NAVIGATION ====================
      
      // Move playhead left - ArrowLeft or J
      case 'ArrowLeft':
      case 'KeyJ':
        e.preventDefault();
        if (e.ctrlKey || e.metaKey) {
          // Frame-by-frame backward (Ctrl/Cmd + Left)
          onTimeChange(Math.max(0, currentTime - frameDuration));
        } else if (e.shiftKey) {
          // Large skip backward (Shift + Left)
          onTimeChange(Math.max(0, currentTime - largeSkip));
        } else {
          // Small skip backward
          onTimeChange(Math.max(0, currentTime - smallSkip));
        }
        break;
        
      // Move playhead right - ArrowRight or L  
      case 'ArrowRight':
      case 'KeyL':
        e.preventDefault();
        if (e.ctrlKey || e.metaKey) {
          // Frame-by-frame forward (Ctrl/Cmd + Right)
          onTimeChange(Math.min(duration, currentTime + frameDuration));
        } else if (e.shiftKey) {
          // Large skip forward (Shift + Right)
          onTimeChange(Math.min(duration, currentTime + largeSkip));
        } else {
          // Small skip forward
          onTimeChange(Math.min(duration, currentTime + smallSkip));
        }
        break;
        
      // Jump to start
      case 'Home':
        e.preventDefault();
        onJumpToStart();
        break;
        
      // Jump to end
      case 'End':
        e.preventDefault();
        onJumpToEnd();
        break;
        
      // ==================== CLIP SELECTION ====================
      
      // Navigate between clips with Tab
      case 'Tab':
        if (clipCount > 0) {
          e.preventDefault();
          if (e.shiftKey) {
            onPrevClip();
          } else {
            onNextClip();
          }
        }
        break;
        
      // Deselect current selection
      case 'Escape':
        e.preventDefault();
        onSelectClip(null);
        break;
        
      // ==================== CLIP ACTIONS ====================
      
      // Delete selected clip
      case 'Delete':
      case 'Backspace':
        if (selectedClipIndex !== null && onDeleteClip) {
          e.preventDefault();
          onDeleteClip(selectedClipIndex);
        }
        break;
        
      // Select/confirm clip (could be extended for clip editing)
      case 'Enter':
        e.preventDefault();
        // Currently just ensures clip is selected
        // Could be extended to open clip editor in the future
        break;
        
      // ==================== ADDITIONAL SHORTCUTS ====================
      
      // Quick jump shortcuts using number keys (0-9)
      // Jump to percentage of timeline: 0=0%, 1=10%, ... 9=90%
      case 'Digit0':
      case 'Digit1':
      case 'Digit2':
      case 'Digit3':
      case 'Digit4':
      case 'Digit5':
      case 'Digit6':
      case 'Digit7':
      case 'Digit8':
      case 'Digit9':
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
          e.preventDefault();
          const digit = parseInt(e.code.replace('Digit', ''), 10);
          const targetTime = (digit / 10) * duration;
          onTimeChange(targetTime);
        }
        break;
    }
  }, [
    isActive,
    duration,
    currentTime,
    isPlaying, // Added missing dependency
    selectedClipIndex,
    clipCount,
    onTimeChange,
    onPlayPause,
    onSelectClip,
    onDeleteClip,
    onNextClip,
    onPrevClip,
    onJumpToStart,
    onJumpToEnd,
    fps,
    smallSkip,
    largeSkip,
  ]);
  
  /**
   * Attach keyboard event listener to window.
   * Uses capture phase to handle events before bubbling.
   */
  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown]);
  
  return {
    shortcuts: SHORTCUTS,
  };
}

export default useTimelineKeyboard;
</file>

<file path="hooks/useTimelineSelection.ts">
/**
 * useTimelineSelection Hook
 * 
 * Custom React hook for managing timeline clip selection state.
 * Implements single-selection logic with support for:
 * - Selecting clips on click (Requirement 10.1)
 * - Clearing selection on click outside clips (Requirement 10.2)
 * - Notifying parent components via callback (Requirement 10.3)
 * - Single-selection only - no multi-select (Requirement 10.4)
 * 
 * Requirements: 10.1, 10.2, 10.3, 10.4
 */

import { useState, useCallback, useMemo, useEffect } from "react";
import {
  SelectionState,
  createInitialSelectionState,
  handleClipClick,
  handleOutsideClick,
  isClipSelected,
} from "@/components/TimelineEditor/graphite-timeline-utils";
import { clipIdToSceneId } from "@/components/TimelineEditor/timelineAdapter";

export interface UseTimelineSelectionOptions {
  /** Initial selected clip ID */
  initialSelectedId?: string | null;
  /** Callback when a scene is selected (Requirement 10.3) */
  onSceneSelect?: (sceneId: string) => void;
  /** Callback when selection is cleared */
  onSelectionClear?: () => void;
}

export interface UseTimelineSelectionReturn {
  /** Currently selected clip ID, or null if none */
  selectedClipId: string | null;
  /** Handler for clip click events - selects the clip */
  handleSelectClip: (clipId: string) => void;
  /** Handler for clicking outside clips - clears selection */
  handleClearSelection: () => void;
  /** Check if a specific clip is selected */
  isSelected: (clipId: string) => boolean;
  /** Programmatically set the selected clip ID */
  setSelectedClipId: (clipId: string | null) => void;
}

/**
 * Hook for managing timeline selection state.
 * 
 * @param options - Configuration options
 * @returns Selection state and handlers
 * 
 * @example
 * ```tsx
 * const { selectedClipId, handleSelectClip, handleClearSelection, isSelected } = 
 *   useTimelineSelection({
 *     onSceneSelect: (sceneId) => console.log("Selected:", sceneId),
 *   });
 * 
 * // In TrackLane:
 * <TrackLane
 *   selectedClipId={selectedClipId}
 *   onClipSelect={handleSelectClip}
 *   onLaneClick={handleClearSelection}
 * />
 * ```
 */
export function useTimelineSelection(
  options: UseTimelineSelectionOptions = {}
): UseTimelineSelectionReturn {
  const { initialSelectedId, onSceneSelect, onSelectionClear } = options;

  // Internal selection state
  const [selectionState, setSelectionState] = useState<SelectionState>(() =>
    createInitialSelectionState(initialSelectedId)
  );

  /**
   * Handle clip click - selects the clip and notifies parent.
   * Implements Requirement 10.1 (mark as selected) and 10.3 (notify via callback).
   */
  const handleSelectClip = useCallback(
    (clipId: string) => {
      setSelectionState((currentState) => {
        const { newState, sceneId } = handleClipClick(currentState, clipId);
        return newState;
      });
    },
    []
  );

  // Use useEffect to handle scene selection callback instead of setTimeout
  useEffect(() => {
    if (selectionState.selectedClipId && onSceneSelect) {
      const sceneId = clipIdToSceneId(selectionState.selectedClipId);
      onSceneSelect(sceneId);
    }
  }, [selectionState.selectedClipId, onSceneSelect]);

  /**
   * Handle click outside clips - clears selection.
   * Implements Requirement 10.2.
   */
  const handleClearSelection = useCallback(() => {
    setSelectionState((currentState) => {
      const newState = handleOutsideClick(currentState);
      
      // Call the onSelectionClear callback if selection was cleared
      if (currentState.selectedClipId !== null && onSelectionClear) {
        setTimeout(() => onSelectionClear(), 0);
      }
      
      return newState;
    });
  }, [onSelectionClear]);

  /**
   * Check if a specific clip is selected.
   */
  const isSelected = useCallback(
    (clipId: string) => isClipSelected(selectionState, clipId),
    [selectionState]
  );

  /**
   * Programmatically set the selected clip ID.
   * Useful for external control of selection state.
   */
  const setSelectedClipId = useCallback(
    (clipId: string | null) => {
      setSelectionState({ selectedClipId: clipId });
    },
    []
  );

  // Memoize the return value to prevent unnecessary re-renders
  return useMemo(
    () => ({
      selectedClipId: selectionState.selectedClipId,
      handleSelectClip,
      handleClearSelection,
      isSelected,
      setSelectedClipId,
    }),
    [
      selectionState.selectedClipId,
      handleSelectClip,
      handleClearSelection,
      isSelected,
      setSelectedClipId,
    ]
  );
}

export default useTimelineSelection;
</file>

<file path="hooks/useVideoNarration.ts">
/**
 * useVideoNarration Hook
 * 
 * Handles narration generation and audio playback for video production.
 * Manages audio URLs and cleanup to prevent memory leaks.
 */

import { useState, useCallback, useRef, useEffect } from "react";
import { ContentPlan, NarrationSegment } from "@/types";
import { narrateScene, createAudioUrl, revokeAudioUrl, NarratorConfig } from "@/services/narratorService";
import { syncDurationsToNarration } from "@/services/editorService";
import { VideoPurpose } from "@/constants";
import { ProductionProgress } from "@/services/agentOrchestrator";

export interface VideoNarrationState {
    narrationSegments: NarrationSegment[];
    playingSceneId: string | null;
}

export function useVideoNarration(
    contentPlan: ContentPlan | null,
    videoPurpose: VideoPurpose,
    onProgress?: (progress: ProductionProgress) => void,
    onError?: (error: string) => void,
    onContentPlanUpdate?: (plan: ContentPlan) => void
) {
    const [narrationSegments, setNarrationSegments] = useState<NarrationSegment[]>([]);
    const [playingSceneId, setPlayingSceneId] = useState<string | null>(null);
    
    const audioUrlsRef = useRef<Map<string, string>>(new Map());
    const audioRef = useRef<HTMLAudioElement | null>(null);

    // Cleanup effect for audio URLs to prevent memory leaks
    useEffect(() => {
        return () => {
            // Cleanup all blob URLs on unmount
            audioUrlsRef.current.forEach(url => revokeAudioUrl(url));
            audioUrlsRef.current.clear();
            
            // Stop and cleanup audio element
            if (audioRef.current) {
                audioRef.current.pause();
                audioRef.current = null;
            }
        };
    }, []);

    /**
     * Generate narration for all scenes
     */
    const generateNarration = useCallback(async () => {
        if (!contentPlan) {
            onError?.("No content plan to narrate");
            return;
        }

        const segments: NarrationSegment[] = [];

        for (let i = 0; i < contentPlan.scenes.length; i++) {
            const scene = contentPlan.scenes[i];
            
            // TypeScript strict mode: ensure scene exists
            if (!scene) {
                console.error(`[useVideoNarration] Scene at index ${i} is undefined`);
                continue;
            }

            onProgress?.({
                stage: "narrating",
                progress: Math.round((i / contentPlan.scenes.length) * 100),
                message: `Narrating: ${scene.name}`,
                currentScene: i + 1,
                totalScenes: contentPlan.scenes.length,
            });

            try {
                const narratorConfig: NarratorConfig = { videoPurpose };
                const segment = await narrateScene(scene, narratorConfig);
                segments.push(segment);

                // Create audio URL for playback
                const url = createAudioUrl(segment);
                audioUrlsRef.current.set(scene.id, url);
            } catch (err) {
                console.error(`[useVideoNarration] Narration failed for scene ${scene.id}:`, err);
                onError?.(`Narration failed for "${scene.name}"`);
                return;
            }
        }

        setNarrationSegments(segments);

        // Sync durations
        if (contentPlan && onContentPlanUpdate) {
            const synced = syncDurationsToNarration(contentPlan, segments);
            onContentPlanUpdate(synced);
        }

        onProgress?.({
            stage: "narrating",
            progress: 100,
            message: `${segments.length} narrations complete`,
        });
    }, [contentPlan, videoPurpose, onProgress, onError, onContentPlanUpdate]);

    /**
     * Regenerate narration for a single scene after script edit
     */
    const regenerateSceneNarration = useCallback(async (sceneId: string) => {
        if (!contentPlan) {
            onError?.("No content plan available");
            return;
        }

        const scene = contentPlan.scenes.find(s => s.id === sceneId);
        if (!scene) {
            onError?.(`Scene ${sceneId} not found`);
            return;
        }

        // TypeScript type narrowing: scene is guaranteed to be defined here
        const currentScene = scene;

        onProgress?.({
            stage: "narrating",
            progress: 0,
            message: `Regenerating narration for: ${currentScene.name}`,
            currentScene: 1,
            totalScenes: 1,
        });

        try {
            // Revoke old audio URL if exists
            const oldUrl = audioUrlsRef.current.get(sceneId);
            if (oldUrl) {
                revokeAudioUrl(oldUrl);
                audioUrlsRef.current.delete(sceneId);
            }

            // Generate new narration
            const narratorConfig: NarratorConfig = { videoPurpose };
            const segment = await narrateScene(currentScene, narratorConfig);

            // Create new audio URL
            const url = createAudioUrl(segment);
            audioUrlsRef.current.set(sceneId, url);

            // Update narration segments
            setNarrationSegments(prev => {
                const existing = prev.findIndex(s => s.sceneId === sceneId);
                if (existing >= 0) {
                    const updated = [...prev];
                    updated[existing] = segment;
                    return updated;
                }
                return [...prev, segment];
            });

            // Sync duration for this scene
            if (contentPlan && onContentPlanUpdate) {
                const updatedScenes = contentPlan.scenes.map(s =>
                    s.id === sceneId ? { ...s, duration: Math.ceil(segment.audioDuration) } : s
                );
                const totalDuration = updatedScenes.reduce((sum, s) => sum + s.duration, 0);
                onContentPlanUpdate({
                    ...contentPlan,
                    scenes: updatedScenes,
                    totalDuration,
                });
            }

            onProgress?.({
                stage: "narrating",
                progress: 100,
                message: `Narration updated for: ${currentScene.name}`,
            });

            console.log(`[useVideoNarration] Regenerated narration for scene ${sceneId}, duration: ${segment.audioDuration}s`);
        } catch (err) {
            console.error(`[useVideoNarration] Failed to regenerate narration for scene ${sceneId}:`, err);
            onError?.(err instanceof Error ? err.message : String(err));
        }
    }, [contentPlan, videoPurpose, onProgress, onError, onContentPlanUpdate]);

    /**
     * Play narration for a scene
     */
    const playNarration = useCallback((sceneId: string) => {
        // Stop current playback
        if (audioRef.current) {
            audioRef.current.pause();
            audioRef.current = null;
        }

        if (playingSceneId === sceneId) {
            setPlayingSceneId(null);
            return;
        }

        const url = audioUrlsRef.current.get(sceneId);
        if (!url) {
            console.warn(`No audio URL for scene ${sceneId}`);
            return;
        }

        const audio = new Audio(url);
        audio.onended = () => setPlayingSceneId(null);
        audio.play();
        audioRef.current = audio;
        setPlayingSceneId(sceneId);
    }, [playingSceneId]);

    /**
     * Get audio URLs map for SceneEditor
     */
    const getAudioUrlMap = useCallback((): Record<string, string> => {
        const map: Record<string, string> = {};
        audioUrlsRef.current.forEach((url, sceneId) => {
            map[sceneId] = url;
        });
        return map;
    }, []);

    /**
     * Reset narration state
     */
    const resetNarration = useCallback(() => {
        // Cleanup audio URLs
        audioUrlsRef.current.forEach((url) => revokeAudioUrl(url));
        audioUrlsRef.current.clear();

        if (audioRef.current) {
            audioRef.current.pause();
            audioRef.current = null;
        }

        setNarrationSegments([]);
        setPlayingSceneId(null);
    }, []);

    return {
        // State
        narrationSegments,
        playingSceneId,

        // Actions
        generateNarration,
        regenerateSceneNarration,
        playNarration,
        getAudioUrlMap,
        resetNarration,
        setNarrationSegments,
    };
}
</file>

<file path="hooks/useVideoProductionCore.ts">
/**
 * useVideoProductionCore Hook
 * 
 * Core pipeline state and configuration for video production.
 * Handles the main workflow orchestration and state management.
 */

import { useState, useCallback } from "react";
import { AppState, ContentPlan, Scene, ValidationResult } from "@/types";
import { ProductionProgress, ProductionConfig } from "@/services/agentOrchestrator";
import { VideoPurpose, LanguageCode } from "@/constants";

export interface VideoProductionCoreState {
    // Core state
    appState: AppState;
    topic: string;
    contentPlan: ContentPlan | null;
    validation: ValidationResult | null;
    progress: ProductionProgress | null;
    error: string | null;

    // Config
    targetDuration: number;
    targetAudience: string;
    videoPurpose: VideoPurpose;
    visualStyle: string;
    language: LanguageCode;
    useAgentMode: boolean;
    veoVideoCount: number;
}

export function useVideoProductionCore() {
    // Core state
    const [appState, setAppState] = useState<AppState>(AppState.IDLE);
    const [topic, setTopic] = useState("");
    const [contentPlan, setContentPlan] = useState<ContentPlan | null>(null);
    const [validation, setValidation] = useState<ValidationResult | null>(null);
    const [progress, setProgress] = useState<ProductionProgress | null>(null);
    const [error, setError] = useState<string | null>(null);

    // Config state
    const [targetDuration, setTargetDuration] = useState(60);
    const [targetAudience, setTargetAudience] = useState("General audience");
    const [videoPurpose, setVideoPurpose] = useState<VideoPurpose>("documentary");
    const [visualStyle, setVisualStyle] = useState("Cinematic");
    const [language, setLanguage] = useState<LanguageCode>("auto");
    const [useAgentMode, setUseAgentMode] = useState(true);
    const [veoVideoCount, setVeoVideoCount] = useState(1);

    /**
     * Update scenes (from SceneEditor)
     */
    const updateScenes = useCallback((scenes: Scene[]) => {
        if (!contentPlan) return;

        const totalDuration = scenes.reduce((sum, s) => sum + s.duration, 0);
        setContentPlan({
            ...contentPlan,
            scenes,
            totalDuration,
        });
    }, [contentPlan]);

    /**
     * Reset core state
     */
    const resetCore = useCallback(() => {
        setAppState(AppState.IDLE);
        setTopic("");
        setContentPlan(null);
        setValidation(null);
        setProgress(null);
        setError(null);
    }, []);

    return {
        // State
        appState,
        topic,
        contentPlan,
        validation,
        progress,
        error,
        targetDuration,
        targetAudience,
        videoPurpose,
        visualStyle,
        language,
        useAgentMode,
        veoVideoCount,

        // Setters
        setAppState,
        setTopic,
        setContentPlan,
        setValidation,
        setProgress,
        setError,
        setTargetDuration,
        setTargetAudience,
        setVideoPurpose,
        setVisualStyle,
        setLanguage,
        setUseAgentMode,
        setVeoVideoCount,

        // Actions
        updateScenes,
        resetCore,
    };
}
</file>

<file path="hooks/useVideoProductionRefactored.ts">
/**
 * useVideoProductionRefactored Hook
 * 
 * Refactored version of useVideoProduction that combines focused hooks.
 * This replaces the massive 987-line hook with a clean composition pattern.
 * 
 * Flow: Topic Input ‚Üí ContentPlanner ‚Üí Narrator ‚Üí Visuals ‚Üí SFX ‚Üí Editor ‚Üí Export
 */

import { useCallback } from "react";
import { AppState } from "@/types";
import {
    runProductionPipeline,
    ProductionConfig,
    stageToAppState
} from "@/services/agentOrchestrator";
import {
    runProductionAgent,
    runProductionAgentWithSubagents,
    ProductionProgress as AgentProgress,
} from "@/services/ai/productionAgent";
import { generateContentPlan, ContentPlannerConfig } from "@/services/contentPlannerService";
import { NarratorConfig, createAudioUrl } from "@/services/narratorService";

// Import focused hooks
import { useVideoProductionCore } from "./useVideoProductionCore";
import { useVideoNarration } from "./useVideoNarration";
import { useVideoVisuals } from "./useVideoVisuals";
import { useVideoQuality } from "./useVideoQuality";
import { useVideoSFX } from "./useVideoSFX";
import { useVideoPromptTools } from "./useVideoPromptTools";
import { useSunoMusic } from "./useSunoMusic";

// Toggle between monolithic and multi-agent system
const USE_MULTI_AGENT = import.meta.env.VITE_USE_MULTI_AGENT !== 'false';

export function useVideoProductionRefactored() {
    // Core state and configuration
    const coreHook = useVideoProductionCore();

    // Narration management with proper callbacks
    const narrationHook = useVideoNarration(
        coreHook.contentPlan,
        coreHook.videoPurpose,
        coreHook.setProgress,
        coreHook.setError,
        coreHook.setContentPlan
    );

    // Visual generation and management
    const visualsHook = useVideoVisuals();

    // Quality monitoring with proper callbacks
    const qualityHook = useVideoQuality(
        coreHook.setProgress,
        coreHook.setError
    );

    // SFX and audio mixing with proper callbacks
    const sfxHook = useVideoSFX(
        coreHook.setProgress,
        coreHook.setError
    );

    // Prompt quality tools
    const promptToolsHook = useVideoPromptTools(
        coreHook.contentPlan,
        coreHook.visualStyle,
        coreHook.topic
    );

    // Music generation (Suno API)
    const musicHook = useSunoMusic();

    /**
     * Start the full production pipeline
     */
    const startProduction = useCallback(async (config?: ProductionConfig, topicOverride?: string) => {
        const effectiveTopic = topicOverride || coreHook.topic;

        if (!effectiveTopic.trim()) {
            coreHook.setError("Please enter a topic");
            return;
        }

        // Update topic state if override provided
        if (topicOverride) {
            coreHook.setTopic(topicOverride);
        }

        coreHook.setError(null);
        coreHook.setProgress(null);

        // Calculate scene count from duration (1 scene per ~12 seconds, min 3)
        const effectiveDuration = config?.targetDuration ?? coreHook.targetDuration;
        const calculatedSceneCount = Math.max(3, Math.floor(effectiveDuration / 12));

        try {
            // Check if we should use AI Agent mode (default for complex automation)
            if (coreHook.useAgentMode) {
                console.log(`[useVideoProduction] Using AI Agent mode for ${effectiveDuration}s video`);
                coreHook.setAppState(AppState.CONTENT_PLANNING);

                // Build user request for the agent
                const userRequest = `Create a ${effectiveDuration} second ${coreHook.videoPurpose} video about: ${effectiveTopic}. 
Style: ${coreHook.visualStyle}. Language: ${coreHook.language === 'auto' ? 'detect from topic' : coreHook.language}.
Target audience: ${coreHook.targetAudience}.
${effectiveDuration > 300 ? 'This is a long video, use appropriate number of scenes.' : ''}
${config?.animateVisuals ? 'IMPORTANT: The user wants VIDEO, so you MUST use the animate_image tool for every scene.' : ''}
${coreHook.veoVideoCount > 0 ? `IMPORTANT: Use generate_visuals with veoVideoCount=${coreHook.veoVideoCount} to generate professional videos for the first ${coreHook.veoVideoCount} scenes.` : ''}`;

                // Choose which agent system to use
                const productionFunction = USE_MULTI_AGENT
                    ? runProductionAgentWithSubagents
                    : runProductionAgent;

                console.log(`[useVideoProduction] Using ${USE_MULTI_AGENT ? 'MULTI-AGENT' : 'MONOLITHIC'} system`);

                const agentResult = await productionFunction(
                    userRequest,
                    (agentProg: AgentProgress) => {
                        // Map agent progress to our progress format
                        coreHook.setProgress({
                            stage: agentProg.stage as any,
                            progress: agentProg.isComplete ? 100 : 50,
                            message: agentProg.message,
                        });

                        // Update app state based on tool being called
                        if (agentProg.tool === 'plan_video') {
                            coreHook.setAppState(AppState.CONTENT_PLANNING);
                        } else if (agentProg.tool === 'narrate_scenes') {
                            coreHook.setAppState(AppState.NARRATING);
                        } else if (agentProg.tool === 'generate_visuals' || agentProg.tool === 'animate_image') {
                            coreHook.setAppState(AppState.GENERATING_PROMPTS);
                        } else if (agentProg.tool === 'validate_plan') {
                            coreHook.setAppState(AppState.VALIDATING);
                        }
                    }
                );

                if (agentResult) {
                    coreHook.setContentPlan(agentResult.contentPlan);
                    narrationHook.setNarrationSegments(agentResult.narrationSegments);
                    visualsHook.setVisuals(agentResult.visuals);
                    sfxHook.setSfxPlan(agentResult.sfxPlan);

                    // Create audio URLs for playback from narration segments
                    agentResult.narrationSegments.forEach((segment) => {
                        if (segment.audioBlob) {
                            const url = createAudioUrl(segment);
                            // Note: This would need to be handled by the narration hook
                        }
                    });

                    // Generate quality report if we have a content plan
                    if (agentResult.contentPlan) {
                        // Convert ToolError[] to validation issues format
                        const errorMessages = (agentResult.errors || []).map(err => {
                            if (typeof err === 'string') {
                                return { scene: 'general', type: 'error' as const, message: err };
                            }
                            const sceneInfo = err.sceneIndex !== undefined ? `Scene ${err.sceneIndex}` : err.tool;
                            return {
                                scene: sceneInfo,
                                type: 'error' as const,
                                message: `${err.tool}: ${err.error}${err.fallbackApplied ? ` (fallback: ${err.fallbackApplied})` : ''}`
                            };
                        });

                        const partialReport = agentResult.partialSuccessReport;
                        const hasErrors = errorMessages.length > 0;
                        const score = partialReport?.isUsable
                            ? (partialReport.fallbackApplied > 0 ? 75 : 85)
                            : (hasErrors ? 60 : 85);

                        const validation = {
                            approved: !hasErrors || (partialReport?.isUsable ?? true),
                            score,
                            issues: errorMessages,
                            suggestions: partialReport ? [partialReport.summary] : []
                        };
                        coreHook.setValidation(validation);

                        const qualityReport = qualityHook.generateAndSaveQualityReport(
                            agentResult.contentPlan as any,
                            agentResult.narrationSegments,
                            agentResult.sfxPlan,
                            validation,
                            coreHook.videoPurpose
                        );
                        console.log(`[useVideoProduction] Agent Mode Quality Report: ${qualityReport.overallScore}/100`);
                    }

                    coreHook.setAppState(AppState.READY);
                } else {
                    throw new Error("Agent returned no result");
                }
            } else {
                // Fast mode - use direct orchestrator pipeline
                console.log(`[useVideoProduction] Using Fast mode (orchestrator) for ${effectiveDuration}s video`);

                const result = await runProductionPipeline(
                    effectiveTopic,
                    {
                        targetDuration: effectiveDuration,
                        sceneCount: calculatedSceneCount,
                        targetAudience: coreHook.targetAudience,
                        visualStyle: coreHook.visualStyle,
                        contentPlannerConfig: {
                            videoPurpose: coreHook.videoPurpose,
                            visualStyle: coreHook.visualStyle,
                            language: coreHook.language,
                        },
                        narratorConfig: {
                            videoPurpose: coreHook.videoPurpose,
                            language: coreHook.language,
                        },
                        veoVideoCount: coreHook.veoVideoCount,
                        ...config,
                    },
                    (prog) => {
                        coreHook.setProgress(prog);
                        coreHook.setAppState(stageToAppState(prog.stage));
                    }
                );

                coreHook.setContentPlan(result.contentPlan);
                narrationHook.setNarrationSegments(result.narrationSegments);
                visualsHook.setVisuals(result.visuals);
                sfxHook.setSfxPlan(result.sfxPlan);
                coreHook.setValidation(result.validation);

                // Generate quality report
                const report = qualityHook.generateAndSaveQualityReport(
                    result.contentPlan as any,
                    result.narrationSegments,
                    result.sfxPlan,
                    result.validation,
                    coreHook.videoPurpose
                );
                console.log(`[useVideoProduction] Fast Mode Quality Report: ${report.overallScore}/100`);

                if (!result.success) {
                    coreHook.setError(`Production completed with issues (score: ${result.validation.score})`);
                }

                coreHook.setAppState(AppState.READY);
            }
        } catch (err) {
            console.error("[useVideoProduction] Pipeline failed:", err);
            coreHook.setError(err instanceof Error ? err.message : String(err));
            coreHook.setAppState(AppState.ERROR);
        }
    }, [coreHook, narrationHook, visualsHook, sfxHook, qualityHook]);

    /**
     * Generate content plan only (without narration)
     */
    const generatePlan = useCallback(async (config?: Partial<ContentPlannerConfig>) => {
        if (!coreHook.topic.trim()) {
            coreHook.setError("Please enter a topic");
            return;
        }

        coreHook.setError(null);
        coreHook.setAppState(AppState.CONTENT_PLANNING);
        coreHook.setProgress({
            stage: "content_planning",
            progress: 0,
            message: "Generating video plan...",
        });

        try {
            const effectiveDuration = config?.targetDuration ?? coreHook.targetDuration;
            const plan = await generateContentPlan(coreHook.topic, {
                targetDuration: effectiveDuration,
                sceneCount: Math.max(3, Math.floor(effectiveDuration / 12)),
                targetAudience: coreHook.targetAudience,
                config: {
                    videoPurpose: coreHook.videoPurpose,
                    visualStyle: coreHook.visualStyle,
                },
            });

            coreHook.setContentPlan(plan);
            coreHook.setProgress({
                stage: "content_planning",
                progress: 100,
                message: `Created ${plan.scenes.length} scenes`,
            });
            coreHook.setAppState(AppState.READY);
        } catch (err) {
            console.error("[useVideoProduction] Plan generation failed:", err);
            coreHook.setError(err instanceof Error ? err.message : String(err));
            coreHook.setAppState(AppState.ERROR);
        }
    }, [coreHook]);

    /**
     * Add the selected music track to the timeline
     */
    const addMusicToTimeline = useCallback(() => {
        const selectedTrack = musicHook.getSelectedTrack();

        if (!selectedTrack) {
            console.warn("[useVideoProduction] No track selected to add to timeline");
            return;
        }

        console.log(`[useVideoProduction] Adding track "${selectedTrack.title}" to timeline`);

        sfxHook.setSfxPlan(prev => {
            const basePlan = prev || {
                scenes: [],
                backgroundMusic: null,
                masterVolume: 1.0,
            };

            return {
                ...basePlan,
                generatedMusic: {
                    trackId: selectedTrack.id,
                    audioUrl: selectedTrack.audio_url,
                    duration: selectedTrack.duration,
                    title: selectedTrack.title,
                },
            };
        });
    }, [musicHook.getSelectedTrack, sfxHook.setSfxPlan]);

    /**
     * Reset all state
     */
    const reset = useCallback(() => {
        coreHook.resetCore();
        narrationHook.resetNarration();
        visualsHook.resetVisuals();
        qualityHook.resetQuality();
        sfxHook.resetSFX();
        musicHook.resetMusicState();
    }, [coreHook, narrationHook, visualsHook, qualityHook, sfxHook, musicHook]);

    return {
        // Music generation state (Prioritized)
        musicState: musicHook.musicState,
        generateMusic: musicHook.generateMusic,
        generateLyrics: musicHook.generateLyrics,
        selectTrack: musicHook.selectTrack,
        refreshCredits: musicHook.refreshCredits,
        createMusicVideo: musicHook.createMusicVideo,
        generateCover: musicHook.generateCover,
        addVocals: musicHook.addVocals,
        addInstrumental: musicHook.addInstrumental,
        uploadAndCover: musicHook.uploadAndCover,
        uploadAudio: musicHook.uploadAudio,

        // Core State
        appState: coreHook.appState,
        topic: coreHook.topic,
        contentPlan: coreHook.contentPlan,
        narrationSegments: narrationHook.narrationSegments,
        visuals: visualsHook.visuals,
        sfxPlan: sfxHook.sfxPlan,
        validation: coreHook.validation,
        qualityReport: qualityHook.qualityReport,
        progress: coreHook.progress,
        error: coreHook.error,
        playingSceneId: narrationHook.playingSceneId,

        // Config
        targetDuration: coreHook.targetDuration,
        targetAudience: coreHook.targetAudience,
        videoPurpose: coreHook.videoPurpose,
        visualStyle: coreHook.visualStyle,
        language: coreHook.language,
        useAgentMode: coreHook.useAgentMode,
        setTargetDuration: coreHook.setTargetDuration,
        setTargetAudience: coreHook.setTargetAudience,
        setVideoPurpose: coreHook.setVideoPurpose,
        setVisualStyle: coreHook.setVisualStyle,
        setLanguage: coreHook.setLanguage,
        setUseAgentMode: coreHook.setUseAgentMode,
        veoVideoCount: coreHook.veoVideoCount,
        setVeoVideoCount: coreHook.setVeoVideoCount,

        // Actions
        setTopic: coreHook.setTopic,
        startProduction,
        generatePlan,
        generateNarration: narrationHook.generateNarration,
        regenerateSceneNarration: narrationHook.regenerateSceneNarration,
        runValidation: () => qualityHook.runValidation(
            coreHook.contentPlan as any,
            narrationHook.narrationSegments,
            visualsHook.visuals
        ),
        addMusicToTimeline,
        updateScenes: coreHook.updateScenes,
        playNarration: narrationHook.playNarration,
        reset,

        // Utilities
        getAudioUrlMap: narrationHook.getAudioUrlMap,
        getVisualsMap: visualsHook.getVisualsMap,
        visualsMap: visualsHook.visualsMap,

        // Test/Debug setters (for loading saved sessions)
        setVisuals: visualsHook.setVisuals,
        setContentPlan: coreHook.setContentPlan,
        setNarrationSegments: narrationHook.setNarrationSegments,
        setAppState: coreHook.setAppState,

        // SFX & Freesound
        browseSfx: sfxHook.browseSfx,
        getSfxCategories: sfxHook.getSfxCategories,
        previewSfx: sfxHook.previewSfx,
        isSfxAvailable: sfxHook.isSfxAvailable,
        mixAudio: sfxHook.mixAudio,

        // Prompt Quality Tools
        checkPromptQuality: promptToolsHook.checkPromptQuality,
        improvePrompt: promptToolsHook.improvePrompt,
        getCameraAngles: visualsHook.getCameraAngles,
        getLightingMoods: visualsHook.getLightingMoods,
        setPreferredCameraAngle: visualsHook.setPreferredCameraAngle,
        setPreferredLightingMood: visualsHook.setPreferredLightingMood,

        // Quality Functions
        getQualityHistoryData: qualityHook.getQualityHistoryData,
        getQualityTrend: qualityHook.getQualityTrend,
        exportQualityReport: qualityHook.exportQualityReport,
        getQualitySummaryText: qualityHook.getQualitySummaryText,

        // Camera & Lighting Preferences
        preferredCameraAngle: visualsHook.preferredCameraAngle,
        preferredLightingMood: visualsHook.preferredLightingMood,
    };
}

export default useVideoProductionRefactored;
</file>

<file path="hooks/useVideoPromptTools.ts">
/**
 * useVideoPromptTools Hook
 * 
 * Handles prompt quality checking and improvement tools for video production.
 * Provides AI-powered prompt refinement and quality analysis.
 */

import { useCallback } from "react";
import { ContentPlan } from "@/types";
import {
    lintPrompt,
    refineImagePrompt,
    type PromptLintIssue
} from "@/services/promptService";

export function useVideoPromptTools(
    contentPlan: ContentPlan | null,
    visualStyle: string,
    topic: string
) {
    /**
     * Lint a prompt for quality issues
     */
    const checkPromptQuality = useCallback((promptText: string, globalSubject?: string): PromptLintIssue[] => {
        return lintPrompt({
            promptText,
            globalSubject,
            previousPrompts: contentPlan?.scenes.map(s => s.visualDescription) || []
        });
    }, [contentPlan]);

    /**
     * Refine a prompt using AI
     */
    const improvePrompt = useCallback(async (
        promptText: string,
        intent: "auto" | "more_detailed" | "more_cinematic" | "shorten" = "auto"
    ): Promise<{ refinedPrompt: string; issues: PromptLintIssue[] }> => {
        return refineImagePrompt({
            promptText,
            style: visualStyle,
            globalSubject: topic,
            intent,
            previousPrompts: contentPlan?.scenes.map(s => s.visualDescription) || []
        });
    }, [visualStyle, topic, contentPlan]);

    return {
        // Actions
        checkPromptQuality,
        improvePrompt,
    };
}
</file>

<file path="hooks/useVideoQuality.ts">
/**
 * useVideoQuality Hook
 * 
 * Handles quality monitoring and reporting for video production.
 * Manages quality reports, history, and validation.
 */

import { useState, useCallback } from "react";
import { ContentPlan, NarrationSegment, ValidationResult } from "@/types";
import { VideoSFXPlan } from "@/services/sfxService";
import { VideoPurpose } from "@/constants";
import {
    generateQualityReport,
    saveReportToHistory,
    getQualityHistory,
    getHistoricalAverages,
    getQualitySummary,
    exportReportAsJson,
    ProductionQualityReport
} from "@/services/qualityMonitorService";
import { validateContentPlan } from "@/services/editorService";
import { ProductionProgress } from "@/services/agentOrchestrator";

export interface VideoQualityState {
    qualityReport: ProductionQualityReport | null;
}

export function useVideoQuality(
    onProgress?: (progress: ProductionProgress) => void,
    onError?: (error: string) => void
) {
    const [qualityReport, setQualityReport] = useState<ProductionQualityReport | null>(null);

    /**
     * Generate and save quality report
     */
    const generateAndSaveQualityReport = useCallback((
        contentPlan: ContentPlan,
        narrationSegments: NarrationSegment[],
        sfxPlan: VideoSFXPlan | null,
        validation: ValidationResult,
        videoPurpose: VideoPurpose
    ) => {
        const report = generateQualityReport(
            contentPlan,
            narrationSegments,
            sfxPlan,
            validation,
            videoPurpose
        );
        setQualityReport(report);
        saveReportToHistory(report);
        console.log(`[useVideoQuality] Quality Report: ${report.overallScore}/100`);
        return report;
    }, []);

    /**
     * Validate the current plan
     */
    const runValidation = useCallback(async (
        contentPlan: ContentPlan,
        narrationSegments: NarrationSegment[],
        visuals: any[]
    ): Promise<ValidationResult | null> => {
        if (!contentPlan) {
            onError?.("No content plan to validate");
            return null;
        }

        onProgress?.({
            stage: "validating",
            progress: 0,
            message: "Validating production...",
        });

        try {
            const result = await validateContentPlan(contentPlan, {
                narrationSegments,
                visuals,
                useAICritique: true,
            });

            onProgress?.({
                stage: "validating",
                progress: 100,
                message: `Validation score: ${result.score}/100`,
            });

            return result;
        } catch (err) {
            console.error("[useVideoQuality] Validation failed:", err);
            onError?.(err instanceof Error ? err.message : String(err));
            return null;
        }
    }, [onProgress, onError]);

    /**
     * Get quality history from localStorage
     */
    const getQualityHistoryData = useCallback(() => {
        return getQualityHistory();
    }, []);

    /**
     * Get historical quality averages and trend
     */
    const getQualityTrend = useCallback(() => {
        return getHistoricalAverages();
    }, []);

    /**
     * Export current quality report as JSON
     */
    const exportQualityReport = useCallback(() => {
        if (!qualityReport) return null;
        return exportReportAsJson(qualityReport);
    }, [qualityReport]);

    /**
     * Get quality summary string
     */
    const getQualitySummaryText = useCallback(() => {
        if (!qualityReport) return null;
        return getQualitySummary(qualityReport);
    }, [qualityReport]);

    /**
     * Reset quality state
     */
    const resetQuality = useCallback(() => {
        setQualityReport(null);
    }, []);

    return {
        // State
        qualityReport,

        // Actions
        generateAndSaveQualityReport,
        runValidation,
        getQualityHistoryData,
        getQualityTrend,
        exportQualityReport,
        getQualitySummaryText,
        resetQuality,
        setQualityReport,
    };
}
</file>

<file path="hooks/useVideoSFX.ts">
/**
 * useVideoSFX Hook
 * 
 * Handles sound effects and audio mixing for video production.
 * Manages SFX browsing, preview, and audio mixing capabilities.
 */

import { useState, useCallback } from "react";
import { ContentPlan, NarrationSegment } from "@/types";
import { VideoSFXPlan } from "@/services/sfxService";
import {
    searchAmbientSound,
    getPreviewUrl,
    isFreesoundConfigured,
    AMBIENT_SEARCH_QUERIES,
    type FreesoundSound
} from "@/services/freesoundService";
import {
    mixAudioWithSFX,
    canMixSFX,
    type MixConfig
} from "@/services/audioMixerService";
import { ProductionProgress } from "@/services/agentOrchestrator";

export interface VideoSFXState {
    sfxPlan: VideoSFXPlan | null;
}

export function useVideoSFX(
    onProgress?: (progress: ProductionProgress) => void,
    onError?: (error: string) => void
) {
    const [sfxPlan, setSfxPlan] = useState<VideoSFXPlan | null>(null);

    /**
     * Browse SFX from Freesound library
     */
    const browseSfx = useCallback(async (category: string): Promise<FreesoundSound | null> => {
        if (!isFreesoundConfigured()) {
            console.warn("[useVideoSFX] Freesound API not configured");
            onError?.("Freesound API key not configured. Add VITE_FREESOUND_API_KEY to .env.local");
            return null;
        }

        try {
            const sound = await searchAmbientSound(category);
            if (sound) {
                console.log(`[useVideoSFX] Found SFX: ${sound.name} (${sound.duration.toFixed(1)}s)`);
            }
            return sound;
        } catch (err) {
            console.error("[useVideoSFX] SFX browse failed:", err);
            onError?.(err instanceof Error ? err.message : String(err));
            return null;
        }
    }, [onError]);

    /**
     * Get available SFX categories
     */
    const getSfxCategories = useCallback(() => {
        return Object.keys(AMBIENT_SEARCH_QUERIES);
    }, []);

    /**
     * Preview an SFX sound
     */
    const previewSfx = useCallback((sound: FreesoundSound) => {
        const url = getPreviewUrl(sound);
        const audio = new Audio(url);
        audio.volume = 0.5;
        audio.play();
        return () => audio.pause();
    }, []);

    /**
     * Mix audio with SFX and background music
     */
    const mixAudio = useCallback(async (
        contentPlan: ContentPlan,
        narrationSegments: NarrationSegment[],
        options: {
            includeSfx?: boolean;
            includeMusic?: boolean;
        } = {}
    ): Promise<Blob | null> => {
        const { includeSfx = true, includeMusic = true } = options;

        if (!contentPlan || narrationSegments.length === 0) {
            onError?.("No content to mix - generate narration first");
            return null;
        }

        // Build merged narration URL first
        const orderedBlobs: Blob[] = [];
        for (const scene of contentPlan.scenes) {
            const narration = narrationSegments.find(n => n.sceneId === scene.id);
            if (narration?.audioBlob) orderedBlobs.push(narration.audioBlob);
        }

        if (orderedBlobs.length === 0) {
            onError?.("No narration audio available");
            return null;
        }

        try {
            // Merge narration blobs first
            const { mergeConsecutiveAudioBlobs } = await import("@/services/audioMixerService");
            const mergedNarration = await mergeConsecutiveAudioBlobs(orderedBlobs);
            const narrationUrl = URL.createObjectURL(mergedNarration);

            // Build scene timing info
            let currentTime = 0;
            const scenes = contentPlan.scenes.map(scene => {
                const narration = narrationSegments.find(n => n.sceneId === scene.id);
                const duration = narration?.audioDuration || scene.duration;
                const info = {
                    sceneId: scene.id,
                    startTime: currentTime,
                    duration
                };
                currentTime += duration;
                return info;
            });

            // Prepare mix config
            const mixConfig: MixConfig = {
                narrationUrl,
                sfxPlan: includeSfx ? sfxPlan : null,
                scenes,
                sfxMasterVolume: 0.3,
                musicMasterVolume: includeMusic ? 0.5 : 0,
            };

            // Check if we can actually mix SFX
            if (includeSfx && !canMixSFX(sfxPlan)) {
                console.warn("[useVideoSFX] SFX plan has no audio URLs - mixing narration only");
            }

            onProgress?.({
                stage: "validating",
                progress: 50,
                message: "Mixing audio tracks...",
            });

            const mixedBlob = await mixAudioWithSFX(mixConfig);

            // Cleanup temp URL
            URL.revokeObjectURL(narrationUrl);

            onProgress?.({
                stage: "validating",
                progress: 100,
                message: "Audio mix complete!",
            });

            return mixedBlob;
        } catch (err) {
            console.error("[useVideoSFX] Audio mixing failed:", err);
            onError?.(err instanceof Error ? err.message : String(err));
            return null;
        }
    }, [sfxPlan, onProgress, onError]);

    /**
     * Check if Freesound is configured
     */
    const isSfxAvailable = useCallback(() => isFreesoundConfigured(), []);

    /**
     * Reset SFX state
     */
    const resetSFX = useCallback(() => {
        setSfxPlan(null);
    }, []);

    return {
        // State
        sfxPlan,

        // Setters
        setSfxPlan,

        // Actions
        browseSfx,
        getSfxCategories,
        previewSfx,
        mixAudio,
        isSfxAvailable,
        resetSFX,
    };
}
</file>

<file path="hooks/useVideoVisuals.ts">
/**
 * useVideoVisuals Hook
 * 
 * Handles visual generation and management for video production.
 * Manages generated images and visual preferences.
 */

import { useState, useCallback, useMemo } from "react";
import { GeneratedImage } from "@/types";
import { CAMERA_ANGLES, LIGHTING_MOODS } from "@/constants/video";

export interface VideoVisualsState {
    visuals: GeneratedImage[];
    preferredCameraAngle: string | null;
    preferredLightingMood: string | null;
}

export function useVideoVisuals() {
    const [visuals, setVisuals] = useState<GeneratedImage[]>([]);
    const [preferredCameraAngle, setPreferredCameraAngle] = useState<string | null>(null);
    const [preferredLightingMood, setPreferredLightingMood] = useState<string | null>(null);

    /**
     * Get visuals map for SceneEditor (sceneId -> imageUrl)
     * Memoized to prevent unnecessary re-renders in consuming components
     */
    const visualsMap = useMemo((): Record<string, string> => {
        const map: Record<string, string> = {};
        visuals.forEach((visual) => {
            if (visual.imageUrl) {
                map[visual.promptId] = visual.imageUrl;
            }
        });
        return map;
    }, [visuals]);

    /**
     * Legacy getter for backward compatibility
     */
    const getVisualsMap = useCallback(() => visualsMap, [visualsMap]);

    /**
     * Get available camera angles
     */
    const getCameraAngles = useCallback(() => [...CAMERA_ANGLES], []);

    /**
     * Get available lighting moods
     */
    const getLightingMoods = useCallback(() => [...LIGHTING_MOODS], []);

    /**
     * Reset visuals state
     */
    const resetVisuals = useCallback(() => {
        setVisuals([]);
        setPreferredCameraAngle(null);
        setPreferredLightingMood(null);
    }, []);

    return {
        // State
        visuals,
        preferredCameraAngle,
        preferredLightingMood,
        visualsMap,

        // Setters
        setVisuals,
        setPreferredCameraAngle,
        setPreferredLightingMood,

        // Actions
        getVisualsMap,
        getCameraAngles,
        getLightingMoods,
        resetVisuals,
    };
}
</file>

<file path="i18n/index.ts">
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import LanguageDetector from 'i18next-browser-languagedetector';

import en from './locales/en.json';
import ar from './locales/ar.json';

export const supportedLanguages = ['en', 'ar'] as const;
export type SupportedLanguage = (typeof supportedLanguages)[number];

export const languageConfig = {
  en: { name: 'English', dir: 'ltr' as const, flag: 'üá∫üá∏' },
  ar: { name: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', dir: 'rtl' as const, flag: 'üá∏üá¶' },
};

i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    resources: {
      en: { translation: en },
      ar: { translation: ar },
    },
    fallbackLng: 'en',
    supportedLngs: supportedLanguages,
    interpolation: {
      escapeValue: false, // React already escapes values
    },
    detection: {
      order: ['localStorage', 'navigator'],
      caches: ['localStorage'],
      lookupLocalStorage: 'lyriclens-language',
    },
  });

export default i18n;
</file>

<file path="i18n/locales/ar.json">
{
  "nav": {
    "home": "ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©",
    "studio": "ÿßŸÑÿßÿ≥ÿ™ŸàÿØŸäŸà",
    "visualizer": "ÿßŸÑŸÖŸèÿµŸàŸêŸëÿ±",
    "back": "ÿ±ÿ¨Ÿàÿπ",
    "settings": "ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™",
    "projects": "ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ",
    "quickCreate": "ÿ•ŸÜÿ¥ÿßÿ° ÿ≥ÿ±Ÿäÿπ",
    "gradientGenerator": "ŸÖŸàŸÑÿØ ÿßŸÑÿ™ÿØÿ±ÿ¨ÿßÿ™",
    "help": "ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ©"
  },
  "home": {
    "title": "ŸÑŸäÿ±ŸäŸÉ ŸÑŸäŸÜÿ≤",
    "subtitle": "ÿ•ŸÜÿ™ÿßÿ¨ ŸÅŸäÿØŸäŸà ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä",
    "createVideo": "ÿ•ŸÜÿ¥ÿßÿ° ŸÅŸäÿØŸäŸà",
    "createVideoDesc": "ÿ£ŸÜÿ¥ÿ¶ ŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÖÿ∞ŸáŸÑÿ© ŸÖŸÜ ÿßŸÑŸÜÿµ ÿ£Ÿà ÿßŸÑŸÖŸàÿßÿ∂Ÿäÿπ",
    "createMusic": "ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸàÿ≥ŸäŸÇŸâ",
    "createMusicDesc": "ÿ£ŸÜÿ¥ÿ¶ ŸÖŸÇÿßÿ∑ÿπ ŸÖŸàÿ≥ŸäŸÇŸäÿ© ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä",
    "visualizer": "ÿßŸÑŸÖŸèÿµŸàŸêŸëÿ±",
    "visualizerDesc": "ÿ£ŸÜÿ¥ÿ¶ ŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÉŸÑŸÖÿßÿ™ ŸÖŸÜ ŸÖŸÑŸÅÿßÿ™ ÿµŸàÿ™Ÿäÿ©",
    "recentProjects": "ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ ÿßŸÑÿ£ÿÆŸäÿ±ÿ©",
    "noProjects": "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖÿ¥ÿßÿ±Ÿäÿπ ÿ≠ÿØŸäÿ´ÿ©",
    "features": {
      "video": ["ÿßŸÑÿ≥ÿ±ÿØ ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä", "ÿ™ŸàŸÑŸäÿØ ÿßŸÑŸÖÿ±ÿ¶Ÿäÿßÿ™", "ŸÖŸàÿ≥ŸäŸÇŸâ ÿÆŸÑŸÅŸäÿ©"],
      "music": ["ÿ£ÿ∫ÿßŸÜŸä ŸÉÿßŸÖŸÑÿ©", "ŸÖŸàÿ≥ŸäŸÇŸâ ÿ¢ŸÑŸäÿ©", "ŸÉŸÑŸÖÿßÿ™ ŸÖÿÆÿµÿµÿ©"],
      "visualizer": ["ŸÖÿ≤ÿßŸÖŸÜÿ© ÿßŸÑŸÉŸÑŸÖÿßÿ™", "ŸÖÿ§ÿ´ÿ±ÿßÿ™ ÿ®ÿµÿ±Ÿäÿ©", "ÿ™ŸàŸÇŸäÿ™ ŸÖÿÆÿµÿµ"]
    }
  },
  "studio": {
    "title": "ÿßŸÑÿßÿ≥ÿ™ŸàÿØŸäŸà",
    "placeholder": "ÿµŸêŸÅ ŸÖÿß ÿ™ÿ±ŸäÿØ ÿ•ŸÜÿ¥ÿßÿ°Ÿá...",
    "send": "ÿ•ÿ±ÿ≥ÿßŸÑ",
    "export": "ÿ™ÿµÿØŸäÿ±",
    "edit": "ÿ™ÿπÿØŸäŸÑ",
    "timeline": "ÿßŸÑÿ¨ÿØŸàŸÑ ÿßŸÑÿ≤ŸÖŸÜŸä",
    "quality": "ÿßŸÑÿ¨ŸàÿØÿ©",
    "newProject": "ŸÖÿ¥ÿ±Ÿàÿπ ÿ¨ÿØŸäÿØ",
    "simpleMode": "ÿ®ÿ≥Ÿäÿ∑",
    "advancedMode": "ŸÖÿ™ŸÇÿØŸÖ",
    "scenes": "ÿßŸÑŸÖÿ¥ÿßŸáÿØ",
    "preview": "ŸÖÿπÿßŸäŸÜÿ©",
    "generating": "ÿ¨ÿßÿ±Ÿç ÿßŸÑÿ•ŸÜÿ¥ÿßÿ°...",
    "processing": "ÿ¨ÿßÿ±Ÿç ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©..."
  },
  "visualizer": {
    "title": "ÿßŸÑŸÖŸèÿµŸàŸêŸëÿ±",
    "uploadAudio": "ÿ±ŸÅÿπ ŸÖŸÑŸÅ ÿµŸàÿ™Ÿä",
    "uploadSubtitles": "ÿ±ŸÅÿπ ŸÖŸÑŸÅ ÿ™ÿ±ÿ¨ŸÖÿ©",
    "dropAudio": "ÿßÿ≥ÿ≠ÿ® ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿµŸàÿ™Ÿä ŸáŸÜÿß ÿ£Ÿà ÿßŸÜŸÇÿ± ŸÑŸÑÿ™ÿµŸÅÿ≠",
    "dropSubtitles": "ÿßÿ≥ÿ≠ÿ® ŸÖŸÑŸÅ SRT ŸáŸÜÿß ÿ£Ÿà ÿßŸÜŸÇÿ± ŸÑŸÑÿ™ÿµŸÅÿ≠",
    "generate": "ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÅŸäÿØŸäŸà"
  },
  "common": {
    "loading": "ÿ¨ÿßÿ±Ÿç ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...",
    "error": "ÿÆÿ∑ÿ£",
    "retry": "ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©",
    "cancel": "ÿ•ŸÑÿ∫ÿßÿ°",
    "save": "ÿ≠ŸÅÿ∏",
    "delete": "ÿ≠ÿ∞ŸÅ",
    "confirm": "ÿ™ÿ£ŸÉŸäÿØ",
    "close": "ÿ•ÿ∫ŸÑÿßŸÇ",
    "yes": "ŸÜÿπŸÖ",
    "no": "ŸÑÿß",
    "ok": "ŸÖŸàÿßŸÅŸÇ",
    "download": "ÿ™ÿ≠ŸÖŸäŸÑ",
    "upload": "ÿ±ŸÅÿπ",
    "search": "ÿ®ÿ≠ÿ´",
    "clear": "ŸÖÿ≥ÿ≠",
    "reset": "ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ",
    "apply": "ÿ™ÿ∑ÿ®ŸäŸÇ",
    "done": "ÿ™ŸÖ",
    "next": "ÿßŸÑÿ™ÿßŸÑŸä",
    "previous": "ÿßŸÑÿ≥ÿßÿ®ŸÇ",
    "comingSoon": "ŸÇÿ±Ÿäÿ®ÿßŸã",
    "unsavedChanges": "ÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ ÿ∫Ÿäÿ± ŸÖÿ≠ŸÅŸàÿ∏ÿ©",
    "unsavedChangesMessage": "ŸÑÿØŸäŸÉ ÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ ÿ∫Ÿäÿ± ŸÖÿ≠ŸÅŸàÿ∏ÿ©. ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ÿ£ŸÜŸÉ ÿ™ÿ±ŸäÿØ ÿßŸÑŸÖÿ∫ÿßÿØÿ±ÿ©ÿü ÿ≥ÿ™ŸÅŸÇÿØ ÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ŸÉ.",
    "stay": "ÿßŸÑÿ®ŸÇÿßÿ°",
    "leaveAnyway": "ÿßŸÑŸÖÿ∫ÿßÿØÿ±ÿ© ÿπŸÑŸâ ÿ£Ÿä ÿ≠ÿßŸÑ",
    "items_zero": "ŸÑÿß ÿπŸÜÿßÿµÿ±",
    "items_one": "ÿπŸÜÿµÿ± Ÿàÿßÿ≠ÿØ",
    "items_two": "ÿπŸÜÿµÿ±ÿßŸÜ",
    "items_few": "{{count}} ÿπŸÜÿßÿµÿ±",
    "items_many": "{{count}} ÿπŸÜÿµÿ±ÿßŸã",
    "items_other": "{{count}} ÿπŸÜÿµÿ±",
    "somethingWentWrong": "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÖÿß",
    "import": "ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ",
    "all": "ÿßŸÑŸÉŸÑ"
  },
  "a11y": {
    "languageSwitch": "ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑŸÑÿ∫ÿ©",
    "mainNav": "ÿßŸÑÿ™ŸÜŸÇŸÑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä",
    "skipToContent": "ÿßŸÜÿ™ŸÇŸÑ ÿ•ŸÑŸâ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä",
    "currentLanguage": "ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©: {{language}}",
    "openMenu": "ŸÅÿ™ÿ≠ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©",
    "closeMenu": "ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©"
  },
  "errors": {
    "generic": "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÖÿß. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
    "network": "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ¥ÿ®ŸÉÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿ™ÿµÿßŸÑŸÉ.",
    "notFound": "ÿßŸÑÿµŸÅÿ≠ÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©",
    "unauthorized": "ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ŸÑŸÉ ÿ®ÿπÿ±ÿ∂ Ÿáÿ∞Ÿá ÿßŸÑÿµŸÅÿ≠ÿ©"
  },
  "story": {
    "charactersEmpty": "ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿ¥ÿÆÿµŸäÿßÿ™ ÿ®ÿπÿØ.",
    "continuity": "ÿßŸÑÿßÿ≥ÿ™ŸÖÿ±ÿßÿ±Ÿäÿ©",
    "visualDescription": "ÿßŸÑŸàÿµŸÅ ÿßŸÑÿ®ÿµÿ±Ÿä",
    "issuesFound": "ÿßŸÑŸÖÿ¥ÿßŸÉŸÑ ÿßŸÑŸÖŸÉÿ™ÿ¥ŸÅÿ©",
    "suggestions": "ÿßŸÑÿßŸÇÿ™ÿ±ÿßÿ≠ÿßÿ™",
    "verifyContinuity": "ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿ≥ÿ™ŸÖÿ±ÿßÿ±Ÿäÿ©",
    "verifying": "ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßÿ≥ÿ™ŸÖÿ±ÿßÿ±Ÿäÿ©...",
    "storyIdea": "ŸÅŸÉÿ±ÿ© ÿßŸÑŸÇÿµÿ©",
    "whatsYourStory": "ŸÖÿß ŸáŸä ŸÇÿµÿ™ŸÉÿü",
    "describeYourConcept": "ÿµŸêŸÅ ŸÅŸÉÿ±ÿ™ŸÉ Ÿàÿ≥ŸÜÿ≠ŸàŸëŸÑŸáÿß ÿ•ŸÑŸâ ŸÖÿ¥ÿßŸáÿØ Ÿàÿ¥ÿÆÿµŸäÿßÿ™ ŸàŸÑŸàÿ≠ÿ© ŸÇÿµÿµŸäÿ© ÿ®ÿµÿ±Ÿäÿ©.",
    "placeholderStory": "ŸÖÿ≠ŸÇŸÇ ŸäŸÉÿ™ÿ¥ŸÅ ÿ£ŸÜ ÿ¨ÿ±ŸäŸÖÿ© ÿßŸÑŸÇÿ™ŸÑ ÿßŸÑÿ™Ÿä Ÿäÿ≠ŸÇŸÇ ŸÅŸäŸáÿß ÿßÿ±ÿ™ŸÉÿ®Ÿáÿß ŸáŸà ŸÜŸÅÿ≥Ÿá ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑ...",
    "tryTemplate": "ÿ¨ÿ±Ÿëÿ® ŸÇÿßŸÑÿ®ÿßŸã",
    "browseAll": "ÿ™ÿµŸÅÿ≠ ÿßŸÑŸÉŸÑ",
    "genre": "ÿßŸÑŸÜŸàÿπ",
    "allCount": "ÿßŸÑŸÉŸÑ {{count}}",
    "buildingStory": "ÿ¨ÿßÿ±Ÿç ÿ®ŸÜÿßÿ° ŸÇÿµÿ™ŸÉ...",
    "beginStory": "ÿßÿ®ÿØÿ£ ÿßŸÑŸÇÿµÿ©",
    "breakdown": "ÿßŸÑÿ™ŸÇÿ≥ŸäŸÖ",
    "storyboard": "ŸÑŸàÿ≠ÿ© ÿßŸÑŸÇÿµÿ©",
    "sceneBreakdown": "ÿ™ŸÇÿ≥ŸäŸÖ ÿßŸÑŸÖÿ¥ÿßŸáÿØ",
    "script": "ÿßŸÑÿ≥ŸäŸÜÿßÿ±ŸäŸà",
    "cast": "ŸÅÿ±ŸäŸÇ ÿßŸÑÿ™ŸÖÿ´ŸäŸÑ",
    "shotList": "ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÑŸÇÿ∑ÿßÿ™",
    "visualStyle": "ÿßŸÑŸÜŸÖÿ∑ ÿßŸÑÿ®ÿµÿ±Ÿä",
    "narration": "ÿßŸÑÿ≥ÿ±ÿØ",
    "animation": "ÿßŸÑÿ±ÿ≥ŸàŸÖ ÿßŸÑŸÖÿ™ÿ≠ÿ±ŸÉÿ©",
    "export": "ÿßŸÑÿ™ÿµÿØŸäÿ±",
    "shotBreakdown": "ÿ™ŸÅÿµŸäŸÑ ÿßŸÑŸÑŸÇÿ∑ÿßÿ™",
    "locked": "ŸÖŸèŸÇŸÅŸéŸÑ",
    "generateShots": "ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÑŸÇÿ∑ÿßÿ™",
    "noShotsGenerated": "ŸÑŸÖ Ÿäÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ŸÑŸÇÿ∑ÿßÿ™",
    "generateNarration": "ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≥ÿ±ÿØ",
    "regenerateNarration": "ÿ•ÿπÿßÿØÿ© ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≥ÿ±ÿØ",
    "narrationDescription": "ÿ•ŸÜÿ¥ÿßÿ° ÿ™ÿπŸÑŸäŸÇ ÿµŸàÿ™Ÿä ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ŸÑŸÉŸÑ ŸÖÿ¥ŸáÿØ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Gemini TTS.",
    "noNarrationYet": "ŸÑŸÖ Ÿäÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿ≥ÿ±ÿØ ÿ®ÿπÿØ",
    "clickGenerateNarration": "ÿßŸÜŸÇÿ± \"ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≥ÿ±ÿØ\" ŸÑÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ™ÿπŸÑŸäŸÇ ÿßŸÑÿµŸàÿ™Ÿä",
    "regenerateAll": "ÿ•ÿπÿßÿØÿ© ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÉŸÑ",
    "animateAllShots": "ÿ™ÿ≠ÿ±ŸäŸÉ ŸÉŸÑ ÿßŸÑŸÑŸÇÿ∑ÿßÿ™",
    "animationDescription": "ÿ™ÿ≠ŸàŸäŸÑ ÿµŸàÿ± ŸÑŸàÿ≠ÿ© ÿßŸÑŸÇÿµÿ© ÿ•ŸÑŸâ ŸÖŸÇÿßÿ∑ÿπ ŸÅŸäÿØŸäŸà ŸÖÿ™ÿ≠ÿ±ŸÉÿ© ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ DeAPI ÿ£Ÿà Veo.",
    "animated": "ŸÖÿ™ÿ≠ÿ±ŸÉ",
    "noShotsToAnimate": "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÑŸÇÿ∑ÿßÿ™ ŸÑŸÑÿ™ÿ≠ÿ±ŸäŸÉ",
    "generateStoryboardFirst": "ÿ£ŸÜÿ¥ÿ¶ ÿßŸÑÿ±ÿ≥ŸàŸÖÿßÿ™ ÿßŸÑÿ®ÿµÿ±Ÿäÿ© ÿ£ŸàŸÑÿßŸã",
    "exportVideo": "ÿ™ÿµÿØŸäÿ± ÿßŸÑŸÅŸäÿØŸäŸà",
    "scenes": "ÿßŸÑŸÖÿ¥ÿßŸáÿØ",
    "shots": "ÿßŸÑŸÑŸÇÿ∑ÿßÿ™",
    "duration": "ÿßŸÑŸÖÿØÿ©",
    "renderingVideo": "ÿ¨ÿßÿ±Ÿç ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÅŸäÿØŸäŸà...",
    "downloadVideo": "ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÅŸäÿØŸäŸà",
    "generateNarrationBeforeExport": "ÿ£ŸÜÿ¥ÿ¶ ÿßŸÑÿ≥ÿ±ÿØ ŸÇÿ®ŸÑ ÿßŸÑÿ™ÿµÿØŸäÿ±",
    "createScript": "ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≥ŸäŸÜÿßÿ±ŸäŸà",
    "continueToCast": "ÿßŸÑÿßÿ≥ÿ™ŸÖÿ±ÿßÿ± ÿ•ŸÑŸâ ŸÅÿ±ŸäŸÇ ÿßŸÑÿ™ŸÖÿ´ŸäŸÑ",
    "lockScript": "ŸÇŸÅŸÑ ÿßŸÑÿ≥ŸäŸÜÿßÿ±ŸäŸà",
    "createShotList": "ÿ•ŸÜÿ¥ÿßÿ° ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÑŸÇÿ∑ÿßÿ™",
    "selectStyle": "ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÜŸÖÿ∑",
    "generateStoryboard": "ÿ•ŸÜÿ¥ÿßÿ° ŸÑŸàÿ≠ÿ© ÿßŸÑŸÇÿµÿ©",
    "addNarration": "ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ≥ÿ±ÿØ",
    "animateShots": "ÿ™ÿ≠ÿ±ŸäŸÉ ÿßŸÑŸÑŸÇÿ∑ÿßÿ™",
    "genres": {
      "Drama": "ÿØÿ±ÿßŸÖÿß",
      "Comedy": "ŸÉŸàŸÖŸäÿØŸäÿß",
      "Thriller": "ÿ•ÿ´ÿßÿ±ÿ©",
      "Sci-Fi": "ÿÆŸäÿßŸÑ ÿπŸÑŸÖŸä",
      "Mystery": "ÿ∫ŸÖŸàÿ∂",
      "Action": "ÿ£ŸÉÿ¥ŸÜ",
      "Horror": "ÿ±ÿπÿ®",
      "Fantasy": "ŸÅÿßŸÜÿ™ÿßÿ≤Ÿäÿß",
      "Romance": "ÿ±ŸàŸÖÿßŸÜÿ≥Ÿä",
      "Historical": "ÿ™ÿßÿ±ŸäÿÆŸä",
      "Documentary": "Ÿàÿ´ÿßÿ¶ŸÇŸä",
      "Animation": "ÿ±ÿ≥ŸàŸÖ ŸÖÿ™ÿ≠ÿ±ŸÉÿ©"
    },
    "templates": {
      "title": "ÿßŸÑŸÇŸàÿßŸÑÿ®",
      "searchPlaceholder": "ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑŸÇŸàÿßŸÑÿ®...",
      "noTemplatesFound": "ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÇŸàÿßŸÑÿ®",
      "clearSearch": "ŸÖÿ≥ÿ≠ ÿßŸÑÿ®ÿ≠ÿ´",
      "scenes": "ÿßŸÑŸÖÿ¥ÿßŸáÿØ",
      "visualStyles": "ÿßŸÑÿ£ŸÜŸÖÿßÿ∑ ÿßŸÑÿ®ÿµÿ±Ÿäÿ©",
      "useTemplate": "ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÇÿßŸÑÿ®",
      "duration": "ÿßŸÑŸÖÿØÿ©",
      "style": "ÿßŸÑŸÜŸÖÿ∑",
      "ratio": "ÿßŸÑŸÜÿ≥ÿ®ÿ©",
      "difficulty": {
        "beginner": "ŸÖÿ®ÿ™ÿØÿ¶",
        "intermediate": "ŸÖÿ™Ÿàÿ≥ÿ∑",
        "advanced": "ŸÖÿ™ŸÇÿØŸÖ"
      },
      "categories": {
        "narrative": "ÿ≥ÿ±ÿØŸä",
        "commercial": "ÿ™ÿ¨ÿßÿ±Ÿä",
        "educational": "ÿ™ÿπŸÑŸäŸÖŸä",
        "social": "Ÿàÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™ŸàÿßÿµŸÑ",
        "experimental": "ÿ™ÿ¨ÿ±Ÿäÿ®Ÿä"
      },
      "genres": {
        "Drama": "ÿØÿ±ÿßŸÖÿß",
        "Horror": "ÿ±ÿπÿ®",
        "Comedy": "ŸÉŸàŸÖŸäÿØŸäÿß",
        "Science Fiction": "ÿÆŸäÿßŸÑ ÿπŸÑŸÖŸä",
        "Fantasy": "ŸÅÿßŸÜÿ™ÿßÿ≤Ÿäÿß",
        "Commercial": "ÿ™ÿ¨ÿßÿ±Ÿä",
        "Social": "ÿßÿ¨ÿ™ŸÖÿßÿπŸä",
        "Educational": "ÿ™ÿπŸÑŸäŸÖŸä",
        "Music Video": "ŸÅŸäÿØŸäŸà ŸÖŸàÿ≥ŸäŸÇŸä",
        "Documentary": "Ÿàÿ´ÿßÿ¶ŸÇŸä"
      },
      "tags": {
        "drama": "ÿØÿ±ÿßŸÖÿß",
        "emotional": "ÿπÿßÿ∑ŸÅŸä",
        "character-driven": "ŸÇÿßÿ¶ŸÖ ÿπŸÑŸâ ÿßŸÑÿ¥ÿÆÿµŸäÿßÿ™",
        "cinematic": "ÿ≥ŸäŸÜŸÖÿßÿ¶Ÿä",
        "horror": "ÿ±ÿπÿ®",
        "suspense": "ÿ™ÿ¥ŸàŸäŸÇ",
        "atmospheric": "ÿ¨Ÿà ŸÖŸÖŸäÿ≤",
        "thriller": "ÿ•ÿ´ÿßÿ±ÿ©",
        "comedy": "ŸÉŸàŸÖŸäÿØŸäÿß",
        "humor": "ŸÅŸÉÿßŸáÿ©",
        "sketch": "ÿßÿ≥ŸÉÿ™ÿ¥",
        "funny": "ŸÖÿ∂ÿ≠ŸÉ",
        "sci-fi": "ÿÆŸäÿßŸÑ ÿπŸÑŸÖŸä",
        "futuristic": "ŸÖÿ≥ÿ™ŸÇÿ®ŸÑŸä",
        "technology": "ÿ™ŸÇŸÜŸäÿ©",
        "visionary": "ÿ±ÿ§ŸäŸàŸä",
        "fantasy": "ŸÅÿßŸÜÿ™ÿßÿ≤Ÿäÿß",
        "adventure": "ŸÖÿ∫ÿßŸÖÿ±ÿ©",
        "magic": "ÿ≥ÿ≠ÿ±",
        "epic": "ŸÖŸÑÿ≠ŸÖŸä",
        "product": "ŸÖŸÜÿ™ÿ¨",
        "commercial": "ÿ™ÿ¨ÿßÿ±Ÿä",
        "marketing": "ÿ™ÿ≥ŸàŸäŸÇ",
        "showcase": "ÿπÿ±ÿ∂",
        "brand": "ÿπŸÑÿßŸÖÿ© ÿ™ÿ¨ÿßÿ±Ÿäÿ©",
        "story": "ŸÇÿµÿ©",
        "values": "ŸÇŸäŸÖ",
        "tiktok": "ÿ™ŸäŸÉ ÿ™ŸàŸÉ",
        "reels": "ÿ±ŸäŸÑÿ≤",
        "social": "ÿßÿ¨ÿ™ŸÖÿßÿπŸä",
        "viral": "ŸÅŸäÿ±Ÿàÿ≥Ÿä",
        "short-form": "ŸÇÿµŸäÿ±",
        "educational": "ÿ™ÿπŸÑŸäŸÖŸä",
        "explainer": "ÿ¥ÿ±ÿ≠",
        "tutorial": "ÿØÿ±ÿ≥",
        "informative": "ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿä",
        "music": "ŸÖŸàÿ≥ŸäŸÇŸâ",
        "artistic": "ŸÅŸÜŸä",
        "visual": "ÿ®ÿµÿ±Ÿä",
        "experimental": "ÿ™ÿ¨ÿ±Ÿäÿ®Ÿä",
        "documentary": "Ÿàÿ´ÿßÿ¶ŸÇŸä",
        "real": "ŸàÿßŸÇÿπŸä",
        "interview": "ŸÖŸÇÿßÿ®ŸÑÿ©",
        "investigative": "ÿßÿ≥ÿ™ŸÇÿµÿßÿ¶Ÿä"
      },
      "styles": {
        "Cinematic": "ÿ≥ŸäŸÜŸÖÿßÿ¶Ÿä",
        "Film Noir": "ŸÅŸäŸÑŸÖ ŸÜŸàÿßÿ±",
        "Golden Hour": "ÿßŸÑÿ≥ÿßÿπÿ© ÿßŸÑÿ∞Ÿáÿ®Ÿäÿ©",
        "Moody": "ÿØÿ±ÿßŸÖŸä",
        "Dark Cinematic": "ÿ≥ŸäŸÜŸÖÿßÿ¶Ÿä ÿØÿßŸÉŸÜ",
        "Desaturated": "ÿ£ŸÑŸàÿßŸÜ ÿ®ÿßŸáÿ™ÿ©",
        "High Contrast": "ÿ™ÿ®ÿßŸäŸÜ ÿπÿßŸÑŸä",
        "Gothic": "ŸÇŸàÿ∑Ÿä",
        "Bright": "ŸÖÿ¥ÿ±ŸÇ",
        "Colorful": "ŸÖŸÑŸàŸëŸÜ",
        "Sitcom": "ŸÖÿ≥ŸÑÿ≥ŸÑ ŸÉŸàŸÖŸäÿØŸä",
        "Casual": "ÿπŸÅŸàŸä",
        "Cyberpunk": "ÿ≥ÿßŸäÿ®ÿ±ÿ®ÿßŸÜŸÉ",
        "Clean Futuristic": "ŸÖÿ≥ÿ™ŸÇÿ®ŸÑŸä ŸÜÿ∏ŸäŸÅ",
        "Neon Noir": "ŸÜŸäŸàŸÜ ŸÜŸàÿßÿ±",
        "Blade Runner": "ÿ®ŸÑŸäÿØ ÿ±ŸÜÿ±",
        "Epic Fantasy": "ŸÅÿßŸÜÿ™ÿßÿ≤Ÿäÿß ŸÖŸÑÿ≠ŸÖŸäÿ©",
        "Painterly": "ŸÑŸàÿ≠ÿ© ŸÅŸÜŸäÿ©",
        "Magical Realism": "ŸàÿßŸÇÿπŸäÿ© ÿ≥ÿ≠ÿ±Ÿäÿ©",
        "Lord of the Rings": "ÿ≥ŸäÿØ ÿßŸÑÿÆŸàÿßÿ™ŸÖ",
        "Clean Minimal": "ÿ®ÿ≥Ÿäÿ∑ ŸàŸÜÿ∏ŸäŸÅ",
        "Premium": "ŸÅÿßÿÆÿ±",
        "Tech Modern": "ÿ™ŸÇŸÜŸä ÿ≠ÿØŸäÿ´",
        "Lifestyle": "ŸÜŸÖÿ∑ ÿ≠Ÿäÿßÿ©",
        "Documentary": "Ÿàÿ´ÿßÿ¶ŸÇŸä",
        "Warm": "ÿØÿßŸÅÿ¶",
        "Authentic": "ÿ£ÿµŸäŸÑ",
        "Trendy": "ÿπÿµÿ±Ÿä",
        "Bold": "ÿ¨ÿ±Ÿäÿ°",
        "High Energy": "ÿ∑ÿßŸÇÿ© ÿπÿßŸÑŸäÿ©",
        "Aesthetic": "ÿ¨ŸÖÿßŸÑŸä",
        "Clean": "ŸÜÿ∏ŸäŸÅ",
        "Illustrated": "ŸÖÿ±ÿ≥ŸàŸÖ",
        "Infographic": "ÿ•ŸÜŸÅŸàÿ¨ÿ±ÿßŸÅŸäŸÉ",
        "Modern": "ÿ≠ÿØŸäÿ´",
        "Artistic": "ŸÅŸÜŸä",
        "Abstract": "ÿ™ÿ¨ÿ±ŸäÿØŸä",
        "Neon": "ŸÜŸäŸàŸÜ",
        "Dreamlike": "ÿ≠ÿßŸÑŸÖ",
        "Raw": "ÿÆÿßŸÖ",
        "Journalistic": "ÿµÿ≠ŸÅŸä"
      },
      "items": {
        "short-film-drama": {
          "name": "ŸÅŸäŸÑŸÖ ŸÇÿµŸäÿ± - ÿØÿ±ÿßŸÖÿß",
          "description": "ŸÅŸäŸÑŸÖ ÿØÿ±ÿßŸÖŸä ŸÇÿµŸäÿ± ŸÖÿØÿ™Ÿá Ÿ£-Ÿ• ÿØŸÇÿßÿ¶ŸÇ ŸÖÿπ ŸÇŸàÿ≥ ÿπÿßÿ∑ŸÅŸä Ÿàÿ™ÿ∑Ÿàÿ± ÿ¥ÿÆÿµŸäÿßÿ™ ŸàŸÖÿ¥ÿßŸáÿØ ÿ≥ŸäŸÜŸÖÿßÿ¶Ÿäÿ©.",
          "scene1_heading": "ÿØÿßÿÆŸÑŸä. ŸÖŸàŸÇÿπ - ŸÜŸáÿßÿ±",
          "scene1_action": "ŸÖÿ¥ŸáÿØ ÿßŸÅÿ™ÿ™ÿßÿ≠Ÿä ŸäŸèÿπÿ±ŸëŸÅ ÿ®ÿßŸÑÿ®ÿ∑ŸÑ ŸàÿπÿßŸÑŸÖŸá.",
          "scene2_heading": "ÿÆÿßÿ±ÿ¨Ÿä. ŸÖŸàŸÇÿπ - ŸÜŸáÿßÿ±",
          "scene2_action": "ÿßŸÑÿ≠ÿØÿ´ ÿßŸÑŸÖÿ≠ÿ±ŸÉ ÿßŸÑÿ∞Ÿä ŸäŸÇŸÑÿ® ÿ≠Ÿäÿßÿ© ÿßŸÑÿ®ÿ∑ŸÑ.",
          "scene3_heading": "ÿØÿßÿÆŸÑŸä. ŸÖŸàŸÇÿπ - ŸÑŸäŸÑ",
          "scene3_action": "ÿ™ÿµÿßÿπÿØ ÿßŸÑÿ™Ÿàÿ™ÿ± ŸàÿßŸÑŸÖŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿπÿßÿ∑ŸÅŸäÿ©.",
          "scene4_heading": "ÿÆÿßÿ±ÿ¨Ÿä. ŸÖŸàŸÇÿπ - ŸÜŸáÿßÿ±",
          "scene4_action": "ÿßŸÑÿ≠ŸÑ Ÿàÿ™ÿ≠ŸàŸÑ ÿßŸÑÿ¥ÿÆÿµŸäÿ©."
        },
        "horror-short": {
          "name": "ŸÅŸäŸÑŸÖ ÿ±ÿπÿ® ŸÇÿµŸäÿ±",
          "description": "ŸÅŸäŸÑŸÖ ÿ±ÿπÿ® ŸÖÿ¥ŸàŸÇ ŸÖÿØÿ™Ÿá Ÿ¢-Ÿ£ ÿØŸÇÿßÿ¶ŸÇ ŸÖÿπ ÿ™Ÿàÿ™ÿ± ÿ¨ŸàŸä ŸàŸÖŸÅÿßÿ¨ÿ¢ÿ™ ŸÖÿ±ÿπÿ®ÿ© ŸàÿµŸàÿ± ŸÖŸÇŸÑŸÇÿ©.",
          "scene1_heading": "ÿØÿßÿÆŸÑŸä. ŸÖŸàŸÇÿπ ŸÖÿ∏ŸÑŸÖ - ŸÑŸäŸÑ",
          "scene1_action": "ÿ™ÿ£ÿ≥Ÿäÿ≥ ÿ£ÿ¨Ÿàÿßÿ° ŸÖŸÇŸÑŸÇÿ©. ÿ¥Ÿäÿ° ŸÖÿß ŸÑŸäÿ≥ ÿπŸÑŸâ ŸÖÿß Ÿäÿ±ÿßŸÖ.",
          "scene2_heading": "ÿØÿßÿÆŸÑŸä. ŸÖŸàŸÇÿπ ŸÖÿ∏ŸÑŸÖ - ŸÑŸäŸÑ",
          "scene2_action": "ÿ®ÿØÿßŸäÿ© ÿßŸÑÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑÿ∫ÿ±Ÿäÿ®ÿ©. Ÿäÿ™ÿµÿßÿπÿØ ÿßŸÑÿ™Ÿàÿ™ÿ±.",
          "scene3_heading": "ÿØÿßÿÆŸÑŸä. ŸÖŸàŸÇÿπ ŸÖÿ∏ŸÑŸÖ - ŸÑŸäŸÑ",
          "scene3_action": "ŸäŸÉÿ¥ŸÅ ÿßŸÑÿ±ÿπÿ® ÿπŸÜ ŸÜŸÅÿ≥Ÿá. ÿ∞ÿ±Ÿàÿ© ÿßŸÑÿÆŸàŸÅ.",
          "scene4_heading": "ÿØÿßÿÆŸÑŸä/ÿÆÿßÿ±ÿ¨Ÿä. ŸÖŸàŸÇÿπ - ŸÑŸäŸÑ",
          "scene4_action": "ŸÜŸáÿßŸäÿ© ÿ∫ÿßŸÖÿ∂ÿ© ÿ™ÿ™ÿ±ŸÉ ÿßŸÑŸÖÿ¥ÿßŸáÿØ ŸÅŸä ÿ≠ÿßŸÑÿ© ŸÇŸÑŸÇ."
        },
        "comedy-sketch": {
          "name": "ÿßÿ≥ŸÉÿ™ÿ¥ ŸÉŸàŸÖŸäÿØŸä",
          "description": "ÿßÿ≥ŸÉÿ™ÿ¥ ŸÉŸàŸÖŸäÿØŸä ÿ≥ÿ±Ÿäÿπ ŸÖÿØÿ™Ÿá Ÿ°-Ÿ¢ ÿØŸÇŸäŸÇÿ© ŸÖÿπ ÿ™ŸÖŸáŸäÿØ Ÿàÿ™ÿµÿπŸäÿØ ŸàŸÜŸáÿßŸäÿ© ŸÖÿ∂ÿ≠ŸÉÿ©.",
          "scene1_heading": "ÿØÿßÿÆŸÑŸä. ŸÖŸàŸÇÿπ ŸäŸàŸÖŸä - ŸÜŸáÿßÿ±",
          "scene1_action": "ÿßŸÑÿ™ŸÖŸáŸäÿØ: ÿ™ÿ£ÿ≥Ÿäÿ≥ ÿßŸÑŸÖŸàŸÇŸÅ ÿßŸÑÿ∑ÿ®ŸäÿπŸä ŸàÿßŸÑÿ¥ÿÆÿµŸäÿßÿ™.",
          "scene2_heading": "ÿØÿßÿÆŸÑŸä. ŸÜŸÅÿ≥ ÿßŸÑŸÖŸàŸÇÿπ - ŸÜŸáÿßÿ±",
          "scene2_action": "ÿßŸÑÿ™ÿπŸÇŸäÿØ: Ÿäÿ≠ÿØÿ´ ÿ¥Ÿäÿ° ÿ≥ÿÆŸäŸÅ ÿ£Ÿà ŸäŸèŸÉÿ¥ŸÅ ÿπŸÜŸá.",
          "scene3_heading": "ÿØÿßÿÆŸÑŸä. ŸÜŸÅÿ≥ ÿßŸÑŸÖŸàŸÇÿπ - ŸÜŸáÿßÿ±",
          "scene3_action": "ÿßŸÑŸÜŸáÿßŸäÿ© ÿßŸÑŸÖÿ∂ÿ≠ŸÉÿ©: ÿßŸÑŸÇŸÅŸÑÿ© ÿßŸÑŸÉŸàŸÖŸäÿØŸäÿ©."
        },
        "sci-fi-concept": {
          "name": "ŸÖŸÅŸáŸàŸÖ ÿÆŸäÿßŸÑ ÿπŸÑŸÖŸä",
          "description": "ŸÅŸäŸÑŸÖ ÿÆŸäÿßŸÑ ÿπŸÑŸÖŸä ŸÖÿ∞ŸáŸÑ ÿ®ÿµÿ±ŸäÿßŸã ŸÖÿØÿ™Ÿá Ÿ¢-Ÿ§ ÿØŸÇÿßÿ¶ŸÇ Ÿäÿ≥ÿ™ŸÉÿ¥ŸÅ ŸÖŸàÿßÿ∂Ÿäÿπ ŸÖÿ≥ÿ™ŸÇÿ®ŸÑŸäÿ©.",
          "scene1_heading": "ÿÆÿßÿ±ÿ¨Ÿä. ŸÖÿØŸäŸÜÿ© ŸÖÿ≥ÿ™ŸÇÿ®ŸÑŸäÿ© - ŸÑŸäŸÑ",
          "scene1_action": "ÿ™ÿ£ÿ≥Ÿäÿ≥ ÿßŸÑÿπÿßŸÑŸÖ Ÿàÿ™ŸÇŸÜŸäÿßÿ™Ÿá ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ©.",
          "scene2_heading": "ÿØÿßÿÆŸÑŸä. ŸÖŸÜÿ¥ÿ£ÿ© ÿπÿßŸÑŸäÿ© ÿßŸÑÿ™ŸÇŸÜŸäÿ© - ŸÜŸáÿßÿ±",
          "scene2_action": "ÿ™ŸÇÿØŸäŸÖ ÿßŸÑŸÖŸÅŸáŸàŸÖ ÿßŸÑŸÖÿ±ŸÉÿ≤Ÿä ÿ£Ÿà ÿßŸÑÿµÿ±ÿßÿπ.",
          "scene3_heading": "ÿÆÿßÿ±ÿ¨Ÿä/ÿØÿßÿÆŸÑŸä. ŸÖÿ™ŸÜŸàÿπ - ŸÜŸáÿßÿ±/ŸÑŸäŸÑ",
          "scene3_action": "ÿ™ÿ™ŸÉÿ¥ŸÅ ÿ™ÿØÿßÿπŸäÿßÿ™ ÿßŸÑÿ™ŸÇŸÜŸäÿ©.",
          "scene4_heading": "ÿÆÿßÿ±ÿ¨Ÿä. ŸÖŸÜÿ∏ÿ± ŸÖÿ≥ÿ™ŸÇÿ®ŸÑŸä - ŸÅÿ¨ÿ±",
          "scene4_action": "ÿÆÿßÿ™ŸÖÿ© ŸÅŸÑÿ≥ŸÅŸäÿ© ÿπŸÜ ÿßŸÑÿ•ŸÜÿ≥ÿßŸÜŸäÿ© ŸàÿßŸÑÿ™ŸÇŸÜŸäÿ©."
        },
        "fantasy-adventure": {
          "name": "ŸÖÿ∫ÿßŸÖÿ±ÿ© ŸÅÿßŸÜÿ™ÿßÿ≤Ÿäÿß",
          "description": "ÿ±ÿ≠ŸÑÿ© ŸÅÿßŸÜÿ™ÿßÿ≤Ÿäÿß ŸÖŸÑÿ≠ŸÖŸäÿ© ŸÖÿØÿ™Ÿáÿß Ÿ£-Ÿ• ÿØŸÇÿßÿ¶ŸÇ ŸÖÿπ ÿπŸÜÿßÿµÿ± ÿ≥ÿ≠ÿ±Ÿäÿ© ŸàŸÑÿ≠ÿ∏ÿßÿ™ ÿ®ÿ∑ŸàŸÑŸäÿ©.",
          "scene1_heading": "ÿÆÿßÿ±ÿ¨Ÿä. ÿπÿßŸÑŸÖ ÿ≥ÿ≠ÿ±Ÿä - ŸÜŸáÿßÿ±",
          "scene1_action": "ÿ™ÿ£ÿ≥Ÿäÿ≥ ÿßŸÑÿπÿßŸÑŸÖ ÿßŸÑÿ≥ÿ≠ÿ±Ÿä Ÿàÿ¨ŸÖÿßŸÑŸá.",
          "scene2_heading": "ÿØÿßÿÆŸÑŸä. ÿ®ŸÜÿßÿ° ŸÇÿØŸäŸÖ - ŸÜŸáÿßÿ±",
          "scene2_action": "ÿßŸÑÿ®ÿ∑ŸÑ Ÿäÿ™ŸÑŸÇŸâ ŸÖŸáŸÖÿ™Ÿá ÿ£Ÿà ŸÜÿØÿßÿ°Ÿá.",
          "scene3_heading": "ÿÆÿßÿ±ÿ¨Ÿä. ÿ£ÿ±ÿ∂ ŸÖÿ≠ŸÅŸàŸÅÿ© ÿ®ÿßŸÑŸÖÿÆÿßÿ∑ÿ± - ŸÜŸáÿßÿ±",
          "scene3_action": "ÿßŸÑÿ®ÿ∑ŸÑ ŸäŸàÿßÿ¨Ÿá ÿßŸÑÿ™ÿ≠ÿØŸäÿßÿ™ ŸàŸäŸèÿ∏Ÿáÿ± ÿ¥ÿ¨ÿßÿπÿ™Ÿá.",
          "scene4_heading": "ÿÆÿßÿ±ÿ¨Ÿä. ŸÖŸàŸÇÿπ ÿßŸÑÿßŸÜÿ™ÿµÿßÿ± - ÿ∫ÿ±Ÿàÿ®",
          "scene4_action": "ÿßŸÑŸÜÿµÿ± Ÿàÿ™ÿ≠ŸàŸÑ ÿßŸÑÿ®ÿ∑ŸÑ."
        },
        "product-showcase": {
          "name": "ÿπÿ±ÿ∂ ŸÖŸÜÿ™ÿ¨",
          "description": "ŸÅŸäÿØŸäŸà ŸÖŸÜÿ™ÿ¨ ÿ£ŸÜŸäŸÇ ŸÖÿØÿ™Ÿá Ÿ£Ÿ†-Ÿ¶Ÿ† ÿ´ÿßŸÜŸäÿ© Ÿäÿ≥ŸÑÿ∑ ÿßŸÑÿ∂Ÿàÿ° ÿπŸÑŸâ ÿßŸÑŸÖŸÖŸäÿ≤ÿßÿ™ ŸàÿßŸÑŸÅŸàÿßÿ¶ÿØ.",
          "scene1_heading": "ŸÉÿ¥ŸÅ ÿßŸÑŸÖŸÜÿ™ÿ¨",
          "scene1_action": "ŸÉÿ¥ŸÅ ÿØÿ±ÿßŸÖŸä ŸÑŸÑŸÖŸÜÿ™ÿ¨ ŸÖŸÜ ÿßŸÑÿ∏ŸÑÿßŸÖ ÿ•ŸÑŸâ ÿßŸÑŸÜŸàÿ±.",
          "scene2_heading": "ÿ£ÿ®ÿ±ÿ≤ ÿßŸÑŸÖŸÖŸäÿ≤ÿßÿ™",
          "scene2_action": "ÿπÿ±ÿ∂ ÿßŸÑŸÖŸÖŸäÿ≤ÿßÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ÿ®ÿ≠ÿ±ŸÉÿßÿ™ ŸÉÿßŸÖŸäÿ±ÿß ÿØŸäŸÜÿßŸÖŸäŸÉŸäÿ©.",
          "scene3_heading": "ŸÇŸäÿØ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ",
          "scene3_action": "ÿßŸÑŸÖŸÜÿ™ÿ¨ ŸÅŸä ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸàÿßŸÇÿπŸä ŸÑÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑŸÅŸàÿßÿ¶ÿØ.",
          "scene4_heading": "ÿØÿπŸàÿ© ŸÑŸÑÿπŸÖŸÑ",
          "scene4_action": "ŸÑŸÇÿ∑ÿ© ŸÜŸáÿßÿ¶Ÿäÿ© ŸÑŸÑŸÖŸÜÿ™ÿ¨ ŸÖÿπ ÿßŸÑÿπŸÑÿßŸÖÿ© ÿßŸÑÿ™ÿ¨ÿßÿ±Ÿäÿ©."
        },
        "brand-story": {
          "name": "ŸÇÿµÿ© ÿßŸÑÿπŸÑÿßŸÖÿ© ÿßŸÑÿ™ÿ¨ÿßÿ±Ÿäÿ©",
          "description": "ŸÅŸäÿØŸäŸà ÿπŸÑÿßŸÖÿ© ÿ™ÿ¨ÿßÿ±Ÿäÿ© ÿπÿßÿ∑ŸÅŸä ŸÖÿØÿ™Ÿá Ÿ°-Ÿ¢ ÿØŸÇŸäŸÇÿ© Ÿäÿ™ŸàÿßÿµŸÑ ŸÖÿπ ŸÇŸäŸÖ ÿßŸÑÿ¨ŸÖŸáŸàÿ±.",
          "scene1_heading": "ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©",
          "scene1_action": "ÿπÿ±ÿ∂ ÿßŸÑÿ™ÿ≠ÿØŸä ÿ£Ÿà ÿßŸÑÿ≠ÿßÿ¨ÿ© ÿßŸÑÿ™Ÿä ŸäŸàÿßÿ¨ŸáŸáÿß ÿßŸÑÿ¨ŸÖŸáŸàÿ±.",
          "scene2_heading": "ÿßŸÑÿ±ÿ≠ŸÑÿ©",
          "scene2_action": "ŸÇÿµÿ© ÿßŸÑÿπŸÑÿßŸÖÿ© ÿßŸÑÿ™ÿ¨ÿßÿ±Ÿäÿ© Ÿàÿ¥ÿ∫ŸÅŸáÿß ŸÅŸä ÿ≠ŸÑ ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©.",
          "scene3_heading": "ÿßŸÑÿ≠ŸÑ",
          "scene3_action": "ŸÉŸäŸÅ ÿ™ŸÇÿØŸÖ ÿßŸÑÿπŸÑÿßŸÖÿ© ÿßŸÑÿ™ÿ¨ÿßÿ±Ÿäÿ© ÿßŸÑŸÇŸäŸÖÿ© Ÿàÿ™ÿ∫Ÿäÿ± ÿßŸÑÿ≠Ÿäÿßÿ©.",
          "scene4_heading": "ÿßŸÑÿ±ÿ§Ÿäÿ©",
          "scene4_action": "ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑ ÿßŸÑÿ∞Ÿä ÿ™ÿ®ŸÜŸäŸá ÿßŸÑÿπŸÑÿßŸÖÿ© ÿßŸÑÿ™ÿ¨ÿßÿ±Ÿäÿ© ŸÖÿπ ÿπŸÖŸÑÿßÿ¶Ÿáÿß."
        },
        "tiktok-reel": {
          "name": "ŸÅŸäÿØŸäŸà ÿ™ŸäŸÉ ÿ™ŸàŸÉ/ÿ±ŸäŸÑÿ≤",
          "description": "ŸÅŸäÿØŸäŸà ÿπŸÖŸàÿØŸä ÿ≥ÿ±Ÿäÿπ ŸÖÿØÿ™Ÿá Ÿ°Ÿ•-Ÿ¶Ÿ† ÿ´ÿßŸÜŸäÿ© ŸÖÿ≠ÿ≥ŸëŸÜ ŸÑŸÑÿ™ŸÅÿßÿπŸÑ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπŸä.",
          "scene1_heading": "ÿßŸÑÿ¨ÿ∞ÿ®",
          "scene1_action": "ÿ¨ÿ∞ÿ® ÿßŸÑÿßŸÜÿ™ÿ®ÿßŸá ŸÅŸä ÿ£ŸàŸÑ Ÿ£ ÿ´ŸàÿßŸÜŸç.",
          "scene2_heading": "ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ",
          "scene2_action": "ÿ™ŸÇÿØŸäŸÖ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ÿ£Ÿà ÿßŸÑÿ™ÿ±ŸÅŸäŸá.",
          "scene3_heading": "ÿßŸÑŸÖŸÉÿßŸÅÿ£ÿ©",
          "scene3_action": "ŸÜŸáÿßŸäÿ© ŸÖŸèÿ±ÿ∂Ÿäÿ© ÿ™ÿ¥ÿ¨ÿπ ÿπŸÑŸâ ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉÿ©."
        },
        "explainer-video": {
          "name": "ŸÅŸäÿØŸäŸà ÿ™Ÿàÿ∂Ÿäÿ≠Ÿä",
          "description": "ŸÅŸäÿØŸäŸà ÿ™ÿπŸÑŸäŸÖŸä Ÿàÿßÿ∂ÿ≠ ŸÖÿØÿ™Ÿá Ÿ¢-Ÿ£ ÿØŸÇÿßÿ¶ŸÇ Ÿäÿ¥ÿ±ÿ≠ ÿßŸÑŸÖŸàÿßÿ∂Ÿäÿπ ÿßŸÑŸÖÿπŸÇÿØÿ©.",
          "scene1_heading": "ÿßŸÑŸÖŸÇÿØŸÖÿ©",
          "scene1_action": "ÿ™ŸÇÿØŸäŸÖ ÿßŸÑŸÖŸàÿ∂Ÿàÿπ Ÿàÿ£ŸáŸÖŸäÿ™Ÿá.",
          "scene2_heading": "ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©",
          "scene2_action": "ÿ¥ÿ±ÿ≠ ÿßŸÑÿ™ÿ≠ÿØŸä ÿ£Ÿà ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑŸÖÿ∑ÿ±Ÿàÿ≠.",
          "scene3_heading": "ÿßŸÑÿ¥ÿ±ÿ≠",
          "scene3_action": "ÿ™ŸÅŸÉŸäŸÉ ÿßŸÑŸÖŸÅŸáŸàŸÖ ÿÆÿ∑Ÿàÿ© ÿ®ÿÆÿ∑Ÿàÿ©.",
          "scene4_heading": "ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©",
          "scene4_action": "ÿ™ŸÑÿÆŸäÿµ ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ŸàÿßŸÑÿÆÿ∑Ÿàÿßÿ™ ÿßŸÑÿ™ÿßŸÑŸäÿ©."
        },
        "music-video-concept": {
          "name": "ŸÖŸÅŸáŸàŸÖ ŸÅŸäÿØŸäŸà ŸÖŸàÿ≥ŸäŸÇŸä",
          "description": "ÿ≥ÿ±ÿØ ÿ®ÿµÿ±Ÿä ŸÅŸÜŸä ŸÖÿØÿ™Ÿá Ÿ£-Ÿ§ ÿØŸÇÿßÿ¶ŸÇ ŸÖÿµŸÖŸÖ ŸÑŸÖÿ±ÿßŸÅŸÇÿ© ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ.",
          "scene1_heading": "ÿßŸÑŸÖŸÇÿØŸÖÿ©/ÿßŸÑŸÖŸÇÿ∑ÿπ ÿßŸÑÿ£ŸàŸÑ",
          "scene1_action": "ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖÿ≤ÿßÿ¨ Ÿàÿ™ŸÇÿØŸäŸÖ ÿßŸÑŸÖŸàÿßÿ∂Ÿäÿπ ÿßŸÑÿ®ÿµÿ±Ÿäÿ©.",
          "scene2_heading": "ÿßŸÑŸÑÿßÿ≤ŸÖÿ© ÿßŸÑÿ£ŸàŸÑŸâ",
          "scene2_action": "ÿßŸÜŸÅÿ¨ÿßÿ± ÿ®ÿµÿ±Ÿä Ÿäÿ∑ÿßÿ®ŸÇ ÿßŸÑÿ∞ÿ±Ÿàÿ© ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸäÿ©.",
          "scene3_heading": "ÿßŸÑŸÖŸÇÿ∑ÿπ ÿßŸÑÿ´ÿßŸÜŸä/ÿßŸÑÿ¨ÿ≥ÿ±",
          "scene3_action": "ÿ™ÿ∑ŸàŸäÿ± ÿßŸÑÿ≥ÿ±ÿØ ÿßŸÑÿ®ÿµÿ±Ÿä ŸàÿßŸÑŸÖŸàÿßÿ∂Ÿäÿπ.",
          "scene4_heading": "ÿßŸÑŸÑÿßÿ≤ŸÖÿ© ÿßŸÑÿ£ÿÆŸäÿ±ÿ©/ÿßŸÑÿÆÿßÿ™ŸÖÿ©",
          "scene4_action": "ÿ∞ÿ±Ÿàÿ© ÿ®ÿµÿ±Ÿäÿ© ŸàÿÆÿßÿ™ŸÖÿ© ŸÖŸèÿ±ÿ∂Ÿäÿ©."
        },
        "documentary-mini": {
          "name": "ŸÅŸäŸÑŸÖ Ÿàÿ´ÿßÿ¶ŸÇŸä ŸÇÿµŸäÿ±",
          "description": "ŸÅŸäŸÑŸÖ Ÿàÿ´ÿßÿ¶ŸÇŸä ŸÖÿ™ÿ£ŸÜŸç ŸÖÿØÿ™Ÿá Ÿ£-Ÿ• ÿØŸÇÿßÿ¶ŸÇ Ÿäÿ≥ÿ™ŸÉÿ¥ŸÅ ŸÖŸàÿ∂ŸàÿπÿßŸã ÿ®ÿπŸÖŸÇ.",
          "scene1_heading": "ÿßŸÑÿßŸÅÿ™ÿ™ÿßÿ≠Ÿäÿ© ÿßŸÑÿ®ÿßÿ±ÿØÿ©",
          "scene1_action": "ÿ¨ÿ∞ÿ® ÿßŸÑŸÖÿ¥ÿßŸáÿØ ÿ®ŸÑŸÇÿ∑ÿßÿ™ ÿ£Ÿà ÿ™ÿµÿ±Ÿäÿ≠ ŸÖÿ´Ÿäÿ± ŸÑŸÑÿßŸáÿ™ŸÖÿßŸÖ.",
          "scene2_heading": "ÿßŸÑÿ≥ŸäÿßŸÇ",
          "scene2_action": "ÿ™ŸÇÿØŸäŸÖ ÿßŸÑÿÆŸÑŸÅŸäÿ© ŸàÿßŸÑÿ≥ŸäÿßŸÇ ŸÑŸÑŸÖŸàÿ∂Ÿàÿπ.",
          "scene3_heading": "ÿßŸÑÿ™ÿπŸÖŸÇ",
          "scene3_action": "ÿßÿ≥ÿ™ŸÉÿ¥ÿßŸÅ ÿßŸÑŸÖŸàÿ∂Ÿàÿπ ŸÖŸÜ ÿ≤ŸàÿßŸäÿß ŸÖÿ™ÿπÿØÿØÿ©.",
          "scene4_heading": "ÿßŸÑÿÆÿßÿ™ŸÖÿ©",
          "scene4_action": "ÿ™ÿ±ŸÉ ÿßŸÑŸÖÿ¥ÿßŸáÿØ ŸÖÿπ ÿ¥Ÿäÿ° ŸÑŸÑÿ™ŸÅŸÉŸäÿ± ŸÅŸäŸá."
        }
      }
    },
    "breakdown_progress": {
      "developing": "ÿ¨ÿßÿ±Ÿç ÿßŸÑÿ™ÿ∑ŸàŸäÿ±...",
      "craftedFrameByFrame": "Ÿäÿ™ŸÖ ÿµŸäÿßÿ∫ÿ© ŸÇÿµÿ™ŸÉ ÿ•ÿ∑ÿßÿ±ÿßŸã ÿ®ÿ•ÿ∑ÿßÿ±",
      "readingIdea": "ŸÇÿ±ÿßÿ°ÿ© ŸÅŸÉÿ±ÿ© ÿßŸÑŸÇÿµÿ©",
      "aligningGenre": "ÿßŸÑŸÖŸàÿßÿ°ŸÖÿ© ŸÖÿπ ÿßŸÑŸÜŸàÿπ",
      "aligningWith": "ÿßŸÑŸÖŸàÿßÿ°ŸÖÿ© ŸÖÿπ {{genre}}",
      "identifyingCharacters": "ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ¥ÿÆÿµŸäÿßÿ™",
      "creatingBreakdown": "ÿ•ŸÜÿ¥ÿßÿ° ÿ™ŸÇÿ≥ŸäŸÖ ÿßŸÑŸÖÿ¥ÿßŸáÿØ",
      "processing": "ÿ¨ÿßÿ±Ÿç ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©"
    },
    "storyboard_progress": {
      "developingVision": "ÿ¨ÿßÿ±Ÿç ÿ™ÿ∑ŸàŸäÿ± ÿ±ÿ§Ÿäÿ™ŸÉ",
      "renderedFrameByFrame": "Ÿäÿ™ŸÖ ÿπÿ±ÿ∂ ŸÑŸàÿ≠ÿ© ÿßŸÑŸÇÿµÿ© ÿ•ÿ∑ÿßÿ±ÿßŸã ÿ®ÿ•ÿ∑ÿßÿ±...",
      "generatingShotList": "ÿ•ŸÜÿ¥ÿßÿ° ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÑŸÇÿ∑ÿßÿ™",
      "breakingScenes": "ÿ™ŸÇÿ≥ŸäŸÖ ÿßŸÑŸÖÿ¥ÿßŸáÿØ ÿ•ŸÑŸâ ŸÑŸÇÿ∑ÿßÿ™",
      "preparingCast": "ÿ™ÿ¨ŸáŸäÿ≤ ŸÅÿ±ŸäŸÇ ÿßŸÑÿ™ŸÖÿ´ŸäŸÑ",
      "loadingProfiles": "ÿ™ÿ≠ŸÖŸäŸÑ ŸÖŸÑŸÅÿßÿ™ ÿßŸÑÿ¥ÿÆÿµŸäÿßÿ™",
      "renderingStoryboard": "ÿπÿ±ÿ∂ ŸÑŸàÿ≠ÿ© ÿßŸÑŸÇÿµÿ©",
      "creatingFrames": "ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ•ÿ∑ÿßÿ±ÿßÿ™ ÿßŸÑÿ®ÿµÿ±Ÿäÿ©",
      "visualMasterpiece": "ÿ™ÿ≠ŸÅÿ™ŸÉ ÿßŸÑÿ®ÿµÿ±Ÿäÿ© ÿ™ÿ™ÿ¥ŸÉŸÑ..."
    },
    "lock_dialog": {
      "lockTheScript": "ŸÇŸÅŸÑ ÿßŸÑÿ≥ŸäŸÜÿßÿ±ŸäŸà",
      "scriptFinalized": "ÿ≥Ÿäÿ™ŸÖ ÿßÿπÿ™ŸÖÿßÿØ ÿßŸÑÿ≥ŸäŸÜÿßÿ±ŸäŸà Ÿàÿ®ÿØÿ° ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨...",
      "productionEstimate": "ÿ™ŸÇÿØŸäÿ± ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨",
      "estimatedShots": "ÿßŸÑŸÑŸÇÿ∑ÿßÿ™ ÿßŸÑŸÖŸÇÿØŸëÿ±ÿ©",
      "totalBudget": "ÿßŸÑŸÖŸäÿ≤ÿßŸÜŸäÿ© ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸäÿ©",
      "shotBreakdownInfo": "ÿ≥Ÿäÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑŸÑŸÇÿ∑ÿßÿ™ Ÿàÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑÿπŸÜÿßÿµÿ± ÿßŸÑÿ®ÿµÿ±Ÿäÿ© ŸÑŸÑÿ•ŸÜÿ™ÿßÿ¨. ŸÇÿØ ÿ™ÿÆÿ™ŸÑŸÅ ÿßŸÑÿ™ŸÉÿßŸÑŸäŸÅ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© ÿ≠ÿ≥ÿ® ÿ™ÿπŸÇŸäÿØ ÿßŸÑŸÑŸÇÿ∑ÿßÿ™.",
      "backToEdit": "ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ™ÿπÿØŸäŸÑ",
      "lockAndBegin": "ŸÇŸÅŸÑ Ÿàÿ®ÿØÿ°"
    },
    "export_panel": {
      "exportOptions": "ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿ™ÿµÿØŸäÿ±",
      "videoFormats": "ÿµŸäÿ∫ ÿßŸÑŸÅŸäÿØŸäŸà",
      "subtitles": "ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿßÿ™",
      "project": "ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ",
      "mp4Video": "ŸÅŸäÿØŸäŸà MP4",
      "mp4Desc": "ÿµŸäÿ∫ÿ© ŸÅŸäÿØŸäŸà ŸÇŸäÿßÿ≥Ÿäÿ© ŸÑÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿ¨Ÿáÿ≤ÿ©",
      "webmVideo": "ŸÅŸäÿØŸäŸà WebM",
      "webmDesc": "ÿµŸäÿ∫ÿ© ŸÖÿ≠ÿ≥ŸëŸÜÿ© ŸÑŸÑŸàŸäÿ®",
      "srtSubtitles": "ÿ™ÿ±ÿ¨ŸÖÿßÿ™ SRT",
      "srtDesc": "ÿµŸäÿ∫ÿ© ÿ™ÿ±ÿ¨ŸÖÿ© ŸÇŸäÿßÿ≥Ÿäÿ©",
      "webvttSubtitles": "ÿ™ÿ±ÿ¨ŸÖÿßÿ™ WebVTT",
      "webvttDesc": "ÿ™ÿ±ÿ¨ŸÖÿßÿ™ HTML5 ÿßŸÑÿ£ÿµŸÑŸäÿ©",
      "projectFile": "ŸÖŸÑŸÅ ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ",
      "projectFileDesc": "ŸÜÿ≥ÿÆÿ© ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ© ŸÉÿßŸÖŸÑÿ© (.json)",
      "generateVideoFirst": "ÿ£ŸÜÿ¥ÿ¶ ÿßŸÑŸÅŸäÿØŸäŸà ÿ£ŸàŸÑÿßŸã",
      "generateShotsFirst": "ÿ£ŸÜÿ¥ÿ¶ ÿßŸÑŸÑŸÇÿ∑ÿßÿ™ ÿ£ŸàŸÑÿßŸã",
      "importProject": "ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ŸÖÿ¥ÿ±Ÿàÿπ",
      "importProjectDesc": "ÿßÿÆÿ™ÿ± ŸÖŸÑŸÅ ŸÖÿ¥ÿ±Ÿàÿπ (.json) ŸÑŸÑÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ. ÿ≥Ÿäÿ≠ŸÑ ŸÖÿ≠ŸÑ ŸÖÿ¥ÿ±ŸàÿπŸÉ ÿßŸÑÿ≠ÿßŸÑŸä.",
      "clickToSelect": "ÿßŸÜŸÇÿ± ŸÑÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÑŸÅ",
      "orDragDrop": "ÿ£Ÿà ÿßÿ≥ÿ≠ÿ® Ÿàÿ£ŸÅŸÑÿ™"
    }
  },
  "projects": {
    "title": "ŸÖÿ¥ÿßÿ±ŸäÿπŸä",
    "loading": "ÿ¨ÿßÿ±Ÿç ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ...",
    "loadError": "ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ",
    "createError": "ŸÅÿ¥ŸÑ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ",
    "create": "ÿ•ŸÜÿ¥ÿßÿ° ÿ¨ÿØŸäÿØ",
    "createVideo": "ŸÖÿ¥ÿ±Ÿàÿπ ŸÅŸäÿØŸäŸà",
    "createStory": "ŸÖÿ¥ÿ±Ÿàÿπ ŸÇÿµÿ©",
    "createVisualizer": "ŸÖÿ¥ÿ±Ÿàÿπ ŸÖŸèÿµŸàŸêŸëÿ±",
    "favorites": "ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©",
    "recent": "ÿßŸÑÿ£ÿÆŸäÿ±ÿ©",
    "allProjects": "ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ",
    "search": "ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ...",
    "empty": "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖÿ¥ÿßÿ±Ÿäÿπ ÿ®ÿπÿØ",
    "emptyHint": "ÿ£ŸÜÿ¥ÿ¶ ŸÖÿ¥ÿ±ŸàÿπŸÉ ÿßŸÑÿ£ŸàŸÑ ŸÑŸÑÿ®ÿØÿ°",
    "noResults": "ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿ¥ÿßÿ±Ÿäÿπ",
    "tryDifferentSearch": "ÿ¨ÿ±ÿ® ÿ®ÿ≠ÿ´ÿßŸã ÿ£Ÿà ŸÅŸÑÿ™ÿ±ÿßŸã ŸÖÿÆÿ™ŸÑŸÅÿßŸã",
    "open": "ŸÅÿ™ÿ≠",
    "export": "ÿ™ÿµÿØŸäÿ±",
    "delete": "ÿ≠ÿ∞ŸÅ",
    "favorite": "ÿ•ÿ∂ÿßŸÅÿ© ŸÑŸÑŸÖŸÅÿ∂ŸÑÿ©",
    "unfavorite": "ÿ•ÿ≤ÿßŸÑÿ© ŸÖŸÜ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©",
    "confirmDelete": "ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≠ÿ∞ŸÅ Ÿáÿ∞ÿß ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπÿü ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿ™ÿ±ÿßÿ¨ÿπ ÿπŸÜ Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°."
  }
}
</file>

<file path="i18n/locales/en.json">
{
  "nav": {
    "home": "Home",
    "studio": "Studio",
    "visualizer": "Visualizer",
    "back": "Back",
    "settings": "Settings",
    "projects": "Projects",
    "quickCreate": "Quick Create",
    "gradientGenerator": "Gradient Generator",
    "help": "Help"
  },
  "home": {
    "title": "LyricLens",
    "subtitle": "AI-Powered Video Production",
    "createVideo": "Create Video",
    "createVideoDesc": "Generate stunning videos from text or topics",
    "createMusic": "Generate Music",
    "createMusicDesc": "Create AI-powered music tracks",
    "visualizer": "Visualizer",
    "visualizerDesc": "Create lyric videos from audio files",
    "recentProjects": "Recent Projects",
    "noProjects": "No recent projects",
    "features": {
      "video": ["AI Narration", "Visual Generation", "Background Music"],
      "music": ["Full Songs", "Instrumentals", "Custom Lyrics"],
      "visualizer": ["Lyric Sync", "Visual Effects", "Custom Timing"]
    }
  },
  "studio": {
    "title": "Studio",
    "placeholder": "Describe what you want to create...",
    "send": "Send",
    "export": "Export",
    "edit": "Edit",
    "timeline": "Timeline",
    "quality": "Quality",
    "newProject": "New Project",
    "simpleMode": "Simple",
    "advancedMode": "Advanced",
    "scenes": "Scenes",
    "preview": "Preview",
    "generating": "Generating...",
    "processing": "Processing..."
  },
  "visualizer": {
    "title": "Visualizer",
    "uploadAudio": "Upload Audio",
    "uploadSubtitles": "Upload Subtitles",
    "dropAudio": "Drop audio file here or click to browse",
    "dropSubtitles": "Drop SRT file here or click to browse",
    "generate": "Generate Video"
  },
  "common": {
    "loading": "Loading...",
    "error": "Error",
    "retry": "Retry",
    "cancel": "Cancel",
    "save": "Save",
    "delete": "Delete",
    "confirm": "Confirm",
    "close": "Close",
    "yes": "Yes",
    "no": "No",
    "ok": "OK",
    "download": "Download",
    "upload": "Upload",
    "search": "Search",
    "clear": "Clear",
    "reset": "Reset",
    "apply": "Apply",
    "done": "Done",
    "next": "Next",
    "previous": "Previous",
    "comingSoon": "Coming Soon",
    "unsavedChanges": "Unsaved Changes",
    "unsavedChangesMessage": "You have unsaved changes. Are you sure you want to leave? Your changes will be lost.",
    "stay": "Stay",
    "leaveAnyway": "Leave Anyway",
    "items_one": "{{count}} item",
    "items_other": "{{count}} items",
    "somethingWentWrong": "Something went wrong",
    "import": "Import",
    "all": "All"
  },
  "a11y": {
    "languageSwitch": "Switch language",
    "mainNav": "Main navigation",
    "skipToContent": "Skip to main content",
    "currentLanguage": "Current language: {{language}}",
    "openMenu": "Open menu",
    "closeMenu": "Close menu"
  },
  "errors": {
    "generic": "Something went wrong. Please try again.",
    "network": "Network error. Please check your connection.",
    "notFound": "Page not found",
    "unauthorized": "You are not authorized to view this page"
  },
  "story": {
    "charactersEmpty": "Characters haven't been extracted yet.",
    "continuity": "Continuity",
    "visualDescription": "Visual Description",
    "issuesFound": "Issues Found",
    "suggestions": "Suggestions",
    "verifyContinuity": "Verify Continuity",
    "verifying": "Verifying continuity...",
    "storyIdea": "Story Idea",
    "whatsYourStory": "What's your story?",
    "describeYourConcept": "Describe your concept and we'll shape it into scenes, characters, and a visual storyboard.",
    "placeholderStory": "A detective discovers that the murder they're investigating was committed by their own future self...",
    "tryTemplate": "Try a template",
    "browseAll": "Browse all",
    "genre": "Genre",
    "allCount": "All {{count}}",
    "buildingStory": "Building your story...",
    "beginStory": "Begin Story",
    "breakdown": "Breakdown",
    "storyboard": "Storyboard",
    "sceneBreakdown": "Scene Breakdown",
    "script": "Script",
    "cast": "Cast",
    "shotList": "Shot List",
    "visualStyle": "Visual Style",
    "narration": "Narration",
    "animation": "Animation",
    "export": "Export",
    "shotBreakdown": "Shot Breakdown",
    "locked": "LOCKED",
    "generateShots": "Generate Shots",
    "noShotsGenerated": "No shots generated",
    "generateNarration": "Generate Narration",
    "regenerateNarration": "Regenerate Narration",
    "narrationDescription": "Generate AI voiceover for each scene using Gemini TTS.",
    "noNarrationYet": "No narration generated yet",
    "clickGenerateNarration": "Click \"Generate Narration\" to create voiceover",
    "regenerateAll": "Regenerate All",
    "animateAllShots": "Animate All Shots",
    "animationDescription": "Convert storyboard images to animated video clips using DeAPI or Veo.",
    "animated": "Animated",
    "noShotsToAnimate": "No shots to animate",
    "generateStoryboardFirst": "Generate storyboard visuals first",
    "exportVideo": "Export Video",
    "scenes": "Scenes",
    "shots": "Shots",
    "duration": "Duration",
    "renderingVideo": "Rendering Video...",
    "downloadVideo": "Download Video",
    "generateNarrationBeforeExport": "Generate narration before exporting",
    "createScript": "Create Script",
    "continueToCast": "Continue to Cast",
    "lockScript": "Lock Script",
    "createShotList": "Create Shot List",
    "selectStyle": "Select Style",
    "generateStoryboard": "Generate Storyboard",
    "addNarration": "Add Narration",
    "animateShots": "Animate Shots",
    "genres": {
      "Drama": "Drama",
      "Comedy": "Comedy",
      "Thriller": "Thriller",
      "Sci-Fi": "Sci-Fi",
      "Mystery": "Mystery",
      "Action": "Action",
      "Horror": "Horror",
      "Fantasy": "Fantasy",
      "Romance": "Romance",
      "Historical": "Historical",
      "Documentary": "Doc",
      "Animation": "Animation"
    },
    "templates": {
      "title": "Templates",
      "searchPlaceholder": "Search templates...",
      "noTemplatesFound": "No templates found",
      "clearSearch": "Clear search",
      "scenes": "Scenes",
      "visualStyles": "Visual Styles",
      "useTemplate": "Use Template",
      "duration": "Duration",
      "style": "Style",
      "ratio": "Ratio",
      "difficulty": {
        "beginner": "Beginner",
        "intermediate": "Intermediate",
        "advanced": "Advanced"
      },
      "categories": {
        "narrative": "Narrative",
        "commercial": "Commercial",
        "educational": "Educational",
        "social": "Social Media",
        "experimental": "Experimental"
      },
      "genres": {
        "Drama": "Drama",
        "Horror": "Horror",
        "Comedy": "Comedy",
        "Science Fiction": "Science Fiction",
        "Fantasy": "Fantasy",
        "Commercial": "Commercial",
        "Social": "Social",
        "Educational": "Educational",
        "Music Video": "Music Video",
        "Documentary": "Documentary"
      },
      "tags": {
        "drama": "drama",
        "emotional": "emotional",
        "character-driven": "character-driven",
        "cinematic": "cinematic",
        "horror": "horror",
        "suspense": "suspense",
        "atmospheric": "atmospheric",
        "thriller": "thriller",
        "comedy": "comedy",
        "humor": "humor",
        "sketch": "sketch",
        "funny": "funny",
        "sci-fi": "sci-fi",
        "futuristic": "futuristic",
        "technology": "technology",
        "visionary": "visionary",
        "fantasy": "fantasy",
        "adventure": "adventure",
        "magic": "magic",
        "epic": "epic",
        "product": "product",
        "commercial": "commercial",
        "marketing": "marketing",
        "showcase": "showcase",
        "brand": "brand",
        "story": "story",
        "values": "values",
        "tiktok": "tiktok",
        "reels": "reels",
        "social": "social",
        "viral": "viral",
        "short-form": "short-form",
        "educational": "educational",
        "explainer": "explainer",
        "tutorial": "tutorial",
        "informative": "informative",
        "music": "music",
        "artistic": "artistic",
        "visual": "visual",
        "experimental": "experimental",
        "documentary": "documentary",
        "real": "real",
        "interview": "interview",
        "investigative": "investigative"
      },
      "styles": {
        "Cinematic": "Cinematic",
        "Film Noir": "Film Noir",
        "Golden Hour": "Golden Hour",
        "Moody": "Moody",
        "Dark Cinematic": "Dark Cinematic",
        "Desaturated": "Desaturated",
        "High Contrast": "High Contrast",
        "Gothic": "Gothic",
        "Bright": "Bright",
        "Colorful": "Colorful",
        "Sitcom": "Sitcom",
        "Casual": "Casual",
        "Cyberpunk": "Cyberpunk",
        "Clean Futuristic": "Clean Futuristic",
        "Neon Noir": "Neon Noir",
        "Blade Runner": "Blade Runner",
        "Epic Fantasy": "Epic Fantasy",
        "Painterly": "Painterly",
        "Magical Realism": "Magical Realism",
        "Lord of the Rings": "Lord of the Rings",
        "Clean Minimal": "Clean Minimal",
        "Premium": "Premium",
        "Tech Modern": "Tech Modern",
        "Lifestyle": "Lifestyle",
        "Documentary": "Documentary",
        "Warm": "Warm",
        "Authentic": "Authentic",
        "Trendy": "Trendy",
        "Bold": "Bold",
        "High Energy": "High Energy",
        "Aesthetic": "Aesthetic",
        "Clean": "Clean",
        "Illustrated": "Illustrated",
        "Infographic": "Infographic",
        "Modern": "Modern",
        "Artistic": "Artistic",
        "Abstract": "Abstract",
        "Neon": "Neon",
        "Dreamlike": "Dreamlike",
        "Raw": "Raw",
        "Journalistic": "Journalistic"
      },
      "items": {
        "short-film-drama": {
          "name": "Short Film - Drama",
          "description": "A compelling 3-5 minute dramatic short with emotional arc, character development, and cinematic visuals.",
          "scene1_heading": "INT. LOCATION - DAY",
          "scene1_action": "Opening scene establishing the protagonist and their world.",
          "scene2_heading": "EXT. LOCATION - DAY",
          "scene2_action": "The inciting incident that disrupts the protagonist's life.",
          "scene3_heading": "INT. LOCATION - NIGHT",
          "scene3_action": "Rising tension and emotional confrontation.",
          "scene4_heading": "EXT. LOCATION - DAY",
          "scene4_action": "Resolution and character transformation."
        },
        "horror-short": {
          "name": "Horror Short",
          "description": "A tense 2-3 minute horror piece with atmospheric tension, jump scares, and unsettling imagery.",
          "scene1_heading": "INT. DARK LOCATION - NIGHT",
          "scene1_action": "Establishing an unsettling atmosphere. Something feels wrong.",
          "scene2_heading": "INT. DARK LOCATION - NIGHT",
          "scene2_action": "Strange occurrences begin. Tension builds.",
          "scene3_heading": "INT. DARK LOCATION - NIGHT",
          "scene3_action": "The horror reveals itself. Peak terror moment.",
          "scene4_heading": "INT/EXT. LOCATION - NIGHT",
          "scene4_action": "Ambiguous ending leaving audience unsettled."
        },
        "comedy-sketch": {
          "name": "Comedy Sketch",
          "description": "A punchy 1-2 minute comedy sketch with setup, escalation, and punchline.",
          "scene1_heading": "INT. EVERYDAY LOCATION - DAY",
          "scene1_action": "Setup: Establish the normal situation and characters.",
          "scene2_heading": "INT. SAME LOCATION - DAY",
          "scene2_action": "Complication: Something absurd happens or is revealed.",
          "scene3_heading": "INT. SAME LOCATION - DAY",
          "scene3_action": "Punchline: The comedic payoff that lands the joke."
        },
        "sci-fi-concept": {
          "name": "Sci-Fi Concept",
          "description": "A visually stunning 2-4 minute science fiction piece exploring futuristic themes.",
          "scene1_heading": "EXT. FUTURISTIC CITY - NIGHT",
          "scene1_action": "Establishing the world and its advanced technology.",
          "scene2_heading": "INT. HIGH-TECH FACILITY - DAY",
          "scene2_action": "Introduction of the central concept or conflict.",
          "scene3_heading": "EXT/INT. VARIOUS - DAY/NIGHT",
          "scene3_action": "The implications of the technology unfold.",
          "scene4_heading": "EXT. FUTURISTIC VISTA - DAWN",
          "scene4_action": "Philosophical conclusion about humanity and technology."
        },
        "fantasy-adventure": {
          "name": "Fantasy Adventure",
          "description": "An epic 3-5 minute fantasy journey with magical elements and heroic moments.",
          "scene1_heading": "EXT. MAGICAL REALM - DAY",
          "scene1_action": "Establishing the magical world and its beauty.",
          "scene2_heading": "INT. ANCIENT STRUCTURE - DAY",
          "scene2_action": "The hero receives their quest or calling.",
          "scene3_heading": "EXT. PERILOUS TERRAIN - DAY",
          "scene3_action": "The hero faces trials and demonstrates courage.",
          "scene4_heading": "EXT. TRIUMPHANT LOCATION - SUNSET",
          "scene4_action": "Victory and transformation of the hero."
        },
        "product-showcase": {
          "name": "Product Showcase",
          "description": "A sleek 30-60 second product video highlighting features and benefits.",
          "scene1_heading": "PRODUCT REVEAL",
          "scene1_action": "Dramatic reveal of the product from darkness to light.",
          "scene2_heading": "FEATURE HIGHLIGHTS",
          "scene2_action": "Showcase key features with dynamic camera movements.",
          "scene3_heading": "IN USE",
          "scene3_action": "Product in real-world use showing benefits.",
          "scene4_heading": "CALL TO ACTION",
          "scene4_action": "Final product shot with branding and CTA."
        },
        "brand-story": {
          "name": "Brand Story",
          "description": "An emotional 1-2 minute brand video connecting with audience values.",
          "scene1_heading": "THE PROBLEM",
          "scene1_action": "Showing the challenge or need the audience faces.",
          "scene2_heading": "THE JOURNEY",
          "scene2_action": "The brand's story and passion for solving the problem.",
          "scene3_heading": "THE SOLUTION",
          "scene3_action": "How the brand delivers value and changes lives.",
          "scene4_heading": "THE VISION",
          "scene4_action": "The future the brand is building with its customers."
        },
        "tiktok-reel": {
          "name": "TikTok/Reels Video",
          "description": "A fast-paced 15-60 second vertical video optimized for social engagement.",
          "scene1_heading": "HOOK",
          "scene1_action": "Grab attention in the first 3 seconds.",
          "scene2_heading": "CONTENT",
          "scene2_action": "Deliver the main message or entertainment.",
          "scene3_heading": "PAYOFF",
          "scene3_action": "Satisfying ending that encourages sharing."
        },
        "explainer-video": {
          "name": "Explainer Video",
          "description": "A clear 2-3 minute educational video breaking down complex topics.",
          "scene1_heading": "INTRODUCTION",
          "scene1_action": "Introduce the topic and why it matters.",
          "scene2_heading": "THE PROBLEM",
          "scene2_action": "Explain the challenge or question being addressed.",
          "scene3_heading": "THE EXPLANATION",
          "scene3_action": "Break down the concept step by step.",
          "scene4_heading": "KEY TAKEAWAYS",
          "scene4_action": "Recap the main points and next steps."
        },
        "music-video-concept": {
          "name": "Music Video Concept",
          "description": "An artistic 3-4 minute visual narrative designed to accompany music.",
          "scene1_heading": "INTRO/VERSE 1",
          "scene1_action": "Set the mood and introduce visual themes.",
          "scene2_heading": "CHORUS 1",
          "scene2_action": "Visual explosion matching musical peak.",
          "scene3_heading": "VERSE 2/BRIDGE",
          "scene3_action": "Development of visual narrative and themes.",
          "scene4_heading": "FINAL CHORUS/OUTRO",
          "scene4_action": "Peak visual moment and satisfying conclusion."
        },
        "documentary-mini": {
          "name": "Mini Documentary",
          "description": "A thoughtful 3-5 minute documentary piece exploring a subject in depth.",
          "scene1_heading": "COLD OPEN",
          "scene1_action": "Hook the viewer with intriguing footage or statement.",
          "scene2_heading": "CONTEXT",
          "scene2_action": "Provide background and context for the subject.",
          "scene3_heading": "DEEP DIVE",
          "scene3_action": "Explore the subject through multiple perspectives.",
          "scene4_heading": "CONCLUSION",
          "scene4_action": "Leave the viewer with something to think about."
        }
      }
    },
    "breakdown_progress": {
      "developing": "DEVELOPING...",
      "craftedFrameByFrame": "Your story is being crafted frame by frame",
      "readingIdea": "Reading your story idea",
      "aligningGenre": "Aligning with genre",
      "aligningWith": "Aligning with {{genre}}",
      "identifyingCharacters": "Identifying characters",
      "creatingBreakdown": "Creating scene breakdown",
      "processing": "Processing"
    },
    "storyboard_progress": {
      "developingVision": "DEVELOPING YOUR VISION",
      "renderedFrameByFrame": "Your storyboard is being rendered frame by frame...",
      "generatingShotList": "Generating Shot List",
      "breakingScenes": "Breaking down scenes into shots",
      "preparingCast": "Preparing Cast",
      "loadingProfiles": "Loading character profiles",
      "renderingStoryboard": "Rendering Storyboard",
      "creatingFrames": "Creating visual frames",
      "visualMasterpiece": "Your visual masterpiece is taking shape..."
    },
    "lock_dialog": {
      "lockTheScript": "LOCK THE SCRIPT",
      "scriptFinalized": "Your screenplay will be finalized and production begins...",
      "productionEstimate": "Production Estimate",
      "estimatedShots": "Estimated Shots",
      "totalBudget": "Total Budget",
      "shotBreakdownInfo": "Shot breakdowns will be generated and visuals prepared for production. Final costs may vary based on shot complexity.",
      "backToEdit": "Back to Edit",
      "lockAndBegin": "Lock & Begin"
    },
    "export_panel": {
      "exportOptions": "Export Options",
      "videoFormats": "Video Formats",
      "subtitles": "Subtitles",
      "project": "Project",
      "mp4Video": "MP4 Video",
      "mp4Desc": "Standard video format for all devices",
      "webmVideo": "WebM Video",
      "webmDesc": "Web-optimized format for embedding",
      "srtSubtitles": "SRT Subtitles",
      "srtDesc": "Standard subtitle format",
      "webvttSubtitles": "WebVTT Subtitles",
      "webvttDesc": "HTML5 native subtitles",
      "projectFile": "Project File",
      "projectFileDesc": "Full project backup (.json)",
      "generateVideoFirst": "Generate video first",
      "generateShotsFirst": "Generate shots first",
      "importProject": "Import Project",
      "importProjectDesc": "Select a project file (.json) to import. This will replace your current project.",
      "clickToSelect": "Click to select a file",
      "orDragDrop": "or drag and drop"
    }
  },
  "projects": {
    "title": "My Projects",
    "loading": "Loading projects...",
    "loadError": "Failed to load projects",
    "createError": "Failed to create project",
    "create": "Create New",
    "createVideo": "Video Project",
    "createStory": "Story Project",
    "createVisualizer": "Visualizer Project",
    "favorites": "Favorites",
    "recent": "Recent",
    "allProjects": "All Projects",
    "search": "Search projects...",
    "empty": "No projects yet",
    "emptyHint": "Create your first project to get started",
    "noResults": "No projects found",
    "tryDifferentSearch": "Try a different search or filter",
    "open": "Open",
    "export": "Export",
    "delete": "Delete",
    "favorite": "Add to favorites",
    "unfavorite": "Remove from favorites",
    "confirmDelete": "Are you sure you want to delete this project? This cannot be undone."
  }
}
</file>

<file path="i18n/useLanguage.ts">
import { useCallback, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { languageConfig, SupportedLanguage, supportedLanguages } from './index';

export interface UseLanguageReturn {
  language: SupportedLanguage;
  direction: 'ltr' | 'rtl';
  isRTL: boolean;
  setLanguage: (lang: SupportedLanguage) => void;
  t: ReturnType<typeof useTranslation>['t'];
  languageConfig: typeof languageConfig;
  supportedLanguages: typeof supportedLanguages;
}

export function useLanguage(): UseLanguageReturn {
  const { t, i18n } = useTranslation();

  const language = (supportedLanguages.includes(i18n.language as SupportedLanguage)
    ? i18n.language
    : 'en') as SupportedLanguage;

  const direction = languageConfig[language].dir;
  const isRTL = direction === 'rtl';

  const setLanguage = useCallback(
    (lang: SupportedLanguage) => {
      i18n.changeLanguage(lang);
    },
    [i18n]
  );

  // Update HTML attributes when language changes
  useEffect(() => {
    const html = document.documentElement;
    html.setAttribute('lang', language);
    html.setAttribute('dir', direction);
  }, [language, direction]);

  return {
    language,
    direction,
    isRTL,
    setLanguage,
    t,
    languageConfig,
    supportedLanguages,
  };
}

export default useLanguage;
</file>

<file path="index.css">
@import "tailwindcss";
@import "tw-animate-css";
@plugin "tailwindcss-animate";

@custom-variant dark (&:is(.dark *));

/*
  LyricLens Design System 2026: "The Invisible Interface"
  Philosophy: Intentional Minimalism, Deep Space, Bioluminescence
*/

@theme inline {
    --color-background: var(--background);
    --color-foreground: var(--foreground);
    --color-card: var(--card);
    --color-card-foreground: var(--card-foreground);
    --color-popover: var(--popover);
    --color-popover-foreground: var(--popover-foreground);
    --color-primary: var(--primary);
    --color-primary-foreground: var(--primary-foreground);
    --color-secondary: var(--secondary);
    --color-secondary-foreground: var(--secondary-foreground);
    --color-muted: var(--muted);
    --color-muted-foreground: var(--muted-foreground);
    --color-accent: var(--accent);
    --color-accent-foreground: var(--accent-foreground);
    --color-destructive: var(--destructive);
    --color-destructive-foreground: var(--destructive-foreground);
    --color-border: var(--border);
    --color-input: var(--input);
    --color-ring: var(--ring);

    --radius-sm: calc(var(--radius) - 4px);
    --radius-md: calc(var(--radius) - 2px);
    --radius-lg: var(--radius);
    --radius-xl: calc(var(--radius) + 4px);
    --radius-2xl: calc(var(--radius) + 8px);
    --radius-3xl: calc(var(--radius) + 16px);
    --radius-full: 9999px;

    --font-sans: "Inter", "Geist Sans", system-ui, sans-serif;
    --font-mono: "JetBrains Mono", "Fira Code", monospace;
    --font-display: "Playfair Display", Georgia, "Times New Roman", serif;
    --font-script: "Crimson Pro", Georgia, "Times New Roman", serif;
    --font-editorial: "Sora", "Inter", system-ui, sans-serif;
    --font-code: "DM Mono", "JetBrains Mono", monospace;

    /* Cinematic Easing Curves */
    --ease-cinematic: cubic-bezier(0.22, 1, 0.36, 1);
    --ease-dramatic: cubic-bezier(0.16, 1, 0.3, 1);
    --ease-curtain: cubic-bezier(0.65, 0, 0.35, 1);

    --animate-float: float 8s ease-in-out infinite;
    --animate-pulse-slow: pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    --animate-glow: glow 2s ease-in-out infinite alternate;

    /* Typography Scale */
    --text-hero: clamp(2.5rem, 5vw, 4rem);
    --text-heading: clamp(1.5rem, 3vw, 2.5rem);
    --text-subheading: clamp(1.125rem, 2vw, 1.5rem);
    --text-body: clamp(0.875rem, 1.2vw, 1rem);
    --text-caption: 0.75rem;
    --text-micro: 0.625rem;

    /* Spacing Scale */
    --space-section: 3rem;
    --space-card: 1.5rem;
    --space-element: 0.75rem;
}

:root {
    --radius: 1rem;

    /* 
       PALETTE: Deep Space & Bioluminescence 
       Using OKLCH for wider gamut and perceptual uniformity.
    */

    /* The Void (Background) - Darker, richer than black */
    --background: oklch(0.05 0.01 240); 
    
    /* Starlight (Foreground) - Pure, crisp white */
    --foreground: oklch(0.98 0 0);

    /* Event Horizon (Cards) - Subtle surface, almost invisible */
    --card: oklch(0.12 0.02 245);
    --card-foreground: oklch(0.98 0 0);

    --popover: oklch(0.08 0.02 245);
    --popover-foreground: oklch(0.98 0 0);

    /* Nebula (Primary) - Vibrant Cyan/Teal */
    --primary: oklch(0.70 0.15 190);
    --primary-foreground: oklch(0.05 0.01 240);

    /* Dark Matter (Secondary) - Deep Indigo */
    --secondary: oklch(0.15 0.05 240);
    --secondary-foreground: oklch(0.90 0.05 240);

    /* Stardust (Muted) */
    --muted: oklch(0.20 0.02 240);
    --muted-foreground: oklch(0.60 0.05 240);

    /* Supernova (Accent) - Intense Orange/Red */
    --accent: oklch(0.65 0.25 30);
    --accent-foreground: oklch(0.98 0 0);

    /* Quasar (Destructive) */
    --destructive: oklch(0.55 0.25 25);
    --destructive-foreground: oklch(0.98 0 0);

    /* Boundaries (barely visible) */
    --border: oklch(0.20 0.03 240);
    --input: oklch(0.20 0.03 240);
    --ring: oklch(0.70 0.15 190);

    /* Glow Variables */
    --glow-primary: oklch(0.70 0.15 190 / 0.5);
    --glow-accent: oklch(0.65 0.25 30 / 0.5);

    /* ==========================================
       CINEMATIC/EDITORIAL PALETTE
       Film noir vibes, dramatic lighting
       ========================================== */

    /* The Void - Deepest black with subtle warmth */
    --cinema-void: oklch(0.03 0.005 30);

    /* Celluloid - Rich dark brown/black (film base) */
    --cinema-celluloid: oklch(0.08 0.02 45);

    /* Silver Screen - Warm off-white for text */
    --cinema-silver: oklch(0.92 0.01 60);

    /* Spotlight - Golden accent (key light) */
    --cinema-spotlight: oklch(0.75 0.15 80);

    /* Velvet - Deep theatrical red */
    --cinema-velvet: oklch(0.35 0.15 25);

    /* Editorial Accent - Deep burgundy */
    --cinema-editorial: oklch(0.55 0.12 15);

    /* Cinematic Shadows */
    --cinema-shadow: oklch(0 0 0 / 0.6);
    --cinema-shadow-soft: oklch(0 0 0 / 0.3);

    /* Cinematic Glows */
    --glow-spotlight: oklch(0.75 0.15 80 / 0.4);
    --glow-velvet: oklch(0.35 0.15 25 / 0.3);
}

/* ==========================================
   AVANT-GARDE UTILITIES
   ========================================== */

@layer base {
    * {
        @apply border-border outline-ring/50;
    }
    
    html {
        scroll-behavior: smooth;
    }

    body {
        @apply bg-background text-foreground antialiased;
        font-feature-settings: "ss01", "ss02", "cv01", "cv02";
        background-image: 
            radial-gradient(circle at 50% 0%, oklch(0.15 0.05 240 / 0.3) 0%, transparent 50%),
            radial-gradient(circle at 100% 100%, oklch(0.12 0.05 280 / 0.2) 0%, transparent 40%);
        background-attachment: fixed;
    }

    /* Custom Selection */
    ::selection {
        @apply bg-primary/30 text-primary-foreground;
    }

    /* Sleek Scrollbar */
    * {
        scrollbar-width: thin;
        scrollbar-color: rgba(255,255,255,0.08) transparent;
    }

    *::-webkit-scrollbar {
        width: 6px;
        height: 6px;
    }

    *::-webkit-scrollbar-track {
        background: transparent;
    }

    *::-webkit-scrollbar-thumb {
        background: rgba(255,255,255,0.08);
        border-radius: 3px;
    }

    *::-webkit-scrollbar-thumb:hover {
        background: rgba(255,255,255,0.15);
    }

    *::-webkit-scrollbar-corner {
        background: transparent;
    }
}

/* ==========================================
   CINEMATIC TYPOGRAPHY
   ========================================== */

.font-display {
    font-family: var(--font-display);
}

.font-script {
    font-family: var(--font-script);
}

.font-editorial {
    font-family: var(--font-editorial);
}

.font-code {
    font-family: var(--font-code);
}

/* ==========================================
   TYPOGRAPHY HIERARCHY
   ========================================== */

.heading-hero {
    font-family: var(--font-display);
    font-size: var(--text-hero);
    font-weight: 600;
    letter-spacing: -0.02em;
    line-height: 1.1;
    color: var(--cinema-silver);
}

.heading-section {
    font-family: var(--font-display);
    font-size: var(--text-heading);
    font-weight: 500;
    letter-spacing: -0.01em;
    line-height: 1.2;
    color: var(--cinema-silver);
}

.heading-card {
    font-family: var(--font-editorial);
    font-size: var(--text-subheading);
    font-weight: 500;
    line-height: 1.3;
    color: oklch(0.95 0.01 60);
}

.text-body-editorial {
    font-family: var(--font-editorial);
    font-size: var(--text-body);
    line-height: 1.65;
    color: oklch(0.75 0.02 60);
}

.text-caption-mono {
    font-family: var(--font-code);
    font-size: var(--text-micro);
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: oklch(0.55 0.03 60);
}

/* ==========================================
   CINEMATIC SURFACES
   ========================================== */

.surface-card {
    background: var(--cinema-celluloid);
    border: 1px solid oklch(0.92 0.01 60 / 0.08);
    border-radius: var(--radius-lg);
    box-shadow:
        0 2px 4px oklch(0 0 0 / 0.2),
        0 8px 24px oklch(0 0 0 / 0.15),
        inset 0 1px 0 0 oklch(1 0 0 / 0.03);
    transition: border-color 0.3s var(--ease-cinematic), box-shadow 0.3s var(--ease-cinematic);
}

.surface-card:hover {
    border-color: oklch(0.75 0.15 80 / 0.2);
    box-shadow:
        0 2px 4px oklch(0 0 0 / 0.2),
        0 12px 32px oklch(0 0 0 / 0.25),
        0 0 0 1px oklch(0.75 0.15 80 / 0.06),
        inset 0 1px 0 0 oklch(1 0 0 / 0.04);
}

.surface-elevated {
    background: oklch(0.10 0.02 245);
    border: 1px solid oklch(1 0 0 / 0.06);
    border-radius: var(--radius-lg);
    box-shadow:
        0 4px 8px oklch(0 0 0 / 0.3),
        0 16px 48px oklch(0 0 0 / 0.2),
        inset 0 1px 0 0 oklch(1 0 0 / 0.05);
}

/* ==========================================
   CINEMATIC EFFECTS
   ========================================== */

/* Film grain overlay - apply to containers */
.cinema-grain::before {
    content: "";
    position: absolute;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    opacity: 0.03;
    pointer-events: none;
    z-index: 1;
    mix-blend-mode: overlay;
}

/* Vignette effect */
.cinema-vignette::after {
    content: "";
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse at center, transparent 40%, var(--cinema-void) 100%);
    pointer-events: none;
    z-index: 1;
}

/* Spotlight glow effect */
.cinema-spotlight-glow {
    box-shadow:
        0 0 60px 20px var(--glow-spotlight),
        0 10px 30px -5px var(--cinema-shadow);
}

/* Cinematic shadow (dramatic) */
.shadow-cinematic {
    box-shadow:
        0 4px 6px -1px var(--cinema-shadow-soft),
        0 20px 40px -10px var(--cinema-shadow),
        inset 0 1px 0 0 oklch(1 0 0 / 0.05);
}

/* Editorial shadow (refined) */
.shadow-editorial {
    box-shadow:
        0 2px 4px var(--cinema-shadow-soft),
        0 8px 16px oklch(0 0 0 / 0.15);
}

/* Letterbox bars */
.cinema-letterbox::before,
.cinema-letterbox::after {
    content: "";
    position: absolute;
    left: 0;
    right: 0;
    height: 10%;
    background: var(--cinema-void);
    z-index: 2;
}

.cinema-letterbox::before {
    top: 0;
}

.cinema-letterbox::after {
    bottom: 0;
}

/* Film strip sprocket holes */
.cinema-sprockets {
    background-image:
        repeating-linear-gradient(
            to bottom,
            transparent 0px,
            transparent 8px,
            var(--cinema-void) 8px,
            var(--cinema-void) 12px,
            transparent 12px,
            transparent 20px
        );
    background-size: 100% 28px;
}

/* Golden spotlight border on focus */
.cinema-focus:focus-visible {
    outline: none;
    box-shadow:
        0 0 0 2px var(--cinema-spotlight),
        0 0 20px var(--glow-spotlight);
}

/* Cinematic button */
.btn-cinematic {
    background: linear-gradient(135deg, var(--cinema-spotlight) 0%, oklch(0.65 0.12 70) 100%);
    color: var(--cinema-void);
    font-weight: 600;
    transition: all 0.3s var(--ease-cinematic);
}

.btn-cinematic:hover {
    box-shadow: 0 0 30px var(--glow-spotlight);
    transform: translateY(-1px);
}

/* Film reel spin animation */
@keyframes filmReelSpin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.animate-film-reel {
    animation: filmReelSpin 2s linear infinite;
}

/* Curtain rise animation */
@keyframes curtainRise {
    from {
        opacity: 0;
        transform: translateY(40px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.animate-curtain-rise {
    animation: curtainRise 0.6s var(--ease-curtain) forwards;
}

/* Spotlight reveal animation */
@keyframes spotlightReveal {
    from {
        opacity: 0;
        transform: scale(0.95);
        filter: blur(10px);
    }
    to {
        opacity: 1;
        transform: scale(1);
        filter: blur(0);
    }
}

.animate-spotlight-reveal {
    animation: spotlightReveal 0.5s var(--ease-dramatic) forwards;
}

/* Shimmer effect for loading states */
@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.cinema-shimmer::before {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(
        90deg,
        transparent 0%,
        oklch(1 0 0 / 0.05) 50%,
        transparent 100%
    );
    animation: shimmer 2s infinite linear;
}

/* ==========================================
   GLASSMORPHISM & SURFACES
   ========================================== */

.glass {
    background: color-mix(in oklch, var(--card), transparent 30%);
    backdrop-filter: blur(16px) saturate(180%);
    -webkit-backdrop-filter: blur(16px) saturate(180%);
    border: 1px solid oklch(1 1 1 / 0.05);
    box-shadow: 
        0 4px 30px oklch(0 0 0 / 0.1),
        inset 0 0 0 1px oklch(1 1 1 / 0.05);
}

.glass-panel {
    background: color-mix(in oklch, var(--background), transparent 20%);
    backdrop-filter: blur(24px) saturate(140%);
    border-top: 1px solid oklch(1 1 1 / 0.1);
    border-left: 1px solid oklch(1 1 1 / 0.05);
}

.glass-button {
    background: oklch(1 1 1 / 0.03);
    backdrop-filter: blur(8px);
    border: 1px solid oklch(1 1 1 / 0.1);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.glass-button:hover {
    background: oklch(1 1 1 / 0.08);
    border-color: var(--primary);
    box-shadow: 0 0 20px var(--glow-primary);
    transform: translateY(-1px);
}

/* ==========================================
   TEXT EFFECTS
   ========================================== */

.text-gradient {
    background: linear-gradient(135deg, var(--foreground) 0%, var(--muted-foreground) 100%);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
}

.text-gradient-primary {
    background: linear-gradient(135deg, var(--primary) 0%, oklch(0.8 0.1 240) 100%);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
}

/* ==========================================
   ANIMATIONS
   ========================================== */

@keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

@keyframes glow {
    from { box-shadow: 0 0 10px -5px var(--glow-primary); }
    to { box-shadow: 0 0 25px 5px var(--glow-primary); }
}

.animate-in-fade {
    animation: fadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
}

.animate-in-slide-up {
    animation: slideUp 0.8s cubic-bezier(0.16, 1, 0.3, 1) forwards;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

/* ==========================================
   MICRO-INTERACTIONS
   ========================================== */

.hover-glow {
    transition: box-shadow 0.3s ease;
}
.hover-glow:hover {
    box-shadow: 0 0 30px var(--glow-primary);
}

.click-scale:active {
    transform: scale(0.98);
}

/* Hide scrollbar but allow functionality */
.no-scrollbar::-webkit-scrollbar {
    display: none;
}
.no-scrollbar {
    -ms-overflow-style: none;
    scrollbar-width: none;
}

/* ==========================================
   RTL (Right-to-Left) SUPPORT
   ========================================== */

/* RTL direction utilities */
[dir="rtl"] {
    /* Flip text alignment */
    --text-align-start: right;
    --text-align-end: left;
}

[dir="ltr"] {
    --text-align-start: left;
    --text-align-end: right;
}

/* RTL-aware flex utilities */
[dir="rtl"] .rtl\:flex-row-reverse {
    flex-direction: row-reverse;
}

[dir="rtl"] .rtl\:space-x-reverse > :not([hidden]) ~ :not([hidden]) {
    --tw-space-x-reverse: 1;
}

/* RTL-aware text alignment */
[dir="rtl"] .rtl\:text-right {
    text-align: right;
}

[dir="rtl"] .rtl\:text-left {
    text-align: left;
}

/* RTL-aware margins and padding using logical properties */
.ms-auto { margin-inline-start: auto; }
.me-auto { margin-inline-end: auto; }
.ps-0 { padding-inline-start: 0; }
.pe-0 { padding-inline-end: 0; }
.ps-1 { padding-inline-start: 0.25rem; }
.pe-1 { padding-inline-end: 0.25rem; }
.ps-2 { padding-inline-start: 0.5rem; }
.pe-2 { padding-inline-end: 0.5rem; }
.ps-3 { padding-inline-start: 0.75rem; }
.pe-3 { padding-inline-end: 0.75rem; }
.ps-4 { padding-inline-start: 1rem; }
.pe-4 { padding-inline-end: 1rem; }
.ps-6 { padding-inline-start: 1.5rem; }
.pe-6 { padding-inline-end: 1.5rem; }
.ms-0 { margin-inline-start: 0; }
.me-0 { margin-inline-end: 0; }
.ms-1 { margin-inline-start: 0.25rem; }
.me-1 { margin-inline-end: 0.25rem; }
.ms-2 { margin-inline-start: 0.5rem; }
.me-2 { margin-inline-end: 0.5rem; }
.ms-3 { margin-inline-start: 0.75rem; }
.me-3 { margin-inline-end: 0.75rem; }
.ms-4 { margin-inline-start: 1rem; }
.me-4 { margin-inline-end: 1rem; }
.ms-6 { margin-inline-start: 1.5rem; }
.me-6 { margin-inline-end: 1.5rem; }

/* RTL-aware border utilities */
.border-s { border-inline-start-width: 1px; }
.border-e { border-inline-end-width: 1px; }
.border-s-0 { border-inline-start-width: 0; }
.border-e-0 { border-inline-end-width: 0; }
.rounded-s { border-start-start-radius: var(--radius); border-end-start-radius: var(--radius); }
.rounded-e { border-start-end-radius: var(--radius); border-end-end-radius: var(--radius); }
.rounded-s-lg { border-start-start-radius: var(--radius-lg); border-end-start-radius: var(--radius-lg); }
.rounded-e-lg { border-start-end-radius: var(--radius-lg); border-end-end-radius: var(--radius-lg); }

/* RTL-aware positioning */
.start-0 { inset-inline-start: 0; }
.end-0 { inset-inline-end: 0; }
.start-1 { inset-inline-start: 0.25rem; }
.end-1 { inset-inline-end: 0.25rem; }
.start-2 { inset-inline-start: 0.5rem; }
.end-2 { inset-inline-end: 0.5rem; }
.start-4 { inset-inline-start: 1rem; }
.end-4 { inset-inline-end: 1rem; }
.start-auto { inset-inline-start: auto; }
.end-auto { inset-inline-end: auto; }

/* RTL-aware text alignment */
.text-start { text-align: start; }
.text-end { text-align: end; }

/* RTL icon flip utility */
[dir="rtl"] .rtl\:flip,
[dir="rtl"] .rtl-flip {
    transform: scaleX(-1);
}

/* RTL-aware gap utilities for flex containers */
[dir="rtl"] .rtl\:gap-reverse {
    flex-direction: row-reverse;
}

/* Body RTL class for global RTL state */
body.rtl {
    direction: rtl;
    text-align: right;
}

body:not(.rtl) {
    direction: ltr;
    text-align: left;
}


/* ==========================================
   ACCESSIBILITY & KEYBOARD NAVIGATION
   Requirements: 9.4, 9.5 - Keyboard navigation support
   ========================================== */

/* Screen reader only utility */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
}

/* Make sr-only visible on focus (for skip links) */
.sr-only:focus,
.sr-only:focus-visible {
    position: static;
    width: auto;
    height: auto;
    padding: inherit;
    margin: inherit;
    overflow: visible;
    clip: auto;
    white-space: normal;
}

/* Focus visible styles for keyboard navigation */
:focus-visible {
    outline: 2px solid var(--ring);
    outline-offset: 2px;
}

/* Remove default focus outline for mouse users */
:focus:not(:focus-visible) {
    outline: none;
}

/* Enhanced focus styles for interactive elements */
button:focus-visible,
a:focus-visible,
input:focus-visible,
textarea:focus-visible,
select:focus-visible,
[role="button"]:focus-visible,
[tabindex]:focus-visible {
    outline: 2px solid var(--primary);
    outline-offset: 2px;
    box-shadow: 0 0 0 4px oklch(0.70 0.15 190 / 0.2);
}

/* Focus styles for cards and interactive containers */
.focus-ring:focus-visible {
    outline: 2px solid var(--primary);
    outline-offset: 2px;
    box-shadow: 0 0 0 4px oklch(0.70 0.15 190 / 0.2);
}

/* Skip to content link styles */
.skip-to-content {
    position: absolute;
    top: -100%;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    padding: 0.75rem 1.5rem;
    background: var(--primary);
    color: var(--primary-foreground);
    border-radius: var(--radius);
    font-weight: 600;
    text-decoration: none;
    transition: top 0.2s ease;
}

.skip-to-content:focus {
    top: 1rem;
}

/* Ensure all interactive elements have visible focus indicators */
[role="button"]:focus-visible,
[role="link"]:focus-visible,
[role="menuitem"]:focus-visible,
[role="tab"]:focus-visible,
[role="checkbox"]:focus-visible,
[role="radio"]:focus-visible,
[role="switch"]:focus-visible,
[role="slider"]:focus-visible {
    outline: 2px solid var(--primary);
    outline-offset: 2px;
}

/* Focus within for composite widgets */
[role="listbox"]:focus-within,
[role="menu"]:focus-within,
[role="tablist"]:focus-within,
[role="toolbar"]:focus-within {
    outline: 1px solid oklch(0.70 0.15 190 / 0.3);
    outline-offset: 2px;
}

/* High contrast mode support */
@media (prefers-contrast: high) {
    :focus-visible {
        outline: 3px solid currentColor;
        outline-offset: 3px;
    }
    
    button:focus-visible,
    a:focus-visible {
        outline: 3px solid currentColor;
        outline-offset: 3px;
        box-shadow: none;
    }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
    }
}

/* Ensure disabled elements are not focusable visually */
[disabled],
[aria-disabled="true"] {
    cursor: not-allowed;
    opacity: 0.5;
}

[disabled]:focus,
[aria-disabled="true"]:focus {
    outline: none;
    box-shadow: none;
}

/* Focus trap container styles */
[role="dialog"][aria-modal="true"] {
    /* Ensure modal is above other content */
    z-index: 50;
}

/* Ensure proper tab order for RTL */
[dir="rtl"] [tabindex] {
    /* Tab order is handled by the browser based on DOM order */
    /* This ensures visual order matches logical order */
}

/* Visible focus indicator for custom checkboxes and radios */
input[type="checkbox"]:focus-visible + label,
input[type="radio"]:focus-visible + label {
    outline: 2px solid var(--primary);
    outline-offset: 2px;
}

/* Focus styles for dropdown menu items */
[role="menuitem"]:focus,
[role="menuitemcheckbox"]:focus,
[role="menuitemradio"]:focus {
    background: oklch(0.70 0.15 190 / 0.1);
    outline: none;
}

/* Ensure touch targets are large enough (44x44px minimum) */
@media (pointer: coarse) {
    button,
    a,
    input,
    select,
    textarea,
    [role="button"],
    [role="link"] {
        min-height: 44px;
        min-width: 44px;
    }
}

/* ==========================================
   MOBILE RESPONSIVE ADJUSTMENTS
   ========================================== */

@media (max-width: 640px) {
    :root {
        --space-section: 2rem;
        --space-card: 1rem;
    }

    .heading-hero {
        font-size: clamp(2rem, 8vw, 2.5rem);
    }

    .heading-section {
        font-size: clamp(1.25rem, 5vw, 1.75rem);
    }

    .heading-card {
        font-size: clamp(1rem, 4vw, 1.25rem);
    }

    /* Compact surfaces on mobile */
    .surface-card {
        padding: var(--space-card);
    }
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LyricLens</title>
    <!-- Cinematic Typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700;900&family=Crimson+Pro:ital,wght@0,400;0,500;0,600;1,400;1,500&family=Sora:wght@300;400;500;600;700&family=DM+Mono:ital,wght@0,300;0,400;0,500;1,300&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/index.css">
  <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "@google/genai": "https://esm.sh/@google/genai@^1.33.0",
    "lucide-react": "https://esm.sh/lucide-react@^0.561.0"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>
  <script type="module" src="/index.tsx"></script>
</body>
</html>
</file>

<file path="index.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

// Expose test functions only in development
if (import.meta.env.DEV) {
  import('@/services/freesoundService').then(({ testFreesoundAPI }) => {
    if (typeof window !== "undefined") {
      (window as any).testFreesoundAPI = testFreesoundAPI;
    }
  });

  // Test Firebase configuration at startup
  import('@/services/firebase/config').then(({ isFirebaseConfigured, getFirebaseApp, getFirebaseAuth }) => {
    console.log('=== FIREBASE STARTUP TEST ===');
    console.log('[Firebase] Is configured?', isFirebaseConfigured());
    console.log('[Firebase] Environment variables:', {
      apiKey: import.meta.env.VITE_FIREBASE_API_KEY ? '‚úì Set' : '‚úó Missing',
      authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN ? '‚úì Set' : '‚úó Missing',
      projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID ? '‚úì Set' : '‚úó Missing',
      // storageBucket not used - GCS handled by cloudStorageService.ts
      messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID ? '‚úì Set' : '‚úó Missing',
      appId: import.meta.env.VITE_FIREBASE_APP_ID ? '‚úì Set' : '‚úó Missing',
    });

    const app = getFirebaseApp();
    console.log('[Firebase] App initialized?', !!app);

    if (app) {
      const auth = getFirebaseAuth();
      console.log('[Firebase] Auth initialized?', !!auth);
      if (auth) {
        console.log('[Firebase] Auth config:', {
          appName: auth.app.name,
          apiKey: auth.config.apiKey.substring(0, 10) + '...',
          authDomain: auth.config.authDomain
        });
      }
    }
    console.log('=== END FIREBASE TEST ===');
  });
}

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="package.json">
{
  "name": "@studio/frontend",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "dev:host": "vite --host",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest",
    "test:run": "vitest run"
  },
  "dependencies": {
    "@capacitor/android": "^8.0.1",
    "@capacitor/cli": "^8.0.1",
    "@capacitor/core": "^8.0.1",
    "@capacitor/filesystem": "^8.1.0",
    "@capacitor/ios": "^8.0.1",
    "@capacitor/share": "^8.0.0",
    "@google/genai": "^1.38.0",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-progress": "^1.1.8",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-slider": "^1.3.6",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-toast": "^1.2.15",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@studio/shared": "workspace:*",
    "@tailwindcss/postcss": "^4.1.18",
    "@vercel/analytics": "^1.6.1",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.29.0",
    "i18next": "^25.8.0",
    "i18next-browser-languagedetector": "^8.2.0",
    "lucide-react": "^0.563.0",
    "react": "^19.2.4",
    "react-dom": "^19.2.4",
    "react-i18next": "^16.5.4",
    "react-router-dom": "^7.13.0",
    "tailwind-merge": "^3.4.0",
    "tailwindcss-animate": "^1.0.7",
    "zustand": "^5.0.11"
  },
  "devDependencies": {
    "@eslint/js": "^10.0.1",
    "@playwright/test": "^1.58.2",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.2",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^25.2.2",
    "@types/react": "^19.2.13",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.3",
    "@vitest/ui": "^4.0.18",
    "autoprefixer": "^10.4.24",
    "concurrently": "^9.2.1",
    "eslint": "^10.0.0",
    "eslint-plugin-react": "^7.37.5",
    "eslint-plugin-react-hooks": "^7.0.1",
    "fast-check": "^4.5.3",
    "globals": "^17.3.0",
    "jsdom": "^28.0.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.18",
    "tsx": "^4.21.0",
    "tw-animate-css": "^1.4.0",
    "typescript": "^5.9.3",
    "typescript-eslint": "^8.54.0",
    "vite": "^7.3.1",
    "vite-plugin-sitemap": "^0.8.2",
    "vitest": "^4.0.18"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    "@tailwindcss/postcss": {},
    autoprefixer: {},
  },
};
</file>

<file path="public/production_prod_1769364025193_ch60ee8c1/_session_started.txt">
Session Started: 2026-01-25T18:00:27.146Z
SessionId: prod_1769364025193_ch60ee8c1
</file>

<file path="public/robots.txt">
# robots.txt for LyricLens

User-agent: *
Allow: /
Disallow: /api/

# Sitemap location
Sitemap: https://yourdomain.com/sitemap.xml
</file>

<file path="public/sitemap.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sitemap - LyricLens</title>
    <meta name="description" content="Complete sitemap of LyricLens - AI-powered lyric video generator">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #e2e8f0;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            min-height: 100vh;
            padding: 2rem;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            padding: 3rem;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            color: #94a3b8;
            margin-bottom: 2rem;
            font-size: 1.1rem;
        }
        
        .section {
            margin-bottom: 2rem;
        }
        
        .section h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #f1f5f9;
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 0.5rem;
        }
        
        .links {
            list-style: none;
        }
        
        .links li {
            margin-bottom: 0.75rem;
        }
        
        .links a {
            color: #60a5fa;
            text-decoration: none;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
        }
        
        .links a:hover {
            background: rgba(59, 130, 246, 0.1);
            color: #93c5fd;
            transform: translateX(5px);
        }
        
        .links a::before {
            content: '‚Üí';
            margin-right: 0.75rem;
            font-weight: bold;
        }
        
        .description {
            color: #94a3b8;
            font-size: 0.9rem;
            margin-left: 2rem;
            margin-top: 0.25rem;
        }
        
        .footer {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid rgba(148, 163, 184, 0.2);
            text-align: center;
            color: #64748b;
        }
        
        .footer a {
            color: #60a5fa;
            text-decoration: none;
        }
        
        .footer a:hover {
            text-decoration: underline;
        }
        
        @media (max-width: 640px) {
            body {
                padding: 1rem;
            }
            
            .container {
                padding: 1.5rem;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ LyricLens Sitemap</h1>
        <p class="subtitle">Navigate through all pages of our AI-powered lyric video generator</p>
        
        <div class="section">
            <h2>Main Pages</h2>
            <ul class="links">
                <li>
                    <a href="/">Home</a>
                    <p class="description">Welcome page and introduction to LyricLens</p>
                </li>
                <li>
                    <a href="/projects">Projects</a>
                    <p class="description">View and manage your video projects</p>
                </li>
                <li>
                    <a href="/studio">Studio</a>
                    <p class="description">Create AI-powered story-driven videos</p>
                </li>
                <li>
                    <a href="/visualizer">Visualizer</a>
                    <p class="description">Generate audio-first lyric videos</p>
                </li>
            </ul>
        </div>
        
        <div class="section">
            <h2>Account & Settings</h2>
            <ul class="links">
                <li>
                    <a href="/signin">Sign In</a>
                    <p class="description">Access your account</p>
                </li>
                <li>
                    <a href="/settings">Settings</a>
                    <p class="description">Configure API keys and preferences</p>
                </li>
            </ul>
        </div>
        
        <div class="footer">
            <p>¬© 2026 LyricLens. All rights reserved.</p>
            <p style="margin-top: 0.5rem;">
                <a href="/sitemap.xml">XML Sitemap</a> ‚Ä¢ 
                <a href="/robots.txt">Robots.txt</a>
            </p>
        </div>
    </div>
</body>
</html>
</file>

<file path="public/sitemap.xml">
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"
        xmlns:xhtml="http://www.w3.org/1999/xhtml">
  
  <url>
    <loc>https://yourdomain.com/</loc>
    <lastmod>2026-02-04</lastmod>
    <changefreq>weekly</changefreq>
    <priority>1</priority>
  </url>

  <url>
    <loc>https://yourdomain.com/studio</loc>
    <lastmod>2026-02-04</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.9</priority>
  </url>

  <url>
    <loc>https://yourdomain.com/visualizer</loc>
    <lastmod>2026-02-04</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.9</priority>
  </url>

  <url>
    <loc>https://yourdomain.com/settings</loc>
    <lastmod>2026-02-04</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.5</priority>
  </url>

</urlset>
</file>

<file path="router/guards/index.ts">
/**
 * Router guards exports
 */

export { UnsavedChangesGuard, useUnsavedChanges } from './UnsavedChangesGuard';
</file>

<file path="router/guards/UnsavedChangesGuard.tsx">
/**
 * Unsaved Changes Guard
 * Requirements: 10.3 - Warn users before navigating away from unsaved work
 * 
 * This component provides:
 * 1. A hook to track unsaved changes
 * 2. Browser beforeunload event handling
 * 3. React Router navigation blocking with confirmation dialog
 */

import React, { useEffect, useCallback, useState } from 'react';
import { useBlocker, useLocation } from 'react-router-dom';
import { useTranslation } from 'react-i18next';
import { useAppStore } from '@/stores';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { AlertTriangle } from 'lucide-react';

interface UnsavedChangesGuardProps {
  /** Whether there are unsaved changes to protect */
  hasUnsavedChanges?: boolean;
  /** Custom message to show in the dialog */
  message?: string;
  /** Callback when user confirms leaving */
  onConfirmLeave?: () => void;
  /** Children to render */
  children?: React.ReactNode;
}

/**
 * Guard component that prevents navigation when there are unsaved changes
 */
export function UnsavedChangesGuard({
  hasUnsavedChanges: propHasUnsavedChanges,
  message,
  onConfirmLeave,
  children,
}: UnsavedChangesGuardProps) {
  const { t } = useTranslation();
  const location = useLocation();
  
  // Get unsaved changes state from store if not provided via props
  const storeHasUnsavedChanges = useAppStore((s) => s.navigationState.hasUnsavedChanges);
  const hasUnsavedChanges = propHasUnsavedChanges ?? storeHasUnsavedChanges;
  
  const setHasUnsavedChanges = useAppStore((s) => s.setHasUnsavedChanges);
  const setLastRoute = useAppStore((s) => s.setLastRoute);

  // Track current route
  useEffect(() => {
    setLastRoute(location.pathname);
  }, [location.pathname, setLastRoute]);

  // Block navigation when there are unsaved changes
  const blocker = useBlocker(
    ({ currentLocation, nextLocation }) =>
      hasUnsavedChanges && currentLocation.pathname !== nextLocation.pathname
  );

  // Handle browser beforeunload event (refresh, close tab)
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (hasUnsavedChanges) {
        e.preventDefault();
        // Modern browsers require returnValue to be set
        e.returnValue = '';
        return '';
      }
      return undefined;
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [hasUnsavedChanges]);

  // Handle confirm leave
  const handleConfirmLeave = useCallback(() => {
    setHasUnsavedChanges(false);
    onConfirmLeave?.();
    if (blocker.state === 'blocked') {
      blocker.proceed();
    }
  }, [blocker, setHasUnsavedChanges, onConfirmLeave]);

  // Handle cancel (stay on page)
  const handleCancel = useCallback(() => {
    if (blocker.state === 'blocked') {
      blocker.reset();
    }
  }, [blocker]);

  const defaultMessage = t('common.unsavedChangesMessage', {
    defaultValue: 'You have unsaved changes. Are you sure you want to leave? Your changes will be lost.',
  });

  return (
    <>
      {children}
      
      {/* Confirmation Dialog */}
      <Dialog open={blocker.state === 'blocked'} onOpenChange={(open) => !open && handleCancel()}>
        <DialogContent className="sm:max-w-md bg-zinc-900 border-zinc-800">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2 text-white">
              <AlertTriangle className="w-5 h-5 text-amber-500" />
              {t('common.unsavedChanges', { defaultValue: 'Unsaved Changes' })}
            </DialogTitle>
            <DialogDescription className="text-zinc-400">
              {message || defaultMessage}
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="flex gap-2 sm:gap-0">
            <Button
              variant="ghost"
              onClick={handleCancel}
              className="text-zinc-400 hover:text-white hover:bg-zinc-800"
            >
              {t('common.stay', { defaultValue: 'Stay' })}
            </Button>
            <Button
              variant="destructive"
              onClick={handleConfirmLeave}
              className="bg-red-600 hover:bg-red-700"
            >
              {t('common.leaveAnyway', { defaultValue: 'Leave Anyway' })}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}

/**
 * Hook to manage unsaved changes state
 * Use this in components that need to track unsaved changes
 */
export function useUnsavedChanges() {
  const hasUnsavedChanges = useAppStore((s) => s.navigationState.hasUnsavedChanges);
  const setHasUnsavedChanges = useAppStore((s) => s.setHasUnsavedChanges);

  const markAsUnsaved = useCallback(() => {
    setHasUnsavedChanges(true);
  }, [setHasUnsavedChanges]);

  const markAsSaved = useCallback(() => {
    setHasUnsavedChanges(false);
  }, [setHasUnsavedChanges]);

  return {
    hasUnsavedChanges,
    markAsUnsaved,
    markAsSaved,
    setHasUnsavedChanges,
  };
}

export default UnsavedChangesGuard;
</file>

<file path="router/index.tsx">
/**
 * Router configuration for LyricLens
 * Requirements: 2.1 - Use React Router for all navigation
 * Requirements: 2.2 - Support routes: / (Home), /studio (Studio), /visualizer (Visualizer)
 * Requirements: 5.1 - Show NotFound page for invalid routes
 */

import { Suspense, lazy } from 'react';
import {
  BrowserRouter,
  Routes,
  Route,
} from 'react-router-dom';
import { RouteLayout } from './RouteLayout';

// Lazy load screen components for code splitting
const HomeScreen = lazy(() => import('../screens/HomeScreen'));
const StudioScreen = lazy(() => import('../screens/StudioScreen'));
const VisualizerScreen = lazy(() => import('../screens/VisualizerScreen'));
const ProjectsScreen = lazy(() => import('../screens/ProjectsScreen'));
const GradientGeneratorScreen = lazy(() => import('../screens/GradientGeneratorScreen'));
const SettingsScreen = lazy(() => import('../screens/SettingsScreen'));
const SignInScreen = lazy(() => import('../screens/SignInScreen'));
const NotFoundScreen = lazy(() => import('../screens/NotFoundScreen'));

// Loading fallback component
function LoadingFallback() {
  return (
    <div className="flex items-center justify-center min-h-screen">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
    </div>
  );
}

/**
 * Main router component with all route definitions
 */
export function AppRouter() {
  return (
    <BrowserRouter>
      <Suspense fallback={<LoadingFallback />}>
        <Routes>
          <Route element={<RouteLayout />}>
            {/* Home route - default landing page */}
            <Route path="/" element={<HomeScreen />} />

            {/* Projects route - user's project dashboard */}
            <Route path="/projects" element={<ProjectsScreen />} />

            {/* Studio route - unified creation workspace */}
            <Route path="/studio" element={<StudioScreen />} />

            {/* Visualizer route - audio-first lyric videos */}
            <Route path="/visualizer" element={<VisualizerScreen />} />

            {/* Gradient Generator route - CSS gradient creation tool */}
            <Route path="/gradient-generator" element={<GradientGeneratorScreen />} />

            {/* Settings route - API key management */}
            <Route path="/settings" element={<SettingsScreen />} />

            {/* Sign-in route - authentication page */}
            <Route path="/signin" element={<SignInScreen />} />

            {/* Catch-all: show 404 page for invalid routes (Requirement 5.1) */}
            <Route path="*" element={<NotFoundScreen />} />
          </Route>
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

export { routes, getRouteByPath, isValidRoute } from './routes';
export { UnsavedChangesGuard, useUnsavedChanges } from './guards';
</file>

<file path="router/RouteLayout.tsx">
/**
 * Route layout wrapper component
 * Requirements: 2.2 - Handle document title updates per route
 */

import React, { useEffect } from 'react';
import { Outlet, useLocation } from 'react-router-dom';
import { useTranslation } from 'react-i18next';
import { getRouteByPath } from './routes';
import { Sidebar } from '@/components/layout/Sidebar';
import { useLanguage } from '@/i18n/useLanguage';
import { cn } from '@/lib/utils';

/**
 * Layout wrapper that applies to all routes
 * - Updates document title based on current route
 * - Provides consistent layout structure with Sidebar
 */
export function RouteLayout() {
  const location = useLocation();
  const { t } = useTranslation();
  const { isRTL } = useLanguage();

  // Update document title when route changes
  useEffect(() => {
    const routeConfig = getRouteByPath(location.pathname);
    if (routeConfig) {
      const translatedTitle = t(routeConfig.title);
      document.title = `${translatedTitle} | LyricLens`;
    } else {
      document.title = 'LyricLens';
    }
  }, [location.pathname, t]);

  return (
    <div className={cn('flex min-h-screen', isRTL && 'flex-row-reverse')}>
      {/* Sidebar Navigation */}
      <aside
        className="w-16 shrink-0 bg-[#0a0a0f]/80 backdrop-blur-xl border-white/5 z-30"
        style={{ borderInlineEnd: '1px solid rgba(255,255,255,0.05)' }}
      >
        <div className="sticky top-0 h-screen py-4 px-2">
          <Sidebar />
        </div>
      </aside>

      {/* Main Content */}
      <main className="flex-1 min-h-screen overflow-x-hidden">
        <Outlet />
      </main>
    </div>
  );
}
</file>

<file path="router/routes.ts">
/**
 * Route definitions for LyricLens application
 * Requirements: 2.2 - Support routes: / (Home), /studio (Studio), /visualizer (Visualizer)
 */

export interface RouteConfig {
  path: string;
  title: string; // i18n key for document title
  meta?: {
    requiresAuth?: boolean;
    preserveState?: boolean;
  };
}

export const routes: RouteConfig[] = [
  {
    path: '/',
    title: 'nav.home',
  },
  {
    path: '/projects',
    title: 'nav.projects',
    meta: { requiresAuth: true },
  },
  {
    path: '/studio',
    title: 'nav.studio',
    meta: { preserveState: true },
  },
  {
    path: '/visualizer',
    title: 'nav.visualizer',
    meta: { preserveState: true },
  },
  {
    path: '/gradient-generator',
    title: 'nav.gradientGenerator',
  },
  {
    path: '/settings',
    title: 'nav.settings',
  },
];

/**
 * Get route config by path
 */
export function getRouteByPath(path: string): RouteConfig | undefined {
  return routes.find((route) => route.path === path);
}

/**
 * Check if a path is a valid route
 */
export function isValidRoute(path: string): boolean {
  return routes.some((route) => route.path === path);
}
</file>

<file path="screens/GradientGeneratorScreen.tsx">
/**
 * Gradient Generator Screen - CSS gradient creation tool
 * Provides a full-screen interface for creating and exporting CSS gradients
 */

import React from 'react';
import { useNavigate } from 'react-router-dom';
import { motion } from 'framer-motion';
import { Palette, Sparkles } from 'lucide-react';
import { useLanguage } from '@/i18n/useLanguage';
import { cn } from '@/lib/utils';
import { ScreenLayout } from '@/components/layout/ScreenLayout';
import { GradientGenerator } from '@/components/gradient-generator';

export default function GradientGeneratorScreen() {
  const { t, isRTL } = useLanguage();
  const navigate = useNavigate();

  return (
    <ScreenLayout
      title={t('nav.gradientGenerator') || 'Gradient Generator'}
      showBackButton
      onBack={() => navigate('/')}
      maxWidth="full"
      contentClassName="py-6"
    >
      {/* Header Section */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="mb-8 text-center"
      >
        <div className={cn('flex items-center justify-center gap-3 mb-4', isRTL && 'flex-row-reverse')}>
          <div className="w-14 h-14 rounded-xl bg-gradient-to-br from-violet-500 to-purple-600 flex items-center justify-center shadow-lg shadow-violet-500/30">
            <Palette className="w-7 h-7 text-white" aria-hidden="true" />
          </div>
          <div className={cn('text-left', isRTL && 'text-right')}>
            <h1 className="text-2xl md:text-3xl font-bold text-white">
              {t('nav.gradientGenerator') || 'Gradient Generator'}
            </h1>
            <p className="text-sm text-white/60">
              Create beautiful CSS gradients with ease
            </p>
          </div>
        </div>
      </motion.div>

      {/* Gradient Generator Component */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.1 }}
      >
        <GradientGenerator
          showPresets={true}
          showExportPanel={true}
          maxColorStops={10}
          minColorStops={2}
          enableAnimation={false}
        />
      </motion.div>

      {/* Footer Info */}
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ delay: 0.2 }}
        className="mt-8 text-center text-sm text-white/40"
      >
        <div className={cn('flex items-center justify-center gap-2', isRTL && 'flex-row-reverse')}>
          <Sparkles className="w-4 h-4" />
          <span>Create, customize, and export CSS gradients for your projects</span>
        </div>
      </motion.div>
    </ScreenLayout>
  );
}
</file>

<file path="screens/HomeScreen.tsx">
/**
 * Home Screen - Landing page with creation mode selection
 * Requirements: 1.1, 1.2 - Display Home screen as default with 3 main screens
 * Requirements: 7.1, 7.2 - Display max 3 creation mode cards and navigate on selection
 * Requirements: 9.1 - Use semantic HTML elements (nav, main, header, footer)
 */

import React, { useEffect, useRef } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { motion } from 'framer-motion';
import { Video, Music, AudioWaveform, Film } from 'lucide-react';
import { useLanguage } from '@/i18n/useLanguage';
import { cn } from '@/lib/utils';
import { Header } from '@/components/layout/Header';
import { ForwardChevron } from '@/components/layout/DirectionalIcon';
import {
  staggerContainer,
  staggerItem,
} from '@/lib/cinematicMotion';

// Creation mode card data with cinematic palette
const CREATION_MODES = [
  {
    id: 'video' as const,
    titleKey: 'home.createVideo',
    descKey: 'home.createVideoDesc',
    featuresKey: 'home.features.video',
    icon: Video,
    accentColor: 'var(--cinema-spotlight)',
    accentGlow: 'var(--glow-spotlight)',
    route: '/studio?mode=video',
  },
  {
    id: 'music' as const,
    titleKey: 'home.createMusic',
    descKey: 'home.createMusicDesc',
    featuresKey: 'home.features.music',
    icon: Music,
    accentColor: 'var(--cinema-editorial)',
    accentGlow: 'var(--glow-velvet)',
    route: '/studio?mode=music',
  },
  {
    id: 'visualizer' as const,
    titleKey: 'home.visualizer',
    descKey: 'home.visualizerDesc',
    featuresKey: 'home.features.visualizer',
    icon: AudioWaveform,
    accentColor: 'var(--primary)',
    accentGlow: 'var(--glow-primary)',
    route: '/visualizer',
  },
];

export default function HomeScreen() {
  const { t, isRTL } = useLanguage();
  const navigate = useNavigate();
  const location = useLocation();
  const mainContentRef = useRef<HTMLElement>(null);

  // Focus main content on navigation (Requirement 9.4)
  useEffect(() => {
    const timer = setTimeout(() => {
      mainContentRef.current?.focus();
    }, 100);
    return () => clearTimeout(timer);
  }, [location.pathname]);

  const handleModeSelect = (route: string) => {
    navigate(route);
  };

  return (
    <div className="min-h-screen bg-background text-foreground overflow-hidden flex flex-col">
      {/* Cinematic background */}
      <div className="fixed inset-0 pointer-events-none" aria-hidden="true">
        <div
          className="absolute top-[-20%] left-[10%] w-[600px] h-[600px] rounded-full blur-[180px] opacity-20"
          style={{ background: 'var(--cinema-spotlight)' }}
        />
        <div
          className="absolute bottom-[-10%] right-[15%] w-[500px] h-[500px] rounded-full blur-[160px] opacity-10"
          style={{ background: 'var(--primary)' }}
        />
        <div
          className="absolute top-[40%] right-[5%] w-[300px] h-[300px] rounded-full blur-[120px] opacity-8"
          style={{ background: 'var(--cinema-velvet)' }}
        />
      </div>

      {/* Content */}
      <div className="relative z-10 flex flex-col flex-1">
        {/* Header */}
        <div className="p-4 md:p-6">
          <Header />
        </div>

        {/* Main Content */}
        <main
          id="main-content"
          ref={mainContentRef}
          className="flex-1 flex items-center justify-center p-4 md:p-6"
          tabIndex={-1}
          aria-label={t('home.title')}
        >
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ duration: 0.8, ease: [0.22, 1, 0.36, 1] }}
            className="max-w-5xl w-full"
          >
            {/* Title Block */}
            <div className={cn('text-center mb-12 md:mb-16', isRTL && 'rtl')}>
              <motion.div
                initial={{ opacity: 0, y: 16 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.1, duration: 0.6, ease: [0.22, 1, 0.36, 1] }}
                className="flex items-center justify-center gap-3 mb-6"
              >
                <div
                  className="w-12 h-12 md:w-14 md:h-14 rounded-xl flex items-center justify-center"
                  style={{
                    background: 'linear-gradient(135deg, var(--cinema-spotlight), oklch(0.65 0.12 70))',
                    boxShadow: '0 4px 24px var(--glow-spotlight)',
                  }}
                >
                  <Film className="w-6 h-6 md:w-7 md:h-7 text-[var(--cinema-void)]" aria-hidden="true" />
                </div>
              </motion.div>

              <motion.h1
                initial={{ opacity: 0, y: 12 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.2, duration: 0.6, ease: [0.22, 1, 0.36, 1] }}
                className="heading-hero mb-4"
              >
                {t('home.title')}
              </motion.h1>

              <motion.p
                initial={{ opacity: 0, y: 8 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.3, duration: 0.5, ease: [0.22, 1, 0.36, 1] }}
                className="text-body-editorial max-w-2xl mx-auto"
              >
                {t('home.subtitle')}
              </motion.p>
            </div>

            {/* Mode Cards */}
            <nav aria-label={t('a11y.mainNav')}>
              <motion.div
                variants={staggerContainer}
                initial="initial"
                animate="animate"
                className="grid grid-cols-1 md:grid-cols-3 gap-5 md:gap-6"
                role="list"
              >
                {CREATION_MODES.map((mode) => {
                  const Icon = mode.icon;
                  const features = t(mode.featuresKey, { returnObjects: true }) as string[];
                  return (
                    <motion.button
                      key={mode.id}
                      variants={staggerItem}
                      onClick={() => handleModeSelect(mode.route)}
                      whileHover={{ y: -6, transition: { duration: 0.3, ease: [0.22, 1, 0.36, 1] } }}
                      whileTap={{ scale: 0.98 }}
                      className={cn(
                        'group relative surface-card p-6 md:p-7 text-start',
                        'focus:outline-none focus-visible:ring-2 focus-visible:ring-[var(--cinema-spotlight)]/50 focus-visible:ring-offset-2 focus-visible:ring-offset-background',
                        isRTL && 'text-right'
                      )}
                      style={{
                        ['--card-accent' as string]: mode.accentColor,
                      }}
                      aria-label={`${t(mode.titleKey)} - ${t(mode.descKey)}`}
                      role="listitem"
                    >
                      {/* Top accent line */}
                      <div
                        className="absolute top-0 left-4 right-4 h-px opacity-0 group-hover:opacity-100 transition-opacity duration-500"
                        style={{ background: `linear-gradient(90deg, transparent, ${mode.accentColor}, transparent)` }}
                      />

                      {/* Icon */}
                      <div
                        className="w-11 h-11 rounded-lg flex items-center justify-center mb-5 transition-all duration-300 group-hover:shadow-lg"
                        style={{
                          background: `color-mix(in oklch, ${mode.accentColor}, transparent 88%)`,
                          border: `1px solid color-mix(in oklch, ${mode.accentColor}, transparent 75%)`,
                        }}
                        aria-hidden="true"
                      >
                        <Icon
                          className="w-5 h-5 transition-colors duration-300"
                          style={{ color: mode.accentColor }}
                        />
                      </div>

                      {/* Title & Description */}
                      <h3 className="heading-card mb-2 transition-colors duration-300">
                        {t(mode.titleKey)}
                      </h3>
                      <p className="text-body-editorial text-sm mb-5 leading-relaxed">
                        {t(mode.descKey)}
                      </p>

                      {/* Features */}
                      <div
                        className={cn('flex flex-wrap gap-2', isRTL && 'justify-end')}
                        aria-label="Features"
                      >
                        {Array.isArray(features) &&
                          features.map((feature: string, i: number) => (
                            <span
                              key={i}
                              className="px-2.5 py-1 text-[11px] font-editorial font-medium rounded-md transition-colors duration-200"
                              style={{
                                background: 'rgba(255,255,255,0.04)',
                                border: '1px solid rgba(255,255,255,0.06)',
                                color: 'oklch(0.70 0.02 60)',
                              }}
                            >
                              {feature}
                            </span>
                          ))}
                      </div>

                      {/* Arrow indicator */}
                      <div
                        className={cn(
                          'absolute top-7 opacity-0 group-hover:opacity-100 transition-all duration-300 group-hover:translate-x-1',
                          isRTL ? 'left-6 group-hover:-translate-x-1' : 'right-6'
                        )}
                        aria-hidden="true"
                      >
                        <ForwardChevron size={18} className="text-[var(--cinema-silver)]/60" />
                      </div>
                    </motion.button>
                  );
                })}
              </motion.div>
            </nav>
          </motion.div>
        </main>

        {/* Footer */}
        <footer className="p-4 md:p-6 text-center">
          <span className="text-caption-mono">
            Powered by Gemini AI & Suno
          </span>
        </footer>
      </div>
    </div>
  );
}
</file>

<file path="screens/index.ts">
/**
 * Screen components barrel export
 */

export { default as HomeScreen } from './HomeScreen';
export { default as StudioScreen, parseStudioParams } from './StudioScreen';
export type { StudioParams } from './StudioScreen';
export { default as VisualizerScreen } from './VisualizerScreen';
export { default as SettingsScreen } from './SettingsScreen';
export { default as GradientGeneratorScreen } from './GradientGeneratorScreen';
export { default as NotFoundScreen } from './NotFoundScreen';
</file>

<file path="screens/NotFoundScreen.tsx">
/**
 * NotFound Screen - 404 error page for invalid routes
 * Requirements: 5.1 - Display NotFound page for invalid routes
 * Requirements: 5.2, 5.3, 5.4 - Display 404 message, home button, and use design system
 * Requirements: 5.5 - Support i18n translations
 */

import React from 'react';
import { useNavigate } from 'react-router-dom';
import { motion } from 'framer-motion';
import { Home, AlertCircle } from 'lucide-react';
import { useLanguage } from '@/i18n/useLanguage';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

export default function NotFoundScreen() {
  const { t, isRTL } = useLanguage();
  const navigate = useNavigate();

  const handleGoHome = () => {
    navigate('/');
  };

  return (
    <div className="min-h-screen bg-[#0a0a0f] text-white overflow-hidden flex items-center justify-center">
      {/* Background gradient */}
      <div className="fixed inset-0 pointer-events-none" aria-hidden="true">
        <div className="absolute top-1/4 left-1/4 w-96 h-96 bg-red-500/10 rounded-full blur-[128px]" />
        <div className="absolute bottom-1/4 right-1/4 w-96 h-96 bg-orange-500/10 rounded-full blur-[128px]" />
      </div>

      {/* Content */}
      <div className="relative z-10 p-4 md:p-6">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className={cn(
            "max-w-md w-full text-center",
            isRTL && "rtl"
          )}
        >
          {/* Glass panel container */}
          <div className="p-8 md:p-12 rounded-2xl bg-white/5 backdrop-blur-sm border border-white/10">
            {/* Icon */}
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ delay: 0.2, type: "spring", stiffness: 200 }}
              className="flex justify-center mb-6"
            >
              <div className="w-20 h-20 rounded-full bg-gradient-to-br from-red-500/20 to-orange-500/20 flex items-center justify-center border border-red-500/30">
                <AlertCircle className="w-10 h-10 text-red-400" aria-hidden="true" />
              </div>
            </motion.div>

            {/* 404 Heading */}
            <motion.h1
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 0.3 }}
              className="text-6xl md:text-7xl font-bold mb-4 bg-gradient-to-br from-red-400 to-orange-400 bg-clip-text text-transparent"
            >
              404
            </motion.h1>

            {/* Error message */}
            <motion.p
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 0.4 }}
              className="text-lg md:text-xl text-white/80 mb-8"
            >
              {t('errors.notFound')}
            </motion.p>

            {/* Home button */}
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ delay: 0.5 }}
            >
              <Button
                onClick={handleGoHome}
                size="lg"
                className="bg-gradient-to-r from-violet-500 to-purple-600 hover:from-violet-600 hover:to-purple-700 text-white"
                aria-label={t('nav.home')}
              >
                <Home className="w-5 h-5" aria-hidden="true" />
                {t('nav.home')}
              </Button>
            </motion.div>
          </div>
        </motion.div>
      </div>
    </div>
  );
}
</file>

<file path="screens/ProjectsScreen.tsx">
/**
 * Projects Screen - User's Project Dashboard
 *
 * Displays all user projects in a grid with:
 * - Search and filter capabilities
 * - Create new project options
 * - Recent projects section
 * - Favorite projects section
 */

import React, { useEffect, useState, useMemo, useRef } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Plus,
  Search,
  Folder,
  Video,
  Film,
  AudioWaveform,
  Star,
  Clock,
  Grid3X3,
  List,
  SortAsc,
  SortDesc,
  Loader2,
  FolderOpen,
  Sparkles,
} from 'lucide-react';
import { useLanguage } from '@/i18n/useLanguage';
import { cn } from '@/lib/utils';
import { Header } from '@/components/layout/Header';
import { ProjectCard } from '@/components/projects/ProjectCard';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import {
  listUserProjects,
  deleteProject,
  toggleFavorite,
  createProject,
  type Project,
  type ProjectType,
} from '@/services/projectService';
import { useAuth } from '@/hooks/useAuth';

type SortField = 'updatedAt' | 'createdAt' | 'title';
type SortOrder = 'asc' | 'desc';
type FilterType = 'all' | ProjectType;
type ViewMode = 'grid' | 'list';

const CREATE_OPTIONS: Array<{
  type: ProjectType;
  icon: typeof Video;
  titleKey: string;
  gradient: string;
  iconColor: string;
}> = [
  {
    type: 'production',
    icon: Video,
    titleKey: 'projects.createVideo',
    gradient: 'from-primary/80 to-primary/40',
    iconColor: 'text-primary',
  },
  {
    type: 'story',
    icon: Film,
    titleKey: 'projects.createStory',
    gradient: 'from-accent/80 to-accent/40',
    iconColor: 'text-accent',
  },
  {
    type: 'visualizer',
    icon: AudioWaveform,
    titleKey: 'projects.createVisualizer',
    gradient: 'from-ring/80 to-ring/40',
    iconColor: 'text-ring',
  },
];

export default function ProjectsScreen() {
  const { t, isRTL } = useLanguage();
  const navigate = useNavigate();
  const location = useLocation();
  const mainContentRef = useRef<HTMLElement>(null);

  // State
  const [projects, setProjects] = useState<Project[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [filterType, setFilterType] = useState<FilterType>('all');
  const [sortField, setSortField] = useState<SortField>('updatedAt');
  const [sortOrder, setSortOrder] = useState<SortOrder>('desc');
  const [viewMode, setViewMode] = useState<ViewMode>('grid');
  const [isCreating, setIsCreating] = useState(false);

  // Check authentication
  const { user, isAuthenticated, isLoading: authLoading } = useAuth();

  // Redirect to sign in if not authenticated (only after auth check completes)
  useEffect(() => {
    if (!authLoading && !isAuthenticated) {
      navigate('/signin', { state: { from: location.pathname } });
    }
  }, [authLoading, isAuthenticated, navigate, location]);

  // Focus main content on navigation
  useEffect(() => {
    const timer = setTimeout(() => {
      mainContentRef.current?.focus();
    }, 100);
    return () => clearTimeout(timer);
  }, [location.pathname]);

  // Load projects (only when authenticated)
  useEffect(() => {
    async function loadProjects() {
      if (!isAuthenticated) return;

      setIsLoading(true);
      setError(null);

      try {
        const userProjects = await listUserProjects(100);
        setProjects(userProjects);
      } catch (err) {
        console.error('[ProjectsScreen] Failed to load projects:', err);
        setError(t('projects.loadError') || 'Failed to load projects');
      } finally {
        setIsLoading(false);
      }
    }

    loadProjects();
  }, [isAuthenticated, t]);

  // Filtered and sorted projects
  const filteredProjects = useMemo(() => {
    let result = [...projects];

    // Apply search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(
        (p) =>
          p.title.toLowerCase().includes(query) ||
          p.topic?.toLowerCase().includes(query) ||
          p.description?.toLowerCase().includes(query)
      );
    }

    // Apply type filter
    if (filterType !== 'all') {
      result = result.filter((p) => p.type === filterType);
    }

    // Apply sorting
    result.sort((a, b) => {
      let comparison = 0;

      if (sortField === 'title') {
        comparison = a.title.localeCompare(b.title);
      } else if (sortField === 'createdAt') {
        comparison = a.createdAt.getTime() - b.createdAt.getTime();
      } else {
        comparison = a.updatedAt.getTime() - b.updatedAt.getTime();
      }

      return sortOrder === 'desc' ? -comparison : comparison;
    });

    return result;
  }, [projects, searchQuery, filterType, sortField, sortOrder]);

  // Recent projects (last 5 accessed)
  const recentProjects = useMemo(() => {
    return [...projects]
      .filter((p) => p.lastAccessedAt)
      .sort((a, b) => {
        const aTime = a.lastAccessedAt?.getTime() || 0;
        const bTime = b.lastAccessedAt?.getTime() || 0;
        return bTime - aTime;
      })
      .slice(0, 5);
  }, [projects]);

  // Favorite projects
  const favoriteProjects = useMemo(() => {
    return projects.filter((p) => p.isFavorite);
  }, [projects]);

  // Handlers
  const handleCreateProject = async (type: ProjectType) => {
    setIsCreating(true);

    try {
      const title =
        type === 'production'
          ? 'New Video'
          : type === 'story'
            ? 'New Story'
            : 'New Visualizer';

      const project = await createProject({
        title,
        type,
      });

      if (project) {
        // Navigate to the appropriate screen with the new project
        const routes: Record<ProjectType, string> = {
          production: '/studio?mode=video',
          story: '/studio?mode=story',
          visualizer: '/visualizer',
        };

        const route = routes[type];
        const separator = route.includes('?') ? '&' : '?';
        navigate(`${route}${separator}projectId=${project.id}`);
      }
    } catch (err) {
      console.error('[ProjectsScreen] Failed to create project:', err);
      setError(t('projects.createError') || 'Failed to create project');
    } finally {
      setIsCreating(false);
    }
  };

  const handleDeleteProject = async (projectId: string) => {
    const success = await deleteProject(projectId);
    if (success) {
      setProjects((prev) => prev.filter((p) => p.id !== projectId));
    }
  };

  const handleToggleFavorite = async (projectId: string) => {
    const success = await toggleFavorite(projectId);
    if (success) {
      setProjects((prev) =>
        prev.map((p) =>
          p.id === projectId ? { ...p, isFavorite: !p.isFavorite } : p
        )
      );
    }
  };

  const toggleSortOrder = () => {
    setSortOrder((prev) => (prev === 'asc' ? 'desc' : 'asc'));
  };

  // Render loading state
  if (isLoading) {
    return (
      <div className="min-h-screen bg-background text-foreground flex items-center justify-center">
        <div className="flex flex-col items-center gap-4">
          <Loader2 className="w-8 h-8 animate-spin text-primary" />
          <p className="text-muted-foreground font-editorial">{t('projects.loading') || 'Loading projects...'}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background text-foreground overflow-hidden flex flex-col">
      {/* Background ambient glow */}
      <div className="fixed inset-0 pointer-events-none" aria-hidden="true">
        <div
          className="absolute top-[-10%] left-[10%] w-[50%] h-[50%] rounded-full blur-[160px] mix-blend-screen"
          style={{ backgroundColor: 'oklch(0.70 0.15 190 / 0.08)' }}
        />
        <div
          className="absolute bottom-[-10%] right-[10%] w-[40%] h-[40%] rounded-full blur-[140px] mix-blend-screen"
          style={{ backgroundColor: 'oklch(0.65 0.25 30 / 0.05)' }}
        />
      </div>

      {/* Content */}
      <div className="relative z-10 flex flex-col flex-1">
        {/* Header */}
        <div className="p-4 md:p-6">
          <Header />
        </div>

        {/* Main Content */}
        <main
          id="main-content"
          ref={mainContentRef}
          className="flex-1 px-4 md:px-6 pb-6 overflow-auto"
          tabIndex={-1}
          aria-label={t('projects.title') || 'My Projects'}
        >
          <div className="max-w-7xl mx-auto">
            {/* Page Title & Create Button */}
            <motion.div
              initial={{ opacity: 0, y: 12 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5, ease: [0.22, 1, 0.36, 1] }}
              className={cn(
                'flex flex-col sm:flex-row sm:items-center justify-between gap-4 mb-8',
                isRTL && 'sm:flex-row-reverse'
              )}
            >
              <div className={cn(isRTL && 'text-right')}>
                <h1 className="text-2xl md:text-3xl font-display font-bold flex items-center gap-3 text-foreground">
                  <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-primary/20 to-accent/10 border border-border flex items-center justify-center">
                    <Folder className="w-5 h-5 text-primary" />
                  </div>
                  {t('projects.title') || 'My Projects'}
                </h1>
                <p className="text-muted-foreground mt-1.5 font-editorial text-sm">
                  {projects.length} {projects.length === 1 ? 'project' : 'projects'}
                </p>
              </div>

              {/* Create New Dropdown */}
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    disabled={isCreating}
                    className="bg-primary hover:bg-primary/90 text-primary-foreground shadow-lg shadow-primary/20"
                  >
                    {isCreating ? (
                      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    ) : (
                      <Plus className="w-4 h-4 mr-2" />
                    )}
                    {t('projects.create') || 'Create New'}
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end" className="w-56">
                  {CREATE_OPTIONS.map((option) => {
                    const Icon = option.icon;
                    return (
                      <DropdownMenuItem
                        key={option.type}
                        onClick={() => handleCreateProject(option.type)}
                        className="cursor-pointer"
                      >
                        <div
                          className={cn(
                            'w-8 h-8 rounded-lg flex items-center justify-center mr-3',
                            'bg-gradient-to-br',
                            option.gradient
                          )}
                        >
                          <Icon className="w-4 h-4 text-white" />
                        </div>
                        {t(option.titleKey) || option.type}
                      </DropdownMenuItem>
                    );
                  })}
                </DropdownMenuContent>
              </DropdownMenu>
            </motion.div>

            {/* Error Display */}
            {error && (
              <div className="mb-6 p-4 rounded-xl bg-destructive/10 border border-destructive/20 text-destructive">
                {error}
              </div>
            )}

            {/* Show Recent & Favorites if there are projects */}
            {projects.length > 0 && (
              <>
                {/* Favorites Section */}
                {favoriteProjects.length > 0 && (
                  <motion.section
                    initial={{ opacity: 0, y: 12 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.5, delay: 0.1 }}
                    className="mb-10"
                  >
                    <h2
                      className={cn(
                        'text-sm font-editorial font-semibold mb-4 flex items-center gap-2 text-muted-foreground uppercase tracking-wider',
                        isRTL && 'flex-row-reverse'
                      )}
                    >
                      <Star className="w-4 h-4 text-accent fill-accent" />
                      {t('projects.favorites') || 'Favorites'}
                    </h2>
                    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                      <AnimatePresence mode="popLayout">
                        {favoriteProjects.slice(0, 4).map((project) => (
                          <ProjectCard
                            key={project.id}
                            project={project}
                            onDelete={handleDeleteProject}
                            onToggleFavorite={handleToggleFavorite}
                          />
                        ))}
                      </AnimatePresence>
                    </div>
                  </motion.section>
                )}

                {/* Recent Section */}
                {recentProjects.length > 0 && (
                  <motion.section
                    initial={{ opacity: 0, y: 12 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.5, delay: 0.15 }}
                    className="mb-10"
                  >
                    <h2
                      className={cn(
                        'text-sm font-editorial font-semibold mb-4 flex items-center gap-2 text-muted-foreground uppercase tracking-wider',
                        isRTL && 'flex-row-reverse'
                      )}
                    >
                      <Clock className="w-4 h-4 text-primary" />
                      {t('projects.recent') || 'Recent'}
                    </h2>
                    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4">
                      <AnimatePresence mode="popLayout">
                        {recentProjects.map((project) => (
                          <ProjectCard
                            key={project.id}
                            project={project}
                            onDelete={handleDeleteProject}
                            onToggleFavorite={handleToggleFavorite}
                          />
                        ))}
                      </AnimatePresence>
                    </div>
                  </motion.section>
                )}
              </>
            )}

            {/* All Projects Section */}
            <motion.section
              initial={{ opacity: 0, y: 12 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5, delay: 0.2 }}
            >
              <div
                className={cn(
                  'flex flex-col sm:flex-row sm:items-center justify-between gap-4 mb-4',
                  isRTL && 'sm:flex-row-reverse'
                )}
              >
                <h2
                  className={cn(
                    'text-sm font-editorial font-semibold flex items-center gap-2 text-muted-foreground uppercase tracking-wider',
                    isRTL && 'flex-row-reverse'
                  )}
                >
                  <FolderOpen className="w-4 h-4" />
                  {t('projects.allProjects') || 'All Projects'}
                </h2>

                {/* Filters & Search */}
                <div
                  className={cn(
                    'flex flex-wrap items-center gap-2',
                    isRTL && 'flex-row-reverse'
                  )}
                >
                  {/* Search */}
                  <div className="relative">
                    <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground" />
                    <Input
                      type="text"
                      placeholder={t('projects.search') || 'Search...'}
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      className="pl-9 w-48 bg-secondary border-border"
                    />
                  </div>

                  {/* Type Filter */}
                  <Select
                    value={filterType}
                    onValueChange={(value) => setFilterType(value as FilterType)}
                  >
                    <SelectTrigger className="w-32 bg-secondary border-border">
                      <SelectValue placeholder="All types" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">All types</SelectItem>
                      <SelectItem value="production">Video</SelectItem>
                      <SelectItem value="story">Story</SelectItem>
                      <SelectItem value="visualizer">Visualizer</SelectItem>
                    </SelectContent>
                  </Select>

                  {/* Sort */}
                  <Select
                    value={sortField}
                    onValueChange={(value) => setSortField(value as SortField)}
                  >
                    <SelectTrigger className="w-32 bg-secondary border-border">
                      <SelectValue placeholder="Sort by" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="updatedAt">Last updated</SelectItem>
                      <SelectItem value="createdAt">Created</SelectItem>
                      <SelectItem value="title">Title</SelectItem>
                    </SelectContent>
                  </Select>

                  {/* Sort Order */}
                  <Button
                    variant="outline"
                    size="icon"
                    onClick={toggleSortOrder}
                    className="bg-secondary border-border"
                  >
                    {sortOrder === 'desc' ? (
                      <SortDesc className="w-4 h-4" />
                    ) : (
                      <SortAsc className="w-4 h-4" />
                    )}
                  </Button>

                  {/* View Mode */}
                  <div className="flex rounded-lg border border-border overflow-hidden">
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => setViewMode('grid')}
                      className={cn(
                        'rounded-none',
                        viewMode === 'grid' && 'bg-secondary'
                      )}
                    >
                      <Grid3X3 className="w-4 h-4" />
                    </Button>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => setViewMode('list')}
                      className={cn(
                        'rounded-none',
                        viewMode === 'list' && 'bg-secondary'
                      )}
                    >
                      <List className="w-4 h-4" />
                    </Button>
                  </div>
                </div>
              </div>

              {/* Projects Grid/List */}
              {filteredProjects.length > 0 ? (
                <div
                  className={cn(
                    viewMode === 'grid'
                      ? 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4'
                      : 'flex flex-col gap-2'
                  )}
                >
                  <AnimatePresence mode="popLayout">
                    {filteredProjects.map((project) => (
                      <ProjectCard
                        key={project.id}
                        project={project}
                        onDelete={handleDeleteProject}
                        onToggleFavorite={handleToggleFavorite}
                      />
                    ))}
                  </AnimatePresence>
                </div>
              ) : (
                <motion.div
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  className="py-20 text-center"
                >
                  {searchQuery || filterType !== 'all' ? (
                    <>
                      <div className="w-16 h-16 mx-auto mb-5 rounded-2xl bg-secondary border border-border flex items-center justify-center">
                        <Search className="w-7 h-7 text-muted-foreground" />
                      </div>
                      <p className="text-foreground/70 font-editorial">
                        {t('projects.noResults') || 'No projects found'}
                      </p>
                      <p className="text-muted-foreground text-sm mt-1.5">
                        {t('projects.tryDifferentSearch') ||
                          'Try a different search or filter'}
                      </p>
                    </>
                  ) : (
                    <>
                      <div className="w-20 h-20 mx-auto mb-6 rounded-2xl bg-gradient-to-br from-primary/10 to-accent/10 border border-border flex items-center justify-center">
                        <Sparkles className="w-9 h-9 text-primary/60" />
                      </div>
                      <p className="text-foreground/80 text-lg mb-2 font-display">
                        {t('projects.empty') || 'No projects yet'}
                      </p>
                      <p className="text-muted-foreground text-sm mb-8 max-w-sm mx-auto">
                        {t('projects.emptyHint') ||
                          'Create your first project to get started'}
                      </p>
                      <div className="flex justify-center gap-3">
                        {CREATE_OPTIONS.map((option) => {
                          const Icon = option.icon;
                          return (
                            <Button
                              key={option.type}
                              variant="outline"
                              onClick={() => handleCreateProject(option.type)}
                              className="bg-secondary border-border hover:bg-muted hover:border-primary/30 transition-all"
                            >
                              <Icon className={cn("w-4 h-4 mr-2", option.iconColor)} />
                              {t(option.titleKey) || option.type}
                            </Button>
                          );
                        })}
                      </div>
                    </>
                  )}
                </motion.div>
              )}
            </motion.section>
          </div>
        </main>
      </div>
    </div>
  );
}
</file>

<file path="screens/SettingsScreen.tsx">
/**
 * Settings Screen - API key management and app configuration
 * Requirements: Settings page for managing API keys and preferences
 */

import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { motion } from 'framer-motion';
import {
  Key,
  CheckCircle2,
  XCircle,
  ExternalLink,
  Copy,
  Eye,
  EyeOff,
  RefreshCw,
  Info,
  Sparkles,
  Video,
  Music,
  Volume2,
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { useLanguage } from '@/i18n/useLanguage';
import { ScreenLayout } from '@/components/layout/ScreenLayout';

// Import API status checkers
import { isDeApiConfigured, getImg2VideoWaitTime, getImg2VideoQueueLength } from '@/services/deapiService';

// ============================================================
// Types
// ============================================================

interface ApiKeyConfig {
  id: string;
  name: string;
  envVar: string;
  description: string;
  required: boolean;
  docsUrl: string;
  icon: React.ComponentType<{ className?: string }>;
  checkConfigured: () => boolean;
  features: string[];
}

// ============================================================
// API Key Configurations
// ============================================================

const API_KEYS: ApiKeyConfig[] = [
  {
    id: 'gemini',
    name: 'Google Gemini',
    envVar: 'VITE_GEMINI_API_KEY',
    description: 'Powers AI content generation, narration, and visual prompts',
    required: true,
    docsUrl: 'https://aistudio.google.com/apikey',
    icon: Sparkles,
    checkConfigured: () => {
      // @ts-ignore
      const key = import.meta.env?.VITE_GEMINI_API_KEY;
      return Boolean(key && key.trim().length > 0);
    },
    features: ['Content Planning', 'Narration (TTS)', 'Image Generation (Imagen)', 'Story Analysis'],
  },
  {
    id: 'deapi',
    name: 'DeAPI',
    envVar: 'VITE_DEAPI_API_KEY',
    description: 'Converts still images to animated video clips',
    required: false,
    docsUrl: 'https://deapi.ai',
    icon: Video,
    checkConfigured: isDeApiConfigured,
    features: ['Image-to-Video Animation', 'Motion Effects', 'Video Loops'],
  },
  {
    id: 'suno',
    name: 'Suno',
    envVar: 'VITE_SUNO_API_KEY',
    description: 'AI-powered music and song generation',
    required: false,
    docsUrl: 'https://suno.ai',
    icon: Music,
    checkConfigured: () => {
      // @ts-ignore
      const key = import.meta.env?.VITE_SUNO_API_KEY;
      return Boolean(key && key.trim().length > 0);
    },
    features: ['Full Song Generation', 'Instrumental Tracks', 'Custom Lyrics'],
  },
  {
    id: 'freesound',
    name: 'Freesound',
    envVar: 'VITE_FREESOUND_API_KEY',
    description: 'Access to sound effects library for ambient audio',
    required: false,
    docsUrl: 'https://freesound.org/apiv2/apply/',
    icon: Volume2,
    checkConfigured: () => {
      // @ts-ignore
      const key = import.meta.env?.VITE_FREESOUND_API_KEY;
      return Boolean(key && key.trim().length > 0);
    },
    features: ['Ambient SFX', 'Sound Effects', 'Audio Transitions'],
  },
];

// ============================================================
// Components
// ============================================================

interface ApiKeyCardProps {
  config: ApiKeyConfig;
  isRTL: boolean;
}

function ApiKeyCard({ config, isRTL }: ApiKeyCardProps) {
  const [isConfigured, setIsConfigured] = useState(false);
  const [showEnvVar, setShowEnvVar] = useState(false);

  useEffect(() => {
    setIsConfigured(config.checkConfigured());
  }, [config]);

  const Icon = config.icon;

  const copyEnvVar = () => {
    navigator.clipboard.writeText(`${config.envVar}=your_api_key_here`);
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      className={cn(
        'p-5 rounded-xl border transition-all',
        isConfigured
          ? 'bg-emerald-500/5 border-emerald-500/20'
          : config.required
          ? 'bg-red-500/5 border-red-500/20'
          : 'bg-white/5 border-white/10'
      )}
    >
      {/* Header */}
      <div className={cn('flex items-start justify-between mb-3', isRTL && 'flex-row-reverse')}>
        <div className={cn('flex items-center gap-3', isRTL && 'flex-row-reverse')}>
          <div
            className={cn(
              'w-10 h-10 rounded-lg flex items-center justify-center',
              isConfigured ? 'bg-emerald-500/20' : 'bg-white/10'
            )}
          >
            <Icon className={cn('w-5 h-5', isConfigured ? 'text-emerald-400' : 'text-white/60')} />
          </div>
          <div>
            <h3 className="font-medium text-white flex items-center gap-2">
              {config.name}
              {config.required && (
                <span className="text-xs px-1.5 py-0.5 rounded bg-violet-500/20 text-violet-300">
                  Required
                </span>
              )}
            </h3>
            <p className="text-sm text-white/50">{config.description}</p>
          </div>
        </div>

        {/* Status Badge */}
        <div
          className={cn(
            'flex items-center gap-1.5 px-2 py-1 rounded-full text-xs font-medium',
            isConfigured ? 'bg-emerald-500/20 text-emerald-300' : 'bg-white/10 text-white/50'
          )}
        >
          {isConfigured ? (
            <>
              <CheckCircle2 className="w-3.5 h-3.5" />
              Configured
            </>
          ) : (
            <>
              <XCircle className="w-3.5 h-3.5" />
              Not Set
            </>
          )}
        </div>
      </div>

      {/* Features */}
      <div className={cn('flex flex-wrap gap-1.5 mb-4', isRTL && 'justify-end')}>
        {config.features.map((feature) => (
          <span
            key={feature}
            className="px-2 py-0.5 text-xs rounded-full bg-white/5 text-white/60"
          >
            {feature}
          </span>
        ))}
      </div>

      {/* Environment Variable */}
      <div className="p-3 rounded-lg bg-black/30 border border-white/5">
        <div className={cn('flex items-center justify-between mb-2', isRTL && 'flex-row-reverse')}>
          <span className="text-xs text-white/40">Environment Variable</span>
          <div className={cn('flex items-center gap-1', isRTL && 'flex-row-reverse')}>
            <button
              onClick={() => setShowEnvVar(!showEnvVar)}
              className="p-1 hover:bg-white/10 rounded transition-colors"
              title={showEnvVar ? 'Hide' : 'Show'}
            >
              {showEnvVar ? (
                <EyeOff className="w-3.5 h-3.5 text-white/40" />
              ) : (
                <Eye className="w-3.5 h-3.5 text-white/40" />
              )}
            </button>
            <button
              onClick={copyEnvVar}
              className="p-1 hover:bg-white/10 rounded transition-colors"
              title="Copy"
            >
              <Copy className="w-3.5 h-3.5 text-white/40" />
            </button>
          </div>
        </div>
        <code className="text-sm font-mono text-violet-300">
          {showEnvVar ? `${config.envVar}=your_api_key_here` : `${config.envVar}=‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢`}
        </code>
      </div>

      {/* Action Button */}
      <div className={cn('mt-4 flex items-center gap-2', isRTL && 'flex-row-reverse justify-end')}>
        <a
          href={config.docsUrl}
          target="_blank"
          rel="noopener noreferrer"
          className={cn(
            'inline-flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors',
            'bg-white/5 hover:bg-white/10 text-white/70 hover:text-white'
          )}
        >
          Get API Key
          <ExternalLink className="w-3.5 h-3.5" />
        </a>
      </div>
    </motion.div>
  );
}

// ============================================================
// Main Component
// ============================================================

export default function SettingsScreen() {
  const { t, isRTL } = useLanguage();
  const navigate = useNavigate();
  const [refreshKey, setRefreshKey] = useState(0);

  // DeAPI rate limit info
  const [deapiWaitTime, setDeapiWaitTime] = useState(0);
  const [deapiQueueLength, setDeapiQueueLength] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setDeapiWaitTime(getImg2VideoWaitTime());
      setDeapiQueueLength(getImg2VideoQueueLength());
    }, 1000);
    return () => clearInterval(interval);
  }, []);

  const handleRefresh = () => {
    setRefreshKey((k) => k + 1);
  };

  const configuredCount = API_KEYS.filter((k) => k.checkConfigured()).length;
  const requiredConfigured = API_KEYS.filter((k) => k.required && k.checkConfigured()).length;
  const requiredTotal = API_KEYS.filter((k) => k.required).length;

  return (
    <ScreenLayout
      title={t('nav.settings')}
      showBackButton
      onBack={() => navigate('/')}
      headerActions={
        <Button
          variant="ghost"
          size="sm"
          onClick={handleRefresh}
          className="text-white/50 hover:text-white"
        >
          <RefreshCw className="w-4 h-4 me-2" />
          Refresh
        </Button>
      }
      maxWidth="2xl"
      contentClassName="py-8"
    >
      {/* Status Overview */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        className="mb-8 p-6 rounded-xl bg-white/5 border border-white/10"
      >
        <div className={cn('flex items-center gap-4 mb-4', isRTL && 'flex-row-reverse')}>
          <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-violet-500/20 to-purple-500/20 flex items-center justify-center">
            <Key className="w-6 h-6 text-violet-400" />
          </div>
          <div>
            <h2 className="text-xl font-semibold text-white">API Configuration</h2>
            <p className="text-sm text-white/50">
              {configuredCount} of {API_KEYS.length} services configured
            </p>
          </div>
        </div>

        {/* Status Bars */}
        <div className="space-y-3">
          <div>
            <div className={cn('flex justify-between text-sm mb-1', isRTL && 'flex-row-reverse')}>
              <span className="text-white/60">Required APIs</span>
              <span className={requiredConfigured === requiredTotal ? 'text-emerald-400' : 'text-amber-400'}>
                {requiredConfigured}/{requiredTotal}
              </span>
            </div>
            <div className="h-2 bg-white/10 rounded-full overflow-hidden">
              <div
                className={cn(
                  'h-full transition-all duration-500',
                  requiredConfigured === requiredTotal ? 'bg-emerald-500' : 'bg-amber-500'
                )}
                style={{ width: `${(requiredConfigured / requiredTotal) * 100}%` }}
              />
            </div>
          </div>

          <div>
            <div className={cn('flex justify-between text-sm mb-1', isRTL && 'flex-row-reverse')}>
              <span className="text-white/60">Optional APIs</span>
              <span className="text-white/40">
                {configuredCount - requiredConfigured}/{API_KEYS.length - requiredTotal}
              </span>
            </div>
            <div className="h-2 bg-white/10 rounded-full overflow-hidden">
              <div
                className="h-full bg-violet-500 transition-all duration-500"
                style={{
                  width: `${((configuredCount - requiredConfigured) / (API_KEYS.length - requiredTotal)) * 100}%`,
                }}
              />
            </div>
          </div>
        </div>

        {/* DeAPI Rate Limit Status */}
        {isDeApiConfigured() && (deapiWaitTime > 0 || deapiQueueLength > 0) && (
          <div className="mt-4 p-3 rounded-lg bg-amber-500/10 border border-amber-500/20">
            <div className={cn('flex items-center gap-2 text-sm text-amber-300', isRTL && 'flex-row-reverse')}>
              <Info className="w-4 h-4" />
              <span>
                DeAPI Rate Limit: {deapiQueueLength > 0 ? `${deapiQueueLength} queued, ` : ''}
                {deapiWaitTime > 0 ? `~${deapiWaitTime}s until next request` : 'Ready'}
              </span>
            </div>
          </div>
        )}
      </motion.div>

      {/* Instructions */}
      <div className="mb-6 p-4 rounded-lg bg-blue-500/10 border border-blue-500/20">
        <div className={cn('flex items-start gap-3', isRTL && 'flex-row-reverse')}>
          <Info className="w-5 h-5 text-blue-400 shrink-0 mt-0.5" />
          <div className="text-sm text-blue-200/80">
            <p className="font-medium mb-1">How to configure API keys:</p>
            <ol className={cn('list-decimal list-inside space-y-1 text-blue-200/60', isRTL && 'text-right')}>
              <li>Create a <code className="px-1 py-0.5 rounded bg-blue-500/20">.env.local</code> file in the project root</li>
              <li>Add your API keys in the format shown below each service</li>
              <li>Restart the development server (<code className="px-1 py-0.5 rounded bg-blue-500/20">npm run dev:all</code>)</li>
            </ol>
          </div>
        </div>
      </div>

      {/* API Key Cards */}
      <div className="grid gap-4" key={refreshKey}>
        {API_KEYS.map((config) => (
          <ApiKeyCard key={config.id} config={config} isRTL={isRTL} />
        ))}
      </div>

      {/* Footer */}
      <div className="mt-8 text-center text-sm text-white/30">
        API keys are stored in environment variables for security.
        <br />
        They are never exposed to the browser or stored in localStorage.
      </div>
    </ScreenLayout>
  );
}
</file>

<file path="screens/SignInScreen.tsx">
/**
 * SignInScreen - Split-screen authentication page for AIsoul Studio
 *
 * Design: "Digital Soul Awakening"
 * Left: Animated neural mesh background with floating particles
 * Right: Refined dark minimalism with elegant typography
 */

import { useState, useEffect, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { Loader2, AlertCircle, Sparkles } from 'lucide-react';
import { useAuth } from '@/hooks/useAuth';
import { cn } from '@/lib/utils';

// Generate deterministic positions for neural nodes
function generateNodes(count: number, seed: number) {
  const nodes: Array<{ x: number; y: number; size: number; delay: number }> = [];
  for (let i = 0; i < count; i++) {
    const pseudoRandom = Math.sin(seed + i * 12.9898) * 43758.5453;
    const x = (pseudoRandom % 100 + 100) % 100;
    const y = ((pseudoRandom * 1.3) % 100 + 100) % 100;
    const size = 2 + (pseudoRandom % 4);
    const delay = (i * 0.2) % 3;
    nodes.push({ x, y, size, delay });
  }
  return nodes;
}

// Generate connections between nearby nodes
function generateConnections(nodes: Array<{ x: number; y: number }>) {
  const connections: Array<{ x1: number; y1: number; x2: number; y2: number; delay: number }> = [];
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      const dx = nodes[i]!.x - nodes[j]!.x;
      const dy = nodes[i]!.y - nodes[j]!.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance < 25 && connections.length < 20) {
        connections.push({
          x1: nodes[i]!.x,
          y1: nodes[i]!.y,
          x2: nodes[j]!.x,
          y2: nodes[j]!.y,
          delay: i * 0.1,
        });
      }
    }
  }
  return connections;
}

// Animated Neural Background Component
function NeuralBackground() {
  const nodes = useMemo(() => generateNodes(24, 42), []);
  const connections = useMemo(() => generateConnections(nodes), [nodes]);

  return (
    <div className="absolute inset-0 overflow-hidden">
      {/* Deep space gradient base */}
      <div className="absolute inset-0 bg-gradient-to-br from-[oklch(0.08_0.04_280)] via-[oklch(0.05_0.02_240)] to-[oklch(0.03_0.01_200)]" />

      {/* Animated mesh gradient blobs */}
      <motion.div
        className="absolute w-[600px] h-[600px] rounded-full opacity-30"
        style={{
          background: 'radial-gradient(circle, oklch(0.45 0.15 280 / 0.4) 0%, transparent 70%)',
          left: '10%',
          top: '20%',
          filter: 'blur(60px)',
        }}
        animate={{
          x: [0, 50, 0],
          y: [0, -30, 0],
          scale: [1, 1.2, 1],
        }}
        transition={{
          duration: 15,
          repeat: Infinity,
          ease: 'easeInOut',
        }}
      />
      <motion.div
        className="absolute w-[500px] h-[500px] rounded-full opacity-25"
        style={{
          background: 'radial-gradient(circle, oklch(0.50 0.18 190 / 0.5) 0%, transparent 70%)',
          right: '5%',
          bottom: '10%',
          filter: 'blur(80px)',
        }}
        animate={{
          x: [0, -40, 0],
          y: [0, 40, 0],
          scale: [1, 1.15, 1],
        }}
        transition={{
          duration: 18,
          repeat: Infinity,
          ease: 'easeInOut',
          delay: 2,
        }}
      />
      <motion.div
        className="absolute w-[400px] h-[400px] rounded-full opacity-20"
        style={{
          background: 'radial-gradient(circle, oklch(0.55 0.20 30 / 0.3) 0%, transparent 70%)',
          left: '50%',
          top: '60%',
          filter: 'blur(70px)',
        }}
        animate={{
          x: [0, 30, -20, 0],
          y: [0, -50, 20, 0],
          scale: [1, 1.1, 0.95, 1],
        }}
        transition={{
          duration: 20,
          repeat: Infinity,
          ease: 'easeInOut',
          delay: 5,
        }}
      />

      {/* Neural network connections */}
      <svg className="absolute inset-0 w-full h-full" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="lineGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="oklch(0.70 0.15 190 / 0.3)" />
            <stop offset="100%" stopColor="oklch(0.55 0.20 280 / 0.1)" />
          </linearGradient>
        </defs>
        {connections.map((conn, i) => (
          <motion.line
            key={i}
            x1={`${conn.x1}%`}
            y1={`${conn.y1}%`}
            x2={`${conn.x2}%`}
            y2={`${conn.y2}%`}
            stroke="url(#lineGradient)"
            strokeWidth="1"
            initial={{ pathLength: 0, opacity: 0 }}
            animate={{ pathLength: 1, opacity: [0, 0.6, 0.3] }}
            transition={{
              duration: 3,
              delay: conn.delay,
              repeat: Infinity,
              repeatType: 'reverse',
              ease: 'easeInOut',
            }}
          />
        ))}
      </svg>

      {/* Neural nodes */}
      {nodes.map((node, i) => (
        <motion.div
          key={i}
          className="absolute rounded-full"
          style={{
            width: node.size,
            height: node.size,
            left: `${node.x}%`,
            top: `${node.y}%`,
            background: i % 3 === 0
              ? 'oklch(0.70 0.15 190)'
              : i % 3 === 1
                ? 'oklch(0.60 0.18 280)'
                : 'oklch(0.65 0.12 30)',
            boxShadow: `0 0 ${node.size * 3}px ${node.size}px oklch(0.70 0.15 190 / 0.3)`,
          }}
          initial={{ opacity: 0, scale: 0 }}
          animate={{
            opacity: [0.4, 0.9, 0.4],
            scale: [1, 1.3, 1],
          }}
          transition={{
            duration: 4 + (i % 3),
            delay: node.delay,
            repeat: Infinity,
            ease: 'easeInOut',
          }}
        />
      ))}

      {/* Floating large orbs */}
      {[...Array(5)].map((_, i) => (
        <motion.div
          key={`orb-${i}`}
          className="absolute rounded-full pointer-events-none"
          style={{
            width: 150 + i * 50,
            height: 150 + i * 50,
            left: `${15 + i * 18}%`,
            top: `${10 + i * 15}%`,
            background: `radial-gradient(circle at 30% 30%, oklch(0.70 0.15 ${190 + i * 25} / 0.08) 0%, transparent 60%)`,
          }}
          animate={{
            x: [0, 20 - i * 5, 0],
            y: [0, 15 + i * 3, 0],
            rotate: [0, 180, 360],
          }}
          transition={{
            duration: 20 + i * 5,
            repeat: Infinity,
            ease: 'linear',
          }}
        />
      ))}

      {/* Scan line effect */}
      <motion.div
        className="absolute inset-0 pointer-events-none"
        style={{
          background: 'linear-gradient(to bottom, transparent 0%, oklch(0.70 0.15 190 / 0.03) 50%, transparent 100%)',
          backgroundSize: '100% 4px',
        }}
        animate={{ y: ['-100%', '100%'] }}
        transition={{
          duration: 8,
          repeat: Infinity,
          ease: 'linear',
        }}
      />

      {/* Vignette overlay */}
      <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_center,transparent_20%,oklch(0.03_0.01_240)_100%)]" />

      {/* Film grain */}
      <div className="absolute inset-0 cinema-grain opacity-20" />

      {/* Right edge fade for seamless transition */}
      <div className="absolute inset-y-0 right-0 w-32 bg-gradient-to-l from-[var(--cinema-void)] to-transparent" />
    </div>
  );
}

export default function SignInScreen() {
  const navigate = useNavigate();
  const { user, isLoading, error, signInWithGoogle, signInWithEmail, createAccount, clearError, isAuthenticated } = useAuth();
  const [isSigningIn, setIsSigningIn] = useState(false);
  const [mode, setMode] = useState<'signin' | 'signup'>('signin');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated && user) {
      navigate('/', { replace: true });
    }
  }, [isAuthenticated, user, navigate]);

  const handleGoogleSignIn = async () => {
    setIsSigningIn(true);
    clearError();
    try {
      await signInWithGoogle();
    } finally {
      setIsSigningIn(false);
    }
  };

  const handleContinueWithoutSignIn = () => {
    navigate('/');
  };

  const handleEmailSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSigningIn(true);
    clearError();
    try {
      if (mode === 'signin') {
        await signInWithEmail(email, password);
      } else {
        await createAccount(email, password);
      }
    } finally {
      setIsSigningIn(false);
    }
  };

  const switchMode = () => {
    setMode(mode === 'signin' ? 'signup' : 'signin');
    clearError();
    setEmail('');
    setPassword('');
  };

  return (
    <div className="fixed inset-0 flex bg-[var(--cinema-void)]">
      {/* ===== LEFT PANEL: Animated Neural Background ===== */}
      <motion.div
        className="hidden lg:flex lg:w-1/2 xl:w-[55%] relative overflow-hidden"
        initial={{ opacity: 0, x: -50 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ duration: 0.8, ease: [0.22, 1, 0.36, 1] }}
      >
        <NeuralBackground />

        {/* Floating brand element */}
        <motion.div
          className="absolute bottom-12 left-12 z-10"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.6, duration: 0.8 }}
        >
          <p className="text-[var(--cinema-silver)]/40 text-sm tracking-[0.3em] uppercase font-light">
            Where AI Meets Creativity
          </p>
        </motion.div>
      </motion.div>

      {/* ===== RIGHT PANEL: Authentication ===== */}
      <motion.div
        className="w-full lg:w-1/2 xl:w-[45%] flex flex-col items-center justify-center p-8 md:p-12 lg:p-16 relative"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.6, delay: 0.2 }}
      >
        {/* Subtle background gradient */}
        <div className="absolute inset-0 bg-gradient-to-br from-[var(--cinema-celluloid)] via-[var(--cinema-void)] to-[var(--cinema-void)]" />

        {/* Decorative corner accents */}
        <div className="absolute top-0 right-0 w-64 h-64 pointer-events-none">
          <div className="absolute top-0 right-0 w-full h-full bg-[radial-gradient(circle_at_100%_0%,oklch(0.70_0.15_190_/_0.05)_0%,transparent_50%)]" />
        </div>
        <div className="absolute bottom-0 left-0 w-48 h-48 pointer-events-none">
          <div className="absolute bottom-0 left-0 w-full h-full bg-[radial-gradient(circle_at_0%_100%,oklch(0.55_0.20_280_/_0.03)_0%,transparent_50%)]" />
        </div>

        {/* Content container */}
        <div className="relative z-10 w-full max-w-md space-y-10">

          {/* Brand Section */}
          <motion.div
            className="text-center space-y-6"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4, duration: 0.6 }}
          >
            {/* Logo Icon */}
            <motion.div
              className="mx-auto w-20 h-20 rounded-2xl bg-gradient-to-br from-[oklch(0.70_0.15_190)] to-[oklch(0.55_0.20_280)] flex items-center justify-center shadow-2xl"
              initial={{ scale: 0.8, rotate: -10 }}
              animate={{ scale: 1, rotate: 0 }}
              transition={{ delay: 0.5, type: "spring", stiffness: 200 }}
              style={{
                boxShadow: '0 20px 60px -10px oklch(0.70 0.15 190 / 0.4)',
              }}
            >
              <Sparkles className="w-10 h-10 text-white" />
            </motion.div>

            {/* Brand Name */}
            <div>
              <h1 className="font-display text-4xl md:text-5xl tracking-tight text-[var(--cinema-silver)]">
                {mode === 'signin' ? 'Welcome Back' : 'Join'}{' '}
                <span className="bg-clip-text text-transparent bg-gradient-to-r from-[oklch(0.70_0.15_190)] to-[oklch(0.65_0.25_30)]">
                  {mode === 'signin' ? '' : 'AIsoul Studio'}
                </span>
              </h1>
              <p className="mt-3 text-[var(--cinema-silver)]/50 text-base font-light tracking-wide">
                {mode === 'signin'
                  ? 'Sign in to sync your projects across devices'
                  : 'Create an account to save your work to the cloud'}
              </p>
            </div>
          </motion.div>

          {/* Sign-in Section */}
          <motion.div
            className="space-y-6"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.6, duration: 0.6 }}
          >
            {/* Error Message */}
            <AnimatePresence>
              {error && (
                <motion.div
                  initial={{ opacity: 0, y: -10, height: 0 }}
                  animate={{ opacity: 1, y: 0, height: 'auto' }}
                  exit={{ opacity: 0, y: -10, height: 0 }}
                  className="flex items-center gap-3 p-4 rounded-xl bg-[oklch(0.35_0.15_25_/_0.15)] border border-[oklch(0.35_0.15_25_/_0.3)] text-[oklch(0.75_0.12_25)]"
                >
                  <AlertCircle className="w-5 h-5 shrink-0" />
                  <span className="text-sm">{error}</span>
                </motion.div>
              )}
            </AnimatePresence>

            {/* Google Sign-in Button */}
            <motion.button
              onClick={handleGoogleSignIn}
              disabled={isSigningIn || isLoading}
              className={cn(
                "group w-full flex items-center justify-center gap-3 px-6 py-4 rounded-xl",
                "bg-white hover:bg-gray-50 text-gray-800 font-medium",
                "transition-all duration-300 ease-out",
                "focus:outline-none focus:ring-2 focus:ring-[oklch(0.70_0.15_190)] focus:ring-offset-2 focus:ring-offset-[var(--cinema-void)]",
                "disabled:opacity-50 disabled:cursor-not-allowed",
                "shadow-lg hover:shadow-xl hover:shadow-white/10"
              )}
              whileHover={{ scale: isSigningIn ? 1 : 1.02, y: isSigningIn ? 0 : -2 }}
              whileTap={{ scale: 0.98 }}
            >
              {isSigningIn ? (
                <Loader2 className="w-5 h-5 animate-spin text-gray-600" />
              ) : (
                <svg className="w-5 h-5" viewBox="0 0 24 24" aria-hidden="true">
                  <path
                    fill="#4285F4"
                    d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                  />
                  <path
                    fill="#34A853"
                    d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                  />
                  <path
                    fill="#FBBC05"
                    d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                  />
                  <path
                    fill="#EA4335"
                    d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                  />
                </svg>
              )}
              <span className="text-base">
                {isSigningIn ? 'Signing in...' : 'Sign in with Google'}
              </span>
            </motion.button>

            {/* Divider */}
            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <div className="w-full border-t border-[var(--cinema-silver)]/10" />
              </div>
              <div className="relative flex justify-center">
                <span className="px-4 text-xs text-[var(--cinema-silver)]/30 bg-[var(--cinema-void)] uppercase tracking-widest">
                  or continue with email
                </span>
              </div>
            </div>

            {/* Email/Password Form */}
            <form onSubmit={handleEmailSubmit} className="space-y-4">
              <div>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  placeholder="Email address"
                  required
                  disabled={isSigningIn}
                  className={cn(
                    "w-full px-4 py-3.5 rounded-xl",
                    "bg-[var(--cinema-celluloid)] border border-[var(--cinema-silver)]/10",
                    "text-[var(--cinema-silver)] placeholder:text-[var(--cinema-silver)]/30",
                    "focus:outline-none focus:border-[oklch(0.70_0.15_190)] focus:ring-1 focus:ring-[oklch(0.70_0.15_190_/_0.3)]",
                    "transition-all duration-200",
                    "disabled:opacity-50"
                  )}
                />
              </div>
              <div>
                <input
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="Password"
                  required
                  minLength={6}
                  disabled={isSigningIn}
                  className={cn(
                    "w-full px-4 py-3.5 rounded-xl",
                    "bg-[var(--cinema-celluloid)] border border-[var(--cinema-silver)]/10",
                    "text-[var(--cinema-silver)] placeholder:text-[var(--cinema-silver)]/30",
                    "focus:outline-none focus:border-[oklch(0.70_0.15_190)] focus:ring-1 focus:ring-[oklch(0.70_0.15_190_/_0.3)]",
                    "transition-all duration-200",
                    "disabled:opacity-50"
                  )}
                />
              </div>

              <motion.button
                type="submit"
                disabled={isSigningIn || isLoading}
                className={cn(
                  "w-full flex items-center justify-center gap-3 px-6 py-4 rounded-xl",
                  "bg-gradient-to-r from-[oklch(0.70_0.15_190)] to-[oklch(0.55_0.20_280)]",
                  "hover:from-[oklch(0.75_0.15_190)] hover:to-[oklch(0.60_0.20_280)]",
                  "text-white font-medium",
                  "transition-all duration-300 ease-out",
                  "focus:outline-none focus:ring-2 focus:ring-[oklch(0.70_0.15_190)] focus:ring-offset-2 focus:ring-offset-[var(--cinema-void)]",
                  "disabled:opacity-50 disabled:cursor-not-allowed",
                  "shadow-lg hover:shadow-xl hover:shadow-[oklch(0.70_0.15_190_/_0.3)]"
                )}
                whileHover={{ scale: isSigningIn ? 1 : 1.02, y: isSigningIn ? 0 : -2 }}
                whileTap={{ scale: 0.98 }}
              >
                {isSigningIn ? (
                  <Loader2 className="w-5 h-5 animate-spin" />
                ) : null}
                <span className="text-base">
                  {isSigningIn
                    ? (mode === 'signin' ? 'Signing in...' : 'Creating account...')
                    : (mode === 'signin' ? 'Sign in' : 'Create account')}
                </span>
              </motion.button>
            </form>

            {/* Mode switcher */}
            <div className="text-center text-sm text-[var(--cinema-silver)]/50">
              {mode === 'signin' ? (
                <>
                  Don't have an account?{' '}
                  <button
                    onClick={switchMode}
                    className="text-[oklch(0.70_0.15_190)] hover:text-[oklch(0.75_0.15_190)] transition-colors font-medium"
                  >
                    Sign up
                  </button>
                </>
              ) : (
                <>
                  Already have an account?{' '}
                  <button
                    onClick={switchMode}
                    className="text-[oklch(0.70_0.15_190)] hover:text-[oklch(0.75_0.15_190)] transition-colors font-medium"
                  >
                    Sign in
                  </button>
                </>
              )}
            </div>

            {/* Second Divider */}
            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <div className="w-full border-t border-[var(--cinema-silver)]/10" />
              </div>
              <div className="relative flex justify-center">
                <span className="px-4 text-xs text-[var(--cinema-silver)]/30 bg-[var(--cinema-void)] uppercase tracking-widest">
                  or
                </span>
              </div>
            </div>

            {/* Continue without sign-in */}
            <motion.button
              onClick={handleContinueWithoutSignIn}
              className={cn(
                "w-full px-6 py-3.5 rounded-xl",
                "border border-[var(--cinema-silver)]/10 hover:border-[var(--cinema-silver)]/20",
                "text-[var(--cinema-silver)]/60 hover:text-[var(--cinema-silver)]/80",
                "text-sm font-light tracking-wide",
                "transition-all duration-300",
                "focus:outline-none focus:ring-2 focus:ring-[oklch(0.70_0.15_190_/_0.3)] focus:ring-offset-2 focus:ring-offset-[var(--cinema-void)]"
              )}
              whileHover={{ scale: 1.01 }}
              whileTap={{ scale: 0.99 }}
            >
              Continue without signing in
            </motion.button>
          </motion.div>

          {/* Footer Section */}
          <motion.div
            className="pt-8 text-center space-y-4"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.8, duration: 0.6 }}
          >
            <p className="text-xs text-[var(--cinema-silver)]/30 leading-relaxed">
              By signing in, you agree to our{' '}
              <a href="#" className="text-[var(--cinema-silver)]/50 hover:text-[var(--cinema-silver)]/70 transition-colors underline underline-offset-2">
                Terms of Service
              </a>{' '}
              and{' '}
              <a href="#" className="text-[var(--cinema-silver)]/50 hover:text-[var(--cinema-silver)]/70 transition-colors underline underline-offset-2">
                Privacy Policy
              </a>
            </p>

            <p className="text-xs text-[var(--cinema-silver)]/20">
              Powered by Gemini AI
            </p>
          </motion.div>
        </div>

        {/* Mobile background hint */}
        <motion.div
          className="lg:hidden absolute bottom-8 left-0 right-0 flex justify-center"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 1, duration: 0.6 }}
        >
          <div className="flex items-center gap-2 text-[var(--cinema-silver)]/30 text-xs">
            <div className="w-8 h-0.5 bg-gradient-to-r from-transparent via-[var(--cinema-silver)]/20 to-transparent" />
            <span>AI-Powered Video Creation</span>
            <div className="w-8 h-0.5 bg-gradient-to-r from-transparent via-[var(--cinema-silver)]/20 to-transparent" />
          </div>
        </motion.div>
      </motion.div>
    </div>
  );
}
</file>

<file path="screens/StudioScreen.tsx">
/**
 * Studio Screen - Unified creation workspace
 *
 * Refactored to use extracted components for better maintainability.
 * Requirements: 6.1-6.6, 2.5, 1.5, 9.1, 9.4
 */

import React, { useState, useCallback, useRef, useEffect, useMemo } from 'react';
import { useSearchParams, useNavigate } from 'react-router-dom';
import { motion } from 'framer-motion';
import {
  Video,
  Music as MusicIcon,
  Image as ImageIcon,
  Download,
  RotateCcw,
  Wand2,
  BarChart3,
  Edit3,
  Layers,
  Upload,
  Settings,
  Loader2,
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { useLanguage } from '@/i18n/useLanguage';
import { useVideoProductionRefactored } from '@/hooks/useVideoProductionRefactored';
import { useModalState } from '@/hooks/useModalState';
import { AppState } from '@/types';
import { getEffectiveLegacyTone } from '@/services/tripletUtils';

// Layout & UI Components
import { ScreenLayout } from '@/components/layout/ScreenLayout';
import { SlidePanel } from '@/components/ui/SlidePanel';

// Chat Components
import { MessageBubble, ChatInput, QuickActions, type ChatMessage } from '@/components/chat';

// Feature Components
import { QuickExport } from '@/components/QuickExport';
import { VideoPreviewCard } from '@/components/VideoPreviewCard';
import { studioAgent, type AgentResponse, type QuickAction } from '@/services/ai/studioAgent';
import QualityDashboard from '@/components/QualityDashboard';
import SceneEditor from '@/components/SceneEditor';
import MusicGeneratorModal from '@/components/MusicGeneratorModal';
import { SettingsModal } from '@/components/SettingsModal';
import { GraphiteTimeline } from '@/components/TimelineEditor';
import { useAppStore } from '@/stores';
import { useStoryGeneration } from '@/hooks/useStoryGeneration';
import { useFormatPipeline } from '@/hooks/useFormatPipeline';
import { useProjectSession } from '@/hooks/useProjectSession';
import { getCurrentUser } from '@/services/firebase/authService';
import { StoryWorkspace } from '@/components/story';
import { StoryWorkspaceErrorBoundary } from '@/components/story/StoryWorkspaceErrorBoundary';
import { VideoEditor } from '@/components/VideoEditor';
import { useVideoEditorStore } from '@/components/VideoEditor/hooks/useVideoEditorStore';

// ============================================================
// Types & Helpers
// ============================================================

export interface StudioParams {
  mode?: 'video' | 'music' | 'story';
  style?: string;
  duration?: number;
  topic?: string;
  projectId?: string;
}

export function parseStudioParams(searchParams: URLSearchParams): StudioParams {
  const mode = searchParams.get('mode');
  const style = searchParams.get('style');
  const duration = searchParams.get('duration');
  const topic = searchParams.get('topic');
  const projectId = searchParams.get('projectId');

  return {
    mode: mode === 'video' || mode === 'music' || mode === 'story' ? mode : undefined,
    style: style || undefined,
    duration: duration ? parseInt(duration, 10) : undefined,
    topic: topic || undefined,
    projectId: projectId || undefined,
  };
}

// ============================================================
// Main Component
// ============================================================

export default function StudioScreen() {
  const { t, isRTL } = useLanguage();
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const params = parseStudioParams(searchParams);

  // Project session management
  const {
    project,
    isLoading: isProjectLoading,
    error: projectError,
    restoredState,
    syncProjectMetadata,
  } = useProjectSession(params.projectId);

  // View mode toggle (Requirement 6.6)
  const [viewMode, setViewMode] = useState<'simple' | 'advanced'>('simple');
  const [studioMode, setStudioMode] = useState<'chat' | 'story' | 'editor'>(
    params.mode === 'story' ? 'story' : 'chat'
  );

  // Story Generation Hook - pass projectId so it resets state for new projects
  const storyHook = useStoryGeneration(params.projectId);

  // Format Pipeline Hook - for non-movie-animation format pipelines
  const formatPipelineHook = useFormatPipeline();

  // Modal state (unified)
  const {
    showExport, setShowExport,
    showQuality, setShowQuality,
    showSceneEditor, setShowSceneEditor,
    showMusic, setShowMusic,
    showTimeline, setShowTimeline,
  } = useModalState();
  const [showSettings, setShowSettings] = useState(false);

  const [musicModalMode, setMusicModalMode] = useState<'generate' | 'remix'>('generate');

  // Video production hook
  const {
    appState,
    contentPlan,
    narrationSegments,
    sfxPlan,
    error,
    setTopic,
    targetAudience,
    setTargetAudience,
    setTargetDuration,
    setVideoPurpose,
    setVisualStyle,
    startProduction,
    reset,
    visuals,
    getVisualsMap,
    getAudioUrlMap,
    updateScenes,
    generateMusic,
    generateLyrics,
    musicState,
    selectTrack,
    addMusicToTimeline,
    refreshCredits,
    regenerateSceneNarration,
    playNarration,
    qualityReport,
    playingSceneId,
    browseSfx,
    setPreferredCameraAngle,
    setPreferredLightingMood,
    uploadAudio,
    uploadAndCover,
    addVocals,
    addInstrumental,
    veoVideoCount,
    setVeoVideoCount,
    topic,
    // Test/Debug setters
    setVisuals,
    setContentPlan,
    setNarrationSegments,
    setAppState,
  } = useVideoProductionRefactored();

  // App Store - Chat & UI State (persistent)
  const storeMessages = useAppStore((s) => s.messages);
  const addMessage = useAppStore((s) => s.addMessage);
  const clearMessages = useAppStore((s) => s.clearMessages);
  const updateLastMessage = useAppStore((s) => s.updateLastMessage);
  const setTyping = useAppStore((s) => s.setTyping);
  const trackVideoCreation = useAppStore((s) => s.trackVideoCreation);
  const trackMusicGeneration = useAppStore((s) => s.trackMusicGeneration);
  const recordFeedback = useAppStore((s) => s.recordFeedback);

  // Local UI state
  const [input, setInput] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [storyInitialTopic, setStoryInitialTopic] = useState(params.mode === 'story' ? (params.topic || '') : '');

  // Video preview state
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentSceneIndex, setCurrentSceneIndex] = useState(0);
  const previewIntervalRef = useRef<NodeJS.Timeout | null>(null);

  // Timeline playback state
  const [playbackTime, setPlaybackTime] = useState(0);
  const [selectedSceneId, setSelectedSceneId] = useState<string | null>(null);
  const timelineAudioRef = useRef<HTMLAudioElement>(null);
  const [mergedAudioUrl, setMergedAudioUrl] = useState<string | null>(null);

  const messagesEndRef = useRef<HTMLDivElement>(null);
  const paramsAppliedRef = useRef(false);
  const lastProcessedResultRef = useRef<string | null>(null);

  // ============================================================
  // Effects
  // ============================================================

  // Sync studioMode from URL params when navigating between projects
  useEffect(() => {
    if (params.mode === 'story' && studioMode !== 'story') {
      setStudioMode('story');
    }
  }, [params.mode]);

  // Apply URL parameters OR restore project state on mount (Requirement 2.5)
  useEffect(() => {
    if (paramsAppliedRef.current) return;

    // Wait for project loading to complete if we have a projectId
    if (params.projectId && isProjectLoading) return;

    paramsAppliedRef.current = true;

    // If we have restored state from a project session, apply it
    if (restoredState?.contentPlan) {
      console.log('[StudioScreen] Restoring from project session');
      setContentPlan(restoredState.contentPlan);
      if (restoredState.visuals?.length) {
        setVisuals(restoredState.visuals);
      }
      if (restoredState.narrationSegments?.length) {
        setNarrationSegments(restoredState.narrationSegments);
      }
      // Set topic from restored content plan
      if (restoredState.contentPlan.title) {
        setTopic(restoredState.contentPlan.title);
      }
      setAppState(AppState.READY);
      return;
    }

    // Apply project metadata as initial config (if project exists but no restored state)
    if (project) {
      if (project.topic) setTopic(project.topic);
      if (project.style) setVisualStyle(project.style);
    }

    // Fall back to URL params for mode/style/topic
    if (params.mode === 'video') {
      if (params.style) setVisualStyle(params.style);
      if (params.duration) setTargetDuration(params.duration);
      setVideoPurpose('documentary');

      // Use project topic or URL param topic
      const effectiveTopic = project?.topic || params.topic;
      if (effectiveTopic && !restoredState?.contentPlan) {
        setTopic(effectiveTopic);
        addMessage('assistant', t('studio.generating'));
        setTimeout(() => {
          startProduction({
            skipNarration: false,
            targetDuration: params.duration || 60,
            visualStyle: params.style || project?.style || 'Cinematic',
            contentPlannerConfig: {
              videoPurpose: 'documentary',
              visualStyle: params.style || project?.style || 'Cinematic',
            }
          }, effectiveTopic);
        }, 500);
      }
    } else if (params.mode === 'story') {
      // Apply topic from URL params or project for story mode
      const storyTopic = project?.topic || params.topic;
      if (storyTopic) {
        setStoryInitialTopic(storyTopic);
      }
    } else if (params.mode === 'music') {
      setShowMusic(true);
    }
  }, [params, isProjectLoading, project, restoredState, setVisualStyle, setTargetDuration, setVideoPurpose, setTopic, startProduction, addMessage, t, setShowMusic, setContentPlan, setVisuals, setNarrationSegments, setAppState]);

  // Sync project metadata when production state changes
  useEffect(() => {
    if (!params.projectId || !project) return;

    const updates: Record<string, unknown> = {};

    if (contentPlan) {
      updates.sceneCount = contentPlan.scenes.length;
      updates.status = 'in_progress';
    }

    if (visuals.length > 0) {
      updates.hasVisuals = true;
      // Use first scene visual as thumbnail
      const firstVisual = visuals.find(v => v.imageUrl);
      if (firstVisual?.imageUrl) {
        updates.thumbnailUrl = firstVisual.imageUrl;
      }
    }

    if (narrationSegments.length > 0) {
      updates.hasNarration = true;
      updates.duration = narrationSegments.reduce((sum, n) => sum + n.audioDuration, 0);
    }

    if (sfxPlan?.generatedMusic?.audioUrl) {
      updates.hasMusic = true;
    }

    if (appState === AppState.READY && contentPlan) {
      updates.status = 'completed';
    }

    // Only sync if we have updates
    if (Object.keys(updates).length > 0) {
      syncProjectMetadata(updates);
    }
  }, [params.projectId, project, contentPlan, visuals, narrationSegments, sfxPlan, appState, syncProjectMetadata]);

  // Auto-scroll to bottom
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [storeMessages]);

  // Merge audio for timeline
  useEffect(() => {
    const mergeAudio = async () => {
      if (!contentPlan || narrationSegments.length === 0) return;
      try {
        const orderedBlobs: Blob[] = [];
        for (const scene of contentPlan.scenes) {
          const narration = narrationSegments.find(n => n.sceneId === scene.id);
          if (narration?.audioBlob) orderedBlobs.push(narration.audioBlob);
        }
        if (orderedBlobs.length === 0) return;

        const sampleRate = 24000;
        const bytesPerSample = 2;
        const WAV_HEADER_SIZE = 44;
        let totalPcmSize = 0;
        const pcmDataArrays: Uint8Array[] = [];

        for (const blob of orderedBlobs) {
          const arrayBuffer = await blob.arrayBuffer();
          const fullData = new Uint8Array(arrayBuffer);
          const pcmData = fullData.slice(WAV_HEADER_SIZE);
          pcmDataArrays.push(pcmData);
          totalPcmSize += pcmData.length;
        }

        const mergedPcm = new Uint8Array(totalPcmSize);
        let offset = 0;
        for (const pcmData of pcmDataArrays) {
          mergedPcm.set(pcmData, offset);
          offset += pcmData.length;
        }

        const wavBuffer = new ArrayBuffer(WAV_HEADER_SIZE + totalPcmSize);
        const view = new DataView(wavBuffer);
        const writeString = (off: number, str: string) => {
          for (let i = 0; i < str.length; i++) view.setUint8(off + i, str.charCodeAt(i));
        };

        writeString(0, 'RIFF');
        view.setUint32(4, 36 + totalPcmSize, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * bytesPerSample, true);
        view.setUint16(32, bytesPerSample, true);
        view.setUint16(34, 16, true);
        writeString(36, 'data');
        view.setUint32(40, totalPcmSize, true);
        new Uint8Array(wavBuffer, WAV_HEADER_SIZE).set(mergedPcm);

        const mergedBlob = new Blob([wavBuffer], { type: 'audio/wav' });
        setMergedAudioUrl(URL.createObjectURL(mergedBlob));
      } catch (err) {
        console.error('Failed to merge audio:', err);
      }
    };
    mergeAudio();
  }, [contentPlan, narrationSegments]);

  // Handle preview playback
  useEffect(() => {
    if (isPlaying && contentPlan) {
      previewIntervalRef.current = setInterval(() => {
        setCurrentSceneIndex(prev => (prev + 1) % contentPlan.scenes.length);
      }, 3000);
    } else {
      if (previewIntervalRef.current) clearInterval(previewIntervalRef.current);
    }
    return () => {
      if (previewIntervalRef.current) clearInterval(previewIntervalRef.current);
    };
  }, [isPlaying, contentPlan]);

  // ============================================================
  // Computed Values
  // ============================================================

  const messages: ChatMessage[] = useMemo(() => {
    if (storeMessages.length === 0) {
      return [{
        id: 'welcome',
        role: 'assistant' as const,
        content: t('studio.placeholder'),
        timestamp: Date.now(),
      }];
    }
    return storeMessages as ChatMessage[];
  }, [storeMessages, t]);

  const isVideoReady = useMemo(() => {
    return contentPlan && narrationSegments.length > 0 && appState === AppState.READY;
  }, [contentPlan, narrationSegments, appState]);

  const visualsMap = getVisualsMap();

  const totalDuration = useMemo(() => {
    return narrationSegments.reduce((sum, n) => sum + n.audioDuration, 0);
  }, [narrationSegments]);

  // ============================================================
  // Handlers
  // ============================================================

  const handleReset = useCallback(() => {
    reset();
    clearMessages();
    setCurrentSceneIndex(0);
    setIsPlaying(false);
    setShowTimeline(false);
    setPlaybackTime(0);
    setSelectedSceneId(null);
    studioAgent.resetConversation();
  }, [reset, clearMessages, setShowTimeline]);

  const handleTimelinePlayPause = useCallback(() => {
    if (timelineAudioRef.current) {
      if (isPlaying) timelineAudioRef.current.pause();
      else timelineAudioRef.current.play();
    }
    setIsPlaying(prev => !prev);
  }, [isPlaying]);

  const handleTimelineSeek = useCallback((time: number) => {
    setPlaybackTime(time);
    if (timelineAudioRef.current) timelineAudioRef.current.currentTime = time;
    if (contentPlan) {
      let elapsed = 0;
      for (let i = 0; i < contentPlan.scenes.length; i++) {
        const scene = contentPlan.scenes[i];
        if (!scene) continue;
        const sceneDuration = narrationSegments.find(n => n.sceneId === scene.id)?.audioDuration || scene.duration;
        if (time < elapsed + sceneDuration) {
          setCurrentSceneIndex(i);
          break;
        }
        elapsed += sceneDuration;
      }
    }
  }, [contentPlan, narrationSegments]);

  const handleSceneSelect = useCallback((sceneId: string) => {
    setSelectedSceneId(sceneId);
    if (contentPlan) {
      let elapsed = 0;
      for (const scene of contentPlan.scenes) {
        if (scene.id === sceneId) {
          setPlaybackTime(elapsed);
          if (timelineAudioRef.current) timelineAudioRef.current.currentTime = elapsed;
          break;
        }
        const sceneDuration = narrationSegments.find(n => n.sceneId === scene.id)?.audioDuration || scene.duration;
        elapsed += sceneDuration;
      }
    }
  }, [contentPlan, narrationSegments]);

  const handleSubmit = useCallback(async () => {
    if (!input.trim() || isProcessing) return;

    const userInput = input.trim();
    addMessage('user', userInput);
    setInput('');
    setIsProcessing(true);
    setTyping(true);
    addMessage('assistant', t('common.loading'));

    try {
      const agentResponse: AgentResponse = await studioAgent.processMessage(userInput);
      const messageUpdate: { content: string; quickActions?: QuickAction[] } = {
        content: agentResponse.message,
        quickActions: agentResponse.quickActions || []
      };

      switch (agentResponse.action.type) {
        case 'generate_music': {
          const params = agentResponse.action.params as { prompt?: string; style?: string; title?: string; instrumental?: boolean; customMode?: boolean };
          updateLastMessage(messageUpdate);
          generateMusic({
            prompt: params.prompt ?? "",
            style: params.style,
            title: params.title,
            instrumental: params.instrumental,
            customMode: params.customMode,
            model: 'V5'
          });
          trackMusicGeneration();
          setShowMusic(true);
          break;
        }
        case 'create_video': {
          const params = agentResponse.action.params as { topic: string; duration?: number; style?: string };
          updateLastMessage(messageUpdate);
          setTopic(params.topic);
          setTargetDuration(params.duration || 60);
          setVisualStyle(params.style || 'Cinematic');
          setVideoPurpose('documentary');

          // Track video creation with actual params
          trackVideoCreation({
            style: params.style || 'Cinematic',
            duration: params.duration || 60
          });

          startProduction({
            skipNarration: false,
            targetDuration: params.duration || 60,
            visualStyle: params.style || 'Cinematic',
            contentPlannerConfig: {
              videoPurpose: 'documentary',
              visualStyle: params.style || 'Cinematic',
            }
          }, params.topic);
          break;
        }
        case 'export_video': {
          setShowExport(true);
          updateLastMessage(messageUpdate);
          break;
        }
        case 'reset': {
          handleReset();
          break;
        }
        case 'browse_sfx': {
          const params = agentResponse.action.params as { category: string };
          updateLastMessage(messageUpdate);
          try {
            const sound = await browseSfx(params.category);
            if (sound) {
              addMessage('assistant', `Found SFX: "${sound.name}" (${sound.duration.toFixed(1)}s)`);
            }
          } catch (err: unknown) {
            const errMsg = err instanceof Error ? err.message : String(err);
            addMessage('assistant', `SFX search failed: ${errMsg}`);
          }
          break;
        }
        case 'set_camera_style': {
          const params = agentResponse.action.params as { angle?: string; lighting?: string };
          if (params.angle) setPreferredCameraAngle(params.angle);
          if (params.lighting) setPreferredLightingMood(params.lighting);
          updateLastMessage(messageUpdate);
          break;
        }
        case 'show_quality_report': {
          if (qualityReport) {
            setShowQuality(true);
            updateLastMessage(messageUpdate);
          } else {
            updateLastMessage({ content: t('common.error') });
          }
          break;
        }
        default: {
          updateLastMessage(messageUpdate);
        }
      }
    } catch (err) {
      console.error('Agent error:', err);
      updateLastMessage({ content: t('errors.generic') });
    }

    setTyping(false);
    setIsProcessing(false);
  }, [input, isProcessing, addMessage, updateLastMessage, setTyping, setTopic, setTargetDuration, setVisualStyle, setVideoPurpose, startProduction, handleReset, browseSfx, setPreferredCameraAngle, setPreferredLightingMood, qualityReport, generateMusic, t, setShowMusic, setShowExport, setShowQuality]);

  const handleQuickAction = useCallback(async (action: { type: string; params?: Record<string, unknown> }) => {
    if (isProcessing) return;

    setIsProcessing(true);
    setTyping(true);
    updateLastMessage({ quickActions: [] });

    try {
      switch (action.type) {
        case 'create_video': {
          const params = action.params as { topic: string; duration?: number; style?: string } | undefined;
          if (!params?.topic) break;
          addMessage('assistant', `üé¨ Creating ${params.duration || 60}s ${params.style || 'Cinematic'} video...`);
          setTopic(params.topic);
          setTargetDuration(params.duration || 60);
          setVisualStyle(params.style || 'Cinematic');
          setVideoPurpose('documentary');

          // Track video creation with actual params
          trackVideoCreation({
            style: params.style || 'Cinematic',
            duration: params.duration || 60
          });

          startProduction({
            skipNarration: false,
            targetDuration: params.duration || 60,
            visualStyle: params.style || 'Cinematic',
            contentPlannerConfig: {
              videoPurpose: 'documentary',
              visualStyle: params.style || 'Cinematic',
            }
          }, params.topic);
          break;
        }
        case 'generate_music': {
          const params = action.params as { prompt?: string; style?: string; instrumental?: boolean } | undefined;
          addMessage('assistant', `üéµ Creating ${params?.style || 'music'}...`);
          generateMusic({
            prompt: params?.prompt ?? "",
            style: params?.style,
            instrumental: params?.instrumental ?? true,
            model: 'V5'
          });
          trackMusicGeneration();
          setShowMusic(true);
          break;
        }
        case 'ask_clarification': {
          // Handle clarification requests - just send the message
          const params = action.params as { message?: string } | undefined;
          if (params?.message) {
            setInput(params.message);
          }
          break;
        }
        default:
          console.warn('Unknown quick action type:', action.type);
      }
    } catch (err) {
      console.error('Quick action error:', err);
      addMessage('assistant', t('errors.generic'));
    }

    setTyping(false);
    setIsProcessing(false);
  }, [isProcessing, addMessage, updateLastMessage, setTyping, setTopic, setTargetDuration, setVisualStyle, setVideoPurpose, startProduction, generateMusic, t, setShowMusic, setInput]);

  // Feedback handler
  const handleFeedback = useCallback((
    messageId: string,
    feedback: { helpful: boolean; rating: number; comment?: string }
  ) => {
    const messageIndex = messages.findIndex(m => m.id === messageId);
    if (messageIndex === -1) return;

    const agentMessage = messages[messageIndex];
    const userMessage = messages[messageIndex - 1];

    if (!agentMessage) return;

    recordFeedback({
      messageId,
      userMessage: userMessage?.content || '',
      agentResponse: agentMessage.content,
      helpful: feedback.helpful,
      rating: feedback.rating,
      comment: feedback.comment,
      timestamp: Date.now(),
    });

    console.log('[Feedback] Recorded:', feedback.helpful ? 'üëç Helpful' : 'üëé Not helpful');
  }, [messages, recordFeedback]);

  const handleExport = useCallback(async (
    config: { presetId: string; width: number; height: number; orientation: 'landscape' | 'portrait'; quality: string },
    onProgress?: (percent: number) => void
  ) => {
    if (!contentPlan || narrationSegments.length === 0 || !mergedAudioUrl) {
      throw new Error('Video not ready for export');
    }

    let currentTime = 0;
    const parsedSubtitles = contentPlan.scenes.map((scene, idx) => {
      const narration = narrationSegments.find(n => n.sceneId === scene.id);
      const duration = narration?.audioDuration || scene.duration;
      const subtitle = {
        id: idx + 1,
        startTime: currentTime,
        endTime: currentTime + duration,
        text: narration?.transcript || scene.narrationScript,
      };
      currentTime += duration;
      return subtitle;
    });

    const prompts = contentPlan.scenes.map((scene, idx) => ({
      id: scene.id,
      text: scene.visualDescription,
      mood: getEffectiveLegacyTone(scene),
      timestampSeconds: parsedSubtitles[idx]?.startTime || 0,
    }));

    // Use full visuals array to preserve type, cachedBlobUrl, etc.
    const generatedImages = visuals.filter(v => v.imageUrl).map(v => ({
      ...v,
      // Prefer cached blob URL over original URL (prevents expired URL issues)
      imageUrl: v.cachedBlobUrl || v.imageUrl,
    }));

    const songData = {
      fileName: contentPlan.title || 'ai-video',
      audioUrl: mergedAudioUrl,
      srtContent: '',
      parsedSubtitles,
      prompts,
      generatedImages,
    };

    const sceneTimings = contentPlan.scenes.map((scene, idx) => {
      const narration = narrationSegments.find(n => n.sceneId === scene.id);
      const subtitle = parsedSubtitles[idx];
      return {
        sceneId: scene.id,
        startTime: subtitle?.startTime ?? 0,
        duration: narration?.audioDuration || scene.duration,
      };
    });

    const { exportVideoWithFFmpeg } = await import('@/services/ffmpeg/exporters');

    const result = await exportVideoWithFFmpeg(
      songData,
      (p) => onProgress?.(p.progress),
      {
        orientation: config.orientation,
        useModernEffects: true,
        transitionType: 'dissolve',
        transitionDuration: 1.5,
        contentMode: 'story',
        sfxPlan,
        sceneTimings,
      },
      // Pass export options for history tracking
      {
        projectId: params.projectId,
        cloudSessionId: project?.cloudSessionId,
        userId: getCurrentUser()?.uid,
      }
    );

    // Use blob from result (may include cloudUrl for cloud exports)
    const blob = result.blob ?? result;

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${contentPlan.title || 'video'}-${config.presetId}.mp4`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, [contentPlan, narrationSegments, mergedAudioUrl, visuals, sfxPlan, params.projectId, project]);

  // ============================================================
  // TEST: Load saved media from local folder
  // ============================================================
  const loadTestMedia = useCallback(async () => {
    const basePath = '/production_prod_1769364025193_ch60ee8c1';

    // Create mock content plan
    const mockContentPlan = {
      title: 'ÿ≤ÿ¶Ÿäÿ± ÿßŸÑŸÅŸäŸÜŸäŸÇ: ÿßŸÑÿ´ŸàÿßŸÜŸä ÿßŸÑÿ£ÿÆŸäÿ±ÿ©',
      totalDuration: 78,
      targetAudience: 'General audience',
      overallTone: 'Cinematic',
      scenes: [
        { id: 'scene-1', name: 'ÿßŸÑÿµŸÖÿ™ ŸÇÿ®ŸÑ ÿßŸÑÿπÿßÿµŸÅÿ©', duration: 15, visualDescription: 'Scene 1', narrationScript: '', emotionalTone: 'dramatic' as const, instructionTriplet: { primaryEmotion: 'visceral-dread', cinematicDirection: 'slow-push-in', environmentalAtmosphere: 'desert-silence' } },
        { id: 'scene-2', name: 'ÿßŸÑÿßÿ≥ÿ™ŸäŸÇÿßÿ∏ ÿßŸÑÿØÿßÿÆŸÑŸä', duration: 14, visualDescription: 'Scene 2', narrationScript: '', emotionalTone: 'dramatic' as const, instructionTriplet: { primaryEmotion: 'bittersweet-longing', cinematicDirection: 'close-up', environmentalAtmosphere: 'cathedral-reverb' } },
        { id: 'scene-3', name: 'ÿ≤ÿ¶Ÿäÿ± ÿßŸÑŸÅŸäŸÜŸäŸÇ', duration: 16, visualDescription: 'Scene 3', narrationScript: '', emotionalTone: 'dramatic' as const, instructionTriplet: { primaryEmotion: 'euphoric-wonder', cinematicDirection: 'tracking-shot', environmentalAtmosphere: 'ethereal-echo' } },
        { id: 'scene-4', name: 'ÿßŸÑÿ±ŸÖŸäÿ© ÿßŸÑŸÖŸÇÿØÿ≥ÿ©', duration: 17, visualDescription: 'Scene 4', narrationScript: '', emotionalTone: 'dramatic' as const, instructionTriplet: { primaryEmotion: 'seething-rage', cinematicDirection: 'handheld-float', environmentalAtmosphere: 'tension-drone' } },
        { id: 'scene-5', name: 'ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÇ ŸàÿßŸÑŸÜÿµÿ±', duration: 16, visualDescription: 'Scene 5', narrationScript: '', emotionalTone: 'dramatic' as const, instructionTriplet: { primaryEmotion: 'stoic-resignation', cinematicDirection: 'pull-back', environmentalAtmosphere: 'golden-hour-decay' } },
      ],
    };

    // Create visuals from local video files
    const mockVisuals = [
      { promptId: 'scene-1', imageUrl: `${basePath}/video_clips/scene_0_veo.mp4`, type: 'video' as const, generatedWithVeo: true },
      { promptId: 'scene-2', imageUrl: `${basePath}/video_clips/scene_1_veo.mp4`, type: 'video' as const, generatedWithVeo: true },
      { promptId: 'scene-3', imageUrl: `${basePath}/video_clips/scene_2_veo.mp4`, type: 'video' as const, generatedWithVeo: true },
      { promptId: 'scene-4', imageUrl: `${basePath}/video_clips/scene_3_veo.mp4`, type: 'video' as const, generatedWithVeo: true },
      { promptId: 'scene-5', imageUrl: `${basePath}/video_clips/scene_4_veo.mp4`, type: 'video' as const, generatedWithVeo: true },
    ];

    // Create narration segments from local audio files
    const mockNarrationSegments = await Promise.all([
      { sceneId: 'scene-1', audioUrl: `${basePath}/audio/narration_scene-1.wav`, audioDuration: 13.9, transcript: 'Scene 1 narration' },
      { sceneId: 'scene-2', audioUrl: `${basePath}/audio/narration_scene-2.wav`, audioDuration: 12.3, transcript: 'Scene 2 narration' },
      { sceneId: 'scene-3', audioUrl: `${basePath}/audio/narration_scene-3.wav`, audioDuration: 14.3, transcript: 'Scene 3 narration' },
      { sceneId: 'scene-4', audioUrl: `${basePath}/audio/narration_scene-4.wav`, audioDuration: 15.1, transcript: 'Scene 4 narration' },
      { sceneId: 'scene-5', audioUrl: `${basePath}/audio/narration_scene-5.wav`, audioDuration: 14.8, transcript: 'Scene 5 narration' },
    ].map(async (seg) => {
      // Fetch audio and create blob
      const response = await fetch(seg.audioUrl);
      const blob = await response.blob();
      return {
        sceneId: seg.sceneId,
        audioBlob: blob,
        audioDuration: seg.audioDuration,
        transcript: seg.transcript,
      };
    }));

    // Set the data
    setContentPlan(mockContentPlan as any);
    setVisuals(mockVisuals);
    setNarrationSegments(mockNarrationSegments);
    setAppState(AppState.READY);

    console.log('[TEST] Loaded test media from local folder');
    alert('Test media loaded! You can now export.');
  }, [setContentPlan, setVisuals, setNarrationSegments, setAppState]);

  // Handle format pipeline execution ‚Äî delegates movie-animation to storyHook
  const handleFormatExecute = useCallback(() => {
    if (formatPipelineHook.selectedFormat === 'movie-animation') {
      // Delegate to existing story generation pipeline
      const idea = formatPipelineHook.idea || storyInitialTopic || topic || '';
      const genre = formatPipelineHook.selectedGenre || 'Drama';
      setStoryInitialTopic(idea);
      storyHook.updateGenre(genre);
      storyHook.generateBreakdown(idea, genre);
    } else {
      // Run format-specific pipeline
      const user = getCurrentUser();
      const userId = user?.uid ?? 'anonymous';
      const projectId = params.projectId ?? `fp_${Date.now()}`;
      formatPipelineHook.execute(userId, projectId);
    }
  }, [formatPipelineHook, storyHook, storyInitialTopic, topic, params.projectId]);

  const handleOpenInEditor = useCallback(() => {
    const editorStore = useVideoEditorStore.getState();
    editorStore.reset();

    // Create Tracks
    editorStore.addTrack('video', 'Visuals');
    editorStore.addTrack('audio', 'Voiceover');

    let visuals: any[] = [];
    let narrations: any[] = [];
    let breakdown: any[] = [];

    if (formatPipelineHook.result?.success) {
      const pr = formatPipelineHook.result.partialResults;
      visuals = pr?.visuals || [];
      narrations = pr?.narrationSegments || [];
      breakdown = pr?.screenplay || [];
    } else {
      visuals = storyHook.state.scenesWithVisuals || [];
      narrations = storyHook.state.narrationSegments || [];
      breakdown = storyHook.state.breakdown || [];
    }

    setTimeout(() => {
      const state = useVideoEditorStore.getState();
      const videoTrack = state.tracks.find(t => t.type === 'video');
      const audioTrack = state.tracks.find(t => t.type === 'audio');

      let currentTime = 0;
      breakdown.forEach((scene: any, idx: number) => {
        const visual = visuals.find((v: any) => v.sceneId === scene.id || v.sceneId === scene.sceneId);
        const narration = narrations.find((n: any) => n.sceneId === scene.id || n.sceneId === scene.sceneId);
        const duration = narration?.audioDuration || scene.duration || 5;

        if (visual && videoTrack) {
          state.addClip({
            trackId: videoTrack.id,
            type: 'video',
            startTime: currentTime,
            duration: duration,
            name: scene.heading || `Scene ${idx + 1}`,
            sourceUrl: visual.imageUrl,
            thumbnailUrl: visual.imageUrl,
            inPoint: 0,
            outPoint: duration
          });
        }

        if (narration && audioTrack) {
          const url = narration.audioBlob ? URL.createObjectURL(narration.audioBlob) : narration.audioUrl;
          if (url) {
            state.addClip({
              trackId: audioTrack.id,
              type: 'audio',
              startTime: currentTime,
              duration: duration,
              name: `Voiceover ${idx + 1}`,
              sourceUrl: url,
              inPoint: 0,
              outPoint: duration
            });
          }
        }
        currentTime += duration;
      });

      if (mergedAudioUrl) {
        editorStore.addTrack('audio', 'Music');
        setTimeout(() => {
          const state2 = useVideoEditorStore.getState();
          const musicTrack = [...state2.tracks].reverse().find(t => t.type === 'audio' && t.name === 'Music');
          if (musicTrack) {
            state2.addClip({
              trackId: musicTrack.id,
              type: 'audio',
              startTime: 0,
              duration: currentTime,
              name: 'Background Music',
              sourceUrl: mergedAudioUrl,
              inPoint: 0,
              outPoint: currentTime
            });
          }
        }, 0);
      }

      setStudioMode('editor');
    }, 50);
  }, [formatPipelineHook.result, storyHook.state, mergedAudioUrl]);

  // Auto-transition to Editor upon format pipeline completion
  useEffect(() => {
    if (!formatPipelineHook.isRunning && formatPipelineHook.result?.success) {
      const resultHash = (params.projectId || 'fp') + '_' + (formatPipelineHook.result.partialResults?.totalDuration || Date.now());
      if (lastProcessedResultRef.current !== resultHash) {
        lastProcessedResultRef.current = resultHash;
        handleOpenInEditor();
      }
    }
  }, [formatPipelineHook.isRunning, formatPipelineHook.result, handleOpenInEditor, params.projectId]);

  // Quick actions for welcome state
  const quickActionItems = useMemo(() => [
    { icon: MusicIcon, label: t('home.createMusic'), prompt: 'Generate an upbeat synthwave track about city lights at night' },
    { icon: Video, label: t('home.createVideo'), prompt: 'Create a cinematic travel video about exploring ancient Rome' },
    { icon: ImageIcon, label: t('home.visualizer'), prompt: 'Generate a documentary about the journey of a coffee bean' },
  ], [t]);

  // ============================================================
  // Render
  // ============================================================

  const headerActions = (
    <div className="flex items-center gap-2" role="toolbar" aria-label="Studio actions">
      {/* Mode Toggle Selection */}
      <div className="flex items-center bg-secondary border border-border rounded-lg p-0.5 me-4">
        <Button
          variant="ghost"
          size="sm"
          onClick={() => setStudioMode('chat')}
          className={cn(
            "h-7 px-3 text-[10px] uppercase font-bold transition-all",
            studioMode === 'chat' ? "bg-primary text-primary-foreground shadow-lg" : "text-muted-foreground hover:text-foreground"
          )}
        >
          Chat Mode
        </Button>
        <Button
          variant="ghost"
          size="sm"
          onClick={() => setStudioMode('story')}
          className={cn(
            "h-7 px-3 text-[10px] uppercase font-bold transition-all",
            studioMode === 'story' ? "bg-primary text-primary-foreground shadow-lg" : "text-muted-foreground hover:text-foreground"
          )}
        >
          Story Mode
        </Button>
        <Button
          variant="ghost"
          size="sm"
          onClick={() => setStudioMode('editor')}
          className={cn(
            "h-7 px-3 text-[10px] uppercase font-bold transition-all",
            studioMode === 'editor' ? "bg-primary text-primary-foreground shadow-lg" : "text-muted-foreground hover:text-foreground"
          )}
        >
          Editor
        </Button>
      </div>

      {/* Simple/Advanced toggle */}
      <div className="flex items-center gap-1 bg-secondary rounded-lg p-1" role="group" aria-label="View mode">
        <button
          onClick={() => setViewMode('simple')}
          className={cn(
            'px-3 py-1.5 text-xs font-medium rounded-md transition-all',
            viewMode === 'simple'
              ? 'bg-primary text-primary-foreground'
              : 'text-muted-foreground hover:text-foreground'
          )}
          aria-pressed={viewMode === 'simple'}
        >
          {t('studio.simpleMode')}
        </button>
        <button
          onClick={() => setViewMode('advanced')}
          className={cn(
            'px-3 py-1.5 text-xs font-medium rounded-md transition-all',
            viewMode === 'advanced'
              ? 'bg-primary text-primary-foreground'
              : 'text-muted-foreground hover:text-foreground'
          )}
          aria-pressed={viewMode === 'advanced'}
        >
          {t('studio.advancedMode')}
        </button>
      </div>

      <Button
        variant="ghost"
        size="sm"
        onClick={() => setShowSettings(true)}
        className="text-muted-foreground hover:text-foreground hover:bg-secondary"
      >
        <Settings className="w-4 h-4 me-2" />
        {t('studio.settings')}
      </Button>

      {/* Action buttons */}
      {(messages.length > 1 || contentPlan) && (
        <Button
          variant="ghost"
          size="sm"
          onClick={handleReset}
          className="text-muted-foreground hover:text-foreground hover:bg-secondary"
        >
          <RotateCcw className="w-4 h-4 me-2" aria-hidden="true" />
          {t('studio.newProject')}
        </Button>
      )}
      {isVideoReady && (
        <>
          <Button
            variant={showSceneEditor ? 'secondary' : 'ghost'}
            size="sm"
            onClick={() => setShowSceneEditor(!showSceneEditor)}
            className={cn(
              'gap-2',
              showSceneEditor
                ? 'bg-primary/20 text-primary border border-primary/30'
                : 'text-muted-foreground hover:text-foreground hover:bg-secondary'
            )}
            aria-pressed={showSceneEditor}
          >
            <Edit3 className="w-4 h-4" aria-hidden="true" />
            {t('studio.edit')}
          </Button>
          {qualityReport && (
            <Button
              variant="ghost"
              size="sm"
              onClick={() => setShowQuality(true)}
              className="text-muted-foreground hover:text-foreground hover:bg-secondary gap-2"
            >
              <BarChart3 className="w-4 h-4" />
              {t('studio.quality')}
            </Button>
          )}
          <Button
            variant={showTimeline ? 'secondary' : 'ghost'}
            size="sm"
            onClick={() => setShowTimeline(!showTimeline)}
            className={cn(
              'gap-2',
              showTimeline
                ? 'bg-primary/20 text-primary border border-primary/30'
                : 'text-muted-foreground hover:text-foreground hover:bg-secondary'
            )}
          >
            <Layers className="w-4 h-4" />
            {t('studio.timeline')}
          </Button>
          <Button
            onClick={() => setShowExport(true)}
            size="sm"
            className="bg-primary hover:bg-primary/90 text-primary-foreground gap-2 shadow-lg shadow-primary/20"
          >
            <Download className="w-4 h-4" />
            {t('studio.export')}
          </Button>
        </>
      )}
    </div>
  );

  // Loading state for project
  if (isProjectLoading) {
    return (
      <ScreenLayout
        title={t('studio.title')}
        showBackButton
        onBack={() => navigate('/')}
      >
        <div className="flex items-center justify-center h-full min-h-[50vh]">
          <div className="flex flex-col items-center gap-4">
            <Loader2 className="w-8 h-8 animate-spin text-primary" />
            <p className="text-white/60">{t('studio.loadingProject') || 'Loading project...'}</p>
          </div>
        </div>
      </ScreenLayout>
    );
  }

  // Error state for project loading
  if (projectError) {
    return (
      <ScreenLayout
        title={t('studio.title')}
        showBackButton
        onBack={() => navigate('/')}
      >
        <div className="flex items-center justify-center h-full min-h-[50vh]">
          <div className="p-6 rounded-xl bg-red-500/10 border border-red-500/20 text-center max-w-md">
            <p className="text-red-400 mb-4">{projectError}</p>
            <Button onClick={() => navigate('/projects')}>
              {t('common.backToProjects') || 'Back to Projects'}
            </Button>
          </div>
        </div>
      </ScreenLayout>
    );
  }

  return (
    <ScreenLayout
      title={t('studio.title')}
      showBackButton
      onBack={() => navigate('/')}
      headerActions={headerActions}
      contentClassName={cn("py-8", studioMode === 'story' && "p-0 h-full")}
      maxWidth={studioMode === 'story' ? 'full' : '3xl'}
      footer={
        studioMode === 'chat' ? (
          <ChatInput
            value={input}
            onChange={setInput}
            onSubmit={handleSubmit}
            placeholder={t('studio.placeholder')}
            disabled={appState !== AppState.IDLE}
            isLoading={isProcessing || appState !== AppState.IDLE}
            isRTL={isRTL}
            hintText={`${t('studio.send')}(Enter)`}
            inputId="studio-input"
          />
        ) : null
      }
    >
      {studioMode === 'editor' ? (
        <VideoEditor className="h-full" />
      ) : studioMode === 'story' ? (
        <StoryWorkspaceErrorBoundary
          storyState={storyHook.state}
          onRestore={() => {
            // Restore from version history or last saved state
            console.log('[StoryWorkspace] Restoring from last saved state');
            // The version history system already handles auto-save
          }}
        >
          <StoryWorkspace
            storyState={storyHook.state}
            initialTopic={storyInitialTopic || topic || ''}
            formatPipelineHook={formatPipelineHook}
            onFormatExecute={handleFormatExecute}
            onOpenInEditor={handleOpenInEditor}
            onGenerateIdea={(storyTopic, genre) => {
              setStoryInitialTopic(storyTopic);
              storyHook.updateGenre(genre);
              storyHook.generateBreakdown(storyTopic, genre);
            }}
            onExportScript={storyHook.exportScreenplay}
            onRegenerateScene={storyHook.regenerateScene}
            onVerifyConsistency={storyHook.verifyConsistency}
            onGenerateScreenplay={storyHook.generateScreenplay}
            onGenerateCharacters={storyHook.generateCharacters}
            onGenerateCharacterImage={storyHook.generateCharacterImage}
            onUndo={storyHook.undo}
            onRedo={storyHook.redo}
            canUndo={storyHook.canUndo}
            canRedo={storyHook.canRedo}
            onNextStep={() => {
              const step = storyHook.state.currentStep;
              const isLocked = storyHook.state.isLocked;

              if (step === 'idea') {
                // Idea ‚Üí Breakdown: Generate story outline
                storyHook.generateBreakdown(storyInitialTopic || topic || "A generic story", "Drama");
              } else if (step === 'breakdown') {
                // Breakdown ‚Üí Script: Generate full screenplay
                storyHook.generateScreenplay();
              } else if (step === 'script') {
                // Script ‚Üí Characters: Generate character profiles
                // Note: Lock is handled separately via onLockStory
                storyHook.generateCharacters();
              } else if (step === 'characters') {
                // Characters ‚Üí Shots: Generate shot breakdown
                // Story must be locked at this point
                if (isLocked) {
                  storyHook.generateShots();
                } else {
                  // Shouldn't happen, but fallback to showing lock dialog
                  console.warn('Story should be locked before generating shots');
                  storyHook.setStep('script');
                }
              } else if (step === 'shots') {
                // Shots ‚Üí Style: Move to visual style selection
                storyHook.setStep('style');
              } else if (step === 'style') {
                // Style ‚Üí Storyboard: Generate storyboard visuals
                storyHook.generateVisuals();
              }
            }}
            onGenerateShots={storyHook.generateShots}
            onGenerateVisuals={storyHook.generateVisuals}
            stageProgress={storyHook.getStageProgress()}
            isProcessing={storyHook.isProcessing}
            progress={storyHook.progress}
            // Storyboarder.ai-style workflow props
            onLockStory={storyHook.lockStory}
            onUpdateVisualStyle={storyHook.updateVisualStyle}
            onUpdateAspectRatio={storyHook.updateAspectRatio}
            onUpdateImageProvider={storyHook.updateImageProvider}
            // Error handling
            error={storyHook.error}
            onClearError={storyHook.clearError}
            onRetry={storyHook.retryLastOperation}
            onUpdateShot={storyHook.updateShot}
            // Narration, Animation, and Export
            onGenerateNarration={storyHook.generateNarration}
            onAnimateShots={storyHook.animateShots}
            onExportFinalVideo={storyHook.exportFinalVideo}
            onDownloadVideo={storyHook.downloadVideo}
            allScenesHaveNarration={storyHook.allScenesHaveNarration}
            allShotsHaveAnimation={storyHook.allShotsHaveAnimation}
            // Template and project management
            projectId={storyHook.sessionId ?? undefined}
            onApplyTemplate={storyHook.applyTemplate}
            onImportProject={storyHook.importProject}
          />
        </StoryWorkspaceErrorBoundary>
      ) : (
        <>
          {/* Welcome State */}
          {messages.length === 1 && !contentPlan && (
            <div className="text-center mb-12 pt-12">
              <div className="w-16 h-16 mx-auto mb-6 rounded-2xl bg-linear-to-br from-primary/20 to-accent/20 border border-border flex items-center justify-center" aria-hidden="true">
                <Wand2 className="w-8 h-8 text-primary" />
              </div>
              <h1 className="text-3xl font-light text-white mb-3">{t('studio.placeholder')}</h1>
            </div>
          )}

          {/* Messages */}
          <div className="space-y-6" role="log" aria-live="polite" aria-label="Chat messages">
            {messages.map((message) => (
              <MessageBubble
                key={message.id}
                message={message}
                isRTL={isRTL}
                onQuickAction={handleQuickAction}
                onFeedback={handleFeedback}
              />
            ))}
            {error && (
              <div className="p-4 rounded-xl bg-red-500/10 border border-red-500/20 text-red-200 text-sm max-w-2xl mx-auto" role="alert">
                {error}
              </div>
            )}
            <div ref={messagesEndRef} />
          </div>

          {/* Video Preview Card */}
          {contentPlan && (
            <VideoPreviewCard
              scenes={contentPlan.scenes}
              visualsMap={visualsMap}
              currentSceneIndex={currentSceneIndex}
              onSceneSelect={setCurrentSceneIndex}
              isPlaying={isPlaying}
              onPlayPause={() => setIsPlaying(!isPlaying)}
              isReady={isVideoReady ?? false}
              totalDuration={totalDuration}
              scenesLabel={t('studio.scenes')}
              doneLabel={t('common.done')}
              isRTL={isRTL}
              className="mt-8 mb-4"
            />
          )}

          {/* Timeline Editor (Requirement 6.3) */}
          {showTimeline && contentPlan && (
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
              className="mt-4"
            >
              <GraphiteTimeline
                scenes={contentPlan.scenes}
                visuals={visualsMap}
                narrationSegments={narrationSegments}
                currentTime={playbackTime}
                duration={totalDuration}
                isPlaying={isPlaying}
                onPlayPause={handleTimelinePlayPause}
                onSeek={handleTimelineSeek}
                onSceneSelect={handleSceneSelect}
                selectedSceneId={selectedSceneId}
                projectName={contentPlan.title}
                sfxPlan={sfxPlan}
                className="rounded-xl overflow-hidden border border-white/5"
              />
              <audio
                ref={timelineAudioRef}
                src={mergedAudioUrl || undefined}
                onTimeUpdate={(e) => setPlaybackTime(e.currentTarget.currentTime)}
                onEnded={() => setIsPlaying(false)}
              />
            </motion.div>
          )}

          {/* Quick Actions */}
          {messages.length === 1 && !contentPlan && (
            <>
              <QuickActions
                actions={quickActionItems}
                onSelect={(action) => setInput(action.prompt || '')}
                isRTL={isRTL}
              />
              <div className="flex justify-center">
                <button
                  onClick={() => {
                    setMusicModalMode('remix');
                    setShowMusic(true);
                  }}
                  className="flex items-center gap-2 px-4 py-2.5 rounded-full bg-white/5 hover:bg-white/10 border border-white/10 text-sm text-white/70 hover:text-white transition-all"
                >
                  <Upload className="w-4 h-4 text-primary" />
                  {t('common.upload')}
                </button>
              </div>
            </>
          )}

          {/* Modals & Panels */}
          <MusicGeneratorModal
            open={showMusic}
            onClose={() => {
              setShowMusic(false);
              setMusicModalMode('generate');
            }}
            musicState={musicState}
            onGenerateMusic={generateMusic}
            onGenerateLyrics={generateLyrics}
            onSelectTrack={selectTrack}
            onAddToTimeline={() => {
              addMusicToTimeline();
              setShowTimeline(true);
            }}
            onRefreshCredits={refreshCredits}
            onUploadAudio={uploadAudio}
            onUploadAndCover={uploadAndCover}
            onAddVocals={addVocals}
            onAddInstrumental={addInstrumental}
            initialMode={musicModalMode}
          />

          {qualityReport && (
            <QualityDashboard
              report={qualityReport}
              isOpen={showQuality}
              onClose={() => setShowQuality(false)}
            />
          )}

          <SlidePanel
            isOpen={showSceneEditor && !!contentPlan}
            onClose={() => setShowSceneEditor(false)}
            title={t('studio.edit')}
            isRTL={isRTL}
          >
            {contentPlan && (
              <SceneEditor
                scenes={contentPlan.scenes}
                onChange={updateScenes}
                onPlayNarration={playNarration}
                onRegenerateNarration={regenerateSceneNarration}
                playingSceneId={playingSceneId}
                visuals={visualsMap}
                narrationUrls={getAudioUrlMap()}
              />
            )}
          </SlidePanel>

          <QuickExport
            isOpen={showExport}
            onClose={() => setShowExport(false)}
            onExport={handleExport}
            videoTitle={contentPlan?.title}
            duration={totalDuration}
          />

          <SettingsModal
            isOpen={showSettings}
            onClose={() => setShowSettings(false)}
            contentType={params.mode === 'music' ? 'music' : 'story'}
            onContentTypeChange={() => { }}
            videoPurpose={params.mode === 'video' ? 'documentary' : 'music_video'}
            onVideoPurposeChange={(purpose) => {
              if (purpose !== 'documentary') setVideoPurpose(purpose);
            }}
            targetAudience={targetAudience}
            onTargetAudienceChange={setTargetAudience}
            generationMode={params.mode === 'music' ? 'image' : 'video'}
            onGenerationModeChange={() => { }}
            videoProvider="veo"
            onVideoProviderChange={() => { }}
            veoVideoCount={veoVideoCount}
            onVeoVideoCountChange={setVeoVideoCount}
            aspectRatio="16:9"
            onAspectRatioChange={() => { }}
            selectedStyle={params.style || 'Cinematic'}
            onStyleChange={(style: string) => setVisualStyle(style)}
            globalSubject=""
            onGlobalSubjectChange={() => { }}
          />
        </>
      )}
    </ScreenLayout>
  );
}
</file>

<file path="screens/VisualizerScreen.tsx">
/**
 * Visualizer Screen - Audio-first lyric video creation
 *
 * Refactored to use extracted components for better maintainability.
 * Requirements: 1.1, 9.1, 9.4
 */

import React, { useState, useCallback, useEffect, useMemo } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Download,
  RotateCcw,
  Wand2,
  Video,
  Loader2,
  X,
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { useLanguage } from '@/i18n/useLanguage';
import { useLyricLens } from '@/hooks/useLyricLens';
import { useModalState } from '@/hooks/useModalState';
import { useProjectSession } from '@/hooks/useProjectSession';
import { useAuth } from '@/hooks/useAuth';
import { AppState, GeneratedImage } from '@/types';

// Layout Components
import { ScreenLayout } from '@/components/layout/ScreenLayout';

// Visualizer Components
import { AudioUploadForm, VisualPreview, SceneThumbnails } from '@/components/visualizer';

// Feature Components
import { TimelinePlayer } from '@/components/TimelinePlayer';
import { QuickExport } from '@/components/QuickExport';
import { ErrorState } from '@/components/ui/ErrorState';

// Services
import { animateImageWithDeApi, animateImageBatch } from '@/services/deapiService';

export default function VisualizerScreen() {
  const { t, isRTL } = useLanguage();
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();

  // Get projectId from URL (e.g., /visualizer?projectId=abc123)
  const projectId = searchParams.get('projectId') || undefined;

  // Project and auth hooks
  const { project, sessionId } = useProjectSession(projectId);
  const { user } = useAuth();

  // Modal state
  const { showExport, setShowExport } = useModalState();

  // LyricLens hook for audio processing
  const {
    appState,
    songData,
    setSongData,
    errorMsg,
    isBulkGenerating,
    processFile,
    handleGenerateAll,
    resetApp,
    imageProvider,
    setImageProvider,
    directorMode,
    setDirectorMode,
    globalSubject,
    setGlobalSubject,
  } = useLyricLens();

  // Local state
  const [audioFile, setAudioFile] = useState<File | null>(null);
  const [selectedStyle, setSelectedStyle] = useState('Cinematic');
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [currentSceneIndex, setCurrentSceneIndex] = useState(0);

  // Animation state
  const [animatingPromptId, setAnimatingPromptId] = useState<string | null>(null);
  const [animationError, setAnimationError] = useState<string | null>(null);
  const [isBatchAnimating, setIsBatchAnimating] = useState(false);
  const [batchAnimationProgress, setBatchAnimationProgress] = useState({ current: 0, total: 0 });

  // ============================================================
  // Computed Values
  // ============================================================

  const hasVisuals = useMemo(() => {
    return songData?.generatedImages && songData.generatedImages.length > 0;
  }, [songData]);

  const currentVisual = useMemo(() => {
    if (!songData || !hasVisuals) return null;
    const currentPrompt = songData.prompts[currentSceneIndex];
    if (!currentPrompt) return null;
    return songData.generatedImages.find(img => img.promptId === currentPrompt.id) || null;
  }, [songData, hasVisuals, currentSceneIndex]);

  const isReadyForExport = useMemo(() => {
    return songData && hasVisuals && songData.generatedImages.length >= songData.prompts.length * 0.5;
  }, [songData, hasVisuals]);

  const animatableImagesCount = useMemo(() => {
    if (!songData) return 0;
    return songData.generatedImages.filter(img => img.type !== 'video').length;
  }, [songData]);

  const isProcessing = appState === AppState.PROCESSING_AUDIO ||
    appState === AppState.TRANSCRIBING ||
    appState === AppState.ANALYZING_LYRICS ||
    appState === AppState.GENERATING_PROMPTS;

  const isReady = appState === AppState.READY && songData;

  // ============================================================
  // Effects
  // ============================================================

  // Update current scene based on playback time using binary search for accurate sync
  // This uses absolute video currentTime to prevent cumulative drift over long durations
  useEffect(() => {
    if (!songData || !songData.prompts.length || duration <= 0) return;

    // Binary search to find the correct scene index for the current time
    // This is more efficient and accurate than linear search, especially for long videos
    const prompts = songData.prompts;
    let left = 0;
    let right = prompts.length - 1;
    let targetIndex = 0;

    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const prompt = prompts[mid];
      if (!prompt) break;

      const startTime = prompt.timestampSeconds || 0;
      const nextPrompt = prompts[mid + 1];
      const endTime = nextPrompt?.timestampSeconds || duration;

      if (currentTime >= startTime && currentTime < endTime) {
        // Found the exact scene
        targetIndex = mid;
        break;
      } else if (currentTime < startTime) {
        // Current time is before this scene, search left
        right = mid - 1;
        targetIndex = Math.max(0, mid - 1);
      } else {
        // Current time is after this scene, search right
        left = mid + 1;
        targetIndex = mid;
      }
    }

    // Clamp to valid range
    targetIndex = Math.max(0, Math.min(targetIndex, prompts.length - 1));

    // Only update if the index actually changed (prevents unnecessary re-renders)
    if (targetIndex !== currentSceneIndex) {
      setCurrentSceneIndex(targetIndex);
    }
  }, [currentTime, songData, duration]); // Removed currentSceneIndex from deps to prevent circular updates

  // ============================================================
  // Handlers
  // ============================================================

  const handleStartProcessing = useCallback(async () => {
    if (!audioFile) return;
    await processFile(audioFile, selectedStyle);
  }, [audioFile, selectedStyle, processFile]);

  const handleGenerateVisuals = useCallback(async () => {
    await handleGenerateAll(selectedStyle, '16:9');
  }, [selectedStyle, handleGenerateAll]);

  const handleAnimateImage = useCallback(async (promptId: string) => {
    if (!songData || animatingPromptId) return;

    const image = songData.generatedImages.find(img => img.promptId === promptId);
    if (!image || !image.imageUrl || image.type === 'video') return;

    const prompt = songData.prompts.find(p => p.id === promptId);
    if (!prompt) return;

    setAnimatingPromptId(promptId);
    setAnimationError(null);

    try {
      const videoBase64 = await animateImageWithDeApi(
        image.imageUrl,
        prompt.text,
        '16:9'
      );

      const updatedImage: GeneratedImage = {
        ...image,
        promptId: image.promptId, // Explicitly pass to avoid optional spread issues
        imageUrl: videoBase64,
        type: 'video',
        baseImageUrl: image.imageUrl,
      };

      setSongData(prev => {
        if (!prev) return null;
        return {
          ...prev,
          generatedImages: prev.generatedImages.map(img =>
            img.promptId === promptId ? updatedImage : img
          ),
        };
      });
    } catch (error: any) {
      console.error('Animation failed:', error);
      setAnimationError(error.message || 'Animation failed');
    } finally {
      setAnimatingPromptId(null);
    }
  }, [songData, animatingPromptId, setSongData]);

  const handleAnimateAll = useCallback(async () => {
    if (!songData || isBatchAnimating) return;

    const imagesToAnimate = songData.generatedImages.filter(img => img.type !== 'video');

    if (imagesToAnimate.length === 0) {
      setAnimationError('All images are already animated');
      return;
    }

    setIsBatchAnimating(true);
    setBatchAnimationProgress({ current: 0, total: imagesToAnimate.length });
    setAnimationError(null);

    // Prepare batch items with prompts
    const batchItems = imagesToAnimate
      .map(image => {
        const prompt = songData.prompts.find(p => p.id === image.promptId);
        if (!prompt) return null;
        return {
          id: image.promptId,
          imageUrl: image.imageUrl,
          prompt: prompt.text,
          aspectRatio: '16:9' as const,
        };
      })
      .filter((item): item is NonNullable<typeof item> => item !== null);

    try {
      // Use parallel batch animation (concurrency: 2 for video generation)
      const results = await animateImageBatch(
        batchItems,
        2, // Lower concurrency for video generation (more resource intensive)
        (progress) => {
          setBatchAnimationProgress({ current: progress.completed, total: progress.total });
          // Show which one is currently being processed
          const currentItem = batchItems[progress.completed - 1];
          if (currentItem) {
            setAnimatingPromptId(currentItem.id);
          }
        }
      );

      // Update all successful results
      setSongData(prev => {
        if (!prev) return null;
        const updatedImages = prev.generatedImages.map(img => {
          const result = results.find(r => r.id === img.promptId);
          if (result?.success && result.imageUrl) {
            return {
              ...img,
              imageUrl: result.imageUrl,
              type: 'video' as const,
              baseImageUrl: img.imageUrl,
            };
          }
          return img;
        });
        return { ...prev, generatedImages: updatedImages };
      });

      // Report any failures
      const failures = results.filter(r => !r.success);
      if (failures.length > 0) {
        console.error(`${failures.length} animations failed:`, failures.map(f => f.error));
      }
    } catch (error: any) {
      console.error('Batch animation failed:', error);
      setAnimationError(error.message || 'Batch animation failed');
    }

    setIsBatchAnimating(false);
    setAnimatingPromptId(null);
    setBatchAnimationProgress({ current: 0, total: 0 });
  }, [songData, isBatchAnimating, setSongData]);

  const handleReset = useCallback(() => {
    resetApp();
    setAudioFile(null);
    setIsPlaying(false);
    setCurrentTime(0);
    setDuration(0);
    setAnimationError(null);
  }, [resetApp]);

  const handlePlayPause = useCallback(() => {
    setIsPlaying(prev => !prev);
  }, []);

  const handleSeek = useCallback((time: number) => {
    setCurrentTime(time);
  }, []);

  const handleSceneSelect = useCallback((index: number, timestampSeconds?: number) => {
    setCurrentSceneIndex(index);
    if (timestampSeconds !== undefined) {
      handleSeek(timestampSeconds);
    }
  }, [handleSeek]);

  const handleExport = useCallback(async (
    config: { presetId: string; width: number; height: number; orientation: 'landscape' | 'portrait'; quality: string },
    onProgress?: (percent: number) => void
  ) => {
    if (!songData || !hasVisuals) {
      throw new Error('Video not ready for export');
    }

    const { exportVideoWithFFmpeg } = await import('@/services/ffmpeg/exporters');

    const result = await exportVideoWithFFmpeg(
      songData,
      (p) => onProgress?.(p.progress),
      {
        orientation: config.orientation,
        useModernEffects: true,
        transitionType: 'dissolve',
        transitionDuration: 1.5,
        contentMode: 'music',
      },
      {
        cloudSessionId: sessionId || undefined,
        userId: user?.uid,
        projectId: projectId,
      }
    );

    const url = URL.createObjectURL(result.blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${songData.fileName?.replace(/\.[^/.]+$/, '') || 'lyric-video'}-${config.presetId}.mp4`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, [songData, hasVisuals, sessionId, user?.uid, projectId]);

  // ============================================================
  // Render Helpers
  // ============================================================

  const headerActions = isReady ? (
    <div className={cn('flex items-center gap-2', isRTL && 'flex-row-reverse')}>
      <Button
        variant="ghost"
        size="sm"
        onClick={handleReset}
        className="text-white/60 hover:text-white"
      >
        <RotateCcw className="w-4 h-4 me-2" aria-hidden="true" />
        {t('common.reset')}
      </Button>

      {!isBulkGenerating && songData && songData.generatedImages.length < songData.prompts.length && (
        <Button
          onClick={handleGenerateVisuals}
          size="sm"
          className="bg-cyan-600 hover:bg-cyan-500"
        >
          <Wand2 className="w-4 h-4 me-2" aria-hidden="true" />
          Generate Visuals
        </Button>
      )}

      {isBulkGenerating && songData && (
        <div className={cn('flex items-center gap-2 text-cyan-400 text-sm', isRTL && 'flex-row-reverse')}>
          <Loader2 className="w-4 h-4 animate-spin" aria-hidden="true" />
          Generating ({songData.generatedImages.length}/{songData.prompts.length})
        </div>
      )}

      {hasVisuals && animatableImagesCount > 0 && !isBatchAnimating && (
        <Button
          onClick={handleAnimateAll}
          size="sm"
          className="bg-purple-600 hover:bg-purple-500"
        >
          <Video className="w-4 h-4 me-2" aria-hidden="true" />
          Animate All ({animatableImagesCount})
        </Button>
      )}

      {isBatchAnimating && (
        <div className={cn('flex items-center gap-2 text-purple-400 text-sm', isRTL && 'flex-row-reverse')}>
          <Loader2 className="w-4 h-4 animate-spin" aria-hidden="true" />
          Animating ({batchAnimationProgress.current}/{batchAnimationProgress.total})
        </div>
      )}

      {isReadyForExport && (
        <Button
          onClick={() => setShowExport(true)}
          size="sm"
          className="bg-gradient-to-r from-violet-600 to-purple-600 hover:from-violet-500 hover:to-purple-500"
        >
          <Download className="w-4 h-4 me-2" aria-hidden="true" />
          {t('studio.export')}
        </Button>
      )}
    </div>
  ) : undefined;

  // ============================================================
  // Render
  // ============================================================

  return (
    <ScreenLayout
      title={t('visualizer.title')}
      showBackButton
      onBack={() => navigate('/')}
      headerActions={headerActions}
      maxWidth="full"
      centerContent={!isReady}
      footer={
        <footer className="p-4 md:p-6 text-center text-sm text-white/40">
          Powered by Gemini AI
        </footer>
      }
    >
      <AnimatePresence mode="wait">
        {!isReady ? (
          /* Upload State */
          <motion.div
            key="upload"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            className="flex justify-center"
          >
            <AudioUploadForm
              audioFile={audioFile}
              onAudioFileChange={setAudioFile}
              selectedStyle={selectedStyle}
              onStyleChange={setSelectedStyle}
              imageProvider={imageProvider}
              onProviderChange={setImageProvider}
              directorMode={directorMode}
              onDirectorModeChange={setDirectorMode}
              globalSubject={globalSubject}
              onGlobalSubjectChange={setGlobalSubject}
              appState={appState}
              errorMsg={errorMsg || undefined}
              onStartProcessing={handleStartProcessing}
            />
          </motion.div>
        ) : (
          /* Ready State - Player with Visual Preview */
          <motion.div
            key="player"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            className="max-w-5xl mx-auto w-full px-4"
          >
            {/* Header Info */}
            <div className={cn('mb-6', isRTL && 'text-right')}>
              <h2 className="text-xl font-semibold">{songData?.fileName}</h2>
              <p className="text-sm text-white/60">
                {songData?.parsedSubtitles.length} subtitles ‚Ä¢ {songData?.prompts.length} scenes
                {hasVisuals && ` ‚Ä¢ ${songData?.generatedImages.length} visuals`}
              </p>
            </div>

            {/* Visual Preview Section */}
            {hasVisuals && songData && (
              <div className="mb-6">
                <VisualPreview
                  currentVisual={currentVisual}
                  currentSceneIndex={currentSceneIndex}
                  totalScenes={songData.prompts.length}
                  isPlaying={isPlaying}
                  onPlayPause={handlePlayPause}
                  currentTime={currentTime}
                  subtitles={songData.parsedSubtitles}
                  animatingPromptId={animatingPromptId}
                  onAnimateImage={handleAnimateImage}
                  isRTL={isRTL}
                  className="mb-4"
                />

                <SceneThumbnails
                  prompts={songData.prompts}
                  generatedImages={songData.generatedImages}
                  currentSceneIndex={currentSceneIndex}
                  onSceneSelect={handleSceneSelect}
                  animatingPromptId={animatingPromptId}
                />

                {/* Animation error message */}
                {animationError && (
                  <div className="mt-2 p-3 rounded-lg bg-red-500/10 border border-red-500/20 text-red-200 text-sm flex items-center justify-between">
                    <span>{animationError}</span>
                    <button
                      onClick={() => setAnimationError(null)}
                      className="p-1 hover:bg-white/10 rounded"
                      aria-label="Dismiss error"
                    >
                      <X className="w-4 h-4" aria-hidden="true" />
                    </button>
                  </div>
                )}
              </div>
            )}

            {/* Timeline Player */}
            {songData && (
              <TimelinePlayer
                audioUrl={songData.audioUrl}
                subtitles={songData.parsedSubtitles}
                currentTime={currentTime}
                duration={duration}
                isPlaying={isPlaying}
                onPlayPause={handlePlayPause}
                onSeek={handleSeek}
                onTimeUpdate={setCurrentTime}
                onDurationChange={setDuration}
                onEnded={() => setIsPlaying(false)}
                contentMode="music"
              />
            )}
          </motion.div>
        )}
      </AnimatePresence>

      {/* Export Modal */}
      <QuickExport
        isOpen={showExport}
        onClose={() => setShowExport(false)}
        onExport={handleExport}
        videoTitle={songData?.fileName?.replace(/\.[^/.]+$/, '') || 'lyric-video'}
        duration={duration}
      />
    </ScreenLayout>
  );
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "types": ["node", "vite/client"],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/services/*": ["../shared/src/services/*"],
      "@/types/*": ["../shared/src/types/*"],
      "@/types": ["../shared/src/types.ts"],
      "@/constants": ["../shared/src/constants/index.ts"],
      "@/constants/*": ["../shared/src/constants/*"],
      "@/utils/*": ["../shared/src/utils/*"],
      "@/lib/*": ["../shared/src/lib/*"],
      "@/stores": ["../shared/src/stores/appStore.ts"],
      "@/stores/*": ["../shared/src/stores/*"],
      "@/*": ["./*"]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "**/*.d.ts",
    "../shared/src/**/*.ts"
  ],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="vite-env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_USE_MULTI_AGENT?: string;
  readonly VITE_GEMINI_API_KEY?: string;
  readonly VITE_FREESOUND_API_KEY?: string;
  readonly VITE_SUNO_API_KEY?: string;
  readonly VITE_DEAPI_API_KEY?: string;
  readonly VITE_LANGSMITH_API_KEY?: string;
  readonly GOOGLE_CLOUD_PROJECT?: string;

  // Firebase Authentication
  readonly VITE_FIREBASE_API_KEY?: string;
  readonly VITE_FIREBASE_AUTH_DOMAIN?: string;
  readonly VITE_FIREBASE_PROJECT_ID?: string;
  readonly VITE_FIREBASE_STORAGE_BUCKET?: string;
  readonly VITE_FIREBASE_MESSAGING_SENDER_ID?: string;
  readonly VITE_FIREBASE_APP_ID?: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
</file>

<file path="vite.config.ts">
/// <reference types="vitest" />
import path from "path";
import { defineConfig, loadEnv } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/postcss";
import autoprefixer from "autoprefixer";
import Sitemap from "vite-plugin-sitemap";

// TEMPORARY: Filter out known Tailwind v4 PostCSS warning (upstream issue, cosmetic only)
const originalWarn = console.warn;
console.warn = (...args) => {
  const msg = args[0];
  if (
    typeof msg === "string" &&
    msg.includes("did not pass the `from` option")
  ) {
    return;
  }
  originalWarn.apply(console, args);
};

export default defineConfig(({ mode }) => {
  // Load env from .env files at workspace root (two levels up from packages/frontend/)
  const viteEnv = loadEnv(mode, "../../", "VITE_");
  const allEnv = loadEnv(mode, "../../", "");

  const isMobileBuild = process.env.CAPACITOR_BUILD === "true";

  const vertexProject = allEnv.GOOGLE_CLOUD_PROJECT || "";
  const vertexLocation = allEnv.GOOGLE_CLOUD_LOCATION || "us-central1";

  console.log(`[Vite Config] Vertex AI Project: ${vertexProject || "NOT SET"}`);
  console.log(`[Vite Config] Vertex AI Location: ${vertexLocation}`);

  // Path to shared package source
  const sharedSrc = path.resolve(__dirname, "../shared/src");

  return {
    // Use relative paths for Capacitor mobile builds
    base: isMobileBuild ? "./" : "/",
    // Load .env files from workspace root (where the actual .env lives)
    envDir: path.resolve(__dirname, "../../"),
    server: {
      port: 3000,
      host: true,
      // Note: COOP/COEP headers for SharedArrayBuffer (FFmpeg WASM) are NOT set
      // in dev mode because they break Firebase Auth popups/iframes.
      proxy: {
        "/api": {
          target: "http://localhost:3001",
          changeOrigin: true,
        },
      },
    },
    plugins: [
      react(),
      Sitemap({
        hostname: process.env.VITE_APP_URL || "https://yourdomain.com",
        dynamicRoutes: [
          "/",
          "/projects",
          "/studio",
          "/visualizer",
          "/settings",
          "/signin",
        ],
        exclude: ["/404", "/api/*"],
        changefreq: "monthly",
        priority: 0.7,
        lastmod: new Date(),
        robots: [
          {
            userAgent: "*",
            allow: "/",
            disallow: ["/api/"],
          },
        ],
        readable: true,
      }),
    ],
    css: {
      postcss: {
        plugins: [tailwindcss(), autoprefixer()],
      },
    },
    define: {
      "process.env.GOOGLE_CLOUD_PROJECT": JSON.stringify(vertexProject),
      "process.env.GOOGLE_CLOUD_LOCATION": JSON.stringify(vertexLocation),
      // Restore API keys for client-side LangChain agents that cannot easily use the proxy.
      // TODO: Refactor agents to run on server-side to remove this security risk.
      ...(mode === "development" && {
        "process.env.VITE_GEMINI_API_KEY": JSON.stringify(
          allEnv.VITE_GEMINI_API_KEY || viteEnv.VITE_GEMINI_API_KEY || "",
        ),
        "process.env.VITE_DEAPI_API_KEY": JSON.stringify(
          allEnv.VITE_DEAPI_API_KEY || viteEnv.VITE_DEAPI_API_KEY || "",
        ),
        "process.env.DEAPI_API_KEY": JSON.stringify(
          allEnv.VITE_DEAPI_API_KEY || viteEnv.VITE_DEAPI_API_KEY || "",
        ),
      }),
    },
    resolve: {
      alias: [
        // Shared package aliases ‚Äî must come BEFORE the catch-all "@" alias
        // Order matters: Vite uses the first matching alias
        { find: /^@\/services(.*)$/, replacement: `${sharedSrc}/services$1` },
        { find: /^@\/types(.*)$/, replacement: `${sharedSrc}/types$1` },
        { find: /^@\/constants(.*)$/, replacement: `${sharedSrc}/constants$1` },
        { find: /^@\/utils(.*)$/, replacement: `${sharedSrc}/utils$1` },
        { find: /^@\/lib(.*)$/, replacement: `${sharedSrc}/lib$1` },
        { find: /^@\/stores(.*)$/, replacement: `${sharedSrc}/stores$1` },
        // Catch-all: everything else (@/components, @/hooks, etc.) stays in frontend
        { find: "@", replacement: path.resolve(__dirname, ".") },
      ],
    },
    optimizeDeps: {
      exclude: ["@ffmpeg/ffmpeg", "@ffmpeg/util"],
    },
    test: {
      globals: true,
      environment: "jsdom",
      setupFiles: [],
      include: ["**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}"],
      exclude: ["node_modules", "dist", "e2e/**"],
    },
    build: {
      rollupOptions: {
        output: {
          manualChunks: {
            "vendor-genai": ["@google/genai"],
            "vendor-motion": ["framer-motion"],
            "vendor-radix": [
              "@radix-ui/react-dialog",
              "@radix-ui/react-dropdown-menu",
              "@radix-ui/react-select",
              "@radix-ui/react-scroll-area",
              "@radix-ui/react-slider",
              "@radix-ui/react-switch",
              "@radix-ui/react-progress",
            ],
          },
        },
      },
    },
  };
});
</file>

</files>
